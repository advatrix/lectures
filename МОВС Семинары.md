
# 1. Системы счисления. Выполнение арифметических операций в системах счисления с основанием p

**Число** -- безразмерная величина.

**Система счисления** --  система (математический приём) представления чисел с помощью ограниченного количества символов. Так, например, в троичной СС только три символа -- 0, 1 и 2 и с их помощью мы изображаем любое число.

Римская СС использует символы I, II, III, V, X, L.

СС распадаются на две крупные группы: позиционные и непозиционные.

**Позиционные СС**: вклад цифры в величину числа в которой зависит от положения цифры относительно запятой (например, 47.5: каждая единица на своём месте даёт вклад 10, 1 или 0.1)

**Основание СС** -- количество цифр, которые используются для записи чисел в этой СС.

Наиболее широко используется десятичная. В этой системе все цифры записываются с помощью 10 символов 0, 1, ... 9

На основе этого мы можем любое десятичное число записать в виде развёрнутой записи

<a href="https://ibb.co/rGDSFkX"><img src="https://i.ibb.co/VWfZJVk/image.png" alt="image" border="0"></a>

<a href="https://ibb.co/Gxnd1pg"><img src="https://i.ibb.co/vwVcrq2/image.png" alt="image" border="0"></a>

В обеих записях $x_i$ -- цифры от 0 до 9, $n$ -- количество цифр в записи числа, $m$ -- количество цифр в целой части.

И развёрнутая, и сокращённая записи дают величину числа.

Возможны позиционные СС с любым целым $p > 1$.

### Общий случай (основание р)

<a href="https://imgbb.com/"><img src="https://i.ibb.co/L69C97F/image.png" alt="image" border="0"></a>

<a href="https://imgbb.com/"><img src="https://i.ibb.co/DYwDx4L/image.png" alt="image" border="0"></a>

### Представление чисел
<a href="https://ibb.co/sPh06GD"><img src="https://i.ibb.co/1n3Dd5p/image.png" alt="image" border="0"></a>

<a href="https://ibb.co/wsNfHML"><img src="https://i.ibb.co/C25fdht/image.png" alt="image" border="0"></a>


Ценность развёрнутой записи: по ней сразу можно получить величину числа и перейти от одной системы счисления к другой.

### Двоично-десятичные системы
В основном используются в АСУ, приборах на станциях с индикацией.

Это системы, в которых десятичные цифры записываются с помощью четырёх двоичных разрядов.

Цифр 10, а двоичных четырёхразрядных двоичных кодов 16 ⇒ можно построить много разных систем. Но на практике широко используются две системы: 8421 и 8421+3.

<a href="https://ibb.co/8KF9zyK"><img src="https://i.ibb.co/gjsJv0j/image.png" alt="image" border="0"></a>

Первая система наглядна и проста. Во второй системе во время вычитания достаточно проинвертировать число и сразу получить модифицированный обратный код.

### Арифметические операции

**Сложение**

<a href="https://ibb.co/G9smPD6"><img src="https://i.ibb.co/m0vpzKj/image.png" alt="image" border="0"></a>

Оказывается, что операция сложения выполняется так же, как и в десятичной системе счисления. То есть начинается со сложения младших разрядов и идёт справа налево.

При этом цифра $c_i$ формируется как сумма цифр в $i$ разряде $a_i + b_i$ и плюс перенос из более младшего разряда (он равен либо 0, либо 1).

#### Случаи
1. В i-ом разряде получили результат, который меньше чем основание СС. Тогда в старшие разряды $a_{i-1}$, $b_{i-1}$ перенос не идёт.
2. В i-ом разряде получили результат больше или равен p. Тогда из результата вычитается основание p, а в старшие разряды идёт перенос.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/KND4hvD/image.png" alt="image" border="0"></a>

**Вычитание**

<a href="https://ibb.co/WGwjJ67"><img src="https://i.ibb.co/4KG3r7C/image.png" alt="image" border="0"></a>

Вычитание выполняется точно так же, как и в десятичной системе счисления.

**Случаи**
1. При вычитании результат получается $\geq 0$. Тогда в старшем разряде займа не выполняется
2. Получился результат меньше 0. Тогда к результату прибавляется $p$: получается неотрицательная величина, а из старших разрядов берётся займ

 <a href="https://ibb.co/zsSWL65"><img src="https://i.ibb.co/qBRL4Jn/image.png" alt="image" border="0"></a>

Последний случай -- займ из старшего разряда.

### Умножение
<a href="https://ibb.co/4TZHCbL"><img src="https://i.ibb.co/XsZq6nP/image.png" alt="image" border="0"></a>

Как видно, таблица умножения очень простая, и умножение в двоичной системе выполняется достаточно просто.

### Деление

Мы сравниваем часть делимого с делителем и в частное последовательно идут результаты сравнения

### Примеры
<a href="https://ibb.co/TqhKy4s"><img src="https://i.ibb.co/6JsvQHk/image.png" alt="image" border="0"></a>


<a href="https://ibb.co/FDXdtMQ"><img src="https://i.ibb.co/87bQVpy/image.png" alt="image" border="0"></a>

В пояснении записано, как можно просто оценивать величины фрагментов и формировать цифры частного.

# 2. Перевод целых и дробных чисел из системы счисления с основанием $p_1$ в систему счисления с основанием $p_2$

У нас есть некоторое число в СС с основанием $p$ и в его записи есть целая и дробная часть. Это число, например, надо перевести в семиричную систему.

Рассмотрим саму идею перевода. Когда мы это сделаем, мы получим некоторую целую часть вида $b_1* 7^{m-1}+\dots+b_m* 7^0$ и какую-то дробную часть

<a href="https://imgbb.com/"><img src="https://i.ibb.co/8c1HCQX/image.png" alt="image" border="0"></a>

Целая и дробная части переводятся пораздельно. 

Целую часть исходного числа мы можем разделить на 7. В остатке получаем $b_m$: получили младшую цифру. Далее делим ещё раз и в остатке получаем $b_{m-1}$ и так далее.

Дробную часть умножаем на 7. При умножении на 7 у нас получится дробь и цифра $b_{m+1}$ в целой части. 

### Алгоритм перевода целых чисел (целых чисел) из системы с основанием $p_1$ в $p_2$ 

<a href="https://imgbb.com/"><img src="https://i.ibb.co/vJ7jtr2/image.png" alt="image" border="0"></a>

Делим частные на новое основание, получаем остатки и новые частные. Условие выхода из цикла: очередное новое частное меньше нового основания.
<a href="https://ibb.co/wWVzQkh"><img src="https://i.ibb.co/Xs1C5Qx/image.png" alt="image" border="0"></a>


Число и величина -- синонимы, но это число в разных системах счисления имеет разную **запись**, само число остаётся неизменным.

### Полиномный метод перевода. Целые числа

<a href="https://ibb.co/D16PpW2"><img src="https://i.ibb.co/7STx4Cm/image.png" alt="image" border="0"></a>

Мы формируем развёрнутую запись числа. Она нам даёт величину числа, которая во всех системах одна и та же. Далее величину числа мы расписываем в новой системе счисления через развёрнутую запись

## Перевод дробных чисел

<a href="https://ibb.co/0ZJLM0t"><img src="https://i.ibb.co/q918sH5/image.png" alt="image" border="0"></a>


<a href="https://ibb.co/R9szQJp"><img src="https://i.ibb.co/nbYzQKs/image.png" alt="image" border="0"></a>

### Полиномный метод

<a href="https://ibb.co/jWdjScR"><img src="https://i.ibb.co/Hx09jWd/image.png" alt="image" border="0"></a>

Мы формируем развёрнутую запись для дроби в исходной системе счисления. Далее полученную величину мы расписываем через развёрнутую запись дроби в новой системе счисления. Причём цифры $\alpha_i$ могут принимать только значения 0, 1 или 2 (они в троичной системе счисления).

На первом шаге мы находим наибольшее $\alpha_1$. После этого мы из величины дроби вычитаем $\frac{\alpha_1} {3}$. Аналогично подбираем $\alpha_2$, вычитаем и получаем какой-то остаток. 

Но во всех случая возникает вопрос: сколько цифр после запятой надо оставить? Делить и вычитать можно бесконечно, а сколько надо?

Мы должны оставить столько цифр, чтобы не потерять точность.

Единица младшего разряда в исходной дроби приравнивается к единице младшего разряда в формируемой дроби. Если они равны, то равны и абсолютные погрешности, которые меньше, чем половина младшего разряда,  ⇒ раз абсолютные погрешности равны, то относительные тоже равны: $$p_1^{-n_{p_1}} = p_2^{-n_{p_2}}$$

Отсюда находим необходимое число цифр после запятой $n_{p_2}$:

$$n_{p_2} = \frac{n_{p_1}}{\log_{p_1} p_2} = \frac{n_{p_1}*\lg p_1}{\lg p_2}$$

Обычно берут целую часть и прибавляют единицу, чтобы не потерять точность.
$$n_{p_2} = \left[\frac{n_{p_1}\lg p_1}{\lg p_2}\right]+1$$

<a href="https://ibb.co/m0J7tc3"><img src="https://i.ibb.co/42WxMVH/image.png" alt="image" border="0"></a>

## Перевод чисел из системы счисления с основанием $p_1 = 2$ в систему счисления с основанием $p_1 = 2^k$ и наоборот

Если задано число в двоичной системе счисления, которое содержит и целую часть, и дробную часть, то перевод в систему счисления с основанием $p_2 = 2^k$ выполняется следующим образом: двоичные цифры числа $A_2$ разбиваются на группы по $k$ разрядов влево и вправо от запятой. Каждая из групп даёт запись искомых цифр в системе счисления с основанием $p = 2^k$.

<a href="https://ibb.co/0CyNYqL"><img src="https://i.ibb.co/sK9Ssj4/image.png" alt="image" border="0"></a>

### Обратный перевод

Если задано число в системе счисления с основанием $p = 2^k$, то перевод чисел в двоичную систему выполняется посредством замены цифр числа их двоичными эквивалентами.

## Перевод чисел из двоично-десятичной системы в десятичную и обратно

Этот перевод выполняется таблично. Каждой десятичной цифре исходного числа ставится в соответствие четырехразрядная двоично-десятичная цифра.

### Обратный перевод
Каждое двоично-десятичной цифре ставится в соответствие десятичная цифра

## Перевод с использованием промежуточных систем счисления
Самый простой способ перевести из 16-ричной в 8-ричную: через двоичную и так далее.


# Семинар 3. Представление чисел в ЭВМ
Для ЭВМ есть понятие разрядной сетки. Это можно представить себе как какое-то количество $n$ проводов, которые образуют шину и проходят через всю ЭВМ. Первая позиция всегда отводится под знак, далее  идёт цифровая часть для чисел с фиксированной запятой или точкой.

Разрядность чисел в ЭВМ ограничена и поэтому максимальное и минимальное по величине числа ограничены, и выход за разрядную сетку приводит к переполнению.

### Запись числа в произвольной системе с основанием $p$:
$$X_p = \pm p^m\sum_{i=1}^nx_i*p^{-i}$$
Здесь $n$ -- разрядность чисел (количество разрядов в цифровой части),
$m$ -- количество разрядов в целой части числа
$p$ -- основание системы счисления
$x_i\in \{0,\dots, p-1\}$ -- цифры в системе счисления с основанием $p$.

Когда мы уходим в двоичную систему счисления, то запись числа в самом общем виде такая:
$$X_2 = \pm 2^m\sum_{i=1}^{n} x_i*2^{-i}$$
Здесь $p = 2$, $x_i \in \{0, 1\}$.

Имеется три широко применяющихся представления чисел в ЭВМ: с фиксированной точкой, с фиксированной запятой и с плавающей запятой.

### Представление чисел с фиксированной запятой 
Здесь $m= const = 0$: здесь нет целой части. А сами числа -- правильные дроби, то есть по модулю они меньше единицы.


<a href="https://ibb.co/bgYN3HF"><img src="https://i.ibb.co/ynKgRhp/image.png" alt="image" border="0"></a>

Далее приведена сокращённая и развёрнутая запись чисел с фиксированной запятой.

С помощью фиксированной запятой можно реализовать любой алгоритм.

Фиксированная запятая, как правило, применялась в ЭВМ спец. назначения там где требуется высокое быстродействие и малые аппаратные затраты.

Основной недостаток: все задачи от выходных данных до окончательных результатов надо масштабировать, чтобы они были по модулю меньше единицы. Считается, что это занимает много времени.

Также здесь точность ограничена: для научных расчётов фиксированная запятая не годится.

В настоящее время больше используется плавающая запятая.

### Представление чисел с фиксированной точкой 
Количество цифр в целой части постоянно и равняется $n$. В таком случае ЭВМ работает только с целыми числами.

<a href="https://ibb.co/6RwhNGp"><img src="https://i.ibb.co/tMKf3nN/image.png" alt="image" border="0"></a>

В составе ЭВМ эти числа представляются в таком формате и так располагаются на разрядной сетке: знак, разряды-веса. Положение фиксированной точки -- в самом конце. Так числа фиксируются на регистрах, в оперативной памяти и в таком виде отправляются на операционное устройство.

Особенность ЭВМ с таким представлением чисел: не требуется масштабирование, упрощена аппаратная часть и повышено быстродействие -- это плюсы.

Основной минус: ограниченный класс задач -- это задачи в целых чисел. Любой алгоритм здесь реализовать затруднительно.

### Представление чисел с плавающей запятой
Что такое плавающая запятая? Это означает, что числа идут на обработку, а положение запятой в них разное. Это могут быть целые числа, смешанные числа, дроби и т.д. Положение запятой варьируется через $m$, которое показывает количество цифр в целой части.

$X_p = \pm p^m\sum_{i=1}^nx_i p^{-i}$

$m$ называется порядком числа. Он показывает положение запятой: сколько цифр в целой части числа.

$\sum x_i p^{-i}$ -- мантисса: все цифры числа. Там располагается и целая часть, и дробная часть. Знак мантиссы -- это знак числа.

$n$ -- количество цифр в числе

$m \geq n$ -- целое число
$m \leq 0$ -- правильная дробь
$1 \leq m < n$ -- смешанное число

Здесь достигается большая точность, но требуется обрабатывать и порядки, и мантиссы параллельно ⇒ усложняется аппаратура и работает помедленнее.

Чтобы числа представлять однозначно, вводят понятие нормализованной мантиссы: цифры числа записывают в виде правильной дроби, причём первая цифра после знака мантиссы должна быть отлична от нуля:
$$p^{-1}\leq |\sum x_i p^{-i}| < 1$$
Порядок показывает положение запятой в этой дроби.

<a href="https://ibb.co/rQdr3n0"><img src="https://i.ibb.co/p1hFQCw/image.png" alt="image" border="0"></a>

Разрядностью мантиссы определяется точность представления чисел в ЭВМ.

Порядки -- это целые числа со знаком. Их обрабатывают как числа с фиксированной точкой. Порядками определяется диапазон представления чисел.

<a href="https://ibb.co/1QRpPVd"><img src="https://i.ibb.co/7CrTZcR/image.png" alt="image" border="0"></a>

<a href="https://ibb.co/CvjMsmg"><img src="https://i.ibb.co/bL42RQT/image.png" alt="image" border="0"></a>

После знака мантиссы сразу должна идти единица: эта правило для нормализованной мантиссы.

### Смещённый (машинный) порядок
Они получаются прибавлением к обычному числовому порядку константы смещения. Этим достигается то, что машинные порядки располагаются от всех нулей до всех единиц в разрядной сетке ⇒ это целые положительные числа

Числовые порядки обрабатываются в модифицированных кодах, чтобы выловить переполнение, а в машинном порядке достаточно добавить 0 на первую позицию, и если в результате вычислений он сменится единицей, то это будет говорить о переполнении.

<a href="https://ibb.co/jwTbm82"><img src="https://i.ibb.co/2MyWxFQ/image.png" alt="image" border="0"></a>

Мы сначала перевели десятичное число в двоичную систему, записали его с обычным двоичным порядком и перевели его в машинный порядок, прибавив константу смещения.

На месте $n_п$ должно оказаться 22 (10110).

<a href="https://ibb.co/HTGDdSL"><img src="https://i.ibb.co/1GRf6gY/image.png" alt="image" border="0"></a>

<a href="https://ibb.co/sQfKdvm"><img src="https://i.ibb.co/ZKjBp6L/image.png" alt="image" border="0"></a>

Это есть ни что иное, как алгоритм умножения в прямых кодах со старших разрядов множителя.

На что обратить внимание:

- проверить количество цифр после запятой: если перемножаем 4 разрядные числа, дб 8 разрядный результат
- суммировать лучше по отдельности по 2 числа, после к результату ещё одно, потом ещё -- делать последовательно, сразу все 4 числа не складывать, ошибёмся

<a href="https://ibb.co/t4MLW56"><img src="https://i.ibb.co/mGCNM7K/image.png" alt="image" border="0"></a>

<a href="https://ibb.co/5xNfyGF"><img src="https://i.ibb.co/x8pR0XH/image.png" alt="image" border="0"></a>

Это есть не что иное, как алгоритм умножения чисел в дополнительных кодах с фиксированной запятой со старших разрядов в множителе.
<a href="https://ibb.co/T0Vd3yP"><img src="https://i.ibb.co/5jNwHZs/image.png" alt="image" border="0"></a>

<a href="https://ibb.co/2q7mbGK"><img src="https://i.ibb.co/dB01h8K/image.png" alt="image" border="0"></a>

<a href="https://ibb.co/zscCgzx"><img src="https://i.ibb.co/tBfn69K/image.png" alt="image" border="0"></a>

6 итераций, так как знак тоже обрабатывается.

# Семинар 5. Машинная методика выполнения операции сложения-вычитания чисел с фиксированной запятой.
<a href="https://ibb.co/ZzjY02k"><img src="https://i.ibb.co/hF6ZSYt/image.png" alt="image" border="0"></a>
Операция сложения является базовой операцией в ЭВМ: и сложение, и вычитание выполняются как сложение; в случае вычитания просто преобразуется вычитаемое.

Эта операция отработана. Поэтому машинная методика позволяет когда мы работаем с фиксированной запятой
- заменить операцию вычитания сложением
- знаковые разряда обрабатываются точно так же, как и цифровая часть, то есть не требуется приставки к сумматору для отдельной обработки знака
- автоматически фиксируется переполнение

Это достигается за счёт применения специальных кодов, а именно обратных и дополнительных кодов.

Прямой код также используется в ЭВМ: он применяется для ввода-вывода чисел и для кодировки знака.

### Как формируются коды для положительного числа 
$$A = +0.a_1a_2\dots a_n>0$$
Прямой, обратный и дополнительный коды числа -- это есть само число; а модифицированные коды -- тоже само число, но с двумя знаковыми разрядами

### Как формируются коды для отрицательного числа
В этом случае коды разные и формируются таким образом:
$$A = -0.a_1a_2\dots a_n$$
- Прямой код: кодировка знака единицей и само число;
- Обратный код: знак кодируется единицей + инверсия по цифровой части
- дополнительный код: инверсия разрядов + прибавление единицы в младший разряд на сумматоре
- обратный модифицированный: тот же обратный, но 2 знаковых разряда
- дополнительный модифицированный: тот же модифицированный, но 2 знаковых разряда.

Таким образом, мы можем сделать вывод, что коды есть те же числа. но специально сформированные, которые позволяют добиться такого качестве операций, о которых описано выше. Получив результат в специально сформированных кодах, мы переходим обратно в исходный вид в прямом коде.

### Методика и особенности алгебраического суммирования в прямых кодах

По определению число А в прямом коде это есть само число А, если А положительное и 1 + |A|, если оно отрицательное.
<a href="https://ibb.co/Zg76j6R"><img src="https://i.ibb.co/z2DhMhW/image.png" alt="image" border="0"></a>


Если мы работаем в прямых кодах, мы можем работать **только** с числами с одинаковыми знаками. Например, в кассовых аппаратах. Признак переполнения разрядной сетки -- это перенос из разряда $c_1$.

При прямых кодах знак автоматически не вырабатывается.

### Методика и особенности алгебраического суммирования в обратных кодах
<a href="https://ibb.co/RYZvbBK"><img src="https://i.ibb.co/XjN2L3P/image.png" alt="image" border="0"></a>


Двоякое представление нуля -- это недостаток обратных кодов. Поэтому при применении обратных кодов в ЭВМ необходимо иметь какую-то дополнительную схему, которая оценивала бы входящие числа на предмет равенства нулю.

Что даёт нам обратный код без модификации?
- сложение чисел с произвольными знаками
- знак результата вырабатывается автоматически
- признак переполнения разрядной сетки (превышение результатом по модулю единицы) -- знак результата противоположен знаку операндов

<a href="https://ibb.co/jWNXQBh"><img src="https://i.ibb.co/Jy1JG0n/image.png" alt="image" border="0"></a>
Первые два примера -- на переполнение разрядной сетки, а второй -- на обычное сложение с фиксацией знака.

В первом примере при сложении двух положительных чисел мы получили отрицательное ⇒ полученный результат не может быть суммой этих двух чисел ⇒ переполненние.

Аналогично во втором примере: при сложении двух отрицательных чисел получили положительный результат ⇒ переполнение.

При сложении чисел с разными знаками переполнения в принципе быть не может.

Когда мы выполняем суммирование в обратных кодах, всё, что получается в переносе, не пропадает, а идёт на суммирование в младший разряд.

<a href="https://ibb.co/2qZFKX1"><img src="https://i.ibb.co/mJNRzQV/image.png" alt="image" border="0"></a>

Особенности
- возможность складывать числа с произвольными знаками
- при этом знак вырабатывается автоматически
- признак переполнения в обычных дополнительных кодах -- знаки операндов противоположны знаку результата
- ноль в дополнительных кодах представляется однозначно

<a href="https://ibb.co/Fgbbkbc"><img src="https://i.ibb.co/MMDDyDK/image.png" alt="image" border="0"></a>

Преимущество в том, что если перейти от плюс нуля к минус нулю, мы получим то же самое.

### Модифицированные коды

Модифицированные коды позволяют более удобно фиксировать переполнение разрядной сетки.

Разрядная сетка с использованием модифицированных кодов выглядит так:

<a href="https://ibb.co/LDT9yWf"><img src="https://i.ibb.co/spTs4Gr/image.png" alt="image" border="0"></a>

Заметим, что Sg1 определяет знак числа, а Sg2 -- переполнение.

<a href="https://ibb.co/Ns9qrpb"><img src="https://i.ibb.co/9Nb0h2S/image.png" alt="image" border="0"></a>


<a href="https://ibb.co/pJ8VtRn"><img src="https://i.ibb.co/HnswWxX/image.png" alt="image" border="0"></a>
                                                                                                    


# Семинар 6. Деление прямых и дополнительных кодов чисел с фиксированной запятой.
### Алгоритм деления без таблицы умножения

Этот алгоритм широко применяется, в том числе и в двоичной СС.


<a href="https://ibb.co/rw0qC4D"><img src="https://i.ibb.co/4VtC6Ph/image.png" alt="image" border="0"></a>

<a href="https://ibb.co/t261r8Q"><img src="https://i.ibb.co/s14XYyb/image.png" alt="image" border="0"></a>

<a href="https://ibb.co/r5S3SnS"><img src="https://i.ibb.co/xz0Y0V0/image.png" alt="image" border="0"></a>

первый остаток вычисляется как разность модулей; последующие остатки вычисляются по формуле.

<a href="https://ibb.co/g3LyvZJ"><img src="https://i.ibb.co/3791fmc/image.png" alt="image" border="0"></a>

$\alpha_0 < 0\implies z_0 = 0$

<a href="https://ibb.co/N2FZ6Vm"><img src="https://i.ibb.co/hFgDR7Z/image.png" alt="image" border="0"></a>

Обратим внимание, что возникает локальное переполнение в $2\alpha_1$, которое тут же убирается вычитанием частного

<a href="https://ibb.co/T02D5CV"><img src="https://i.ibb.co/4StwxQ6/image.png" alt="image" border="0"></a>

<a href="https://ibb.co/G5QZr9m"><img src="https://i.ibb.co/vj4NMh9/image.png" alt="image" border="0"></a>
<a href="https://ibb.co/FVCQG5s"><img src="https://i.ibb.co/yS7zL6h/image.png" alt="image" border="0"></a>

локальные переполнения операции деления допустимы, они тут же убираются.

<a href="https://ibb.co/hHFH5pX"><img src="https://i.ibb.co/FJ4JvGs/image.png" alt="image" border="0"></a>

при этом порядки мб представлены в прямых, обратных и дополнительных кодах. а также целыми числами в машинных порядках.

мантиссы мб представлены в прямых, обратных и дополнительных кодах.


При этом операции умножения и деления выполняются в два этапа. На первом этапе находится сумма или разность порядков, на втором -- произведение или результат деления мантисс. 

Эта операция (умножение/деление) считается наиболее простой для чисел с плавающей запятой. Центр тяжести смещается на частные случаи: мы работает в ограниченной разрядной сетке, и переполнение может быть как в разрядной сетке порядков, так и в разрядной сетке мантисс, и все такие случаи надо отрабатывать.

Рассмотрим сперва умножение чисел с плавающей запятой и частный случай при работе с мантиссами при умножении:

<img src="https://i.ibb.co/rp3b4K3/image.png" alt="image" border="0">

Наименьший результат, который может получиться при умножении мантисс, это 1/4 -- 0.010000. Здесь после знакового разряда появляется ноль: это нарушение нормализации, и таких случаев достаточно много. Получается, что где-то половина операций умножения чисел с плавающей запятой потребует коррекции мантиссы.

Фиксация таких случаев следующая: первый разряд после запятой, то есть после знака, равняется нулю. Эта фиксация зависит от кодировки: для ПК это просто 0, для ОК и ДК -- это 0 для положительных чисел и 1 для отрицательных в первом разряде после знакового.

<a href="https://ibb.co/r0SyrkF"><img src="https://i.ibb.co/3dqhZ14/image.png" alt="image" border="0"></a>
При делении также возникает частный случай при работе с мантиссами: если минимально возможное частное гарантированно больше 1/2 по величине, то слева с нормализаций всё в порядке. Однако справа может сложиться ситуация, когда частное может иметь целую часть, так как величина максимальной мантиссы по модулю равняется почти 1, и разделив её на минимальную мантиссу, равную 1/2, мы получим число, заведомо большее 1  ⇒ такая мантисса будет ненормализована.

Мантисса нормализуется сдвигом вправо на одну позицию (делением на 2) и одновременно прибавлением 1 к разности порядков.

Эта ситуация фиксируется анализом цифры перед запятой. Если появляется целая часть в мантиссе, равная единице, которая может появляться **только при делении прямых кодов**, то это переполнение.

При делении ОК и ДК таких ситуаций не возникает, так как область применения методик деления для таких кодов предполагает, что |X| < |Y|, и частное никогда не будет иметь целую часть.

Когда мы делим прямые коды, мы сначала определяем знак, и на первом шаге вычисляем $\alpha_0$. Если $\alpha_0$ положительный, то у нас в частном будет целая часть -- это та ситуация, которая требует нормализации мантисс и коррекции порядков.

<a href="https://ibb.co/YZR6vZf"><img src="https://i.ibb.co/bJWxpJN/image.png" alt="image" border="0"></a>

Числовые порядки -- целые числа со знаком, то есть числа с фиксированной точкой. На фиксацию отводится $n_п$ разрядов.

Тут может возникать переполнение порядковых разрядов при умножении или делении.

Если происходит положительное переполнение, и не хватает разрядной сетки, когда результирующий порядок больше максимального, который можно представить в ЭВМ, результат выполнения операции принимают равным бесконечности. Этот случай фиксируется с использованием модифицированных кодов на операционных устройствах, на которых знак **удваивается** (в памяти числа хранятся с одним знаком). Если в знаковых результатах на операционном устройстве получается код 01, то это признак бесконечности.

Когда результат не вписывается в разрядную сетку, но настолько мал, что не может вписаться, это случай, когда сумма или разность порядков меньше минимально возможного порядка, которой можно представить в ЭВМ. В этих случаях полагают, что результат равен 0, вычисления продолжаются. Признак случая: в старших разрядах (знаковых) результат получается с кодом 10.

<a href="https://ibb.co/NLtZJcC"><img src="https://i.ibb.co/p3bJMYw/image.png" alt="image" border="0"></a>


<a href="https://ibb.co/6yckdKW"><img src="https://i.ibb.co/RgGq5XD/image.png" alt="image" border="0"></a>

<a href="https://ibb.co/8zQ5c6c"><img src="https://i.ibb.co/M8JV6M6/image.png" alt="image" border="0"></a>

Первый пример будет на числовые порядки, а второй на машинные. Выполняются операции умножения и деления, надо каким-то образом обработать порядок и указать результирующий порядок с указанием особенностей

<a href="https://ibb.co/MMf1qMP"><img src="https://i.ibb.co/cDw8zD2/image.png" alt="image" border="0"></a>

nп = 4: оидн разряд -- знак, три -- цифровая часть.

Нужно найти машинные порядки произведения и частного. Но сперва нам необходимо сформировать машинные порядки для исходных чисел. Формируем их по определению: это есть обычный числовой порядок плюс константа смещения. 

Порядок на операционном устройстве будет представлен со знаком (0.0101 для X), а в оперативной памяти он будет храниться как 0101, без знакового разряда.

При умножении чисел в МП порядки складываются и вычитается константа смещения. Сперва мы считаем их в десятичной системе, аналогично для деления.

Далее мы воспроизводим, как вычисления выполняются на операционном устройстве. А именно, 5 = 0.0101 складывается с 14 = 0.1110 и вычитается 8 = 1.1000. Складываем всё и получаем результат 0.1011. Записываем машинный порядок произведения в десятичной СС и в двоичной то, что получилось на операционном устройстве.

Аналогично для деления: 5 = 0.0101 + (-14) = 1.0010 + 1 = 0.1000 = 1.1111 в ДК. Ответ в десятичной СС и то, что получили в ОУ: там переполнение, Z равняется 0.

<a href="https://ibb.co/kGXmNcs"><img src="https://i.ibb.co/x26Fx5t/image.png" alt="image" border="0"></a>

Тут в конце ошибка: $m_{х*у м} = 1.0001_2$

<a href="https://ibb.co/9Y96PgV"><img src="https://i.ibb.co/QmFL0QC/image.png" alt="image" border="0"></a>

Опечатка: во втором пункте $m_x - m_y < 0$

В этой операции порядки могут быть представлены в прямых, обратных или дополнительных кодах, а также целыми числами в машинных порядках (порядках со смещением). Когда они обрабатываются, происходит их модификация.

Мантиссы также могут быть представлены в прямых, обратных или дополнительных кодах.

Когда порядки обрабатываются, выполняется их модификация, с мантиссами тоже самое. (МОК или МДК).

I этап -- обеспечение равенства порядков. Находится разность порядков. По знаку разности определяется там мантисса, которая будет подвергаться денормализации -- та мантисса, которой соответствует меньший порядок; а по абсолютной величине разности будет выполняться сдвиг мантиссы с наименьшим порядком.

Далее следует пример, иллюстрирующий необходимость этого этапа. 

<a href="https://ibb.co/YbY8D28"><img src="https://i.ibb.co/yVG5h05/image.png" alt="image" border="0"></a>

На III этапе: одновременно из максимального порядка, который идёт в ответ, вычитается $i$ единиц.

Результат меньше минимально возможного директивно назначается равным нулю и ЭВМ продолжает работу. Аналогично, если результат больше максимально возможного, он полагается равным бесконечности и происходит аварийный останов машины.


<a href="https://imgbb.com/"><img src="https://i.ibb.co/hmzjsy9/image.png" alt="image" border="0"></a>


<a href="https://ibb.co/wYVTgg6"><img src="https://i.ibb.co/t3gSKKC/image.png" alt="image" border="0"></a>

<a href="https://ibb.co/rZZCfsK"><img src="https://i.ibb.co/brrSRJj/image.png" alt="image" border="0"></a>

$$X = 2^{m_x}*M_x\quad Y = 2^{m_Y}*M_Y$$$$S = X\pm Y = 2^{\max (m_X, m_Y)}*(M'_X\pm M'_Y)$$

### Последовательность вычислений
1. Выравнивание порядков
2. Сложение мантисс
3. Нормализация
4. Перевод в ПК

## Случаи переполнения разрядной сетки порядков
### 1. Порядок больше максимально возможного
Обеспечили равенство порядков. Сложили мантиссы. Получили, что результат сложения по модулю больше 1. Попытка нормализации ре


<a href="https://imgbb.com/"><img src="https://i.ibb.co/WyzHTf4/image.png" alt="image" border="0"></a>


<a href="https://imgbb.com/"><img src="https://i.ibb.co/Yp528Nb/image.png" alt="image" border="0"></a>

<a href="https://imgbb.com/"><img src="https://i.ibb.co/L05pqNn/image.png" alt="image" border="0"></a>

<a href="https://imgbb.com/"><img src="https://i.ibb.co/JjyGnwM/image.png" alt="image" border="0"></a>

<a href="https://imgbb.com/"><img src="https://i.ibb.co/grHqZKB/image.png" alt="image" border="0"></a>
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTM5ODg4MDA2MiwtNTQ2NTM3MDk3LDU3OD
k2MjY3LC01Mzc5MjYwNzksOTIwNTA3MTMsMTM3OTYzOTg2LC0x
MDUyMTk4NTkxLC02ODMyNzM5MzYsLTM4NDUzNTIzOCwxMTI1OT
E3NDUzLDE2MTU1NDY0MzgsMTMyMzcxNTk4OCwtMTUxMzg3MjE1
MSw3Mjg1MTQzNDYsLTEzNzQ0NjEwMDQsLTUzNjQxMTcyMSwxOT
Y2MTkxNTk3LDk5OTIwMzg2MF19
-->