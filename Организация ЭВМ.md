
# Общая структурная схема процессора


БО -- блок, который непосредственно выполняет арифметико-логические операции.

Управляет блоком операции МУУ -- местное устройство управления. Он формирует управляющие сигналы для выполнения арифметико-логических операций на БО.

ЦУУ -- центральное устройство управления. 

П -- память или система памяти. Она мб показана пунктиром, потому что из системы памяти внутри процессора находится только кэш, а ОП по определению находится вне процессора (максимум только какая-то её часть).

Блок операции и МУУ вместе образуют АЛУ -- арифметико-логическое устройство. Оно выполняет арифметические и логические операции.

Пунктирные блоки -- опциональные -- блок контроля и диагностики и блок связи с каналами (с внешними устройствами).

Блок контроли и диагностика работает при включении компьютера: он выполняет некоторое тестирование. Контроль от диагностики отличается тем, что контроль -- то, что выполняется во время работы процессора при осуществлении операций, а диагностика -- это специальный режим проверки, какой из блоков не работает (например, контроль по чётности -- это когда к данным или командам добавляются дополнительные разряды, которые контролируются в процессе выполнения).

У нас эти пунктирные блоки отсутствуют. Они не входят в состав процессора, так как они опциональные.

Внутри ЦУУ -- устройство, которое занимает верхний уровень в иерархии управления, делится на БУК и БМК.

**БУК** -- блок управления командами. Он формирует **исполнительные** адреса операндов и адреса следующей команды или следующих команд. То есть он управляет последовательностью команд.

**БМК** -- блок формирования (выработки) микрокоманд. Он отвечает за формирование управляющих сигналов для управления другими блоками процессора. Фактически там же формируется $Y_C$.

Можно было ьы считать, что как по аналогии в АЛУ БУК -- это как БО, а БМК -- это как МУУ.

Система памяти состоит из ОП и РОН (регистры общего назначения). Также там может быть кэш нескольких уровней, а ВЗУ -- внешнее запоминающее устройство, обычно реализуется через связи с внешними устройствами.

**Процессор** -- это устройство, осуществляющее процесс обработки данных по заданной программе.

**Центральный процессор** -- это процессор, в состав которого входят устройства управления, АЛУ, и который осуществляет наряду с обработкой данных управление другими устройствами ЭВМ.

ЦУ в иерархии подчинения занимает самое высокое место.

<a href="https://ibb.co/3Nj4mDD"><img src="https://i.ibb.co/C7YmKkk/image.png" alt="image" border="0"></a>

Работа процессора начинается с включения питания. 

После этого может осуществляться автоматический контроль (но он опциональный, это не рассматриваем)

1. Самое первое, что надо выполнить после включения питания, -- сброс (CLR или синхронный сброс). Например, в ПЛИС после загрузки информации проходит сигнал GSR -- global set reset. При этом может очищаться память (хотя раз там нет нужной информации, в этом нет необходимости).

2. Затем надо задать начальный адрес программы $A_{нач}$. Как правило, это выполняется автоматически: задаётся нулевой адрес, из которого можем куда-то переходить. При этом сброс и загрузка начального сброса могут происходит одновременно. 

3. После этого надо задать команду start, чтобы запустить систему. Начальный адрес поступает в SK -- счётчик команд. **Счётчик команд** -- предназначен для хранения текущего адреса программы (продвинутого адреса -- не текущего, а продвинутого на следующую команду). 
4. По определению программа и исходные данные хранятся в ОП, которые могут туда поступить с флешки, диска или с ПЗУ. В оперативную память происходит обращение по начальному адресу из счётчика команд. Вообще говоря, между ОП и процессором может быть кэш нескольких уровней, но в кэш дублируется часть ячеек из ОП.
5. Задаём управляющие сигналы для обращения к памяти Уск от БМК, под действием которых 
6.  Мы считываем из памяти код команды. Он поступает в регистр команды RK. При этом код команды может считываться не за одно обращение. А иногда мы наоборот, за одно обращение может считать и принять в регистр команд несколько команд, если команды короткие, а регистр многоразрядный. Код команды содержит код операции и адреса

<div align="center"><a href="https://imgbb.com/"><img src="https://i.ibb.co/myv1Xq9/image.png" alt="image" border="0"></a></div>

Команда делится на две части -- операционная и адресная. Как правило, эти поля одной и той же размерности (например, А1 имеет больше разрядов, чем Ак). В нашем процессоре двухадресные команды с разным механизмом адресации первого и второго адреса.

При этом в адресном поле могут задаваться указатели адреса или признаки адреса. Например, пусть по два разряда входят в каждый адрес, и они определяют вид адресации.

<div align="center"><a href="https://imgbb.com/"><img src="https://i.ibb.co/VMZbbSV/image.png" alt="image" border="0"></div>

При прямой адресации на адрес отводится как двоичный логарифм $M = \log_2(n)$, где $n$ -- количество байт.

7. Когда мы считали команду, следующее действие -- дешифрация кода операции. Надо определить, какая это команда -- линейная или нелинейная (она же  -- команда перехода). На размерность команды также указывает код операции: при дешифрации мы определяем не только вид команды, то ещё и размерность команды -- количество разрядов и адресов: одноадресная, двухадресная команда, какой тип адресации и так далее. Кроме того, на размерность команды может указывать и признак адреса: если мы указываем обращение к регистровой памяти, а не к оперативной, то адреса будут намного короче. На основании дешифрации определяется размерность команды, назначение полей и какую команду выполняем.

Сначала рассмотрим пример выполнения линейной команды. Для этого следующим действием будет подготовить операнды.

### Линейная команда

8. Извлечь операнды. При этом операндов не один, а несколько и адрес операндов может меняться в зависимости от механизма адресации. Поэтому сначала надо сформировать исполнительные адреса операндов в БУКе, которые поступают уже как в ОП, так и в РОНы: операнды могут находиться и в регистрах. При этом также формируются управляющие сигналы для памяти, а на выходе из неё эти операнды принимаются в буферные регистры Р1 и Р2 (или BP1, BP2, учитывая, что P1 и P2 будут зарезервированы за состояниями датчика состояний, которые находятся внутри МУУ). Эти регистры установлены между ОП и блоком операции. Мы извлекаем эти операнды последовательно так, чтобы оба они были готовы перед началом операции, потому что их мы загружаем в БО одновременно. В общем случае этих буферных регистров может быть гораздо больше там, где работает конвейер (например, в эльбрусе до 14 ступеней -- готовились операнды для выполнения 14 команд). 
9. Данными буферными регистрами управляет БМК с помощью управляющих сигналов УСk
10. Под действием управляющих сигналов выполняется загрузка операндов из памяти в Р1 и Р2.
11. После того, как мы подготовили операнды, надо начать выполнять операцию в АЛУ. Для этого АЛУ нужно сообщить, какую операцию нужно выполнить. Для этого мы сообщаем туда код операции COP': мы передаём не весь код операции, а какую-то его часть. Для наших процессоров, раз выполняется две команды, достаточно только одного бита. А есть ещё и команды перехода, у которых больше разрядов, поэтому в МУУ передаётся только часть разрядов. Поэтому кодирование команд желательно выполнить так, чтобы можно было в МУУ передавать только часть кода операции.
12. Запустить АЛУ, сообщив в его то, что всё подготовлено для опреации. Для этого подаётся SNO -- сигнал начала операции. При этом приостанавливается выполнение команды в ЦУУ и начинает работать АЛУ. (В конвейере ЦУУ после этого может готовить данные для следующей команды). 
13. В соответствии с разработанными алгоритмами выполнения операций COP', МУУ формирует управляющие сигналы Yi. Выполнение команд в БО начинается с того, что мы операнды A и B одновременно загружаем в регистры RA и RB внутри БО под действием Yi с МУУ. 
14. В алгоритме надо учитывать, что на его выполнение влияют сигналы-признаки, в соответствии с которыми могут быть ветвления или переходы $\varphi_i$ -- статусные или осведомительные сигналы. Эти сигналы посылаются в МУУ, на основании которых тот формирует те или иные сигналы $Y_i$ до тех пор, пока не закончится выполнение операции.
15. Когда операция выполнена, в ЦУУ надо сообщить об этом и формируется сигнал конца операции SKO. В регистре результата RR сформирован результат операции. По сигналу SKO завершается работа АЛУ для данной команды и запускается опять ЦУУ, которое продолжает работать над выполнением данной команды. Если ЦУУ чем-то занято, то эта команда может встать в очередь.
16. ЦУУ должно проверить, нужно ли записывать результат. Если результат записывается, то формируется исполнительный адрес результата по той же самой шине 
17. Результат записывается в ОП.
18. Некоторые из команд формируют признаки результата. Их нужно передать из регистра признака RPR в ЦУУ, который будем поступать как правило, в БМК, потому что в зависимости от признака может меняться алгоритм самой программы. При этом некоторая часть может поступать и в БУК, который может сформировать свои признаки фи перехода. Пунктиром показано, что можно решать, что регистр признака может отсутствовать в БО и/или присутствовать свой регистр признака в БУК, и на каждом шаге мы подаём признак результата в RPR в БУКе. Этот же регистр мог быть не регистром признака, а регистром флага -- где на каждый признак свой флаг, а в случае признаков, а не флагов, -- эти признаки кодируются двоичным кодом, который дальше надо дешифрировать.
19. Подготовить адрес следующей команды в счётчике команд. Для этого СК увеличивается на 1, а если команда содержит не одного слово, мы должны добавить дельту, где $\Delta$ -- это размерность команды. Она должна добавляться не обязательно в итоге, она может учитываться уже в адресации операндов, поэтому обычно адрес команды меняется по шагам. $$СК:=СК + 1(\Delta)$$В счётчике команд формируется адрес следующей команды.
Перед выполнением любой команды в счётчике команд уже находится её адрес.

У системы памяти на считывание один адресный вход, а выходных две шины --  для команды и для операндов. Иногда это может быть корректно, потому что кэш может быть L1 инструкций, и L2 данных. Но эти шины могут быть едины, и с ними же может быть соединена шина адреса, потому что всё равно данные передаются в разное время. Но сейчас это всё разделяют для ускорения.

<div align="center"><a href="https://ibb.co/3MDT34W"><img src="https://i.ibb.co/WPbHhGF/image.png" alt="image" border="0"></a></div>

### Цикл выполнения линейной команды
1. **Выборка команды из ОП** и запись в регистр команд РК **(Instruction Fetch -- IF)**
	Увеличение счётчика команд $СК:=СК+1(\Delta)$
2. **Декодирование КОП** команды и способов адресации, формирование **$A_{исп}$ операндов** **(Instruction Decoding -- ID)**
3. **Выборка (считывание) операндов** из ОП или РОН и запись в буферные регистры процессора **(Operand Reading -- OR)**
4. **Выполнение операции** в АЛУ **(Executing -- EX)**
5. **Запись результата** в ОП или РП **(Write Back -- WB)**.

В одноадресных командах результат может оставаться в регистре-аккумуляторе RR. Он может быть в составе РОН.

Увеличение счётчика команд нельзя выполнять в конце, так как адрес следующей команды может учитываться в способах адресации: там может учитываться уже продвинутый адрес, настроенный на следующую команду.

При этом считывать можно побайтно, по 2 байта или по 4, поэтому в способах адресации учитывается уже именно продвинутый адрес.

Среди этих этапов могут быть только 4, потому что в одноадресных командах участвует только один адрес, и результат такой операции записывается в аккумулятор и последнего этапа -- записи в какое-то отдельное место нет.

### Цикл выполнения нелинейной команды (перехода, цикла, возврата, пропуска)

$$\begin{array}{|c|c|c|}\hline СОР& УА&А_{пер}\\\hline\end{array}$$

УА -- указатель адреса, который может задавать способ адресации. Вместо указателя может быть признак адреса.

1. **Выборка кода команды из ОП** и запись в регистр команд РК **(Instruction Fetch -- IF)**. Увеличение счётчика команд $СК := СК + 1 (\Delta)$.
2. **Декодирование КОП** команды и формирование $A_{исп.пер}$ -- исполнительного адреса перехода:
	- **безусловный** переход $СК := A_{пер. исп}$
	- **условный** переход -- проверка условия
		- условие совпадает (признак $\text{PR}_i$ = 1)- $СК := A_{пер. исп}$
		- условие не совпадает $\text{PR}_i=0$ ⇒  $СК := СК + 1(\Delta)$

Пока мы считываем команду, счётчик команд растёт. Поэтому всегда там, где нужно, участвует именно *продвинутый* счётчик команд, настроенный на следующую команду, для того, чтобы не надо было возвращаться на исходный адрес.

При безусловном переходе происходит переход на *исполнительный* адрес перехода -- он зависит от конкретного механизма адресации.

При условном переходе возможны два варианта в зависимости от значения признака операции. Если он равен единице, то в счётчик команд загружается исполнительный адрес перехода -- не тот, который может стоять в коде команды, а уже вычисленный в соответствии с конкретным механизмом адресации с учётом указателя адреса. Иначе -- если он равен 0, то в счётчик команд загружается $\Delta$ -- размерность команды: для общего случая она считается в байтах, в наших случаях -- 4 разряда или полубайты. При этом команды должны быть плотно расположены без пропуска. Эта $\Delta$ добавляется не сразу, а последовательно и постепенно: где-то на 1, где-то на 2: зависит от того, как команды программы "упакованы" в оперативную память. Поскольку команды находятся плотно друг за другом, то приходится добавлять эту разную величину. После добавления дельты, равной размерности команды, получается *продвинутый адрес*.

Память у нас 8-разрядная, поэтому 12-разрядную команду можно записывать в одну ячейку 8 бит, и половину команды в другую ячейку. Потом во второй половине второй ячейки начинается вторая команда: никаких пропусков быть не должно. Поэтому 12-разрядная команда будет занимать полторы ячейки памяти.

Если условие не совпадает, мы, как правило, идём на следующую команду, которая отличается на дельту -- размерность команды. Например, команда имела 100 адрес и занимает три полуслова, значит, мы должны уйти на 103 адрес.

Адреса формируются не в блоке операции. Для этого существуют свои сумматоры и счётчики, которые находятся в БУКе. Аналогично и счётчик команд, который тоже находится в БУКе, тоже может суммировать какое-то смещение, поэтому и у него тоже есть свой сумматор.

Команда пропуска (как правило, с условием) отличается от других команд перехода тем, что в ней нет адресного поля. Она безадресная, и в КОП уже записано, сколько байтов надо пропустить. Таким образом исключается адресное поле. Команда пропуска заключается в том, что мы "перепрыгиваем" через следующую команду -- осуществляется пропуск одной команды заданной размерности.


В команде перехода мы не передали управление в АЛУ. Если в линейной команде после выборки операндов управление передаётся в АЛУ, то все команды перехода выполняются целиком в ЦУУ.

На схемах пересылка данных изображается двойными линиями, управляющих сигналов -- одинарными.

У системы памяти может быть и своё местное устройство управления. Это вообще относится к каждому устройству в процессоре.

В этой схеме условно отмечены, что в каждом блоке могут быть очереди: в процессоре выполняется совмещение команд -- конвейер. Поэтому в регистре команд условно на входе присутствуют очередь. Такая же очередь есть и на выходе этого регистра, такие очереди есть на буферных регистрах операндов. Очереди есть и на выходе регистра результата, чтобы мы не сразу считывали.

Входные данные могут загружаться через флешку или другое внешнее устройство с помощью контроллера ввода вывода в ОП

Здесь показана отдельно шина информации и шиана адреса. ЗДесь шина данных одна, с которой поступает информация как в БУК, так и в буферные регистры операндов. По этой же самой шине результат записывается в ОП.

Чтобы ускорить, шин таких могут быть две: одна на выдачу информации, а другая -- на приём, то есть память может быть двухпортовая с точки зрения памяти и считывания.

Кроме того, могут быть шины из кеша первого уровня L1. Кэш верхнего уровня делится на два блока -- блок инструкций и блок данных, поэтому могут быть отдельные шины, связывающие команды и данные. 

Мы будем разрабатывать два устройства: МУУ схемного типа (БО), а БМК будет выполнено с помощью микропрограмм. На данной схеме БМК раскрыто как устройство схемного типа с жёсткой логикой.

### БУК 

Блок управления командами. В его состав могут входить

#### Счётчик команд

 Счетчик команд (иногда называют регистром инструкций: можно перед регистром поставить сумматор и получить счётчик -- это бывает удобно чтобы прибавлять смещение в относительной адресации). Относительная адресация -- текущее содержимое счётчика команд + смещение, которое написано в самой команде. Поскольку у нас у всех будет смещение в командах перехода, предлагается использовать не *A* (это адрес в ОП) или *R* (это регистр), а, например, *SM* (смещение) или что-то другое.
 
#### Регистр команд

Предназначен для хранения текущей выполняемой программы. На его входе может быть очередь из последующих команд. В команде находится КОП, который указывает на то, какую операцию нужно выполнять, и несколько адресов -- сколько-адресная команда, столько и адресов A~i~ будет. Кроме того, там же могуп быть и признаки, указывающие на то, какая это адресация. В адресах могут быть номера регистров, смещения и так далее.

При проектировании надо будет выбрать свой механизм адресации из книжке на сайте.

Начальный адрес должен загружаться в счётчик команд (это один из первых шагов при запуске процессора). Если мы будем начинать программу с нулевого адреса, можно одновременно с CLR обнулять счётчик команд, и тогда это не понадобится. А в общем случае перед счётчиком команд стоит мультиплексор, который бирает либо начальный адрес, либо следующий адрес команды.

Если адресация *команд* относительная, то нужен сумматор, на который поступают счётчик команд и смещение --  получаем исполнительны адрес, например, следующей команды, который будет передаваться не в память, а через мультиплексор опять в счётчик команд. 

У относительной адресации есть плюс: мы не привязаны к конкретным адресам в памяти: это полезно при многопрограммном режиме (для выполнения нескольких программ просто загружает начальный адрес A~нач~ в счётчик команд). Ещё один плюс -- укорачивание разрядного поля, потому что смещение может быть неполным (коротким, не все разряды) и иметь знак: мы можем идти как вперёд, так и назад.

#### Сумматор

Здесь условно показано: сумматор может суммировать и не два, а три операнда -- это ведь структурная схема. Этот сумматор может быть реализован внутри на двух сумматорах: например, один сумматор, а за ним второй и будет стоять КСЮЮ которая блокирует какие-то операнды.

#### Регистр очереди

Это регистр адресов, которые могут быть как адресами перехода, загружаемые в счётчик команд, так и адресами операндов.

Из регистра индекса (это могут быть самостоятельными регистрами), но в наших процессорах может быть и регистр базы для базового адреса, и они могут быть и в блоке регистров вместе с РОН. Из них в нужный момент можно извлечь информацию для индексной адресации. (считается, что если нужен индекс, то известно, из какого регистра надо брать значение -- это показано шиной между блоком регистров и регистром индекса R~i~). Регистр индекса и смещения могут находиться и внутри в адресе команды.

Исполнительный адрес A~исп~-- база + индекс + смещение (показано). Они полезны для обработки массивов и статистики.

#### Регистр исполнительного адреса

При косвенной адресации (берём адрес из команды -- мы обращаемся по нему в ОП и уже этот адрес, который мы вытащили из ОП, и будет исполнительным), нужен будет дополнительный регистр исполнительного адреса.  В других случаях он может отсутствовать.


Может быть и многоступенчатая косвенная адресация -- это может быть отмечено в признаке адреса, и тогда таких итераций извлечения адресов и хождений по памяти может быть много. Это возможно при выполнении поиска в каких-то системах.

Для общего случая может и блок операций быть не один, а несколько: например, отдельный БО для фиксированной и плавающей запятой, аналогично с РОНами: могут быть РОНы только связанные с адресами, РОНы для плавающих чисел и так далее. Также могут быть отдельные регистры для базы и индекса -- это всё используется для ускорения выполнения команд и параллелизации.

Например, один БО выполняет умножение, а поскольку эти операции длинные, то можно параллельно запускать другой БО. Даже в ПЛИС, учитывая, что умножение используется часто, предусмотрена автоматическая настройка 19 блоков умножения в spartan 6.

### БМК

Назначение БМК -- формировать управляющие сигналы, которые могут управлять, в первую очередь, БУКом и плюс другими блоками в процессоре: сигналы могут идти в память, на блоки ввода-вывода и идти в АЛУ. БМК может быть только один -- это централизованное устройство управления, а может быть децентрализованное: много местных устройств управления в каждом блоке, а БМК только посылает на них сигналы начала работы и принимает сигналы конца.

В данном случае мы рассматриваем БМК жёсткой логики

Код операции поступает из регистра команд и дешифрируется -- на выходе имеем унитарный код.

Комбинационная схема формирует игреки: на каждом элементе внутри от того, какую нужно выполнять операцию, от того, в каком состоянии находится РИЦ (распределитель импульсов цикла в унитарном коде: на каком такте на каком шаге цикла мы находимся) и от фи для ветвлений подаются управляющие сигналы Y. В ней как минимум столько элементов, сколько игреков может быть. Таким образом, $$Y = f(РИЦ, ДШКОП, \varphi)$$Такие жёсткие схемы быстрые, потому что у них внутри задержка только одного элемента. Но они более сложные, потому что при внесении изменении нужно перепроектировать чуть ли не всю схему. А микропрограммные схемы зато проще.

#### Генератор импульсов (Главный генератор импульсов)

Может быть всего один ГГИ -- он будет находиться в БМК, и по нему можно формировать уже отдельные импульсы (С1 С2 как а лабе про регистры). Из этого главного генератора могут вырабатываться сколько других фаз импульсов. От него можно делить частоту.

В ПЛИС можно настраивать сдвиг этих импульсов от ГГИ с точностью до десятков пикосекунд. Важно, чтобы они потом не встретились на одном синхровходе. Они могут даже накладываться, если импульсы приходят на разные синхровходы разных блоков.

#### Схема пуска-останова (СПО)

Она обязательно присутствует в каждом местном устройстве. Она разрешает проходить синхроимпульсам между сигналами СНО и СКО, вырезая пачку импульсов из бесконечной последовательности от генератора между СНО  и СКО. А может и не вырезать эту пачку импульсов, а просто запрещать работать. В любому случае, там внутри стоит триггер, который переключается по СНО и СКО. Например, этот триггер потом будет разрешать или запрещать формирование игреков внутри КС. А можно вырезать пачку импульсов (как СЕ). Тогда КС может оказаться проще, чтобы не ставить у каждого элемента, отвечающего за Y, соединение с этим триггером: можно просто запретить синхроимпульсам проходить внутрь блока.


#### Блок очереди

В нём хранится очередь кодов операций. Мы могли из команды отправить адреса на формирование -- но мы их ещё не извлекли, операнды не сформировали, и пока это происходит, надо ждать и хранить код операции в очереди до тех пор, пока операнды не придут.

Внутри отдельно могут сотять счётчики циклов и счётчики тактов, еасли микрокоманда выполняется несколько тактов. Счётчик циклов отвечает за подсчёт i в циклах. Такие счётчики могут находиться в каждом местном устройстве управления.

### Память

Она показана как часть системы памяти -- это может быть ОП, до 4 уровней кэша.

ОП по определению в состав процессора не входит, но на кристалле самого процессора есть L1 кэш инструкций и L1 кэш данных, а L2 опционально. 

ОП -- как правило, динамическая память, в которой хранение информации происходит на конденсаторах.

Ещё один вариант построения БМК -- микропрограммный: она содержит управляющую память.

В памяти показаны условно регистр информации или регистр данных (хотя отсюда можно считывать и команды) и регистр адреса. В наших процессорах их не будет: адрес мы поддерживаем, и память при считывании будет работать как КС: память строится на лутах, на входах которых мы задаём адреса. С выходов памяти мы загружаем информацию в буферные регистры.

Также контроллер ввода-вывода может соединяться шиной прямого доступа с памятью.

По определению вся программа и все данные находятся в ОП, поэтому прежде чем процессор начнёт работать, данные надо загрузить в кэш данных, а команды в кэш команд. 

При этом в кэшах информация может быть согласована (когерентная), потому что она дублируется, а в какие-то моменты времени в зависимости от методов записи она может и не совпадать.

У нас будут двухпортовые памяти: одна на запись, другая на считывание. А тут показано, что считыванием и пишем через одну и ту же шину.

Подобную схему можно посмотреть на 4-6 странице в учебном пособии по проектированию процессора.

## Принципы организации управления

1. Уровень управления
	- Программный -- алгоритмы представлены наборами команд
	- Микропрограммные -- алгоритмы представлены микропрограммами выполнения команд

2. Централизованный или децентрализованный принцип
3. По типу (принципу) построения
	- с жёсткой логикой ("схемного типа" СхУУ) -- основой является РИЦ и КС
	- микропрограммное УУ (МкУУ) -- основой является управляющая память

4. Способ организации
- синхронный
- асинхронный (полусинхронный)

**Микрооперация** -- элементарная функциональная микрооперация

**Микрокоманда** -- совокупность совместимых микроопераций, выполняемых одновременно (например, RA := A, RB := B, RR := 0)

**Микропрограмма** -- последовательность микрокоманд, обеспечивающих выполнение машинной команды

**Централизованное УУ** общее для всех блоков

**Децентрализованное УУ** -- когда ЦУУ и МУУ:
- ЦУУ  формирует подготовительные сигналы: запуск
- МУУ формирует исполнительные сигналы
	- сокращает количество шин, расположено ближе к блоку
	- проще проектирование и реализация: меньше сигналов ⇒ меньше вероятность ошибиться
	- легче реализовать совмещение команд: можно запускать несколько блоков сразу
	- может иметь место сокращение аппаратных средств. Иногда какие-то блоки, например, триггеры пуска-остановка, РИЦ ставить в каждом блоке, поэтому сокращение не гарантировано.

**Синхронный способ** -- предполагает выбор фиксированного **постоянного такта T = const** выполнения микрокоманд, равного *максимальному* времени выполнения МК

**Асинхронный способ** -- длительность такта имеет **переменную величину такта Ti = vary**, необходимую для каждой МК

**Полусинхронный способ** -- каждая К-я МК выполняется за **необходимое количество тактов** генератора Ti = Ki * t, где t -- период генератора


**Разрабатываемый процессор**:
- на уровне микрокоманд -- синхронный
- на уровне микропрограмм -- полусинхронный (асинхронный): умножение выполняется, например, за 10 тактов, а сложение -- за 4. 

# Характеристики процессора и способы адресации

### Основные характеристики процессора

**1. Внутренний язык** -- система команд, форматы команд и данных. 

**2. Способы адресации**

**3. Конвейеризация команд** (количество команд и ступеней (этапов) в конвейере). Конвейеризация позволяет параллельное выполнение нескольких команд. Конвейеризация позволяет разбивать команду на несколько этапов (одновременно работают все блоки), а параллелизация -- разбивает на несколько блоков (параллельно работают одинаковые блоки). Для этого используется буферная память FIFO.

**4. ОЗУ** (ёмкость, организация, статическая, динамическая). При этом *физический* адрес -- это адрес при обращении к памяти (то есть к ячейкам), а *логический* -- адрес до байта. При этом если мы считываем два байта, адрес должен быть обязательно чётным: если мы хотим считать 0 и 1 байты, логическим адресом будет 0. Если мы хотим считать 4 слова, то чётность адреса должна быть двойная (в конце адреса должны быть сразу два нуля). Это делается, потому что обмен между памятью и процессором идёт блоками. Если мы будем указывать рандомные адреса, то тогда у нас может получиться так, что считываемые нами данные окажутся в разных блоках.

**5. Наличие и организация СОЗУ (Сверхоперативного ЗУ)**:
- **РОН** (количество и разрядность; для фиксированной и плавающей запятых): будут ли РОНы единые или отдельные для ПЗ и ФЗ. Если они единые, то тогда при работе с ПЗ будут заниматься два регистра сразу. В современных процессорах 32 или 64 регистра, при этом 4 или 8 регистров могут быть выделены для отдельной работы с плавающей запятой.
- **Служебные регистры** (базы, индекса, сегмента, страниц, ...) -- присутствуют ли отдельно эти регистры или же они находятся в РОНах. В наших вариантах процессора они располагаются в РОНах. Кроме того, на входах этих регистров могут стоять буферы.
- **Стек** для выполнения арифметических операций: в стек мы можем записывать результат предыдущих операций и брать операнды оттуда же. При этом команды работы со стеком могут быть безадресными и содержать только коды операции. Также стек используется для организации циклов.
- **Кэш** (иерархия: до 4 уровней L1-L4, ёмкость и организация, методы записи и замещения, где находятся кэши разных уровней -- на кристалле или на плате).

**5. Быстродействие и производительность**. Быстродействие (частота генератора: например, 4 ГГц), а производительность -- количество операций в секунду.

Чтобы оценить быстродействие АЛУ, надо будет подключить макет на отдельной странице: важно, что мы подключаем выходы всех элементов (например, регистры результата или регистры признака) к выходным индикаторам, то размещение может получиться неудачным, так как эти связи могут быть просто удалены. Кроме того, при размещении надо будет привести количество ЛУТов и триггеров в отчёте или как отдельной главой, или в МУУ (АЛУ), где будет приводиться оценка временных параметров.

### Формат команды

Набор операций должен быть функционально полным, чтобы можно было выполнить любые программы. При этом можно определять, какие команды выполняются арифметически, а какие -- с помощью микропрограмм: можно "подкачивать" те или иные микрокоманды. Например, команду деления можно не включать в набор команд процессора, а выполнять отдельно как подпрограмму, записанную в отдельное запоминающее устройство. Таким образом, можно определить, какие команды выполняются аппаратно, а какие -- программно.

Набор команд может быть различным. Существуют две тенденции развития процессоров -- RISC и CISC:
- **RISC -- Reduced Instruction Set Computer** --  уменьшенный набор команд
- **CISC -- Complete Instruction Set Computer** -- полный набор команд процессора

При этом в универсальных процессорах CISC могло содержаться до 600 команд (IBM/370) ради преемственности поколений: если программы работали на одном процессоре, то было бы хорошо, чтобы они продолжали работать и на более новых версиях процессоров. Однако из этих команд большинство никто никогда не применял.


### Набор команд или операций делится на группы

Чтобы можно было декодировать не все разряды, а только какую-то часть (группу), где старшие разряды определяют, к какой группе команд относится команда, а младшие -- какая это конкретно команда:
- арифметические (фиксированная и плавающая запятая, дробные и целые)
- десятичная арифметика
- логические, работа над битами и строками, сдвиги
- обмен, передача данных
- управление и переходы безусловные и условные, пропуски, циклы

**Эффективность набора команд характеризуется**:
- аппаратными затратами на размещение программ и данных
- затратами времени на реализацию алгоритмов (тесты для сравнения). Например,
- удобством для пользователей (хорошее понимание, усвоение)


При этом нужно определять, все ли операции выполнять аппаратно, то есть включать в код операции, или реализовывать их как подпрограммы.

### Размещение в памяти

Надо определить, где будут располагаться программа, операнды, константы и рабочие ячейки. Важно, что между этими блоками, кроме программы, могут быть свободные места, но в программах пропусках быть не должно.

<a href="https://ibb.co/F4Mpxk5"><img src="https://i.ibb.co/nMvpgq7/image.png" alt="image" border="0"></a>

Программы упаковываются плотно, на уровне слов (байтов) между командами пропусков нет.

При этом в первом считываемом байте должен находиться код операции, потому что он определяет размерность команды. За одно обращение (одна строка здесь -- это ячейка памяти) мы считываем два слова -- одну ячейку. А логический адрес -- это тот, который будет в счётчике команд, поэтому у первой команды будет адрес 0, а у второй -- 3.

В отличие от пособия, предлагается чётные адреса располагать в левой части: например, в 8-разрядной памяти слева будет 7 разряд, а справа -- нулевой, учитывая, что память, которую мы будем заполнять (logic block), считывается так, что старший разряд находится слева. Поэтому чётные -- это 7-4 разряды, а нечётные -- это 3-0 разряды.

В отличие от команд, данные могут располагаться с пропусками.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/HYfWyx0/image.png" alt="image" border="0"></a>

При этом в наших примерах операнд будет занимать 1 слово, а результат -- 8, причём пишутся они в одну ячейку. Поэтому операнды обязательно находятся в одной ячейке.

При этом при работе транслятора мы должны были описать С как двухсловную ячейку, и он должен был отвести сразу два слова под них.

В БУКе самое главное -- не запутаться с разрядами, размечая память операндами и командами, -- где старший разряд, а гле младший.

При этом если старшие разряды не равны нулю, в программе нужно вводить какое-то масштабирование, потому что восьмиразрядное число мы уже не можем складывать и умножать.

### Адресность

**Адресность** -- количество адресов в команде (0А -- безадресная, 1А, 2А и 3А)

**Адрес** характеризуется разрядностью и количество разрядов


Например, нам нужно вычислить функцию Y = A*B + (C-D) * E/F

Например, для трёхадресных команд мы выполняем 5 команд. Р1, Р2 -- это рабочие ячейки: там нельзя написать А или В, потому они будут испорчены, а они могут понадобиться в других операциях. Для этого мы вводим дополнительные рабочие ячейки, в которых будем хранить промежуточные результаты вычислений.

В двухадресной команде результат записывается по адресу одного из операндов. Поэтому мы на первом шаге производим считывание в рабочую ячейку А, а результат записывается по адресу первого операнда, хотя в наших заданиях это может быть и не так. Команд уже стало 8.

В одноадресной команде используется регистр-аккумулятор Ra.

<a href="https://ibb.co/fQVs0WJ"><img src="https://i.ibb.co/PtsdCyk/image.png" alt="image" border="0"></a>

### Способы и механизмы адресации

**Способ адресации** устанавливает процедуру (порядок) вычисления адреса оперативной памяти, по которому проводится фактическое обращение -- называется исполнительным адресом А~исп~ (А~физ~)

Эффективность способов адресации характеризуется
- затратами оборудования на обеспечение доступа к памяти (схема формирования А~исп~)
- затратами времени на формирование А~исп~ и времени доступа к ячейке памяти по этому адресу (считывание или запись)

### Прямая адресация

В своих отчётах также надо будте рисовать свою адресацию. Вместо "Адрес" пишем А1 (адрес первого операнда), R, если номер регистра, или SM, если смещение.

В отчётах на каждой шине (стрелке) должна будет стоять разрядность.

Никаких аппаратных затрат на формирование адреса нет, а время цикла равно времени обращения к оперативной памяти.

Вместо "Память" надо будет писать ОП.

<a href="https://ibb.co/L8bsMLS"><img src="https://i.ibb.co/dr1HSdB/image.png" alt="image" border="0"></a>

Может быть и короткая прямая адресация: чтобы сократить адресное поле, адресация может дополняться старшими разрядами, на что может указывать старший разряд адреса (0 или 1  будет указывать, чем конкретно дополняется адрес). Если мы дополнили адрес единицей, то это все адреса будут расположены во второй половине памяти. Поэтому операнды мы можем располагать, например, во второй половине памяти и тем самым выиграть один разряд адреса операндов, не указывая их старший разряд (1).

### Регистровая адресация

<a href="https://imgbb.com/"><img src="https://i.ibb.co/PrVWfsN/image.png" alt="image" border="0"></a>

R -- номер регистра. Если он относится ко второму операнду, то мы пишем R2.

Время обращения будет маленьким, потому что регистровая память будет быстрее. Хотя в наших процессорах что регистры, что ОП находятся на одном и том же кристалле, поэтому мы этого не увидим

<a href="https://ibb.co/HPR3m23"><img src="https://i.ibb.co/mydgQBg/image.png" alt="image" border="0"></a>

Ёмкость ОП намного больше ёмкость РП, поэтому количество разрядов для адресации в ОП значительно больше, чем в РП.

### Непосредственная адресация

Операнд извлекаем не из ОП, а из команды.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/Wpz3vsz/image.png" alt="image" border="0"></a>

В качестве второго операнда может быть константа (и тогда это поле можно будет уменьшать).

### Неявная адресация

В команде нет соответствующего адреса. Он может подразумеваться, например, кодом операции. Например, таким адресом может быть регистр аккумулятора.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/0GT12xM/image.png" alt="image" border="0"></a>

### Косвенная прямая адресация

<a href="https://ibb.co/GsGq17f"><img src="https://i.ibb.co/ZHv0wdR/image.png" alt="image" border="0"></a>

Адрес указывает не на операнд, а на другой адрес. В данном случае будет 2 цикла обращения к ОП. При этом нужен будет внутри дополнительно регистр исполнительного адреса: адрес, который извлекли в первый раз, запомнили в этом регистре, а потом использовали этот адрес при втором обращении к памяти.

Любой адрес в команде, по которому мы обращаемся напрямую (Ai), должен быть полным.

### Многоступенчатая косвенная адресация

Ещё один разряд в окманде может отводиться под признак адресации. Он указывает, косвенный это адрес или адрес операнда.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/hsydKkB/image.png" alt="image" border="0"></a>

Это может применяться в БД. При этом адрес на 1 бит будет больше.

При этом ПА удобнее привязывать к младшим разрядом, а в старших, например, писать 00 (и получится что-то вроде 00PA). При этом надо показать, что PA более короткий.

Обращения к памяти будут идти, пока не встретится ПА=0.


### Косвенная регистровая адресация

<a href="https://imgbb.com/"><img src="https://i.ibb.co/dDtMswt/image.png" alt="image" border="0"></a>

При этом можно не ставить регистр исполнительного адреса. При этом, поскольку регистр 4 разрядный, а адрес 5-разрядный, то надо будет нарисовать дополнительно, что мы дополняем этот адрес единичкой или нулём в старшем или младшем разряде (учитывая, что нам надо будет обращаться за двумя операндами, поэтому адрес точно должен быть чётным), как в короткой адресации.

### Автоинкрементная адресация

<a href="https://imgbb.com/"><img src="https://i.ibb.co/Jkhm5md/image.png" alt="image" border="0"></a>

В адреса стоит номер регистра, по которому мы обращаемся как по косвенной адресации. При этом адрес в регистре увеличивается на размер операнда (можно добавлять 1 и дополнять этот адрес справа нулём; это добавление будет эквивалентно добавлению 2, потому что у нас адреса двухсловные)

Такая адресация удобна при итерации по массиву.

Аналогично, этот адрес можно дополнять, если он короткий.

При этом само увеличение может происходить после записи результата, потому что результат надо записать вместо операнда, и только потом мы начинаем указывать на следующий элемент массива.

### Автодекрементная

Здесь мы будем вычитать размер операнда.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/sVR3PV1/image.png" alt="image" border="0"></a>

Здесь предложено сначала вычитать, а потом обращаться к памяти: изначальный адрес указывает на конец массива. В таком случае требуется больше времени.

Чтобы сделать вариантность такой адресации, то можно варьировать время инкремента или декремента относительно обращения к памяти. Подробнее смотреть на сайте.

В автодекрементной и автоинкрементной операции нужен будет дополнительный сумматор.

Иногда забывают об этой записи в регистр, которая меняет содержимое регистра. 

При этом надо не забыть выполнить цикл записи: извлекли - суммировали - записали. При этом чтение/запись из ОП и запись в РП можно выполнять параллельно. Поэтому, например, в декрементной адресации запись нового значения в регистр и считывание из памяти могут происходить одновременно.

<a href="https://ibb.co/NsLtjjj"><img src="https://i.ibb.co/rmZF666/image.png" alt="image" border="0"></a>

<a href="https://ibb.co/Sv2FBB9"><img src="https://i.ibb.co/JkNDHHM/image.png" alt="image" border="0"></a>


## Адресации со смещением

### Относительная

<a href="https://ibb.co/Zd3zd2W"><img src="https://i.ibb.co/H70T7hn/image.png" alt="image" border="0"></a>

Смещение относительно счётчика команд имеет меньшую разрядность. 

Также дополнительно требуется сумматор для формирования А~исп~.

При этом в своих вариантах надо обязательно показать, чем мы будем дополнять малоразрядное смещение:

<a href="https://imgbb.com/"><img src="https://i.ibb.co/hfB3PLN/image.png" alt="image" border="0"></a>

Так что рисовать надо не 1 к 1 как в пособии, а включать голову и смотреть, как конкретно у нас.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/P1rjS48/image.png" alt="image" border="0"></a>

Кроме того, адресация может быть и со знаком.


### Индексная

<a href="https://imgbb.com/"><img src="https://i.ibb.co/M7nTWqR/image.png" alt="image" border="0"></a>

Регистр указывает на смещение (индекс). Базовый адрес находится в формате команды. При этом смещение, как уже говорилось, может быть коротким, длинным и дополняться нулями, единицами или иметь знак.

### Базовая

В данном случае, наоборот, смещение находится в формате команды, а база -- в регистре.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/BVxSL3G/image.png" alt="image" border="0"></a>

При этом смещение можно опционально дополнять знаком. При этом никакой дополнительной схемы там для этого нет, этот знак или дополнение входит в сумматор.

Эффективность базовой и индексной адресации можно сравнить по разрядности команд: база имеет разрядность больше, чем смещение, поэтому базовая адресация более эффективна с точки зрения размера, чем индексная.

### Страничная адресация

Номер страницы задают старшие разряды адреса, а в команде -- только смещение, которое просто присоединяется к старшим разрядам. Смещение может быть в отдельном регистре страницы (задаётся в служебном режиме). Таким образом, память делится на страницы (не путать с виртуальной памятью) фиксированной ёмкости, и если у нас страницы по 4К, то смещение будет по 12 разрядов, а если вся память 4Гб, то каждая страница будет адресоваться по 20 разрядов.

### Сегментная

Использовалась раньше. Был номер сегменте в сегментном регистре, к которому прибавлялось смещение. Однако сегмент как бы занимал часть старших разрядов, поэтому шло перекрытие смещения и адреса сегмента.

На основании этих адресаций можно делать комбинации типа постиндексная косвенная, подробнее на сайте.

## Расширенные коды операций

Пусть у нас имеется трёхадресная команда, где в поле кода операции в первом, втором и третьем адресе содержатся по 4 разряда, и на код операции отводится тоже 4 разряда. В первом адресе (аааа) задаётся адрес первого операнда, второго (bbbb) и третьего (cccc). КОП меняется от 0000 до 1110.

В случае, когда под КОП будет выделяться 8 разрядов, предложено делать команды двухадресными.

Если отведём 12 разрядов, то будут одноадресные команды.

А если отвести на КОП 16 разрядов, то получится безадресная команда.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/VxPSX75/image.png" alt="image" border="0"></a>

При этом по первым битам КОП можно понять, сколько адресную команду мы имеем.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/NTf5MP7/image.png" alt="image" border="0"></a>

<a href="https://imgbb.com/"><img src="https://i.ibb.co/1JnrC3P/image.png" alt="image" border="0"></a>

Всего получаем 76 команд.

**К экзамену подумать, как тут сделать 100 команд и больше: как задать КОПы и что изменить в алгоритме**

### Критерии выбора системы и форматов команд

**1. Лучше иметь короткие команды, чем длинные** (занимают меньше места в памяти, считывание нескольких команд за один цикл обращения, увеличение пропускной способности памяти (число байт в секунду))

**2. Минимизация разрядности команд может усложнить их декодирование** (минимизация должна уравниваться со временем декодирования и выполнением команды). В хитрых способах адресации появляются дополнительные сумматоры, что усложняет аппаратуру.

**3. Достаточная разрядность для задания кода операции -- $k_{cop} = \log_2 N_{COP}$** (оставить свободное количество для введения новых операций, введение расширенных кодов операций)

**4. Количество разрядов в адресных полях должно быть достаточным для обращения к ОЗУ: $k_{адр} = \log_2 N_{ОЗУ}$** (например, 32 адресных разряда хватит для обращения к 4 Гб памяти)

**5. Совместимость поколений семейства** (обратная совместимость в новых разработках архитектуры необходимо сохранять набор форматов команд)

### Методы уменьшения разрядности адреса

**1. Применение способов адресации с малой адресацией**. Например, короткая адресация, где для получения полного адреса надо дополнить старшие разряды нулями или единицами: например, команды всегда находятся в старшей зоне памяти, а операнды --в младшей

**2. Если операнд используется несколько раз, то его можно разместить в РОН** (увеличивается скорость доступа к операнду: РОН быстрее ОЗУ, требуется меньше разрядов а адресном поле (R вместо A))

**3. Задание операндов в неявной адресации**
- **вместо трёхадресной команды можно применять двухадресную**. Но при этом результат записывается вместо одного из операндов
- **вместо 2-адресной команды применять одноадресную**, где вводится дополнительный вспомогательный внутренний регистр -- аккумулятор, в который записываются результаты текущих операций.
- **вместо одноадресной команды применять безадресную** (можно применять стек для операндом и работа с ним АЛУ: например, стековое АЛУ)

### Ортогональность кодов операций и способов адресации

Команды и способы адресации должны иметь **регулярную структуру**, количество команд должно быть минимально (при этом компилятору проще порождать нужный код).

**Все коды операций** должны допускать **все способы адресации**. (в наших процессорах это не так, потому что у разных команд разные форматы команд).

## Алгоритмы подсчёта единиц в двоичном числе (N бит) на уровне команд

### 1. Алгоритм последовательного просмотра разрядов последовательности

Тут ошибка в алгоритме: i увеличивается только при единице, а должен всегда.

<a href="https://ibb.co/3hG3x3N"><img src="https://i.ibb.co/x5Pknkj/image.png" alt="image" border="0"></a>

При этом можно дополнительно проверять оставшиеся биты на равенство 0, чтобы быстрее выходить из цикла.

### 2. Хитрый алгоритм

B -- число, которое мы проверяем

(ошибка: 1000 1010 - 1 = 1000 1001)

За счёт B & (B - 1) убирается последняя единица.

При этом там ещё одна ошибка: 1000 1000 - 1 = 1000 0111

Эти три единицы в конце значат, что 1000 0111 & 1000 1000 = 1000 0000, то есть мы убрали ещё одну единицу. После этого останется только одна единица.

После 1000 0000 - 1 = 0111 1111, которые при конъюнкции дадут все нули.

<a href="https://ibb.co/JmzBdHf"><img src="https://i.ibb.co/7jGYzKw/image.png" alt="image" border="0"></a>

<a href="https://ibb.co/DpH4TTc"><img src="https://i.ibb.co/Qd39ttS/image.png" alt="image" border="0"></a>

Таким образом, вычитание 1 формирует справа от последней единицы все единицы, и после этого, когда мы объединяем всё это конъюнкцией, последняя единица пропадает.

При этом количество циклов в этом алгоритме будет равно количеству единиц.

### 3. Быстрый алгоритм

Исходное В разделяется на Вчт и Внч. Внч сдвигаем вправо на i разрядов, и к нему прибавляется Вчт.

М -- как маска. В чётной маске единицы стоят в чётных местах. При применении конъюнкции к маске мы получаем только чётные разряды

На Мнч маска содержит нечётные единицы (нечётные разряды), и применяя конъюнкцию с этой маской, выделяем нечётные разряды.

Далее сдвигаем Внч, суммируем с Вчт и получаем новое В.

Во втором цикл мы используем уже маску Мчт[2], то есть там будут уже 2 единицы находиться в чётных местах, и применение конъюнкции с такой маской -- это проверка пары разрядов.

Аналогично Мнч -- нечётная маска из пар бит на нечётных местах.

Сдвигаем, суммируем и получаем новое В.

На третьем шаге к В будет использоваться маска с 4 единицами справа (чётная) или слева (нечётная).

<a href="https://ibb.co/cyHtgz7"><img src="https://i.ibb.co/9pL28RC/image.png" alt="image" border="0"></a>

Количество циклов $k = \log_2 N$.

Здесь как раз может использоваться массив констант -- масок, и на каждом шаге может вытаскиваться своя маска из этого массива.

Когда мы сдвигаем нечётные разряды, то на суммирующем шаге получаем сумму двух разрядов в каждой паре бит.

На втором шаге -- получаем сумму в трёх разрядах и так далее.

Например, в последнем шаге, если число содержало 8 единиц, то будут складываться 4 + 4 = 8 = 1 0000.

При этом маска может быть не из "единиц" (выделяет нужные разряды), а "из нулей" (блокирует нужные разряды). Иногда маскирование определяется не конъюнкцией, а дизъюнкцией.

# Конвейер команд

### Временная организация цикла выполнения команд
1. Выборка кода команды из ОП и запись в регистр команд РК (Instruction Fetch -- IF)
2. Декодирование КОП команды и способов адресации, формирование Аисп адресов (Instruction Decoding -- ID)
3. Выборка (считывание) операнда из ОП или РОН и запись в буферные регистры процессора (Operand Reading -- OR)
4. Выполнение операции в АЛУ (Executing -- EX)
5. Запись результата в ОП или РП (Write Back -- WB). Этот шаг может отсутствовать, например, в одноразрядных командах, где есть неявный регистр-аккумулятор, в который записываются все результаты.

При этом надо не забывать, что на одном из первых шагов выполняется **инкремент счётчика команд**.

Рассмотрим, как будут задействованы блоки процессора во время выполнения команды.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/Ykpwt2C/image.png" alt="image" border="0"></a>

Раз тут элементов (узлов) всего 3, рассмотрим, насколько они загружены:


<a href="https://imgbb.com/"><img src="https://i.ibb.co/fXZVcNv/image.png" alt="image" border="0"></a>

Отсюда видно, что если мы каждый этап выполняем за одно и то же время, то если синхронно, то выбирается такт, равный максимальному времени выполнения этапа, и видно, что ОП во время выполнения занята на 60%, а ЦУУ и АЛУ только на 20% ⇒ видео, что основной простой идёт именно на ЦУУ и АЛУ.


## Выполнение команд в конвейере

Часто в литературе это представляется так:

<a href="https://ibb.co/b25VDCG"><img src="https://i.ibb.co/k92TvwP/image.png" alt="image" border="0"></a>

Если мы представим эту диаграмму относительно устройств:

<a href="https://ibb.co/Z6gmFfc"><img src="https://i.ibb.co/0j9t6nY/image.png" alt="image" border="0"></a>

По сравнению с предыдущими диаграммами, тут введена отдельно память команд и отдельно память данных -- это позволило организовать конвейер, правда, в котором отсутствует этап записи WB.

Посему вводятся два понятия:

**Совмещение операций** -- когда аппаратура компьютера выполняет одновременно более одной операции.  Этот метод включает понятия **параллелизм** и **конвейеризация**.

Буферные регистры BR1 и BR2 как раз нужны, если мы будем совмещать выполнение двух операций -- ведь мы могли бы напрямую передавать данные из ОП или РП в АЛУ. Но эти буферные регистры позволяют выполнять одну операцию в АЛУ и одновременно с этим готовить следующую.

При **параллелизме** совмещение операций достигается путём воспроизведения в нескольких копиях аппаратной структуры. Высокая производительность достигается за счёт одновременной работы всех элементов структур, осуществляющих решение различных частей задачи, то есть могут быть несколько АЛУ, отдельно БО для умножения, отдельно БО для деления, отдельно для плавающей или фиксированной запятой и так далее.

**Конвейеризация (или конвейерная обработка)** основана на разделении исполняемой функции на более мелкие части, называемые **ступенями**, и выделением для каждой из них отдельного блока аппаратура. Производительность при этом возрастает, так как на различных ступенях конвейера одновременно выполняется <u>несколько команд</u>.

**Конвейеризация** выполнения команд предполагает разбиение процесса на подоперации и выполнении этих подопераций отдельными блоками (ступенями). По каждому синхроимпульсу С проходит продвижение команды на следующую ступень. Между ступенями устанавливаются регистры.

<a href="https://ibb.co/XJLqGmj"><img src="https://i.ibb.co/zfxztKQ/image.png" alt="image" border="0"></a>

При этом сами ступени могут быть комбинационными схемами, и тогда синхросигнал С может и е поступать на них. Для общего случая данные могут поступать и в какую-то отдельную ступень извне, минуя DI: например, если что-то отдельно нужно подать в 3 ступень.

**Конвейеризация** увеличивает **пропускную способность** процессора (количество команд в единицу времени). Мы видели, что если одновременно выполняется несколько шагов, то и результат появляется в несколько раз быстрее. Однако каждая команда по отдельности будет выполняться дольше.

Конвейеризация <u>не сокращает время</u> выполнения отдельной команды, а даже увеличивает время из-за накладных расходов, связанных с управлением конвейерными регистрами:
- время задержки регистра
- время предварительной установки
- задержка распространения сигналов по цепям

## Конфликты  в конвейере

**Конфликты** -- такие ситуации в конвейерной обработке, которые препятствуют выполнению очередной команды в предназначенном для неё такте.

### Классификация конфликтов

**Структурные конфликты** -- это конфликты по ресурсам, возникают в том случае, когда аппаратные средства не могут поддерживать все возможные комбинации команд в режиме одновременного выполнения с совмещением.

**Конфликты по данным** -- это ситуации, когда выполнение одной команды зависит от результата выполнения предыдущих команд.

**Конфликты по управлению** -- это ситуации, которые возникают при конвейеризации команд переходов и других команд, изменяющих содержимое счётчика команд.

### Структурные конфликты

Совмещение операций требует конвейеризации функциональных устройств и дублирования ресурсов для разрешения всех возможных конфликтных комбинаций команд в конвейере. Если какая-нибудь комбинация команд не может быть принята из-за конфликта по ресурсам, то в компьютере имеет место структурный конфликт.

#### Причины
1. Недостаточное дублирование некоторых ресурсов
2. Некоторые ступени конвейера отдельных команд выполняются более одного такта
3. Суперскалярные процессоры, имеющие более одного конвейера


#### 1. Недостаточное дублирование некоторых ресурсов

В компьютере имеет место **единственный конвейер доступа к памяти** -- когда команды и операнды находятся в одном запоминающем устройстве. В данном случае конфликт при обращении различных команд за данными с совмещением выборки следующей команды и записью результата -- в этом случае осуществляется приостановка конвейере ("пузырь", простой). То есть, когда мы одновременно обращаемся к одной единственной памяти за командой и за операндами, конвейер вынужден приостановиться.

**Устранение** -- увеличение количества однотипных функциональных устройств. Например, разделяют кэш-память L1 для хранения команд (инструкций) и данных, используют многопортовую регистровую память (порты для записи и для считывания), введение нескольких АЛУ (для целых чисел, с плавающей запятой, умножения, деления).

<a href="https://ibb.co/8NbVND3"><img src="https://i.ibb.co/S5cp5XT/image.png" alt="image" border="0"></a>

Время выполнения первых двух команд не изменилось, но 2 и 3 команда выполняются с задержкой. Видны простои -- пузыри. Узкое место -- ОП.

Введём две памяти: память команд и память данных. Это позволит исключить приостановки конвейере и пузыри. Видно, что все команды выполняются одно и то же время, и после того, как все ступени будут задействованы, мы получаем каждый результат через Тцикла/4: разделение памяти привело к тому, что мы увеличили производительность в 4 раза.

<a href="https://ibb.co/cgJWH5L"><img src="https://i.ibb.co/Qb9WRBd/image.png" alt="image" border="0"></a>

Здесь пока исключена запись WB.

#### 2. Некоторые ступени конвейера отдельных команд выполняются более одного такта

Например, команды может занимать несколько слов или несколько байт так, что мы не можем одновременно считать всю команду. Кроме того, в АЛУ команды выполняются за разное время: умножение выполняется за несколько тактов, сложение меньше

**Устранение**:
- увеличение времени такта работы ступеней конвейера -- снижает эффект конвейерной обработки, так как этапы будут выполняться дольше.
- использовать аппаратные решения, которые позволяют снизить затраты времени на этапы, но усложняют схемы процессора, например, использовать матричные схемы умножения.

Разработчики ищут компромисс между увеличением длительности такта и усложнением устройства. Но, так как некоторые команды встречаются редко, то разработчики допускают наличие некоторых структурных конфликтов.

Как правило, не полностью конвейерное устройство имеет меньшую задержку, чем полностью конвейерное.

Рассмотрим, к чему могут привести такие конфликты:

<a href="https://ibb.co/jhC4h97"><img src="https://i.ibb.co/D4BK4P3/image.png" alt="image" border="0"></a>

Вторая команда вынуждена ждать, пока первая выполнится в АЛУ. Раз так, то мы не можем извлекать и следующую команды (хотя мб и можем, тут это всё равно)


Другой пример -- когда извлечение команды выполняется в два такта. Изначально мы определили, что команда не однословная, поэтому после ЦУУ мы обращаемся к памяти на досчитывание этой команды. Получается, что АЛУ так же простаивает 3 такта.

<a href="https://ibb.co/h81KDwq"><img src="https://i.ibb.co/Qmj6rt5/image.png" alt="image" border="0"></a>

Как видно, после того, как пузырь проходит, конвейер может и самовосстановиться.

#### 3. Суперскалярные процессоры, имеющие более одного конвейера

**Недостаток** -- необходимость синхронного продвижения команд в каждом из конвейером. Разрешение командам выполняться в конвейерах вне зависимости друг от друга приводит к <u>неупорядоченному выполнению команд</u>. При этом команды, стоящие позже, могут завершиться ранее команд, стоящих впереди.

**Устранение** -- вводятся <u>буферы записи результатов</u> в соответствии с восстановленной последовательностью команд -- запись производится только после выполнения предшествующих команд. Эти буферы работают не просто как FIFO -- с данными поступает номер команды в каком-то порядке, и логика работы этого буфера соответствует исходному порядку выполнения команд.

### Конфликты по данным

Это ситуации, когда выполнение одной команды зависит от результата выполнения предыдущей команды. <u>Производительность</u> конвейерных команд существенно зависит от межкомандных логических зависимостей

#### Классификация конфликтов по данным
- RAW (Read after Write) -- чтение после записи
- WAR (Write after Read) -- запись после чтения
- WAW (Write after Write) -- чтение после чтения

Есть ещё RAR (Read after Read), но тут конфликта нет.

Далее во всех вариантах команда $k$ предшествует команде $N$ ($k < N$).


#### RAW: Read after Write

Команда N пытается прочитать операнд из памяти раньше, чем команда k запишет результат по этому адресу в память, то есть команда N получает старое значение.

<a href="https://ibb.co/H7BwbyM"><img src="https://i.ibb.co/y0dvZCM/image.png" alt="image" border="0"></a>

Пусть команда k+1 выполняет какую-то операцию и записывает результат в аккумулятор А, а команда k+2 использует этот результат. В результате получится, что команда k+2 получит старое значение А, а не новое.

С выхода АЛУ можно, кроме выхода в память, подавать обратно на вход АЛУ. 

При этом мог образоваться пузырь из-за этапа WR команды k+1.

#### WAR: Write after Read

Команда N пытается записать результат в память раньше, чем команда k считает операнд из этого адреса в памяти, то есть команда k получает новое значение операнда вместо старого. Это возможно в системах, допускающих выполнение команд не в порядке их расположения в программе

#### WAW: Write after Write

Команда N пытается записать результат в память раньше, чем команда k запишем результат по этому адресу в память, то есть происходит запись в неверном порядке, и в памяти остаётся старое значение (возможно при записи из многих ступеней и нескольких конвейеров).

<a href="https://ibb.co/3h6C3sH"><img src="https://i.ibb.co/f06xgS7/image.png" alt="image" border="0"></a>

Пузыри появляются из-за шагов записи WR. Но логика нарушается, в памяти остаются старые данные.

#### Устранение конфликтов по данным
- **Методика планирования компилятора** -- планирование команд конвейера. В одном блоке (линейном участке программы) так упорядочивают последовательность команд, чтобы минимизировать перестановки. Например, если есть набор команд a := a + b; a := a + d; c := c + k, то логичнее поменять местами две последние команды, чтобы результат выполнения первой команды стал известен в момент начала выполнения третьей.
- **Буферизация команд**, ожидающих разрешения конфликта, и выдача последующих "в обход" буфера
- Организация **коммутирующих магистралей**, обеспечивающих передачу результата операции непосредственно в буфер, хранящий логически зависимую величину, задержанную из-за конфликта -- осуществляется пересылка или продвижение данных "обходом" или "закороткой". Проверяется, если результат предыдущей команды является источником операнда для следующей команды, то результат с выхода АЛУ поступает по цепи обхода АЛУ, а не операнд, считанный из памяти.

### Конфликты по управлению

Это ситуации, которые возникают при конвейеризации команд переходов и других команд, изменяющих состояние счётчика команд.

<u>Потери производительности</u> конвейерных команд при конфликтах по управлению могут быть значительными, даже больше, чем при конфликтах по данным.

Результатом команд перехода является изменение содержимого счётчика команд. 
- В командах **безусловного перехода** в СК записывается **исполнительный адрес**.
- В командах **условного перехода** анализируется признак, в зависимости от которого **сохраняется** ($СК + \Delta$) или **изменяется** (CK := A пер исп) содержимое.

Если команда условного перехода заменяет содержимое СК, то переход называется **выполняемым**.

#### Безусловный переход на адрес М
Мы выполняем предыдущую команду k, на следующем шаге извлекаем следующую команду, которую мы на следующем шаге анализируем (выполняется дешифрация КОП и формирование Аисп). Одновременно с этим мы можем извлекать k+2 команду. Как только мы вычислили исполнительный адрес k+1 команды, что оказалось командой безусловного перехода, то мы переходим на команду М ⇒  команда k+2 нам оказалась не нужна, из-за чего получился простой.


<a href="https://ibb.co/jJHLmbp"><img src="https://i.ibb.co/3Rk024J/image.png" alt="image" border="0"></a>

При этом команду k+2 надо очистить и удалить из буфера, чтобы не продвигать дальше.

#### Условный переход на адрес М. Очистка очереди

Команда k линейная, как в предыдущий раз. Команда k+1 - команда условного перехода на М. В момент времени, когда мы анализируем команду k +1, надо уже знать признак F, чтобы определить: либо мы идём дальше на k+2, либо мы уходим на адрес М.

Признак тут мы получим только после выполнения команды в АЛУ, поэтому мы вынуждены ждать, пока этот признак мы получим. И только после этого мы сможем выполнить команду k + 1.

<a href="https://ibb.co/cKBvs8k"><img src="https://i.ibb.co/CpctS9m/image.png" alt="image" border="0"></a>

Тут показан именно выполняемый переход, то есть сам переход выполняется, потому что признак F получился равным да. Тут простои уже по три такта, ещё один такт простоя появился в памяти команд, чего не было в безусловном переходе.

Чтобы уменьшить простои, можно начать выполнять команды раньше. Можно предположить, что переход выполняемый (и начать выполнять команду М), а можно предположить и другое, и начать выполнять команду k+2. Получив на нужном шаге F, мы можем или продолжить дальше или перейти по М.

<a href="https://ibb.co/NWDkBw2"><img src="https://i.ibb.co/nQdVJhM/image.png" alt="image" border="0"></a>

Только главное не забыть при невыполняемом переходе очистить очередь. Это, конечно, не значит, что надо стирать прямо всё, однако это самое простое решение.

Проблема очистки очереди довольно серьёзная, и это целая отдельная задача - как сделать так, чтобы у нас никуда не записалось и не запомнилось ничего лишнего.

#### Методы (схемы) снижения потерь
- **Метод выжидания** -- замораживание операций на конвейере, пока не станет известно направление (значение признака F) -- простота метода
- **Метод возврата** -- прогнозировать переход **как невыполняемый (F=0)**, то есть программа выполняется, и если затем признак не совпал, то очистка конвейера от команд после команды условного перехода на всех ступенях
	- Альтернатива -- **выполняемый переход**
- **Задержанный переход** -- изменение порядка команд
- **Предсказание (прогнозирование) направления перехода** до момента условного перехода:
	- статическая стратегия -- фиксируется на всё время выполнения программы
	- динамическая стратегия -- в процессе выполнения на основании информации о предшествующих переходах


# МкПУУ

Основным элементов для схемного устройства управления с жёсткой логикой является датчик состояний. А в микропрограммном устройстве -- память.

## Микропрограммное устройство управления

**МкПУУ** -- блок управления, основой которого является **управляющая память (УП)** или **память микропрограмм**, в которой хранятся последовательности микрокоманд (МК) для микропрограмм (МП) выполнения машинной команды (операции) (КОП). Код МК, считанный из УП, интерпретируется как совокупность совместимых управляющих сигналов УС для выполнения соответствующих микроопераций (МО). В процессе работы МкПУУ происходит формирование последовательности адресов МК для выполнения микропрограмм МП операций с учётом условий и признаков, вырабатываемых по ходу вычислений.

Управление операциями, выполненное посредство считывания МК из УП, называется **микропрограммным управлением**.


При этом код микрокоманды, считанной из управляющей памяти, интерпретируется как совокупность совместимых (одновременно задаваемых) управляющих сигналов для выполнения соответствующих микроопераций.

Раз у нас в памяти содержатся микрокоманды, надо формировать и адреса этих микрокоманд, чтобы понимать, куда перейти после выполнения очередной микрокоманды.

Совокупность микрокоманд образует микропрограмму выполнения машинной операции. Под операцией подразумевается умножение, сложение и так далее.

МУУ схемного типа, однако, является более быстродействующим. Поэтому микропрограммные УУ используются, хоть и широко, но всё же не абсолютно везде.

## Общая структурная схема МкПУУ


<a href="https://imgbb.com/"><img src="https://i.ibb.co/q7bGN5T/image.png" alt="image" border="0"></a>

В основе лежит управляющая память УП. Причём память, как отмечено, -- ПЗУ, то есть она работает только на чтение.

- КОП - код операции
- Fi - сигналы-признаки, по которым проходит ветвление
-  СФАМ - схема формирования адреса микрокоманды. В БУКе подобный блок назывался блоком формирования исполнительного адреса (БФИА).
- СМК - счётчик микрокоманд. Мы рассмотрим, что он может быть выполнен не как счётчик, а как РАМ - регистр адреса микрокоманд, который не увеличивает своё значение, а просто его схема увеличивает значение и загружает его внутрь. Это позволяет упростить схему. У счётчика же может быть вход +1, которым мы управляем
- РМК - регистр микрокоманд. В нём есть три поля

Основное назначение микропрограммного устройства, как и любого устройства управления, - **формирование управляющих сигналов**.

### Структура формата микрокоманды

<a href="https://ibb.co/JQ9g5sp"><img src="https://i.ibb.co/xHNdJ7g/image.png" alt="image" border="0"></a>

- **Адресное поле** содержит адрес следующей микрокоманды.
- **Поле маски признаков, управления** используется для проверки сигналов признаков F, используемых для реализации условных переходов, управления вычислительным процессом и задания длительности микрокоманды.
- **Поле микроопераций** предназначено для задания формируемых **управляющих сигналов УС**. Это самое главное поле в команде.

Мы не рассматривали на примере жёсткой логики, что какие-то микрокоманды можно выполнять за несколько тактов. Для этого можно было бы дополнительно ввести счётчик тактов, который бы не давал переходить датчику состояний в следующее состояние до тех пор, пока он не станет равным 0.

Как работает устройство. В начале поступает КОП - код операции умножения или, например, сложения. По этому коду операции СФАМ формирует начальный адрес микропрограммы (умножения или сложения). Этот начальный адрес поступает в счётчик микрокоманд. По этому адресу из УП считывается первая микрокоманда, которая поступает в РМК. Формируются игреки.

Но кроме того адрес следующей микрокоманды поступает в СФАМ, и он может напрямую перейти с СМК, а может с учётом признаков из поля М - выбираются требуемые признаки Fi на основании поля М, которые могут видоизменить адрес в СФАМ, который в итоге поступит в СМК.

Или адресное поле может не учитываться, а в счётчик команд просто добавляется единица - это можно выполнять на линейный участках: СМК := СМК + 1. Для управления +1 или загрузкой отдельного значения в СМК как раз используется поле маски признаков, управления М.

В данном случае можно УП или ПЗУ рассматривать только как накопитель, а памятью чаще называют, когда есть регистр адреса и регистр микрокоманд. То есть блоком памяти или модулем памяти в данном случае будут называть СМК, ПЗУ и РМК вместе. Для общего случая блок памяти, помимо накопителя, должен содержать ещё регистр адреса и регистр данных.

Когда будем выполнять микропрограммное устройство, то надо не забыть, что внутренних регистров у памяти в хилинхе нет, посему надо выдерживать адрес всё время.

## Классификация МкПУУ

В памяти хранятся именно микрокоманды.

Зачем мы пишем "постоянное запоминающее устройство ПЗУ", чтобы показать, что это и как оно обозначается. Например, мы могли писать "регистр первого операнда RA" - то есть сначала название, а потом обозначение. Поэтому так писать можно, это не ошибка.

У себя надо будет отмечать, что мы выбрали. В нашем случае мы не выбираем статическое или динамическое микропрограммирование, но надо будет указать способ формирования адреса следующей микрокоманды, который мы будем использовать в своих ЦУУ. Это же надо будет говорить и на защите.

Также надо будет выбирать способ формирования управляющих сигналов.

**1. По типу управляющей памяти МК**:
- **Статического микропрограммирования** -- в котором используется постоянное запоминающее устройство ПЗУ
- **Динамического микропрограммирования** -- в котором используется оперативное запоминающее устройство ОЗУ, что позволяет изменять состав микропрограммных модулей
- **Статическо-динамического микропрограммирования** -- в котором используются и ПЗУ, и ОЗУ.

**2. По способу формирования адреса следующей микрокоманды**
- принудительная адресация
- естественная адресация

**3. По способу формирования управляющих сигналов УС**
- горизонтальное микропрограммирование
- вертикальное микропрограммирование
- смешанное микропрограммирование


**4. По способу исполнения микрокоманд**
- однофазное кодирование -- одновременное формирование всех УС в МК
- многофазное кодирование -- формирование УС в МК в разные фазы такта

**5. По способу кодирования**
- прямое кодирование -- закрепление за каждым УС фиксированной функции
- косвенное кодирование -- формирование УС в зависимости от дополнительных полей МК


## Способы формирования управляющих сигналов

### Горизонтальное кодирование

<a href="https://ibb.co/KW0KfXs"><img src="https://i.ibb.co/TtvW7k0/image.png" alt="image" border="0"></a>

Каждому управляющему сигналу YC~i~ соответствует отдельный разряд в поле МО. То есть каждый разряд -- это отдельный управляющий сигнал.

Операционная часть МО содержит N разрядов, где N -- общее количество управляющих сигналов УС.

<u>Достоинство</u> способа: простота формирования управляющих сигналов УС и возможность  одновременного независимого задания любого сочетания разрядов (управляющих сигналов УС) в поле МО.

<u>Недостаток</u> -- большое количество разрядов N в поле МО -- количество которых равно количеству управляющих сигналов УС.

Управляющих сигналов может быть не одна сотня. Поэтому если игреков много, то такие команды называют *слабокодированными* -- "в море нулей островки единиц".

 ### Вертикальное кодирование
 
<a href="https://ibb.co/9b05kb4"><img src="https://i.ibb.co/QPVw3PH/image.png" alt="image" border="0"></a>

На выходе поля микрооперации ставится дешифратор. Количество выходов дешифраторов равно количеству игреков (обозначено N), а разрядов в операционной части будет $k=\log_2 N$.

<u>Достоинство</u> способа: наименьшее количество разрядов в поле МО и эффективное использование управляющей памяти УП.

<u>Недостаток</u>: использование дешифраторов на большое количество выходов N, увеличение задержки на формирование управляющих сигналов УС и главное -- в каждой микрокоманде может быть указан только один управляющий сигнал УС, что приводит к увеличению длины микропрограммы.

Ведь на выходе дешифратора только один сигнал - унитарный код. Поэтому если нам нужно было бы выполнять сдвиг А, сдвиг Б и обнуление РР - это мы бы выполняли за три микрокоманды. Понятно, что это даже не будет работать, если надо одновременно подавать несколько сигналов, управляя КС и каким-нибудь регистром. Поэтому в чистом виде такой подход не применяется. К тому же и будет большой и сложный дешифратор, особенно если он будет на большое количество выходов.

В сравнении с предыдущими, такие команды называются "сильнокодированными" или "максимальнокодированными": то есть нет такого, что островки нулей или островки единиц.

### Смешанное (горизонтально-вертикальное) кодирование

<a href="https://ibb.co/GnYqhCk"><img src="https://i.ibb.co/wBGfvpC/image.png" alt="image" border="0"></a>

N сигналов разбиваются на группы, и для каждой группы вводится вертикальное кодирование, и остаётся одна общая группа для горизонтального.

Такое решение можно принять и в курсаче, но это не обязательно.

Поле микрооперации МО **разбивается на группы**, причём вводится несколько групп для вертикального кодирования и одна для горизонтального кодирования.

Группы, для которых применяется вертикальное кодирование, содержат те управляющие сигналы УС, которые не встречаются вместе в одной МК и такие микрооперации (УС) называются **совместимыми** (или **несовместные**, которые могут формироваться одновременно), и для каждой вертикальной группы вводится свой дешифратор и формируется только один управляющий сигнал УС. При этом общее количество управляющих сигналов УС равно количеству групп. Количество разрядов в группе $m_i=\log_2(m_i+1)$, так как в группе может отсутствовать сигнал УС -- то есть в какой-то микрокоманде может не быть ни одного сигнала, а номер должен быть. Либо можно было задавать Enable, но это всё равном лишний разряд.

В горизонтальную группу вводятся совместные управляющие сигналы YC, которые могут формироваться в микрокомандах одновременно.

## Способы исполнения микрокоманд

### Однофазные

<a href="https://ibb.co/Z8y3VjN"><img src="https://i.ibb.co/nchTbGR/image.png" alt="image" border="0"></a>

### Многофазные

<a href="https://ibb.co/QKz1jf6"><img src="https://i.ibb.co/VqrPptv/image.png" alt="image" border="0"></a>

<a href="https://ibb.co/KxcMTbR"><img src="https://i.ibb.co/gZb5kmH/image.png" alt="image" border="0"></a>

Каждый игрек выполняется на последующем такте. Здесь есть не просто один генератор (главный), а ещё мы формируем три фазы (импульсы), а могли бы быть уровни. Таким образом, генератор разбивается на три фазы. Каждый игрек закрепляется за определённой фазой. Поэтому если в какой-то команде этот игрек не используется, то игрек просто не формируется, однако такт проходит. Поэтому вместо 10 микрокоманд получается 4 МК, но выполняем за 12 тактов. Таким образом, сокращается количество микрокоманд, но самое главное - закрепление за игреком определённой фазы.

Почему стало микрокоманд меньше? В однофазных МК каждая МК содержит только один игрек. В многофазных каждая МК содержит несколько игреков. Поэтому можно сократить количество микрокоманд. Однако длительность увеличится.

А раз происходит сокращение количества микрокоманд, у нас сокращается и объём памяти: вместо 10 ячеек 4 - происходит "обогащение" микрокоманд игреками. Так сокращается количество адресов в микропрограмме.

Можно было бы фазы не закреплять, но тогда бы мы увеличили поля, введя, например, ещё один разряд на каждый игрек и указывать, в какой фазе он должен работать. Как пример косвенного задания игрека - указание того, в какой фазе он выполняется, но в таком случае, конечно, увеличилась бы ширина команды, то есть её разрядность.

В общем случае у однофазных микрокоманд тоже может быть много игреков. Просто сами игреки будут выполняться все сразу.

Первое, что мы будем отражать у себя, - **формирование адреса следующей микрокоманды**.

## Способы формирования адреса следующей микрокоманды

<a href="https://ibb.co/pLzFXtt"><img src="https://i.ibb.co/Tg83hVV/image.png" alt="image" border="0"></a>

**Принудительная** адресация - это тот формат, который мы разбирали. Здесь каждая МК содержит все три поля - адреса следующего, маски и поля управления и поле микрооперации.

При этом в счётчик МК принимается адрес следующей команды из соответствующего поля. Он может загружаться или не загружаться, если там будет какое-то условие.

**Естественная** адресация предполагает два вида МК: управляющие (УМК) и операционные (ОМК).

Для этого вводится разряд признака: например, 1 - управляющая команда, 0 - операционная. Можно и наоборот.

**Управляющая** команда содержит адресное поле и поле маски. **Операционная** - только поле микрооперации. При этом понятно, что общий формат будет выбираться по наибольшей разрядности из двух типов команд. При этом может быть и не одно адресное поле, если переход зависит от условия, но переход всё равно произойдёт.

Надо учитывать, что в общем случае МО - это порядка сотен разрядов, а если в памяти содержится 10 000 ячеек, то в адресной части должно быть 14 разрядов ⇒  будут неравномерности, а значит, свободные поля.

Таким образом, мы сокращаем количество разрядов, но дополняем одним разрядом признака. Если работает УМК, то счётчик микрокоманд, как и в предыдущем случае, подаётся Аслед, но с учетом поле управления.

На линейном же участке (операционные команды) можно просто увеличивать счётчик команд на 1.

Эти два типа мы сравниваем по двум критериям: аппаратным и временным.

В естественной адресации команд будет больше, но только в командах условного и безусловного перехода: у них не будет никаких микрооперацией (NOP). Поэтому достоинством естественной адресации является уменьшение разрядности МК, но увеличивается количество самих МК на команды управления: команды условных и безусловных переходов.

<a href="https://ibb.co/1LSy37K"><img src="https://i.ibb.co/KX14Yb7/image.png" alt="image" border="0"></a>

**Порядок работы МкПУУ**:
- КОП операции, в СФАМ формирование Анач операции, передача в СМК далее в РА, извлечение кода команды и запись в РМК
- Формирование управляющих сигналов У и передача Аслед в СФАМ и далее в СМК = Аслед


**В командах управления**
- проверка по маске М сигналов-признаков F~i~
- Если Fi[M]=0, то CMK := CML + 1
- Если Fi[M]=1, то CMK := Aслед

Тут добавляется стек -- используется в командах возврата, цикла, обращения к подпрограммам

<a href="https://ibb.co/VYFLg3G"><img src="https://i.ibb.co/JjYcvCT/image.png" alt="image" border="0"></a>

Слева всё остаётся одним и тем же. Регистр микрокоманд показа как бы из двух частей - на самом деле он просто по разному воспринимает линейные и операционные команды:  в РМК можно считать УМК или ОМК в зависимости от разряда признака, и далее по разному учитывается содержимое этих микрокоманд.

На выходах мы имеем какие-то наборы единиц и нулей, которые всегда приходят на СФАМ, а СФАМ принимать данные и адрес микрокоманды будет в зависимости от признака: если он равен 1, то он будет учитывать адреса и маски.

Тут ещё можно заметить, что ширина команд и, соответственно, разрядность РМК стала намного меньше.

После загрузки в регистр РМК анализируется **признак П** типа микрокоманды:
- если **П=0**, то это **ОМС** и КС формирует управляющие сигналы УС, а в СФАМ формируется сигнал (+1) и СМК := СМК + 1
- если **П=1**, то это **УМК** и СФАМ формирует Аслед микрокоманды в зависимости от значений полей адреса А и маски М и сигналов-признаков Fi

**Достоинство** МкПУУ с ественной адресаций -- **сокращение разрядности МК**.

**Недостатки**: дополнительная КС для формирования управляющих сигналов У и увеличение задержки, увеличение количества микрокоманд на количество команд перехода

<a href="https://ibb.co/pW50Pvh"><img src="https://i.ibb.co/k3vHygm/image.png" alt="image" border="0"></a>

Количество разрядов уменьшается, а количество ячеек увеличивается на дельту - на команды условных и безусловных переходов.

На данной слайде указаны два основных подхода к формату микрокоманд -- принудительная адресация и естественная. В принудительной каждая МК содержит все три поля, а в естественной есть два формата МК -- управляющая и операционная, и в одних и тех же разрядах можно задавать игреки, адрес следующей команды или маски.

При этом обычно говорят, что принудительная адресация в УП занимает больше места, чем при естественной адресации: добавляется дельта, которая связана с командами условных и безусловных переходов. Как правило, эта дельта меньше N, а разрядность и так меньше.

Для процессоров надо отвечать, почему мы выбрали ту или иную адресацию, и уметь их сравнить по аппаратуре. Надо выбрать - у нас будет принудительная или естественная адресация. Желательно в отчёте сравнить оба варианта - плюсы и минусы обоих реализаций и почему мы выбрали именно такую.

## Способы выработки следующего адреса микрокоманды

Применение различных способов формирования Аслед предназначено для обеспечения компромисса между минимизацией объёма управляющей памяти и сокращением времени формирования следующего адреса.

1. **Принудительное задание** адреса Аслед в адресном поле А текущей микрокоманды. Это принудительная адресация.
2. Применение **счётчика команд** на линейных участках. Несмотря на то, что это может применяться и в принудительной адресации, можно пропускать поле адреса следующей команды и просто инкрементировать счётчик на линейных участках. 
3. **Применение различных способов адресации**: прямая, относительная, косвенная и др., чтобы адрес был коротким. Микрокоманд может быть десятки тысяч в реальных процессорах, и если мы уменьшаем адресное, можно значительно выиграть за счёт того же смещения
4. Организация **условного перехода** на два или несколько направлений. В начале МкПУУ надо описать, что мы выбираем и на сколько направлений у нас будет ветвление
5. Выполнение циклов по количеству итераций -- требуется **счётчик числа повторений** (i)
6. Организация обращений к микроподпрограммам, команд возврата и циклов -- **использование стека**
7. Формирование начального адреса **Анач микропрограммы** выполнения команды по КОП -- надо определить, как его выбрать
8. Формирование начального адреса **Анач микропрограммы обработки прерываний** (это могут быть два разных начальных адреса, по которым мы должны уходить на микропрограмму операции или на прерывание)

## Применение стека

Допустим, мы идём по микропрограмме и в i-ой команде может в стек записать адрес возврата. При этом мы уходим на следующий адрес, который при принудительной адресации может быть не i+1, а любой другой. В каком-то другом адресе можно пойти либо на следующий адрес или вернуться обратно на i, который был записан в стеке.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/3v7sC8W/image.png" alt="image" border="0"></a>

Так же может работать и цикл, но надо будет тогда проверять чему равен признак цикла F.

### Обращение к микроподпрограммам

Или можно так же обращаться к микроподпрограммам: пусть в i адресе мы обращаемся по адресу микроподпрограммы, но при этом мы в стек записываем адрес i+1 (он оказывается на вершине стека) -- адрес возврата (он на 1 больше), а уходим на микроподпрограмму с адресом m, который стоит в поле микрокоманды.

<a href="https://ibb.co/J7SCtbc"><img src="https://i.ibb.co/mqPSTYR/image.png" alt="image" border="0"></a>

Далее выполняем микроподпрограмму, доходим до адреса k и дальше записываем k+1 в стек, если надо обратиться к другой микроподпрограмме, на вершине оказывается k+1

Уходим на какой-то адрес n, выполняем n-ную микроподпрограмму, доходим до последней микрокоманды этой микроподпрограммы и из стека получаем адрес k+1 - он подаётся в счётчик микрокоманд, продолжаем выполнять микроподпрограмму k, выполняем её и в конце извлекаем адрес i+1, При этом i+1 может остаться в вершине, его не обязательно исключать из стека - так же как и адрес возврата в цикле

Количество ячеек или адресов в стеке называется глубиной стека. Это количество вложенных циклов или глубина вложенности микроподпрограмм.

## Организация условного перехода на два направления
Пусть мы выполняем i-ую микрокоманду и проверяется условие F. Если оно равно 0, то, как правило, переход не выполняемый, то есть мы идём на следующий адрес по счётчику адреса микрокоманды СМК. А если F=1, то мы уходим на адрес k, который задаётся в микрокоманде в поле адреса следующей микрокоманды.

Если рассматривать регистр МК, в котором есть поля адреса следующей команды и поле маски, поле маски проверяет Fj, или выбираем его, и в зависимости от результата проверки мы либо при нуле увеличиваем СМК либо загружаем в него значение k из поля адреса следующей микрокоманды

<a href="https://ibb.co/MRtFSXT"><img src="https://i.ibb.co/Vvzf9Ky/image.png" alt="image" border="0"></a>

В начале микропрограммного устройства управления надо написать, что мы выбираем - принудительную или естветвенную, горизонтальное или вертикальное микпропрограммирование для игреков, какое органзуется ветвление и та далее. И подобные рисунки надо будет привести.

Второй вариант (В): мы в микрокоманде i так же проверяем f, но уходим на k или на k+1. Ну а дальше мы с адреса k в общем случае мы не можем идти дальше на k+1, надо уйти на адрес v или на адрес z, поэтому данный вариант больше подходит для принудительной адресации.

Если k мб любым (и чётным, и нечётным) то в схему надо будет добавить сумматор

<a href="https://imgbb.com/"><img src="https://i.ibb.co/6mtzyQ2/image.png" alt="image" border="0"></a>

Причём в схеме вход +1 может остаться чтобы на линейных участках продолжать выполнять команды

А если этот адрес k будет чётным, то можно в такую схему вместо сумматора можно просто поставить элемент ИЛИ на младший разряд

<a href="https://imgbb.com/"><img src="https://i.ibb.co/txH6VGq/image.png" alt="image" border="0"></a>

Понятно что КС и сумматором можно управлять, чтобы они не мешали, когда у нас нет ветвления

При этом не можем сразу перейти либо на v либо на z потому что в адресном поле МК доступен только один адрес

В нашем варианте нужно по любому уйти куда-то в другое место, например, если i+1 чем-то занят.

Будем называть связанными адресами i и (i+1), а также k и (k+1)

<a href="https://ibb.co/cDWsTxY"><img src="https://i.ibb.co/gz0cg64/image.png" alt="image" border="0"></a>

Это нужно чтобы не ошибиться, когда будем составлять блок-схему микропрограммы: если есть ветвление надо всегда проверять куда мы уходим: либо уходим со связанного на связанный, либо с обычного на два связанных. В чисто принудительной адресации на линейном участке адреса могут идти не обязательно подряд, а в естественной адресации чтобы с k перейти на v надо будет использовать команду безусловного перехода

<a href="https://imgbb.com/"><img src="https://i.ibb.co/VTvhhWB/image.png" alt="image" border="0"></a>

можно иногда использовать не счётчик микрокоманд, а регистр адреса микрокоманд. В подходе В как раз можно перейти от СМК к РАМ: если k будет чётным, а это задать нетрудно, то нам надо будет использовать только элемент ИЛИ, убирая тяжеловесный сумматор.

Для общего случая можно рассматривать и два адреса (k и m), оба будут в МК и тогда надо будет поставить мультиплексор в схеме, который будет выбирать адрес k или m

## Организация условного перехода на несколько (4) направлений

Допустим у нас есть условный переход на 4 направления в зависимости от двух признаков. Можно было бы разбить эту проверку на 2 части: сначала проверять F1, уходим на 2 направления, а потом проверяем F2, и разветвляемся ещё на 2 направления.

Вместо ухода на 4 разных адреса можно уходить на 4 связанных адреса

<a href="https://imgbb.com/"><img src="https://i.ibb.co/WWbnG5X/image.png" alt="image" border="0"></a>

Это можно выполнить сумматором, если k любой. Важно отметить, что эти 4 адреса связанные

Поэтому мы можем выбирать сразу 2 признака и на сумматоре их прибавлять

<a href="https://imgbb.com/"><img src="https://i.ibb.co/qjm4X6n/image.png" alt="image" border="0"></a>

В вертикальном столбце (по адресам k, …, k+3) должны стоять команды безусловного перехода. С точки зрения игреков это могут быть дополнительные пустые микрокоманды с естественной адресации. В принудительной это всё делается проще

Если k кратно 4 (двойной чётности), то можно обойтись и без сумматора

<a href="https://imgbb.com/"><img src="https://i.ibb.co/FVj7pKC/image.png" alt="image" border="0"></a>

Снова можем уйти от СМК к РАМ в таком случае.

У себя надо будет выбрать, на сколько направлений будет разветвление. При этом какие-то микрокоманды могут повторяться в управляющей памяти, просто у них будут разные адреса (например, те, что в адресах k…k+3)

В данном случае F1, F2 идут на младшие разряды. Это можно изменить, и у нас будут не соседние, а любые разряды у адресов перехода, так что они будут отличаться на дельту - и тогда F1, F2 могут приходить не на младшие, а на любые разряды. Тогда нам в общем случае уже не нужен будет безусловный переход после ветвления, потому что между командами будет свободное место.

<a href="https://ibb.co/GvtF74g"><img src="https://i.ibb.co/sv6tjdL/image.png" alt="image" border="0"></a>

<a href="https://imgbb.com/"><img src="https://i.ibb.co/d6JKhWc/image.png" alt="image" border="0"></a>

Можно подавать F1 и F2 в какие-то промежуточные разряды y и x. Если мы подаём эти признаки на 2 и 3 разряды, то мы получим связанные адреса, которые будут связаны на дельту (0 - 2 - 8 - 10). На рисунке надо зачеркнуть мл, потому что разряды теперь произвольные.

При этом эти дельты условные, это вообще говоря не одни и те же числа - это дельты с учётом весов разрядов, которые поступают на адрес команды. Остальные разряды, вообще говоря, тоже не обязательно нулевые

Ветвление - один из основных моментов в МкПУУ - как сформировать адрес следующей микрокоманды. Большинство будет выбирать переход на два направления.

## Формирование начального адреса микропрограммы операций

Как в зависимости от КОП, переданного в РК, сформировать начальный адрес микропрограммы?

Первый вариант - КОП приходит на КС, которая формирует начальный адрес.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/NsHjkN7/image.png" alt="image" border="0"></a>


Например, так:

<a href="https://imgbb.com/"><img src="https://i.ibb.co/BwW9zy3/image.png" alt="image" border="0"></a>

Адреса можно задавать любыми: можно хитро задать адреса двойной чётности, чтобы убрать сумматор из схемы, а некоторые адреса могут быть свободными, например, при принудительной адресации. Если в программе команды хранятся чётко друг за другом без пропуска, то в микропрограмме, наоборот, могут быть свободные пропущенные адреса. Тут адреса оказались нечётными, значит, А0 всегда равен 1, первый разряд равен старшему разряду КОП1, и так далее:

<a href="https://imgbb.com/"><img src="https://i.ibb.co/GM7s1ry/image.png" alt="image" border="0"></a>

Этот же начальный адрес мог быть адресом прерывания, но в нашем случае каждая МК начинается с того, что мы считываем одно слово и дальше анализируем. Если это первое слово - А0, то дальше как раз мы решаем, куда идти дальше (А1, А5 или А11).

Второй вариант - применять мУХ, чтобы уходить на разные адреса, которые мб заданы в самой команде. Либо использовать DC, чтобы в зависимости от КОП уходить на какой-то адрес. В любом случае это всё КС, просто разные реализации

<a href="https://imgbb.com/"><img src="https://i.ibb.co/VLRr2W8/image.png" alt="image" border="0"></a>

4 вариант - ввести зону адресов в управляющей памяти: например, младшие адреса А0 А1 А2, в которые мы обращаемся по КОП, а в каждом из этих адресов будет стоять безусловный переход на соответствующие операции

<a href="https://imgbb.com/"><img src="https://i.ibb.co/cgCDxXV/image.png" alt="image" border="0"></a>


Этот простой вариант решения требует столько адресов, сколько операций. Это могут быть не обязательно младшие адреса - зона может быть любой. Но, наверное, удобнее, чтобы КОП всё равно завязан был на младшие разряды. Аналогично вместо КОП мог стоять код прерывания и безусловные переходы на микропрограммы обработки прерываний.

Однако раз мы считываем с самого первого слова, то наверняка А0 уже будет занято, поэтому можно, например, расположить эту зону не с нулевого адреса, а с четвёртого или восьмого: пропуски нам разрешены.

## Формирование длительности выполнения микрокоманд


Некоторые микрокоманды могут выполняться несколько тактов.

Предположим, мы должны эту микрокоманду выполнять дольше всего

<a href="https://imgbb.com/"><img src="https://i.ibb.co/BNJ3MNr/image.png" alt="image" border="0"></a>

Пусть она выполняется 40 нс, а все остальные выполняются 10 нс. Введём тау равное 10 нс, но самую длинную микрокоманду разобьём на две: первая будет выполняться три такта (30 нс), и в этом случае мы задаём только Yкс, а затем - вторую МК, которая выполняться будет один такт, и в этой МК мы продолжаем разрешение работы КС, но задаём игреки, управляющие RR. Здесь ВТ - это бит длительности. К - длительность.

Предложено в МК ввести ещё дополнительный бит длительности, который указывает, что микрокоманды должна выполняться больше одного такта; код длительности КТ - сколько тактов должна выполняться. Это значение загружается в счётчик, и при этом формируется признак F, который равен 0, если счётчик равен 0. Если нет, то счётчик будет вычитать значение, пока он не станет равным 0, и только тогда мы будем разрешать загрузку, то есть следующую микрокоманду: YL как раз разрешает загрузить адрес следующей микрокоманды

<a href="https://imgbb.com/"><img src="https://i.ibb.co/xfPZ2j0/image.png" alt="image" border="0"></a>

## МкПУУ с естественной адресацией (схема Шлэпи)

<a href="https://ibb.co/6Bs41YV"><img src="https://i.ibb.co/1629dZh/image.png" alt="image" border="0"></a>

Тут представлены управляющая память (в данном случае показана как ПЗУ, но это не обязательно) микрокоманд, регистр микрокоманд - тут как две сущности, когда в него записаны либо операционная команда, либо управляющая, что зависит от признака команды П. Игреки формируются при признаке, равном 0, и он приходит на КС. 

Есть стек, на входе которого стоит многоразрядная схема И.

Введено поле Н (можно отметить как h') и два дополнительных разряда, которые могут участвовать как в операционной, так и в управляющей микрокоманде - R и S. Плюс на входе СМК дополнительно стоит элемент И, на который тоже приходит S и YL для многотактных микрокоманд - разрешение записи в счётчик микрокоманд. Также эти S и R приходят на элемент И справа. Они же поступают и на входную схему стека.

Это позволяет исключить ряд пустых микрокоманд за счёт введения дополнительных режимов работы.

### Режимы работы

1. Режим S = 1 последовательного счёта СМК := СМК +1
2. S = 1, YL = 1 -- приостановка в многотактовой команде: СМК не изменяется.
3. S = 0, R = 0 -- режим перехода по произвольному адресу: СМК := Аслед
4. S = 1, R = 1 режим записи адреса возврата (СМК) => Стек (это можем сделать в операционной микрокоманде, например, чтобы запомнить адрес возврата в стеке при организации циклов) ⇒ не требуется отдельной управляющей команды
5. S = 0, R = 1 -- режим возврата (СТЕК) => РМК переход на начало цикла или на адрес возврата. Количество вложенных циклов определяется глубиной стека. Позволяет обойтись без отдельной управляющей команды

Таким образом, введение дополнительных двух разрядов в поле H в обоих форматах микрокоманд позволяет сократить количество команд.


## Методы сокращения ёмкости управляющей памяти

Пусть управляющая паять имеет ёмкость NxK, где N -- количество ячеек памяти, k -- разрядность ячеек, при этом разрядность адреса n = log~2~N

### Сокращения в адресной части А

1. Применение различных методов адресации, в первую очередь, за счёт относительной адресации и смещения
2. Уменьшение количества адресов УП за счет <u>введения микроподпрограмм</u>:
	- повторяющихся участков МП
	- общих частей различных МП

<a href="https://imgbb.com/"><img src="https://i.ibb.co/rH0wXq4/image.png" alt="image" border="0"></a>

3. Введение вместо принудительной адресации <u>естественной</u> адресации (ОМК и УМК) (исключение адресной части в ОМК (k/2), но увеличение количества команд на команды перехода)

### Сокращения в операционной части МО

1. Применение вертикального и вертикально-горизонтального кодирования -- сокращение количества разрядов в операционной части
2. Введение многофазного кодирования -- сокращение количества микрокоманд обогащением каждой микрокоманды -- уменьшается разрядность адреса УП

### Сокращения в поле маски (управления) М (Н)

1. Введение вместо горизонтального вертикальное кодирование в маске признаков М -- сокращение количества разрядов маски, если надо выделить только один признак. Если мы хотим проверять два F, тогда бы осталось горизонтальное кодирование

<a href="https://imgbb.com/"><img src="https://i.ibb.co/JFw2Ytr/image.png" alt="image" border="0"></a>

Это пример горизонтального кодирования маски и выбора нужных признаков: за каждый признак отвечает свой разряд маски. Тут как раз нет сокращения, а сократить можно было с помощью мультиплексора, и в маске мог стоять двухразрядный код:

<a href="https://imgbb.com/"><img src="https://i.ibb.co/q5vh5g8/image.png" alt="image" border="0"></a>


Аналогично можно поставить такой мультиплексор для выбора КОП.

У такого вертикального кодирования минус в том, что мы можем проверить только один признак.

## Сравнение устройств управления: микропрограммного и с "жёсткой" логикой

### Зависимость аппаратных средств от сложности алгоритмов микропрограмм

<a href="https://imgbb.com/"><img src="https://i.ibb.co/qxM2hnK/image.png" alt="image" border="0"></a>

До какого-то момента S0 и объёма аппаратуры V0 МкПУУ требует больше аппаратуры по сравнению со схемным. Считается, что объём аппаратуры в схемном УУ прямо пропорционален от сложности алгоритмов. При этом под сложностью понимается количество Y, количество состояний датчика, разветвления и т. д.. 

В МкПУУ же, например, присутствует счётчик микрокоманд, разрядность которого логарифмически зависит от количества микрокоманд. Проверка признаков нужна, но рост сложности у неё незначителен, поэтому начиная с какого-то момента сложность МкПУУ растёт довольно медленно.

### УУ с жесткой логикой
- высокое быстродействие, определяется выбранной элементной базой, задержкой в цепях формирования УС
- сложность перестройки, нерегулярность схемы, недостаточная гибкость
- сложность диагностирования: каждый УС формируется по своему и проверять сложно

### Микропрограммное УУ
- гибкость и приспособляемость, не критично к сложности алгоритмов (длительности микрокоманд, количеству тактов выполнения МК)
- быстрое изменение массива микрокоманд -- прошивка управляющей памяти
- простота проектирования, проверки и диагностики в связи с регулярностью структуры
- увеличение срока использования за счёт перепрограммирования УП под новые задачи: ввести деление, аппаратный интеграл, новую микропрограмму и т.д.
- возможность использования динамического микропрограммирования -- замена части ОС аппаратными средствами
- более низкое быстродействие за счет применения памяти большой ёмкости и задержки

# Запоминающие устройства

## Основные структуры запоминающих устройств

Основой любого адресного ЗУ является **совокупность (массив) запоминающих элементов ЗЭ**, соединённых определенным образом, который называется **накопителем ЗУ (Н)**.

Каждый ЗЭ **хранит бит информации** и должен реализовывать следующие режимы работы: **хранение состояния**, выдача сигнала состояния (**чтение**), **запись** нуля или единицы. Очевидно, что к ЗЭ должны поступать управляющие сигналы для задания режима работы, а также информационный сигнал при записи.

Запоминающий массив имеет <u>систему адресных и разрядных линий</u> (линий выборки).

**Адресные линии** используются для выделения по задаваемому адресу совокупности ЗЭ (запоминающей ячейки -- то, чего мы считываем за одно обращение). **Выборка** отдельных **разрядов** выполняется **разрядными линиями**, по которым передаётся хранимая в ЗЭ информация об их состоянии или информация о записываемых данных.

Запоминающие массивы строятся из специфичных ЗЭ, для которых характерно использование троичных сигналов и совмещение разрядных линий входных и выходных сигналов.
- В зависимости от числа линий выборки и способов их подключения к ЗЭ в составе накопителя различают структуры ЗУ типа **2D**, **3D**, **2.5D**

### Структура 2D

Запоминающие элементы ЗЭ организованы в прямоугольную матрицу размерностью M = k x m, где k -- количество ячеек, m -- их разрядность.

Чтобы выбрать одну из строк, ставится дешифратор, у которого будет n входов адреса и 2^n^=k выходов.

По вертикали будут стоять усилители записи/считывания на каждый столбец, то есть фактически на каждый разряд.

CS (Chip Select) приходит как на дешифратор, так и на усилители. На усилитель также приходит R/W и входы данных. Тут выходы двунаправленные.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/2YQBP4N/image.png" alt="image" border="0"></a>

В дешифраторе при CS вырабатывается на выходе унитарный код, то есть выбирается одна строка, к которой разрешается доступ, то есть выбирается одна **ячейка**. Это происходит с помощью горизонтальных **адресных линий**.

Дальше элементы столбцов соединены вертикальными **разрядными линиями**, на которые поступают данные или с них данные считываются.

Усилители записи при этом обеспечивают интерфейс с внешним миром по напряжению, амплитуде и прочим характеристикам сигнала (ЗЭ могут быть специфическими типа конденсатором). При записи данные поступают на все вертикали, но записываются только в строку, выбираемую дешифратором.

Разрядные линии образуются монтажным ИЛИ, поэтому выходы ЗЭ должны быть **трехстабильными** -- три состояния или открытый коллектор.

О структуре 2D говорят, что она имеет **словарную организацию**: каждая горизонталь содержит слово.

Недостаток: дешифратор гигантской размерности: число выходов должно быть равно количеству ячеек: для мегабайтной памяти это будет 1 млн выходов ⇒ очень медленное быстродействие. Поэтому такая организация используется в ЗУ небольшой ёмкости

<a href="https://imgbb.com/"><img src="https://i.ibb.co/PGZn37c/image.png" alt="image" border="0"></a>

Чтобы CS не подавать на все разряды, можно было бы заблокировать один разряд из шины А: этот придёт на каждый выходной элемент И дешифратора в прямом или инверсном виде, и если на всех из них будут нули, то на всех выходах дешифратора были бы нули

### Структура 3D

Матрица ЗЭ, как правило, квадратная, и ставится два дешифратора, каждый из которых выбирает по горизонтали или по вертикали.

Таким образом выигрываем у дешифратора но проигрываем у ЗЭ, потому что там вводится дополнительный вход.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/fF4RLzS/image.png" alt="image" border="0"></a>

<a href="https://imgbb.com/"><img src="https://i.ibb.co/5M8zSCp/image.png" alt="image" border="0"></a>

<a href="https://imgbb.com/"><img src="https://i.ibb.co/5MJf9Dd/image.png" alt="image" border="0"></a>

<a href="https://ibb.co/XyXK93S"><img src="https://i.ibb.co/28qCwsg/image.png" alt="image" border="0"></a>

### Структура 2.5D

Одномерные запоминающие элементы как в 2D.

Каждый столбец это один разряд всех слов. Каждый мультиплексор выбирает i-ый разряд слова.

Количество MUX/DMUX = m, а это количество разрядов. Мультиплексоры выбирают по одному биту выходного m-разрядного кода. Количество входов у MUX -- 2^k^.

<a href="https://ibb.co/72rYGJG"><img src="https://i.ibb.co/KFV09j9/image.png" alt="image" border="0"></a>


Выбираем только одно слово за счёт мультиплексоров.

При записи вместо мультиплексоров работают демультиплексоры, которые должны передать на соответствующий один столбец данные.

В 2D каждая содержит одно слово или одну ячейку => словарная организация

В 3D матрица содержит один разряд всех n слов, поэтому такую организацию называют матричной

<a href="https://ibb.co/3m6GrPd"><img src="https://i.ibb.co/9HKz8dg/image.png" alt="image" border="0"></a>


В плис каждый лут содержит по одному разряду => для памяти 16х8 таких лутов будет 8, то есть 3D. с другой стороны, учитывая что мы считываем по 2 слова, в плис будет память 2.5D.

## Блочные структуры памяти

С ростом ёмкости ЗУ увеличиваются размеры матрицы ЗЭ и возрастают длины линий выборки и записи/считывания и емкостные нагрузки на них. Раз появляются паразитные емкости, которые нужно заряжать/разряжать, то снижается быстродействие памяти.

Единое ЗУ разделяют на несколько частей -- блоков, при этом укорачиваются словарные и разрядные лини, уменьшаются их паразитные емкости и сопротивления, и, следовательно, уменьшаются задержки переключений.

Уменьшение длины линии передачи в $k$ раз снижает распространение сигнала по линии в $k^$ раз, также увеличиваются амплитуды считываемых сигналов в динамических ЗУ (т.к. зависит от соотношения между емкостью запоминающего конденсатора и емкостью разрядной линии).

Раз мы разбиваем на блоки, то можно выиграть ещё и в энергопотреблении: в один момент времени работает только один блок, а не вся память целиком.

## Локальный параллелизм

**Локальный параллелизм** -- метода, позволяющие реализацию совмещения работы устройств при выполнении одной программы. Память разбивается на одинаковые по характеристикам **блоки**, имеющие отдельные устройства управления **МУУ** и допускающие **автономную работу**.

Кроме того запоминающие части та часть матрицы это накопители а когда мы объединяем в блок то там содержится регистр адреса и регистр данных который мб ка входной так и выходной потому что именно в блоке мб входы и выходы отдельно, на накопителе вход и выход поступает по одним и тем же шинам, а внешне это могут быть разные шины

### Блочная организация

В блоках содержатся последовательные адреса. Каждый блок содержит регистр адреса и регистр данных (входной и выходной). 

При 4 блоках:
- 0 блок адреса 0 -- (n/4 - 1)
- 1 блок адреса (n/4) -- (n/2 - 1)
- 2 блок адреса (n/2) -- (3n/4 - 1)
- 3 блок адреса (3n/4) -- (n-1)

При блочной адресации номер блока указывают **старшие** разряды адреса.

### Расслоение памяти

Здесь **младшие** разряды адреса указывают на номер блока

При 4  блоках
- 0 блок адреса 0, 4, 8, ..., N-4
- 1 блок адреса 1, 5, 9, ..., N-3
- 2 блок адреса 2, 6, 10, ..., (N-2)
- 3 блок адреса 3, 7, 11, ..., N-1

<a href="https://ibb.co/QQKbZry"><img src="https://i.ibb.co/9gr8JsQ/image.png" alt="image" border="0"></a>

Здесь РА -- регистр адреса, Н -- накопитель.

Память распределена на L блоков, на которые поступают старшие разряды адреса, которые будут приниматься в свой регистр адреса -- то есть есть единый регистр адреса всей памяти, а есть локальные регистры адреса у каждого из блоков.

Младшие разряды адреса поступают на дешифратор, которые запускает то или иное МУУ, выбирая, какой блок должен работать.

Если происходит считывание информации, то она считывается в регистр данных блока и из него она объединяется в выходной регистр данных всей ОП. То есть в целом память имеет свои регистры адреса и данных, а также каждый блок по отдельности содержит свои собственные регистры.

Всей этой схемой -- памятью в целом -- управляет отдельные блок управления, который управляет регистром адреса и регистром данных.

В каждом блоке нужно знать, можно ли к нему обращаться или нет --  в каждом из блоков МУУ вводится триггер занятости или готовности, который указывает на то, что к этому блоку в данный момент обращаться нельзя, потому что он занят обслуживанием клиента, а когда он освободится, триггер готовности перейдёт в состояние готовности.

Расслоение памяти это фактически и есть конвейер обращения к памяти. Как в конвейере, за счёт дополнительных ресурсов быстродействие уменьшается, то есть требуется дополнительное время предустановки, задержка на срабатывание и т.д. 

В данном случае рассматривается только чтение. Запись будет работать в обратную сторону.

<a href="https://ibb.co/gjLkTqc"><img src="https://i.ibb.co/j6PnM0j/image.png" alt="image" border="0"></a>

Рассмотрим работу 4 блоков. 

Пришло обращение к нулевому блоку памяти. Через Тцикла на выходе получим результат.

Но этот нулевой адрес мы передали после того как он поступил на вход мы переали в регистр адреса нулевого блока и через Тцикла в его регистре данных мы получили считали данные которые могут поступать на регистр выхода данных ОП.

Раз нулевой адрес был передан то через какое время будем считать 1/4Tцикла обращение к первому блоку дешифратор опреелили что обращение к первому блоку передали обращение к первому блоку и через время цикла на входе получаем результат

Далее аналогично ко второму и третьему блоку через Т цикла получаем резултат

Вспоминая конвейер если в какой-то момент работают 4 блока одновременно то на выходе мы получаем результат каждый 1/4 Тцикла

Таким образом может идти обращение за командами на линейном участке команды - они как раз будут расположены в разных блоказ потому что у них адреса идут последовательно друг за другом. Если была бы блочная память без расслоения, нам бы пришлось ждать последовательно пока освобождается один и тот же блок

Потом мы опять обращаемся к 0, 1 блоку и потом сразу к третьему а он ещё занят. В этом случае можно ждать и не получать никаких результатов и ждать пока соовбодится -- в данном случае задержать на 1 такт

3 мы запустили позже то есть мы подождали пока он освободится. Результат 3 мы получаем не через 1/4 а через полпериода.

Потом если мы опять обращаемся к 3 то он будет ждать ещё дальше

А можно эту тройку отложить если мы второй раз к нему обращаемсч, взять следующий адрес из очереди и начинать обслуживать уже его, чтобы там адреса не простаивали

Там пусть будет 2, двойку обслуживаем потому что она свободна, и так далее

Таким образом при нарушении можно либо ставить всё на паузу ждать и ничего не запрашивать, либо отложить какой-то запрос и перейти к следующим запросам в очереди которые обращаются к другим блокам, а потом, когда занятый блок освободится, обслужить отложенный запрос

Понятно что для того чтобы эту тройку запоминать надо заиметь какой-то буфер и проверять на каждом шаге освободился ли нужный блок - то есть проверять его триггер занятости.

# Кэш память

## Организация двухуровневой памяти

<a href="https://ibb.co/09HQnyV"><img src="https://i.ibb.co/B60wf2K/image.png" alt="image" border="0"></a>

Слева показан процессор. Программа и данные располагаются в ОП. Рассмотрим, когда между процессором и ОП располагается кэш. Это двухуровневая память - есть ОП и есть кэш.

При обращении за данными или за командами у процессора на первом шаге адрес поступает в шину адреса, и на первом шаге всегда обращение идёт в кэш. При этом происходит определение наличия адреса в кэше: есть ли данные по запрашиваемому адрсу в кэше. Если таких данных нет, то одновременно на этом же шаге находим старую информацию.

Далее предположим, что адрес в кэше находится - будет кэш-попадание. Пусть будет обращение на считывание, тогда считывается из кэша информация и передаётся в процессор. Здесь Т - цикл обращения будет равен тау считывания, где тау - это обращение к кэшу (Т большое это обращение к ОП).

Если обращение идёт на запись, и выполняется кэш-попадание, то опять по первому шагу определяем, обращаемся в кэш и определяем попадание. Но может быть также или сразу, или через плюс, запись - это повторное обращение на запись. Как правило, для записи нужно два шага, то есть два тау. Поэтому запись может быть не такая, а чуть чуть другая.

Следующий вариант - кэш-промах, когда при обращении (1) обнаруживается, что в кэше адреса нет, но при этом определяется самая старая информация. При этом дальше мы выполняем считывание старого значения при первом обращении, и затем нужно считать новую информацию из ОП - этот адрес передаётся в регистр адреса ОП, и через Тсч нов мы считываем новую информацию в кэш и в процессор (4).

В кэше дублируется часть информации ОП. Кэш имеет меньший объем, а значит, у него на полпорядка большее быстродействие. Но если в кэше нет нужной информации, новую информацию надо всегда передавать в кэш, а если в кэше места нет - нужно находить старую информацию - ту, к которой дольше всего не было обращения, и на место старой информации записать новую. Поэтому на первом же шаге всегда эта старая информация будет находиться вне зависимости от того, нужна ли она будет (кэш-промах) или нет (кэш-попадание).

Кэш может быть не переполнен, потому что информация может записываться не в любое место в кэше. Если место, куда нужно записать, занято, можно считать, что кэш заполнен -- не в целом весь кэш, а именно то место, куда мы хотим записать.

Поэтому если кэш-промах произошёл при считывании, то можно считать, что процессор через Тсч = тау сч ст + Тсч нов считал информацию. Но на этом цикл обмена в некоторых случаях может быть не завершён. Раз мы считали старую информацию, то её может быть нужно записать в ОП из кэша (Тзп ст), а новую информациб, которую мы только что считали из ОП и отправили в процессор, нужно записать в кэш (7). Поэтому через плюс к предыдущим шагам процессор мог считать эту информацию, а обмен будет всё ещё продолжаться (шаги 6 и 7). Поэтому цикл обмена может быть больше, чем время считывания у процессора (4): 2тау + 2Т. Запись старой и новой информации можно выполнять одновременно, поэтому цикл может быть равен тау + 2Т, если (7) и (6) будут выполняться одновременно, а Т > тау.

Старую информацию переписывать нужно не всегда.

При записи на кэш-промахе мы записываем старую информацию в ОП а в кэш новую - это "обратная запись" в случае, если те старые данные были изменены и их надо актуализировать в ОП. Но может работать и не так, а можно сразу записывать в кэш новую информацию, даже при промахе - когда старые данные не нужно записывать в ОП, потому что они не были изменены со стороны процессора, то есть копия старых данных, которая хранилась в кэше, совпадает с тем, что хранится в ОП, а значит, перезаписывать ничего не надо.

Может быть не обратная, а прямая запись - в этом случае, когда мы определили кэш-промах, то мы записываем новые данные сразу в ОП. Но при прямой записи данные могут записываться и также в кэш-память. И как правило, при прямой так и делают, записывая и в ОП, и в кэш.

Обратная запись: данные пишутся в кэш и переписываются в ОП, только когда они устарели, то есть были изменены со стороны процессора.

Все режимы записи при выполнении тау зп нов (в любом случае) то, как правило, нужно сначала ещё выполнить тау считывания нового блока, потому что обмен идёт блоками. 

Также могут усложняться алгоритмы записи/чтения для того, чтобы избавиться от шин 4 и 5, и сделать так, чтобы процессор взаимодействовал исключительно с кэшем -- это позволит уменьшить количество шин

При прямой записи информация в ОП и в кэше всегда будет одна и та же, а при обратной информация может отличаться => рядом с этой информацией вводится бит изменения, показывающий, что эти данные были изменены со стороны процессора.

Всем этим управляет контроллер, к которому обращается процессор. При этом уровней мб много - L1, L2, …

## Ассоциативные запоминающие устройства (АЗУ)

В отличие от адресных ЗУ или ОП  кэш - это ассоциативное ЗУ.

Например когда мы пишем в ЗУ информацию с датчиков мы пишем информацию в виде {номер датчика: значение}.

**Ассоциативный доступ** реализует поиск информации по некоторому **признаку** данных (сочетанию признаков, например, часть слова), а не по её расположению в памяти (адресу памяти или месту в очереди) -- адресация по содержанию.

В азу вводится следующий формат данных

<a href="https://imgbb.com/"><img src="https://i.ibb.co/S3FPc39/image.png" alt="image" border="0"></a>

Кроме самих данных добавляется признак и дополнительная управляющая информация (на примере кэша -- нужно ли менять данные, обновились ли они и т.д.)

Основной функцией ОЗУ является сравнение заданного кода поисковой информации со всеми кодами, хранящимися в ЗУ (схема сравнения). На выход АЗУ передаются данные, удовлетворяющие этому признаку.

Существуют различные дисциплины выдачи данных и записи новых данных. В наиболее полной версии АЗУ все хранимые в памяти данные одновременно проверяются на соответствие признаку, но это требует большого объёма оборудования.

<a href="https://ibb.co/vhPFNMM"><img src="https://i.ibb.co/zFRM3tt/image.png" alt="image" border="0"></a>

Возможны три способа
- сравнивать признаки последовательно друг за другом -- сколько признаков, столько и сравнений
- сравнивать разряды
- делать всё одновременно в схеме сравнения

В таких схемах для общего случая может быть многократное сравнение. В кэше это не так, и выбирается максимум одна строка

<a href="https://ibb.co/7WwKYY5"><img src="https://i.ibb.co/SnhBss8/image.png" alt="image" border="0"></a>

<a href="https://ibb.co/MDyX60Q"><img src="https://i.ibb.co/d0shgYx/image.png" alt="image" border="0"></a>

<a href="https://ibb.co/DbpgBq5"><img src="https://i.ibb.co/fSvG3c4/image.png" alt="image" border="0"></a>

<a href="https://ibb.co/bvNXsmV"><img src="https://i.ibb.co/94yWbg0/image.png" alt="image" border="0"></a>

<a href="https://ibb.co/JFJZsLk"><img src="https://i.ibb.co/M50dCTN/image.png" alt="image" border="0"></a>

### Кэш память прямого отображения (размещения)

При прямом отображении у группы, где группы содержат столько блоков, сколько строк у кэша, каждый блок будет располагаться в кэша в строго определенном места (в строго определенной строке) в зависимости от положения этого  блока внутри группы.


<a href="https://ibb.co/R2gTcsn"><img src="https://i.ibb.co/LS0d1cw/image.png" alt="image" border="0"></a>

### FACM

Полный физический адрес (кроме смещения)

Смещение выбирает один байт, мультиплексоры выбирают одну строку

Можно выходы буфера с третьим состояниям объединить между собой и поставить всего один мультиплексор

Свободная ячейка - это та, которая не валидная, то еть ещё не занятая
+ у каждой строки может стоять бит валидности и бит записи/модификации, последний бит важен при обратной записи
+ должны где-то быть данные единые для всего устройства, указывающие на самую старую ячейку

<a href="https://ibb.co/z6gRwmF"><img src="https://i.ibb.co/Z2r8CfS/image.png" alt="image" border="0"></a>

### Кэш память множественно-ассоциативного отображения

<a href="https://ibb.co/PzM5f0q"><img src="https://i.ibb.co/M5fR3QF/image.png" alt="image" border="0"></a>

## Алгоритмы записи информации

При обращении к кэш памяти одновременно со сравнением тега адреса с тегами кэш-тегов и формированием сигнала Hit, из кеш-данных считывается строка данных. Это происходит одновременно -- считывание строки (при множественно-ассоциативном кэше -- несколько строк) как с тегом, так и с данными.

Если происходит кэш-попадание (Hit), то есть копия ОП есть в кэше, то есть несколько способов записи:
- **сквозная (прямая) запись, write through, store through** -- информация записывается и в ОП и в кэш.
	- копии всегда совпадают в кэше и в ОП
	- простота реализации, но длительность цикла записи равна времени записи в ОП
	- процессор может не обмениваться с ОП напрямую, то есть может быть шина процессор-кэш, по которой он записывает данные в кэш, и после этого по шине кэш-ОП данные из кэша перезаписываются в ОП (при этом переписывается полностью весь блок -- то есть возможно даже в ОП придётся сделать несколько циклов записи данных в блоке, но на это всё идут из-за предположения о локализации циклов в пространстве и во времени). При этом шины процессор-ОП нет. Как правило, именно из-за отсутствия связей процессора с ОП запись в кэш и в ОП происходит не одновременно, а последовательно. 
- **сквозная запись с буферизацией** -- на входе ОП включают буфер записи FIFO. В этом случае для процессора цикл записи завершается после записи в буфер, он дальше может заниматься своими делами, а буфер дальше сам записывает блок в ОП. При конвейеризации надо будет учитывать, что при дальнейшем обращении к памяти буфер может быть занят, или нужные нам данные находятся ещё в буфере
- **обратная запись (write back, copy back, store in)** -- информация записывается только в кэш и устанавливается флаг состояния (бит записи) -- модификации (dirty bit) строки со стороны процессора. При кэш-промахе и заполнении кэша и "старении" данной строки проверяется этот бит и информация перезаписывается в ОП. При этом переписывается вся строка.

Если кэш-промах (Hit=0 или если есть отдельный сигнал Miss=1), то есть копии ОП в кэше нет:
- **выборка при записи (fetch on write)** -- проводится считывание требуемого блока из ОП и запись в строку кэша, а далее эта же строка кэша может быть перезаписана обратно в ОП (как прямая запись при попадании)
- **запись в окружении (write around)** -- запись проводится только в ОП и не загружается в кэш. Нестандартный режим и не очень правильный с точки зрения работы кэша


Кроме того, процессор определяет размер записи 1-8 байт (биты valid -- говорят, какие биты надо перезаписать). То есть если у нас есть 8 байт, то на каждый байт вводится по биту valid, которые говорят, какие байты нужно перезаписать

## Алгоритмы замещения (учет старения информации)

В наборе нужно определить, где находится самая старая информация.

### Табличный метод

Похож на круговую систему проведения соревнований

<a href="https://imgbb.com/"><img src="https://i.ibb.co/rZcZbzw/image.png" alt="image" border="0"></a>

Самая старая информация -- А5.

Для представления этой таблицы достаточно хранить 6 отдельных бит, так как таблица антисимметрична относительно главной диагонали

### Метод списка

При совпадении тегов перемещается номер строки в вершину списка. Для каждой строки в списке вводятся дополнительные разряды с номером строки в списке.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/bF5gQvk/image.png" alt="image" border="0"></a>

Может быть и другая разновидность, когда новая строка помещается вниз. Тогда старая строка будет верхней.


### PLRU: Pseudo Least Recently Used

На те же 4 строки предлагается ввести всего 3 бита последнего обращения к этим строкам
- B0 = 0 если к L2 или L3
- B0 = 1 если к L0 или L1
	- B1 = 0 если к L1
	- B1 = 1 если к L0
		- B2 = 0 если к L3
		- B2 = 1 если к L2 

Идёт по алгоритму и хотим определить, к какой строке было самое давнее (старое) обращение. Далее доходим до конца и меняем значения соответствующих бит, так как эта старая строка уже будет обновлена, раз мы из неё извлекаем/считыванием, то надо засчитать новое последнее обращение

<a href="https://imgbb.com/"><img src="https://i.ibb.co/Cz53vqy/image.png" alt="image" border="0"></a>

Рассмотрим, почему этот алгоритм называют pseudo. Видно, что при обращениях алгоритм может выдавать не самую старую информацию

<a href="https://imgbb.com/"><img src="https://i.ibb.co/cvdXzGZ/image.png" alt="image" border="0"></a>

Зато здесь используется только 3 бита. Для 8 строк нужно было бы 7 битов, а в табличном способе пришлось бы использовать 28 бит, в списочном 3 * 8 = 24 бит.

### FIFO

Также иногда применяют **алгоритм FIFO** -- замещается самая давняя по пребыванию в кэш-памяти строка по сдвиговому регистру

### Random

**Алгоритм Random** -- замещение проходит случайным образом.


# Динамические ЗУ

<a href="https://ibb.co/ckGXrwD"><img src="https://i.ibb.co/ydwBQpW/image.png" alt="image" border="0"></a>

Раньше значит что длительное время не удавалось подобрать параметры так чтобы всё работало -- было больше транзисторов для того, чтобы обращаться уверенно к памяти (всякие усилители и преобразователи и прочее).

Требования по разбросу параметров: сопротивление, транзисторы до 30% => длительное врем не удавалось создать однотранзисторный элемент

Транзистор который входит в состав зэ выполняет роль ключа и разрешает доступ к конденсатору.

Но конденсатор со временем разряжается за счет цепей утечки, поэтому информацию необходимо периодически восстанавливать (регенерировать).

Для того чтобы восстановить информацию нужно обращаться не к каждому отдельному биту, а ко всем ЗЭ строки сразу. Достаточно обратиться к строке, и тогда информация будет восстановлена. Чтобы восстановить информацию на всем кристалле нужно последовательно перебирать все строки.

Простота динамического элемента: всего один конденсатор и один транзистор -- две линии обращения

<a href="https://ibb.co/RzZxNCd"><img src="https://i.ibb.co/KFRMD9S/image.png" alt="image" border="0"></a>

Пока осуществляется регенерация, доступ процессора к памяти запрещен: регенерация имеет наивысший приоритет

## Однотранзисторный ЗЭ


<a href="https://ibb.co/WxdRQ3D"><img src="https://i.ibb.co/8KRQJBz/image.png" alt="image" border="0"></a>
Запоминающий элемент Сзэ - это запоминающий конденсатор. Транзистор всего один Т1

Линия адреса или шина адреса, линия выборки - горизонтальная линия, это строка. Вертикаль - это разрядная линия. К разрядной линии подключены все элементы столбца.

Есть конденсатор разрядной линии, который иногда показывают пунктиром - "паразитный" конденсатор, который специально не создают - он сам создаётся за счет длинной линии: если мы возьмём 1 млн бит - это 1000х1000 строк => к разрядной линии присоединено 1000 строк, это получается длинная линия внутри кристалла. Этот конденсатор разрядной линии имеет значительно большую ёмкость, чем конденсатор ЗЭ. Поэтому к разрядной линии подключаются усилители записи и считывания.

Рассмотрим, как работает данный запоминающий элемент.

<a href="https://ibb.co/g9mffk4"><img src="https://i.ibb.co/DWzvv0r/image.png" alt="image" border="0"></a>

U - это питание

T0-t1 предзаряд разрядной линии или конденсатора разрядной линии до потенциала U/2. Тут стоит этот уровень сразу, потому что усилитель устанавливает потенциал U/2, а конденсатор может заряжаться или разряжаться в течение этого времени до U/2.

Далее в момент t1 открываем ключ Т1. подаётся сигнал того напряжения, который необходим (условно единичка), открывается транзистор и ключ, который работает как биполярный транзистор, и получается исток и сток замкнуты между собой и получается низкое сопротивлеия - затвор и исток как бы соединены между собой, и получается что ЗЭ и РЛ соединены напрямую, и между ними осуществляется перераспределенеи зарядов.

Если КЗЭ был заряжен, то он разряжается. Если он был заряжен, то разряжается - но так как 2 конденсатора соединены параллельно, они оба приводятся к одному потенциалу, у первого (РЛ) это U/2, а у второго это 0 или U. Перераспределение заряда между конденсаторами происходит на дельта U.

В момент t2 включается усилитель считывания, который считывает это + или - delta U с разрядной линии.

Далее уже после считывания КЗЭ разрядился или зарядился со соответствующей величины, поэтому надо восстановить заряд этого конденсатора. Усилитель записи выставляет потенциал либо 0 либо 1 в зависимости от того, что считали, и осуществляется заряжание (1) до U или разряжание до 0.

Если нужно выполнять запись, то даже для режима записи первые два режима до t2 выполняются. Если нужно записать новое значение, то это как в t2-t3, а если нужно перезаписать (то есть считать одно, а записать другое), то идёт по какой-то другой траектории (например когда считали 0 а записали 1 - будет другая траектория)

После t3 может начинаться новое обращение t0 - с этого момента мы возвращаемся в t0 и опять осуществляем заряд или разряд РЛ.


Получается что любое обращение к памяти на считывание или на запись выполняется с разрушением информации. То есть есть три режима - подготовительный, режим считывания и режим восстановления или записи.

Когда происходит обращение, то аналогичный режим работает по всей строке - определяем, что записано, и если мы восстанавливаем, то идёт только восстановление. А запись осуществляется только в одном столбце - все остальные будут только восстанавливаться. Таким образом, при любом обращении к строке информация будет восстанавливаться по всей строке. Поэтому сразу при записи например 0 или 1 нельзя поставить сраузу 0 или 1 на усилитель записи. Отличие между записью и чтением только в последнем шаге - восстановление или запись, причём запись происходит только в одном столбце.

Когда открывается ключ подачей напряжения на затвор, то в этом случае транзитор можно считать точкой, который замыкает исток и сток между собой. Получаются параллельно подключенные два конденсатора и между ними начинает происходить перераспределение зарядов.

Uзэ-Uрл мб разница до U/2

Как можно увеличить дельта U чтобы можно было уменьшить требования к усилителю считывания? Для этого можно увеличить Сзэ, раз мы его создаём, но раз мы его увеличиваем, то будет увеличиваться площадь ЗЭ. Можно ещё и уменьшить ёмкость разрядной линии, но мы эту ёмкость не создаём, она создаётся сама из-за длинной линии.

Можно разрезать разрядную линию и тем самым уменьшить Срл и поднять дельта U

<a href="https://ibb.co/2vJ3hnT"><img src="https://i.ibb.co/tqRpKm9/image.png" alt="image" border="0"></a>

В динамической памяти вводится мультиплексирование шины адреса. То есть есть адрес строки и есть адрес столбца, которые стробируются сигналами RAS и CAS.

Мультиплексирование адреса вводится для экономии разрядности шины адреса. Тут происходит уменьшение количества выводов в два раза.

По одной и той же шине адреса подаём половину адреса, при этом сначала всегда подаётся RAS - обращение сначала идёт к строке. Адрес относительно фронта RAS выдерживается некоторое время, и адрес сохраняется в регистре адреса строки. Далее спустя время удержания адреса устанавливается вторая половина адреса - адрес столбца, который также должен быть подан до начала фронта и какое-то время после него. Этот адрес можно либо выдерживать всё время дальше, либо не выдерживать, если внутри памяти есть регистр адреса столбца.

Сейчас обычно вместо сигнала R/W обозначают сигнал WR, который инверсный. Если идёт чтение, то относительно сигнала CAS через какое0то время выдаётся считываемая информация. Треугольник в DO в УГО означает что это выход в третьем состоянии (на ВД это Z). Раз Z, то выход DI мог отсутствовать, а сделать двунаправленный вывод DI/DO.

Цикл обращения к памяти - это время от одного обращения RAS до следующего..

При записи подаётся 0 на WR. Надо подать данные - они могут подаваться до WR и по фронту WR передаются во внутренний регистр. Но как правило они просто выдерживаются временем предварительной установи до снятия сигнала WR. Режим записи может начинаться либо по CAS либо по WR в зависимости от того, какой приходит позже

Один из вариантов режима регенерации - когда падётся только RAS, а на вход адреса - строку, которую нужно регенерировать, дальше можно ничего не подавать. При этом как параметр должна быть выдержана длительность RAS а время TrecRAS это время восстановления усилителей

<a href="https://ibb.co/kyx0DHt"><img src="https://i.ibb.co/DbtkMVZ/image.png" alt="image" border="0"></a>

Эта строка могла быть и внешняя и внутренняя: если бы память была как блок, то был бы внутри счётчик регенерации - то есть счётчик строки, которую надо регенерировать и стоял бы мультиплексор, который бы выбирал либо строку для регенерации либо строку со внешнего входа А

## Структурная схема динамического ЗУ

<a href="https://ibb.co/2yTjLvn"><img src="https://i.ibb.co/mG3HY9D/image.png" alt="image" border="0"></a>

16М это 24 разряда на адрес, но раз у нас RAS и CAS, то адрес делится пополам, и получается 12 разрядов.

А12/А0 -> A0

…

А23/А11 -> A11

Старшие разряды адреса (А23-А12) - это строка, а младшие - это столбец, чтобы можно было бы реализовать страничную организацию. Но для регенерации можно было бы делать наоборот, чтобы почаще обращаться к строкам.

Для увеличения delta U надо разбить на 4 секции - delta U увеличивается в 4 раза. Получается что в каждой секции 1024 строки, а на пару секций ставится по одному усилителю. Чтобы соединить их между собой нужны дешифратор столбцов, усилитель записи и усилитель считывания. К каждому столбцу, которых 4096, помимо дешифратора столбцов нужен дешифратор строк (2 шт) оба на 2К выходов

По RAS стробируется адрес строки который записывается в регистр строк, из которого адрес поступает на дешифратор, в котором младший разряд один идёт на верхний DC, а нижний с инверсией на Е на второй DC. Также поступает РГ столбцов. Чтобы регистры сработали, разрешение приёма обеспечивается формирователями тактовых сигналов.

Далее стоит буфер ввода вывода на который поступают сигналы DI, WR и с которого информация передаётся на выход если мы считали её с усилителей либо через буферы на вход. Он также настраивает на определенные фронты которые нужны, величины тока

## Методы повышения быстродействия

### FPM

Подаётся сигнал RAS, который принимается во внутренний регистр. Через  какое-то время подаётся CAS. В быстром страничном режиме подаются несколько сигналов CAS, при этом к каждому фронту подаётся адрес столбца. то есть одна строка и несколько столбцов. Через некоторое время информация появляется на выходе первого столбца, затем второго и так далее.

При этом первый столбец может выдаваться либо относительно RAS, либо относительно CAS, а вот все последующие идут только относительно CAS. 

За одно обращение или t~отн RAS~ или t~отн CAS~ нужно обязательно выдерживать время между RAS и CAS. При этом когда завершили подачу CAS тут же сразу можно считать, что завершается информация и на выходе. Эта информация считывается через время относительно CAS и завершается относительно CAS: как только CAS сняли, информация снимается

При этом когда выбрана конкретная строка, столбцы в ней могут задаваться в произвольном порядке не обязательно подряд


<a href="https://ibb.co/vwwF4sD"><img src="https://i.ibb.co/X22QxyV/image.png" alt="image" border="0"></a>


Раз мы строку извлекли, то за вторыми и дальше данными значительно сокращается время обращения

Есть такая характеристика как пропорциональность времен между первым и последующим обращениями. Говорят, что для FPM это 5-3-3-3

### EDO


При первом режиме можно было брать любой столбец из строки, не подряд идущий, то здесь лучше кучковать адреса

В отличие от предыдущего, по окончании CAS данные не сбрасывается, а вводится внутренний регистр защёлка данных и дальше уже из этого регистра идёт информация

Данные считываются через то же самое время но они не исключаются даже при отсутствии CAS. Данные снимаются из регистра поэтому они выдерживаются до следующей подачи CAS.


<a href="https://ibb.co/3W7zQ9D"><img src="https://i.ibb.co/FJKVCLS/image.png" alt="image" border="0"></a>


### BEDO

Здесь вводится внутренний счётчик адресов столбцов, то есть адреса столбцов теперь задаются не извне - достаточно задавать начальный адрес пакета и потом достаточно задавать только его инкремент. Значит, не нужно выдерживать дополнительное время на установку адреса.

Дальше как на конвейере - тут правда предложено по второму фронту а не по первому, но это не принципиально

<a href="https://ibb.co/Yt295wm"><img src="https://i.ibb.co/br1h4DT/image.png" alt="image" border="0"></a>

Рассмотренные три подхода были асинхронными ЗУ: они никак не связаны с синхросигналами, по которым работает процессор. А значит, нужно выдерживать данные на выходе более длительное время. Было предложено делать память синхронной

### SDRAM

<a href="https://ibb.co/v4KV1Yj"><img src="https://i.ibb.co/s9MbjHV/image.png" alt="image" border="0"></a>

Тут как в EDO и в BEDO есть регистр защёлка и счётчик адреса. Также обеспечивается пакетный режим. К сигналу привязаны RAS и CAS так что известно через какое количество тактов будет получен ответ памяти

<a href="https://ibb.co/bRZyHgh"><img src="https://i.ibb.co/93Lfw9X/image.png" alt="image" border="0"></a>

И на каждом такте получаем новые данные. Важно что приём в регистр адреса строки, столбца и выдача данных выполняются по фронту или по спаду синхросигнала. Trp - это время дезактивации/восстановления усилителей и шин. Время между двумя RAS это длительность цикла. Сколько он длится в тактах - зависит от строки, от того, сколько в пакете данных.

### DDR SDRAM

<a href="https://ibb.co/d0dc7xv"><img src="https://i.ibb.co/XZh4VMP/image.png" alt="image" border="0"></a>

<a href="https://ibb.co/gWz6VBz"><img src="https://i.ibb.co/5jB2FfB/image.png" alt="image" border="0"></a>

Как правило в тайминге памяти все параметры были равны поэтому можно было писать только одно число

<a href="https://ibb.co/KKrQDjG"><img src="https://i.ibb.co/Sf31cXx/image.png" alt="image" border="0"></a>

За счёт уменьшенного питания ускоряется подъём сигнала до фронта.

<a href="https://ibb.co/xjQTwdL"><img src="https://i.ibb.co/4TxrC3t/image.png" alt="image" border="0"></a>

## Регенерация информации

### Пакетный режим

Пусть есть 1024 строк, можно задавать на счетчике номер строки регенерации и выполнять регенерацию всех строк => на время регенерации запрещаем работать процессору. На работу процессора потом отводится время, равное периоду регенерации.

Предложено использовать другой вариант, ведь на время регенерации (а это получается 10нс * 1024 = 10 мкс) процессор к памяти обратиться не может

### Групповой режим

Разбиваем на группы 0-63 по 64 строки то мы эти же 10 мкс разбили на части и процессору запрещаем работу 640 нс с памятью, то есть простои процессора уменьшаются

### Распределенный режим

Когда мы весь период регенерации выполняем обращение через тау которое равно Трег/N строк и только на это время блокируется обращение к памяти. Регенерируется только одна строка за раз

### Бит обращения

Предлагается на каждую строчку ввести бит обращения. В момент работы процессора мы также обращаемся к первой строке - тогда этот бит обращения устанавливается в единицу, ведь при любом обращении к строке со стороны процессора регенерируется вся строка.

Когда наступит время регенерации первой строки, проверяется этот бит и если бит равен единице, то регенерация не выполняется (эта проверка происходит где-то в устройстве управления), бит устанавливается в 0 и так далее.

<a href="https://ibb.co/D84bvvF"><img src="https://i.ibb.co/yY0RZZC/image.png" alt="image" border="0"></a>

Но видно, что в таком случае строка может очень долго не регенерироваться, гораздо дольше, чем период регенерации. Поэтому чтобы так работать и не было потери информации нужно сократить период регенерации в два раза

<a href="https://ibb.co/RyfnGH4"><img src="https://i.ibb.co/YZm94jT/image.png" alt="image" border="0"></a>

### Способы задания режимов регенерации

<a href="https://ibb.co/V3hRqhS"><img src="https://i.ibb.co/LvqmZqt/image.png" alt="image" border="0"></a>

1. Присутствует только RAS, регенерируется вся строка и больше ничего не задаётся
2. Когда CAS опережает RAS -- в этом случае на память задаётся адрес строки во внутреннем счётчике. CAS подаётся раньше -- наступило то время тау, когда нужно регенерировать
3. Скрытая регенерация, когда на вход RAS подаётся два сигнала. В этом случае мы подали начальный адрес, извлекаем данные во внутренние регистры и из внутреннего регистра они передаются на выход. Но раз мы данные на выход передаём из внутреннего регистра, то память свободна, и значит, подавая второй раз RAS мы можем начать выполнять регенерацию. Получается, мы выдаём данные и в этот же момент можем начать регенерировать

# Тенденции развития ЦП

**RISC -- Reduced (Restricted) Instruction Set Computer** -- <u>уменьшенный набор команд</u>, которыми пользуется процессор компьютера, содержащий только наиболее простые команды. RISC имеют набор однородных регистров универсального назначения, количество которых может быть большим; коды команд имеют четкую структуру, как правило фиксированной длины; выполнение команд за минимальное число тактов.

Основоположники -- серии суперкомпьютеров компании Cray для построения быстрых вычислительных машин. Однако окончательно понятие RISC в современном его понимании сформировалось на базе трех исследовательских проектов компьютеров: процессора 801 компании IBM, процессора RISC университета Беркли и процессора MIPS Стенфордского университета

**CISC -- Complete Instruction Set Computer** -- <u>полный набор команд процессора</u>. Состав и назначение их регистров существенно неоднородны, широкий набор команд усложняет декодирование инструкций, на что расходуются аппаратные ресурсы. Возрастает число тактов, необходимое для выполнения инструкций.

Основоположником CISC-архитектуры можно считать компанию IBM с базовой архитектурой IBM/360 (до 600 команд), ядро которой используется с 1964 года и дошло до наших дней, например,  в таких современных мейнфреймах как IBM ES/9000. Лидером в разработке CISC считается компания Intel со своей серией x86 и Pentium

## CISC

Характерно
- сравнительно небольшое число РОН (8-16)
- большое количество машинных команд, некоторые из них нагружены семантически аналогично операторам высокоуровневых ЯП и **выполняются за много тактов** (одна и разделительных причин -- если команда выполняется за 1 такт, то это RISC, иначе CISC)
- большое количество методов адресации (8-12)
- большое количество форматов команд различной разрядности
- преобладание двухадресного формата команд ⇒ результат помещается на место одного из операндов, который затирается
- наличие команд обработки типа регистр-память и память-память


## RISC
- наличие достаточно большого регистрового файла (32-64), что позволяет большему объёму данных храниться в регистрах на процессорном кристалле большее время и упрощает работу компилятора по распределению регистров под переменные
- поэтому операции обработки реализуются в формате регистр-регистр, а для работы с ОП отдельная команда пересылки
- для обработки, как правило, используются трёхадресные команды, что помимо упрощения дешифрации даёт возможность сохранять большее число переменных в регистрах без их последующей перезагрузки (операнды не затираются)
- любая операция должна выполняться за один такт
- система команд должна содержать минимальное число наиболее часто используемых команд (менее 30, должно оставаться место для расширения и кастомизации)
- управление с жесткой логикой
- УУ проще по сравнению с CISC
- многопортовые РОН (трехпортовая: извлекать два и записывать в один)
- раздельные шины ввода и вывода
- ограниченное количество способов адресации
- ограниченное количество форматов команд
- команды одинаковой длины (32 разряда)
- независимые кэш инструкций и кэш данных
- широкое использование методов конвейеризации
- суперскалярная обработка
- быстрая арифметика (параллельность, конвейеризация, сверхпараллельные схемы многоразрядных схем сумматоров, умножителей, делителей и др., несколько исполнительных устройств -- целочисленные операции, АЛУ с плавающей точкой), тут же отдельно могут быть РОНы для чисел с плавающей и фиксированной запятой
- меньше трудоемкость при разработке кристалла

## Тенденции сближения архитектур CISC и RISC

**RISC** -- высокая производительность в вычислениях с плавающей точкой. 

**CISC** -- высокая производительность при целочисленных вычислениях.

Основной недостаток CISC по сравнению с RISC -- 



<!--stackedit_data:
eyJoaXN0b3J5IjpbNTAzNzI1OTU4LC00NDYyMDQ5NjEsMTY2Mz
M1ODkxNCwxNDUyNjI2MTM0LDg5NDY4NTk2Miw3NTgxNTA5ODAs
LTE2NDAyMzI1NzMsLTU2MjIyMjI2MSwtMTg1OTQzNjQ2MywxNj
A4NjUwNjIxLC0xMzIxNTYyMTQ0LC0xMjMxNDU0MDY1LDE1Mzk5
MDczNSwtOTE4ODc2MzM2LDQxNzU4MzAyMiw5MDUwMTg2NTIsMT
E3ODA4MDE3MCwxMTQxNDkxNTU5LC0xODM4NzcyNjk5LDE1ODY4
MTMyNDBdfQ==
-->