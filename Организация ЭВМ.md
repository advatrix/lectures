
# Общая структурная схема процессора


БО -- блок, который непосредственно выполняет арифметико-логические операции.

Управляет блоком операции МУУ -- местное устройство управления. Он формирует управляющие сигналы для выполнения арифметико-логических операций на БО.

ЦУУ -- центральное устройство управления. 

П -- память или система памяти. Она мб показана пунктиром, потому что из системы памяти внутри процессора находится только кэш, а ОП по определению находится вне процессора (максимум только какая-то её часть).

Блок операции и МУУ вместе образуют АЛУ -- арифметико-логическое устройство. Оно выполняет арифметические и логические операции.

Пунктирные блоки -- опциональные -- блок контроля и диагностики и блок связи с каналами (с внешними устройствами).

Блок контроли и диагностика работает при включении компьютера: он выполняет некоторое тестирование. Контроль от диагностики отличается тем, что контроль -- то, что выполняется во время работы процессора при осуществлении операций, а диагностика -- это специальный режим проверки, какой из блоков не работает (например, контроль по чётности -- это когда к данным или командам добавляются дополнительные разряды, которые контролируются в процессе выполнения).

У нас эти пунктирные блоки отсутствуют. Они не входят в состав процессора, так как они опциональные.

Внутри ЦУУ -- устройство, которое занимает верхний уровень в иерархии управления, делится на БУК и БМК.

**БУК** -- блок управления командами. Он формирует **исполнительные** адреса операндов и адреса следующей команды или следующих команд. То есть он управляет последовательностью команд.

**БМК** -- блок формирования (выработки) микрокоманд. Он отвечает за формирование управляющих сигналов для управления другими блоками процессора. Фактически там же формируется $Y_C$.

Можно было ьы считать, что как по аналогии в АЛУ БУК -- это как БО, а БМК -- это как МУУ.

Система памяти состоит из ОП и РОН (регистры общего назначения). Также там может быть кэш нескольких уровней, а ВЗУ -- внешнее запоминающее устройство, обычно реализуется через связи с внешними устройствами.

**Процессор** -- это устройство, осуществляющее процесс обработки данных по заданной программе.

**Центральный процессор** -- это процессор, в состав которого входят устройства управления, АЛУ, и который осуществляет наряду с обработкой данных управление другими устройствами ЭВМ.

ЦУ в иерархии подчинения занимает самое высокое место.

<a href="https://ibb.co/3Nj4mDD"><img src="https://i.ibb.co/C7YmKkk/image.png" alt="image" border="0"></a>

Работа процессора начинается с включения питания. 

После этого может осуществляться автоматический контроль (но он опциональный, это не рассматриваем)

1. Самое первое, что надо выполнить после включения питания, -- сброс (CLR или синхронный сброс). Например, в ПЛИС после загрузки информации проходит сигнал GSR -- global set reset. При этом может очищаться память (хотя раз там нет нужной информации, в этом нет необходимости).

2. Затем надо задать начальный адрес программы $A_{нач}$. Как правило, это выполняется автоматически: задаётся нулевой адрес, из которого можем куда-то переходить. При этом сброс и загрузка начального сброса могут происходит одновременно. 

3. После этого надо задать команду start, чтобы запустить систему. Начальный адрес поступает в SK -- счётчик команд. **Счётчик команд** -- предназначен для хранения текущего адреса программы (продвинутого адреса -- не текущего, а продвинутого на следующую команду). 
4. По определению программа и исходные данные хранятся в ОП, которые могут туда поступить с флешки, диска или с ПЗУ. В оперативную память происходит обращение по начальному адресу из счётчика команд. Вообще говоря, между ОП и процессором может быть кэш нескольких уровней, но в кэш дублируется часть ячеек из ОП.
5. Задаём управляющие сигналы для обращения к памяти Уск от БМК, под действием которых 
6.  Мы считываем из памяти код команды. Он поступает в регистр команды RK. При этом код команды может считываться не за одно обращение. А иногда мы наоборот, за одно обращение может считать и принять в регистр команд несколько команд, если команды короткие, а регистр многоразрядный. Код команды содержит код операции и адреса

<div align="center"><a href="https://imgbb.com/"><img src="https://i.ibb.co/myv1Xq9/image.png" alt="image" border="0"></a></div>

Команда делится на две части -- операционная и адресная. Как правило, эти поля одной и той же размерности (например, А1 имеет больше разрядов, чем Ак). В нашем процессоре двухадресные команды с разным механизмом адресации первого и второго адреса.

При этом в адресном поле могут задаваться указатели адреса или признаки адреса. Например, пусть по два разряда входят в каждый адрес, и они определяют вид адресации.

<div align="center"><a href="https://imgbb.com/"><img src="https://i.ibb.co/VMZbbSV/image.png" alt="image" border="0"></div>

При прямой адресации на адрес отводится как двоичный логарифм $M = \log_2(n)$, где $n$ -- количество байт.

7. Когда мы считали команду, следующее действие -- дешифрация кода операции. Надо определить, какая это команда -- линейная или нелинейная (она же  -- команда перехода). На размерность команды также указывает код операции: при дешифрации мы определяем не только вид команды, то ещё и размерность команды -- количество разрядов и адресов: одноадресная, двухадресная команда, какой тип адресации и так далее. Кроме того, на размерность команды может указывать и признак адреса: если мы указываем обращение к регистровой памяти, а не к оперативной, то адреса будут намного короче. На основании дешифрации определяется размерность команды, назначение полей и какую команду выполняем.

Сначала рассмотрим пример выполнения линейной команды. Для этого следующим действием будет подготовить операнды.

### Линейная команда

8. Извлечь операнды. При этом операндов не один, а несколько и адрес операндов может меняться в зависимости от механизма адресации. Поэтому сначала надо сформировать исполнительные адреса операндов в БУКе, которые поступают уже как в ОП, так и в РОНы: операнды могут находиться и в регистрах. При этом также формируются управляющие сигналы для памяти, а на выходе из неё эти операнды принимаются в буферные регистры Р1 и Р2 (или BP1, BP2, учитывая, что P1 и P2 будут зарезервированы за состояниями датчика состояний, которые находятся внутри МУУ). Эти регистры установлены между ОП и блоком операции. Мы извлекаем эти операнды последовательно так, чтобы оба они были готовы перед началом операции, потому что их мы загружаем в БО одновременно. В общем случае этих буферных регистров может быть гораздо больше там, где работает конвейер (например, в эльбрусе до 14 ступеней -- готовились операнды для выполнения 14 команд). 
9. Данными буферными регистрами управляет БМК с помощью управляющих сигналов УСk
10. Под действием управляющих сигналов выполняется загрузка операндов из памяти в Р1 и Р2.
11. После того, как мы подготовили операнды, надо начать выполнять операцию в АЛУ. Для этого АЛУ нужно сообщить, какую операцию нужно выполнить. Для этого мы сообщаем туда код операции COP': мы передаём не весь код операции, а какую-то его часть. Для наших процессоров, раз выполняется две команды, достаточно только одного бита. А есть ещё и команды перехода, у которых больше разрядов, поэтому в МУУ передаётся только часть разрядов. Поэтому кодирование команд желательно выполнить так, чтобы можно было в МУУ передавать только часть кода операции.
12. Запустить АЛУ, сообщив в его то, что всё подготовлено для опреации. Для этого подаётся SNO -- сигнал начала операции. При этом приостанавливается выполнение команды в ЦУУ и начинает работать АЛУ. (В конвейере ЦУУ после этого может готовить данные для следующей команды). 
13. В соответствии с разработанными алгоритмами выполнения операций COP', МУУ формирует управляющие сигналы Yi. Выполнение команд в БО начинается с того, что мы операнды A и B одновременно загружаем в регистры RA и RB внутри БО под действием Yi с МУУ. 
14. В алгоритме надо учитывать, что на его выполнение влияют сигналы-признаки, в соответствии с которыми могут быть ветвления или переходы $\varphi_i$ -- статусные или осведомительные сигналы. Эти сигналы посылаются в МУУ, на основании которых тот формирует те или иные сигналы $Y_i$ до тех пор, пока не закончится выполнение операции.
15. Когда операция выполнена, в ЦУУ надо сообщить об этом и формируется сигнал конца операции SKO. В регистре результата RR сформирован результат операции. По сигналу SKO завершается работа АЛУ для данной команды и запускается опять ЦУУ, которое продолжает работать над выполнением данной команды. Если ЦУУ чем-то занято, то эта команда может встать в очередь.
16. ЦУУ должно проверить, нужно ли записывать результат. Если результат записывается, то формируется исполнительный адрес результата по той же самой шине 
17. Результат записывается в ОП.
18. Некоторые из команд формируют признаки результата. Их нужно передать из регистра признака RPR в ЦУУ, который будем поступать как правило, в БМК, потому что в зависимости от признака может меняться алгоритм самой программы. При этом некоторая часть может поступать и в БУК, который может сформировать свои признаки фи перехода. Пунктиром показано, что можно решать, что регистр признака может отсутствовать в БО и/или присутствовать свой регистр признака в БУК, и на каждом шаге мы подаём признак результата в RPR в БУКе. Этот же регистр мог быть не регистром признака, а регистром флага -- где на каждый признак свой флаг, а в случае признаков, а не флагов, -- эти признаки кодируются двоичным кодом, который дальше надо дешифрировать.
19. Подготовить адрес следующей команды в счётчике команд. Для этого СК увеличивается на 1, а если команда содержит не одного слово, мы должны добавить дельту, где $\Delta$ -- это размерность команды. Она должна добавляться не обязательно в итоге, она может учитываться уже в адресации операндов, поэтому обычно адрес команды меняется по шагам. $$СК:=СК + 1(\Delta)$$В счётчике команд формируется адрес следующей команды.
Перед выполнением любой команды в счётчике команд уже находится её адрес.

У системы памяти на считывание один адресный вход, а выходных две шины --  для команды и для операндов. Иногда это может быть корректно, потому что кэш может быть L1 инструкций, и L2 данных. Но эти шины могут быть едины, и с ними же может быть соединена шина адреса, потому что всё равно данные передаются в разное время. Но сейчас это всё разделяют для ускорения.

<div align="center"><a href="https://ibb.co/3MDT34W"><img src="https://i.ibb.co/WPbHhGF/image.png" alt="image" border="0"></a></div>

### Цикл выполнения линейной команды
1. **Выборка команды из ОП** и запись в регистр команд РК **(Instruction Fetch -- IF)**
	Увеличение счётчика команд $СК:=СК+1(\Delta)$
2. **Декодирование КОП** команды и способов адресации, формирование **$A_{исп}$ операндов** **(Instruction Decoding -- ID)**
3. **Выборка (считывание) операндов** из ОП или РОН и запись в буферные регистры процессора **(Operand Reading -- OR)**
4. **Выполнение операции** в АЛУ **(Executing -- EX)**
5. **Запись результата** в ОП или РП **(Write Back -- WB)**.

В одноадресных командах результат может оставаться в регистре-аккумуляторе RR. Он может быть в составе РОН.

Увеличение счётчика команд нельзя выполнять в конце, так как адрес следующей команды может учитываться в способах адресации: там может учитываться уже продвинутый адрес, настроенный на следующую команду.

При этом считывать можно побайтно, по 2 байта или по 4, поэтому в способах адресации учитывается уже именно продвинутый адрес.

Среди этих этапов могут быть только 4, потому что в одноадресных командах участвует только один адрес, и результат такой операции записывается в аккумулятор и последнего этапа -- записи в какое-то отдельное место нет.

### Цикл выполнения нелинейной команды (перехода, цикла, возврата, пропуска)

$$\begin{array}{|c|c|c|}\hline СОР& УА&А_{пер}\\\hline\end{array}$$

УА -- указатель адреса, который может задавать способ адресации. Вместо указателя может быть признак адреса.

1. **Выборка кода команды из ОП** и запись в регистр команд РК **(Instruction Fetch -- IF)**. Увеличение счётчика команд $СК := СК + 1 (\Delta)$.
2. **Декодирование КОП** команды и формирование $A_{исп.пер}$ -- исполнительного адреса перехода:
	- **безусловный** переход $СК := A_{пер. исп}$
	- **условный** переход -- проверка условия
		- условие совпадает (признак $\text{PR}_i$ = 1)- $СК := A_{пер. исп}$
		- условие не совпадает $\text{PR}_i=0$ ⇒  $СК := СК + 1(\Delta)$

Пока мы считываем команду, счётчик команд растёт. Поэтому всегда там, где нужно, участвует именно *продвинутый* счётчик команд, настроенный на следующую команду, для того, чтобы не надо было возвращаться на исходный адрес.

При безусловном переходе происходит переход на *исполнительный* адрес перехода -- он зависит от конкретного механизма адресации.

При условном переходе возможны два варианта в зависимости от значения признака операции. Если он равен единице, то в счётчик команд загружается исполнительный адрес перехода -- не тот, который может стоять в коде команды, а уже вычисленный в соответствии с конкретным механизмом адресации с учётом указателя адреса. Иначе -- если он равен 0, то в счётчик команд загружается $\Delta$ -- размерность команды: для общего случая она считается в байтах, в наших случаях -- 4 разряда или полубайты. При этом команды должны быть плотно расположены без пропуска. Эта $\Delta$ добавляется не сразу, а последовательно и постепенно: где-то на 1, где-то на 2: зависит от того, как команды программы "упакованы" в оперативную память. Поскольку команды находятся плотно друг за другом, то приходится добавлять эту разную величину. После добавления дельты, равной размерности команды, получается *продвинутый адрес*.

Память у нас 8-разрядная, поэтому 12-разрядную команду можно записывать в одну ячейку 8 бит, и половину команды в другую ячейку. Потом во второй половине второй ячейки начинается вторая команда: никаких пропусков быть не должно. Поэтому 12-разрядная команда будет занимать полторы ячейки памяти.

Если условие не совпадает, мы, как правило, идём на следующую команду, которая отличается на дельту -- размерность команды. Например, команда имела 100 адрес и занимает три полуслова, значит, мы должны уйти на 103 адрес.

Адреса формируются не в блоке операции. Для этого существуют свои сумматоры и счётчики, которые находятся в БУКе. Аналогично и счётчик команд, который тоже находится в БУКе, тоже может суммировать какое-то смещение, поэтому и у него тоже есть свой сумматор.

Команда пропуска (как правило, с условием) отличается от других команд перехода тем, что в ней нет адресного поля. Она безадресная, и в КОП уже записано, сколько байтов надо пропустить. Таким образом исключается адресное поле. Команда пропуска заключается в том, что мы "перепрыгиваем" через следующую команду -- осуществляется пропуск одной команды заданной размерности.


В команде перехода мы не передали управление в АЛУ. Если в линейной команде после выборки операндов управление передаётся в АЛУ, то все команды перехода выполняются целиком в ЦУУ.

На схемах пересылка данных изображается двойными линиями, управляющих сигналов -- одинарными.

У системы памяти может быть и своё местное устройство управления. Это вообще относится к каждому устройству в процессоре.

В этой схеме условно отмечены, что в каждом блоке могут быть очереди: в процессоре выполняется совмещение команд -- конвейер. Поэтому в регистре команд условно на входе присутствуют очередь. Такая же очередь есть и на выходе этого регистра, такие очереди есть на буферных регистрах операндов. Очереди есть и на выходе регистра результата, чтобы мы не сразу считывали.

Входные данные могут загружаться через флешку или другое внешнее устройство с помощью контроллера ввода вывода в ОП

Здесь показана отдельно шина информации и шиана адреса. ЗДесь шина данных одна, с которой поступает информация как в БУК, так и в буферные регистры операндов. По этой же самой шине результат записывается в ОП.

Чтобы ускорить, шин таких могут быть две: одна на выдачу информации, а другая -- на приём, то есть память может быть двухпортовая с точки зрения памяти и считывания.

Кроме того, могут быть шины из кеша первого уровня L1. Кэш верхнего уровня делится на два блока -- блок инструкций и блок данных, поэтому могут быть отдельные шины, связывающие команды и данные. 

Мы будем разрабатывать два устройства: МУУ схемного типа (БО), а БМК будет выполнено с помощью микропрограмм. На данной схеме БМК раскрыто как устройство схемного типа с жёсткой логикой.

### БУК 

Блок управления командами. В его состав могут входить

#### Счётчик команд

 Счетчик команд (иногда называют регистром инструкций: можно перед регистром поставить сумматор и получить счётчик -- это бывает удобно чтобы прибавлять смещение в относительной адресации). Относительная адресация -- текущее содержимое счётчика команд + смещение, которое написано в самой команде. Поскольку у нас у всех будет смещение в командах перехода, предлагается использовать не *A* (это адрес в ОП) или *R* (это регистр), а, например, *SM* (смещение) или что-то другое.
 
#### Регистр команд

Предназначен для хранения текущей выполняемой программы. На его входе может быть очередь из последующих команд. В команде находится КОП, который указывает на то, какую операцию нужно выполнять, и несколько адресов -- сколько-адресная команда, столько и адресов A~i~ будет. Кроме того, там же могуп быть и признаки, указывающие на то, какая это адресация. В адресах могут быть номера регистров, смещения и так далее.

При проектировании надо будет выбрать свой механизм адресации из книжке на сайте.

Начальный адрес должен загружаться в счётчик команд (это один из первых шагов при запуске процессора). Если мы будем начинать программу с нулевого адреса, можно одновременно с CLR обнулять счётчик команд, и тогда это не понадобится. А в общем случае перед счётчиком команд стоит мультиплексор, который бирает либо начальный адрес, либо следующий адрес команды.

Если адресация *команд* относительная, то нужен сумматор, на который поступают счётчик команд и смещение --  получаем исполнительны адрес, например, следующей команды, который будет передаваться не в память, а через мультиплексор опять в счётчик команд. 

У относительной адресации есть плюс: мы не привязаны к конкретным адресам в памяти: это полезно при многопрограммном режиме (для выполнения нескольких программ просто загружает начальный адрес A~нач~ в счётчик команд). Ещё один плюс -- укорачивание разрядного поля, потому что смещение может быть неполным (коротким, не все разряды) и иметь знак: мы можем идти как вперёд, так и назад.

#### Сумматор

Здесь условно показано: сумматор может суммировать и не два, а три операнда -- это ведь структурная схема. Этот сумматор может быть реализован внутри на двух сумматорах: например, один сумматор, а за ним второй и будет стоять КСЮЮ которая блокирует какие-то операнды.

#### Регистр очереди

Это регистр адресов, которые могут быть как адресами перехода, загружаемые в счётчик команд, так и адресами операндов.

Из регистра индекса (это могут быть самостоятельными регистрами), но в наших процессорах может быть и регистр базы для базового адреса, и они могут быть и в блоке регистров вместе с РОН. Из них в нужный момент можно извлечь информацию для индексной адресации. (считается, что если нужен индекс, то известно, из какого регистра надо брать значение -- это показано шиной между блоком регистров и регистром индекса R~i~). Регистр индекса и смещения могут находиться и внутри в адресе команды.

Исполнительный адрес A~исп~-- база + индекс + смещение (показано). Они полезны для обработки массивов и статистики.

#### Регистр исполнительного адреса

При косвенной адресации (берём адрес из команды -- мы обращаемся по нему в ОП и уже этот адрес, который мы вытащили из ОП, и будет исполнительным), нужен будет дополнительный регистр исполнительного адреса.  В других случаях он может отсутствовать.


Может быть и многоступенчатая косвенная адресация -- это может быть отмечено в признаке адреса, и тогда таких итераций извлечения адресов и хождений по памяти может быть много. Это возможно при выполнении поиска в каких-то системах.

Для общего случая может и блок операций быть не один, а несколько: например, отдельный БО для фиксированной и плавающей запятой, аналогично с РОНами: могут быть РОНы только связанные с адресами, РОНы для плавающих чисел и так далее. Также могут быть отдельные регистры для базы и индекса -- это всё используется для ускорения выполнения команд и параллелизации.

Например, один БО выполняет умножение, а поскольку эти операции длинные, то можно параллельно запускать другой БО. Даже в ПЛИС, учитывая, что умножение используется часто, предусмотрена автоматическая настройка 19 блоков умножения в spartan 6.

### БМК

Назначение БМК -- формировать управляющие сигналы, которые могут управлять, в первую очередь, БУКом и плюс другими блоками в процессоре: сигналы могут идти в память, на блоки ввода-вывода и идти в АЛУ. БМК может быть только один -- это централизованное устройство управления, а может быть децентрализованное: много местных устройств управления в каждом блоке, а БМК только посылает на них сигналы начала работы и принимает сигналы конца.

В данном случае мы рассматриваем БМК жёсткой логики

Код операции поступает из регистра команд и дешифрируется -- на выходе имеем унитарный код.

Комбинационная схема формирует игреки: на каждом элементе внутри от того, какую нужно выполнять операцию, от того, в каком состоянии находится РИЦ (распределитель импульсов цикла в унитарном коде: на каком такте на каком шаге цикла мы находимся) и от фи для ветвлений подаются управляющие сигналы Y. В ней как минимум столько элементов, сколько игреков может быть. Таким образом, $$Y = f(РИЦ, ДШКОП, \varphi)$$Такие жёсткие схемы быстрые, потому что у них внутри задержка только одного элемента. Но они более сложные, потому что при внесении изменении нужно перепроектировать чуть ли не всю схему. А микропрограммные схемы зато проще.

#### Генератор импульсов (Главный генератор импульсов)

Может быть всего один ГГИ -- он будет находиться в БМК, и по нему можно формировать уже отдельные импульсы (С1 С2 как а лабе про регистры). Из этого главного генератора могут вырабатываться сколько других фаз импульсов. От него можно делить частоту.

В ПЛИС можно настраивать сдвиг этих импульсов от ГГИ с точностью до десятков пикосекунд. Важно, чтобы они потом не встретились на одном синхровходе. Они могут даже накладываться, если импульсы приходят на разные синхровходы разных блоков.

#### Схема пуска-останова (СПО)

Она обязательно присутствует в каждом местном устройстве. Она разрешает проходить синхроимпульсам между сигналами СНО и СКО, вырезая пачку импульсов из бесконечной последовательности от генератора между СНО  и СКО. А может и не вырезать эту пачку импульсов, а просто запрещать работать. В любому случае, там внутри стоит триггер, который переключается по СНО и СКО. Например, этот триггер потом будет разрешать или запрещать формирование игреков внутри КС. А можно вырезать пачку импульсов (как СЕ). Тогда КС может оказаться проще, чтобы не ставить у каждого элемента, отвечающего за Y, соединение с этим триггером: можно просто запретить синхроимпульсам проходить внутрь блока.


#### Блок очереди

В нём хранится очередь кодов операций. Мы могли из команды отправить адреса на формирование -- но мы их ещё не извлекли, операнды не сформировали, и пока это происходит, надо ждать и хранить код операции в очереди до тех пор, пока операнды не придут.

Внутри отдельно могут сотять счётчики циклов и счётчики тактов, еасли микрокоманда выполняется несколько тактов. Счётчик циклов отвечает за подсчёт i в циклах. Такие счётчики могут находиться в каждом местном устройстве управления.

### Память

Она показана как часть системы памяти -- это может быть ОП, до 4 уровней кэша.

ОП по определению в состав процессора не входит, но на кристалле самого процессора есть L1 кэш инструкций и L1 кэш данных, а L2 опционально. 

ОП -- как правило, динамическая память, в которой хранение информации происходит на конденсаторах.

Ещё один вариант построения БМК -- микропрограммный: она содержит управляющую память.

В памяти показаны условно регистр информации или регистр данных (хотя отсюда можно считывать и команды) и регистр адреса. В наших процессорах их не будет: адрес мы поддерживаем, и память при считывании будет работать как КС: память строится на лутах, на входах которых мы задаём адреса. С выходов памяти мы загружаем информацию в буферные регистры.

Также контроллер ввода-вывода может соединяться шиной прямого доступа с памятью.

По определению вся программа и все данные находятся в ОП, поэтому прежде чем процессор начнёт работать, данные надо загрузить в кэш данных, а команды в кэш команд. 

При этом в кэшах информация может быть согласована (когерентная), потому что она дублируется, а в какие-то моменты времени в зависимости от методов записи она может и не совпадать.

У нас будут двухпортовые памяти: одна на запись, другая на считывание. А тут показано, что считыванием и пишем через одну и ту же шину.

Подобную схему можно посмотреть на 4-6 странице в учебном пособии по проектированию процессора.

## Принципы организации управления

1. Уровень управления
	- Программный -- алгоритмы представлены наборами команд
	- Микропрограммные -- алгоритмы представлены микропрограммами выполнения команд

2. Централизованный или децентрализованный принцип
3. По типу (принципу) построения
	- с жёсткой логикой ("схемного типа" СхУУ) -- основой является РИЦ и КС
	- микропрограммное УУ (МкУУ) -- основой является управляющая память

4. Способ организации
- синхронный
- асинхронный (полусинхронный)

**Микрооперация** -- элементарная функциональная микрооперация

**Микрокоманда** -- совокупность совместимых микроопераций, выполняемых одновременно (например, RA := A, RB := B, RR := 0)

**Микропрограмма** -- последовательность микрокоманд, обеспечивающих выполнение машинной команды

**Централизованное УУ** общее для всех блоков

**Децентрализованное УУ** -- когда ЦУУ и МУУ:
- ЦУУ  формирует подготовительные сигналы: запуск
- МУУ формирует исполнительные сигналы
	- сокращает количество шин, расположено ближе к блоку
	- проще проектирование и реализация: меньше сигналов ⇒ меньше вероятность ошибиться
	- легче реализовать совмещение команд: можно запускать несколько блоков сразу
	- может иметь место сокращение аппаратных средств. Иногда какие-то блоки, например, триггеры пуска-остановка, РИЦ ставить в каждом блоке, поэтому сокращение не гарантировано.

**Синхронный способ** -- предполагает выбор фиксированного **постоянного такта T = const** выполнения микрокоманд, равного *максимальному* времени выполнения МК

**Асинхронный способ** -- длительность такта имеет **переменную величину такта Ti = vary**, необходимую для каждой МК

**Полусинхронный способ** -- каждая К-я МК выполняется за **необходимое количество тактов** генератора Ti = Ki * t, где t -- период генератора


**Разрабатываемый процессор**:
- на уровне микрокоманд -- синхронный
- на уровне микропрограмм -- полусинхронный (асинхронный): умножение выполняется, например, за 10 тактов, а сложение -- за 4. 

# Характеристики процессора и способы адресации

### Основные характеристики процессора

**1. Внутренний язык** -- система команд, форматы команд и данных. 

**2. Способы адресации**

**3. Конвейеризация команд** (количество команд и ступеней (этапов) в конвейере). Конвейеризация позволяет параллельное выполнение нескольких команд. Конвейеризация позволяет разбивать команду на несколько этапов (одновременно работают все блоки), а параллелизация -- разбивает на несколько блоков (параллельно работают одинаковые блоки). Для этого используется буферная память FIFO.

**4. ОЗУ** (ёмкость, организация, статическая, динамическая). При этом *физический* адрес -- это адрес при обращении к памяти (то есть к ячейкам), а *логический* -- адрес до байта. При этом если мы считываем два байта, адрес должен быть обязательно чётным: если мы хотим считать 0 и 1 байты, логическим адресом будет 0. Если мы хотим считать 4 слова, то чётность адреса должна быть двойная (в конце адреса должны быть сразу два нуля). Это делается, потому что обмен между памятью и процессором идёт блоками. Если мы будем указывать рандомные адреса, то тогда у нас может получиться так, что считываемые нами данные окажутся в разных блоках.

**5. Наличие и организация СОЗУ (Сверхоперативного ЗУ)**:
- **РОН** (количество и разрядность; для фиксированной и плавающей запятых): будут ли РОНы единые или отдельные для ПЗ и ФЗ. Если они единые, то тогда при работе с ПЗ будут заниматься два регистра сразу. В современных процессорах 32 или 64 регистра, при этом 4 или 8 регистров могут быть выделены для отдельной работы с плавающей запятой.
- **Служебные регистры** (базы, индекса, сегмента, страниц, ...) -- присутствуют ли отдельно эти регистры или же они находятся в РОНах. В наших вариантах процессора они располагаются в РОНах. Кроме того, на входах этих регистров могут стоять буферы.
- **Стек** для выполнения арифметических операций: в стек мы можем записывать результат предыдущих операций и брать операнды оттуда же. При этом команды работы со стеком могут быть безадресными и содержать только коды операции. Также стек используется для организации циклов.
- **Кэш** (иерархия: до 4 уровней L1-L4, ёмкость и организация, методы записи и замещения, где находятся кэши разных уровней -- на кристалле или на плате).

**5. Быстродействие и производительность**. Быстродействие (частота генератора: например, 4 ГГц), а производительность -- количество операций в секунду.

Чтобы оценить быстродействие АЛУ, надо будет подключить макет на отдельной странице: важно, что мы подключаем выходы всех элементов (например, регистры результата или регистры признака) к выходным индикаторам, то размещение может получиться неудачным, так как эти связи могут быть просто удалены. Кроме того, при размещении надо будет привести количество ЛУТов и триггеров в отчёте или как отдельной главой, или в МУУ (АЛУ), где будет приводиться оценка временных параметров.

### Формат команды

Набор операций должен быть функционально полным, чтобы можно было выполнить любые программы. При этом можно определять, какие команды выполняются арифметически, а какие -- с помощью микропрограмм: можно "подкачивать" те или иные микрокоманды. Например, команду деления можно не включать в набор команд процессора, а выполнять отдельно как подпрограмму, записанную в отдельное запоминающее устройство. Таким образом, можно определить, какие команды выполняются аппаратно, а какие -- программно.

Набор команд может быть различным. Существуют две тенденции развития процессоров -- RISC и CISC:
- **RISC -- Reduced Instruction Set Computer** --  уменьшенный набор команд
- **CISC -- Complete Instruction Set Computer** -- полный набор команд процессора

При этом в универсальных процессорах CISC могло содержаться до 600 команд (IBM/370) ради преемственности поколений: если программы работали на одном процессоре, то было бы хорошо, чтобы они продолжали работать и на более новых версиях процессоров. Однако из этих команд большинство никто никогда не применял.


### Набор команд или операций делится на группы

Чтобы можно было декодировать не все разряды, а только какую-то часть (группу), где старшие разряды определяют, к какой группе команд относится команда, а младшие -- какая это конкретно команда:
- арифметические (фиксированная и плавающая запятая, дробные и целые)
- десятичная арифметика
- логические, работа над битами и строками, сдвиги
- обмен, передача данных
- управление и переходы безусловные и условные, пропуски, циклы

**Эффективность набора команд характеризуется**:
- аппаратными затратами на размещение программ и данных
- затратами времени на реализацию алгоритмов (тесты для сравнения). Например,
- удобством для пользователей (хорошее понимание, усвоение)


При этом нужно определять, все ли операции выполнять аппаратно, то есть включать в код операции, или реализовывать их как подпрограммы.

### Размещение в памяти

Надо определить, где будут располагаться программа, операнды, константы и рабочие ячейки. Важно, что между этими блоками, кроме программы, могут быть свободные места, но в программах пропусках быть не должно.

<a href="https://ibb.co/F4Mpxk5"><img src="https://i.ibb.co/nMvpgq7/image.png" alt="image" border="0"></a>

Программы упаковываются плотно, на уровне слов (байтов) между командами пропусков нет.

При этом в первом считываемом байте должен находиться код операции, потому что он определяет размерность команды. За одно обращение (одна строка здесь -- это ячейка памяти) мы считываем два слова -- одну ячейку. А логический адрес -- это тот, который будет в счётчике команд, поэтому у первой команды будет адрес 0, а у второй -- 3.

В отличие от пособия, предлагается чётные адреса располагать в левой части: например, в 8-разрядной памяти слева будет 7 разряд, а справа -- нулевой, учитывая, что память, которую мы будем заполнять (logic block), считывается так, что старший разряд находится слева. Поэтому чётные -- это 7-4 разряды, а нечётные -- это 3-0 разряды.

В отличие от команд, данные могут располагаться с пропусками.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/HYfWyx0/image.png" alt="image" border="0"></a>

При этом в наших примерах операнд будет занимать 1 слово, а результат -- 8, причём пишутся они в одну ячейку. Поэтому операнды обязательно находятся в одной ячейке.

При этом при работе транслятора мы должны были описать С как двухсловную ячейку, и он должен был отвести сразу два слова под них.

В БУКе самое главное -- не запутаться с разрядами, размечая память операндами и командами, -- где старший разряд, а гле младший.

При этом если старшие разряды не равны нулю, в программе нужно вводить какое-то масштабирование, потому что восьмиразрядное число мы уже не можем складывать и умножать.

### Адресность

**Адресность** -- количество адресов в команде (0А -- безадресная, 1А, 2А и 3А)

**Адрес** характеризуется разрядностью и количество разрядов


Например, нам нужно вычислить функцию Y = A*B + (C-D) * E/F

Например, для трёхадресных команд мы выполняем 5 команд. Р1, Р2 -- это рабочие ячейки: там нельзя написать А или В, потому они будут испорчены, а они могут понадобиться в других операциях. Для этого мы вводим дополнительные рабочие ячейки, в которых будем хранить промежуточные результаты вычислений.

В двухадресной команде результат записывается по адресу одного из операндов. Поэтому мы на первом шаге производим считывание в рабочую ячейку А, а результат записывается по адресу первого операнда, хотя в наших заданиях это может быть и не так. Команд уже стало 8.

В одноадресной команде используется регистр-аккумулятор Ra.

<a href="https://ibb.co/fQVs0WJ"><img src="https://i.ibb.co/PtsdCyk/image.png" alt="image" border="0"></a>

### Способы и механизмы адресации

**Способ адресации** устанавливает процедуру (порядок) вычисления адреса оперативной памяти, по которому проводится фактическое обращение -- называется исполнительным адресом А~исп~ (А~физ~)

Эффективность способов адресации характеризуется
- затратами оборудования на обеспечение доступа к памяти (схема формирования А~исп~)
- затратами времени на формирование А~исп~ и времени доступа к ячейке памяти по этому адресу (считывание или запись)

### Прямая адресация

В своих отчётах также надо будте рисовать свою адресацию. Вместо "Адрес" пишем А1 (адрес первого операнда), R, если номер регистра, или SM, если смещение.

В отчётах на каждой шине (стрелке) должна будет стоять разрядность.

Никаких аппаратных затрат на формирование адреса нет, а время цикла равно времени обращения к оперативной памяти.

Вместо "Память" надо будет писать ОП.

<a href="https://ibb.co/L8bsMLS"><img src="https://i.ibb.co/dr1HSdB/image.png" alt="image" border="0"></a>

Может быть и короткая прямая адресация: чтобы сократить адресное поле, адресация может дополняться старшими разрядами, на что может указывать старший разряд адреса (0 или 1  будет указывать, чем конкретно дополняется адрес). Если мы дополнили адрес единицей, то это все адреса будут расположены во второй половине памяти. Поэтому операнды мы можем располагать, например, во второй половине памяти и тем самым выиграть один разряд адреса операндов, не указывая их старший разряд (1).

### Регистровая адресация

<a href="https://imgbb.com/"><img src="https://i.ibb.co/PrVWfsN/image.png" alt="image" border="0"></a>

R -- номер регистра. Если он относится ко второму операнду, то мы пишем R2.

Время обращения будет маленьким, потому что регистровая память будет быстрее. Хотя в наших процессорах что регистры, что ОП находятся на одном и том же кристалле, поэтому мы этого не увидим

<a href="https://ibb.co/HPR3m23"><img src="https://i.ibb.co/mydgQBg/image.png" alt="image" border="0"></a>

Ёмкость ОП намного больше ёмкость РП, поэтому количество разрядов для адресации в ОП значительно больше, чем в РП.

### Непосредственная адресация

Операнд извлекаем не из ОП, а из команды.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/Wpz3vsz/image.png" alt="image" border="0"></a>

В качестве второго операнда может быть константа (и тогда это поле можно будет уменьшать).

### Неявная адресация

В команде нет соответствующего адреса. Он может подразумеваться, например, кодом операции. Например, таким адресом может быть регистр аккумулятора.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/0GT12xM/image.png" alt="image" border="0"></a>

### Косвенная прямая адресация

<a href="https://ibb.co/GsGq17f"><img src="https://i.ibb.co/ZHv0wdR/image.png" alt="image" border="0"></a>

Адрес указывает не на операнд, а на другой адрес. В данном случае будет 2 цикла обращения к ОП. При этом нужен будет внутри дополнительно регистр исполнительного адреса: адрес, который извлекли в первый раз, запомнили в этом регистре, а потом использовали этот адрес при втором обращении к памяти.

Любой адрес в команде, по которому мы обращаемся напрямую (Ai), должен быть полным.

### Многоступенчатая косвенная адресация

Ещё один разряд в окманде может отводиться под признак адресации. Он указывает, косвенный это адрес или адрес операнда.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/hsydKkB/image.png" alt="image" border="0"></a>

Это может применяться в БД. При этом адрес на 1 бит будет больше.

При этом ПА удобнее привязывать к младшим разрядом, а в старших, например, писать 00 (и получится что-то вроде 00PA). При этом надо показать, что PA более короткий.

Обращения к памяти будут идти, пока не встретится ПА=0.


### Косвенная регистровая адресация

<a href="https://imgbb.com/"><img src="https://i.ibb.co/dDtMswt/image.png" alt="image" border="0"></a>

При этом можно не ставить регистр исполнительного адреса. При этом, поскольку регистр 4 разрядный, а адрес 5-разрядный, то надо будет нарисовать дополнительно, что мы дополняем этот адрес единичкой или нулём в старшем или младшем разряде (учитывая, что нам надо будет обращаться за двумя операндами, поэтому адрес точно должен быть чётным), как в короткой адресации.

### Автоинкрементная адресация

<a href="https://imgbb.com/"><img src="https://i.ibb.co/Jkhm5md/image.png" alt="image" border="0"></a>

В адреса стоит номер регистра, по которому мы обращаемся как по косвенной адресации. При этом адрес в регистре увеличивается на размер операнда (можно добавлять 1 и дополнять этот адрес справа нулём; это добавление будет эквивалентно добавлению 2, потому что у нас адреса двухсловные)

Такая адресация удобна при итерации по массиву.

Аналогично, этот адрес можно дополнять, если он короткий.

При этом само увеличение может происходить после записи результата, потому что результат надо записать вместо операнда, и только потом мы начинаем указывать на следующий элемент массива.

### Автодекрементная

Здесь мы будем вычитать размер операнда.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/sVR3PV1/image.png" alt="image" border="0"></a>

Здесь предложено сначала вычитать, а потом обращаться к памяти: изначальный адрес указывает на конец массива. В таком случае требуется больше времени.

Чтобы сделать вариантность такой адресации, то можно варьировать время инкремента или декремента относительно обращения к памяти. Подробнее смотреть на сайте.

В автодекрементной и автоинкрементной операции нужен будет дополнительный сумматор.

Иногда забывают об этой записи в регистр, которая меняет содержимое регистра. 

При этом надо не забыть выполнить цикл записи: извлекли - суммировали - записали. При этом чтение/запись из ОП и запись в РП можно выполнять параллельно. Поэтому, например, в декрементной адресации запись нового значения в регистр и считывание из памяти могут происходить одновременно.

<a href="https://ibb.co/NsLtjjj"><img src="https://i.ibb.co/rmZF666/image.png" alt="image" border="0"></a>

<a href="https://ibb.co/Sv2FBB9"><img src="https://i.ibb.co/JkNDHHM/image.png" alt="image" border="0"></a>


## Адресации со смещением

### Относительная

<a href="https://ibb.co/Zd3zd2W"><img src="https://i.ibb.co/H70T7hn/image.png" alt="image" border="0"></a>

Смещение относительно счётчика команд имеет меньшую разрядность. 

Также дополнительно требуется сумматор для формирования А~исп~.

При этом в своих вариантах надо обязательно показать, чем мы будем дополнять малоразрядное смещение:

<a href="https://imgbb.com/"><img src="https://i.ibb.co/hfB3PLN/image.png" alt="image" border="0"></a>

Так что рисовать надо не 1 к 1 как в пособии, а включать голову и смотреть, как конкретно у нас.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/P1rjS48/image.png" alt="image" border="0"></a>

Кроме того, адресация может быть и со знаком.


### Индексная

<a href="https://imgbb.com/"><img src="https://i.ibb.co/M7nTWqR/image.png" alt="image" border="0"></a>

Регистр указывает на смещение (индекс). Базовый адрес находится в формате команды. При этом смещение, как уже говорилось, может быть коротким, длинным и дополняться нулями, единицами или иметь знак.

### Базовая

В данном случае, наоборот, смещение находится в формате команды, а база -- в регистре.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/BVxSL3G/image.png" alt="image" border="0"></a>

При этом смещение можно опционально дополнять знаком. При этом никакой дополнительной схемы там для этого нет, этот знак или дополнение входит в сумматор.

Эффективность базовой и индексной адресации можно сравнить по разрядности команд: база имеет разрядность больше, чем смещение, поэтому базовая адресация более эффективна с точки зрения размера, чем индексная.

### Страничная адресация

Номер страницы задают старшие разряды адреса, а в команде -- только смещение, которое просто присоединяется к старшим разрядам. Смещение может быть в отдельном регистре страницы (задаётся в служебном режиме). Таким образом, память делится на страницы (не путать с виртуальной памятью) фиксированной ёмкости, и если у нас страницы по 4К, то смещение будет по 12 разрядов, а если вся память 4Гб, то каждая страница будет адресоваться по 20 разрядов.

### Сегментная

Использовалась раньше. Был номер сегменте в сегментном регистре, к которому прибавлялось смещение. Однако сегмент как бы занимал часть старших разрядов, поэтому шло перекрытие смещения и адреса сегмента.

На основании этих адресаций можно делать комбинации типа постиндексная косвенная, подробнее на сайте.

## Расширенные коды операций

Пусть у нас имеется трёхадресная команда, где в поле кода операции в первом, втором и третьем адресе содержатся по 4 разряда, и на код операции отводится тоже 4 разряда. В первом адресе (аааа) задаётся адрес первого операнда, второго (bbbb) и третьего (cccc). КОП меняется от 0000 до 1110.

В случае, когда под КОП будет выделяться 8 разрядов, предложено делать команды двухадресными.

Если отведём 12 разрядов, то будут одноадресные команды.

А если отвести на КОП 16 разрядов, то получится безадресная команда.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/VxPSX75/image.png" alt="image" border="0"></a>

При этом по первым битам КОП можно понять, сколько адресную команду мы имеем.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/NTf5MP7/image.png" alt="image" border="0"></a>

<a href="https://imgbb.com/"><img src="https://i.ibb.co/1JnrC3P/image.png" alt="image" border="0"></a>

Всего получаем 76 команд.

**К экзамену подумать, как тут сделать 100 команд и больше: как задать КОПы и что изменить в алгоритме**

### Критерии выбора системы и форматов команд

**1. Лучше иметь короткие команды, чем длинные** (занимают меньше места в памяти, считывание нескольких команд за один цикл обращения, увеличение пропускной способности памяти (число байт в секунду))

**2. Минимизация разрядности команд может усложнить их декодирование** (минимизация должна уравниваться со временем декодирования и выполнением команды). В хитрых способах адресации появляются дополнительные сумматоры, что усложняет аппаратуру.

**3. Достаточная разрядность для задания кода операции -- $k_{cop} = \log_2 N_{COP}$** (оставить свободное количество для введения новых операций, введение расширенных кодов операций)

**4. Количество разрядов в адресных полях должно быть достаточным для обращения к ОЗУ: $k_{адр} = \log_2 N_{ОЗУ}$** (например, 32 адресных разряда хватит для обращения к 4 Гб памяти)

**5. Совместимость поколений семейства** (обратная совместимость в новых разработках архитектуры необходимо сохранять набор форматов команд)

### Методы уменьшения разрядности адреса

**1. Применение способов адресации с малой адресацией**. Например, короткая адресация, где для получения полного адреса надо дополнить старшие разряды нулями или единицами: например, команды всегда находятся в старшей зоне памяти, а операнды --в младшей

**2. Если операнд используется несколько раз, то его можно разместить в РОН** (увеличивается скорость доступа к операнду: РОН быстрее ОЗУ, требуется меньше разрядов а адресном поле (R вместо A))

**3. Задание операндов в неявной адресации**
- **вместо трёхадресной команды можно применять двухадресную**. Но при этом результат записывается вместо одного из операндов
- **вместо 2-адресной команды применять одноадресную**, где вводится дополнительный вспомогательный внутренний регистр -- аккумулятор, в который записываются результаты текущих операций.
- **вместо одноадресной команды применять безадресную** (можно применять стек для операндом и работа с ним АЛУ: например, стековое АЛУ)

### Ортогональность кодов операций и способов адресации

Команды и способы адресации должны иметь **регулярную структуру**, количество команд должно быть минимально (при этом компилятору проще порождать нужный код).

**Все коды операций** должны допускать **все способы адресации**. (в наших процессорах это не так, потому что у разных команд разные форматы команд).

## Алгоритмы подсчёта единиц в двоичном числе (N бит) на уровне команд

### 1. Алгоритм последовательного просмотра разрядов последовательности

Тут ошибка в алгоритме: i увеличивается только при единице, а должен всегда.

<a href="https://ibb.co/3hG3x3N"><img src="https://i.ibb.co/x5Pknkj/image.png" alt="image" border="0"></a>

При этом можно дополнительно проверять оставшиеся биты на равенство 0, чтобы быстрее выходить из цикла.

### 2. Хитрый алгоритм

B -- число, которое мы проверяем

(ошибка: 1000 1010 - 1 = 1000 1001)

За счёт B & (B - 1) убирается последняя единица.

При этом там ещё одна ошибка: 1000 1000 - 1 = 1000 0111

Эти три единицы в конце значат, что 1000 0111 & 1000 1000 = 1000 0000, то есть мы убрали ещё одну единицу. После этого останется только одна единица.

После 1000 0000 - 1 = 0111 1111, которые при конъюнкции дадут все нули.

<a href="https://ibb.co/JmzBdHf"><img src="https://i.ibb.co/7jGYzKw/image.png" alt="image" border="0"></a>

<a href="https://ibb.co/DpH4TTc"><img src="https://i.ibb.co/Qd39ttS/image.png" alt="image" border="0"></a>

Таким образом, вычитание 1 формирует справа от последней единицы все единицы, и после этого, когда мы объединяем всё это конъюнкцией, последняя единица пропадает.

При этом количество циклов в этом алгоритме будет равно количеству единиц.

### 3. Быстрый алгоритм

Исходное В разделяется на Вчт и Внч. Внч сдвигаем вправо на i разрядов, и к нему прибавляется Вчт.

М -- как маска. В чётной маске единицы стоят в чётных местах. При применении конъюнкции к маске мы получаем только чётные разряды

На Мнч маска содержит нечётные единицы (нечётные разряды), и применяя конъюнкцию с этой маской, выделяем нечётные разряды.

Далее сдвигаем Внч, суммируем с Вчт и получаем новое В.

Во втором цикл мы используем уже маску Мчт[2], то есть там будут уже 2 единицы находиться в чётных местах, и применение конъюнкции с такой маской -- это проверка пары разрядов.

Аналогично Мнч -- нечётная маска из пар бит на нечётных местах.

Сдвигаем, суммируем и получаем новое В.

На третьем шаге к В будет использоваться маска с 4 единицами справа (чётная) или слева (нечётная).

<a href="https://ibb.co/cyHtgz7"><img src="https://i.ibb.co/9pL28RC/image.png" alt="image" border="0"></a>

Количество циклов $k = \log_2 N$.

Здесь как раз может использоваться массив констант -- масок, и на каждом шаге может вытаскиваться своя маска из этого массива.

Когда мы сдвигаем нечётные разряды, то на суммирующем шаге получаем сумму двух разрядов в каждой паре бит.

На втором шаге -- получаем сумму в трёх разрядах и так далее.

Например, в последнем шаге, если число содержало 8 единиц, то будут складываться 4 + 4 = 8 = 1 0000.

При этом маска может быть не из "единиц" (выделяет нужные разряды), а "из нулей" (блокирует нужные разряды). Иногда маскирование определяется не конъюнкцией, а дизъюнкцией.

# Конвейер команд

### Временная организация цикла выполнения команд
1. Выборка кода команды из ОП и запись в регистр команд РК (Instruction Fetch -- IF)
2. Декодирование КОП команды и способов адресации, формирование Аисп адресов (Instruction Decoding -- ID)
3. Выборка (считывание) операнда из ОП или РОН и запись в буферные регистры процессора (Operand Reading -- OR)
4. Выполнение операции в АЛУ (Executing -- EX)
5. Запись результата в ОП или РП (Write Back -- WB). Этот шаг может отсутствовать, например, в одноразрядных командах, где есть неявный регистр-аккумулятор, в который записываются все результаты.

При этом надо не забывать, что на одном из первых шагов выполняется **инкремент счётчика команд**.

Рассмотрим, как будут задействованы блоки процессора во время выполнения команды.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/Ykpwt2C/image.png" alt="image" border="0"></a>

Раз тут элементов (узлов) всего 3, рассмотрим, насколько они загружены:


<a href="https://imgbb.com/"><img src="https://i.ibb.co/fXZVcNv/image.png" alt="image" border="0"></a>

Отсюда видно, что если мы каждый этап выполняем за одно и то же время, то если синхронно, то выбирается такт, равный максимальному времени выполнения этапа, и видно, что ОП во время выполнения занята на 60%, а ЦУУ и АЛУ только на 20% ⇒ видео, что основной простой идёт именно на ЦУУ и АЛУ.


## Выполнение команд в конвейере

Часто в литературе это представляется так:

<a href="https://ibb.co/b25VDCG"><img src="https://i.ibb.co/k92TvwP/image.png" alt="image" border="0"></a>

Если мы представим эту диаграмму относительно устройств:

<a href="https://ibb.co/Z6gmFfc"><img src="https://i.ibb.co/0j9t6nY/image.png" alt="image" border="0"></a>

По сравнению с предыдущими диаграммами, тут введена отдельно память команд и отдельно память данных -- это позволило организовать конвейер, правда, в котором отсутствует этап записи WB.

Посему вводятся два понятия:

**Совмещение операций** -- когда аппаратура компьютера выполняет одновременно более одной операции.  Этот метод включает понятия **параллелизм** и **конвейеризация**.

Буферные регистры BR1 и BR2 как раз нужны, если мы будем совмещать выполнение двух операций -- ведь мы могли бы напрямую передавать данные из ОП или РП в АЛУ. Но эти буферные регистры позволяют выполнять одну операцию в АЛУ и одновременно с этим готовить следующую.

При **параллелизме** совмещение операций достигается путём воспроизведения в нескольких копиях аппаратной структуры. Высокая производительность достигается за счёт одновременной работы всех элементов структур, осуществляющих решение различных частей задачи, то есть могут быть несколько АЛУ, отдельно БО для умножения, отдельно БО для деления, отдельно для плавающей или фиксированной запятой и так далее.

**Конвейеризация (или конвейерная обработка)** основана на разделении исполняемой функции на более мелкие части, называемые **ступенями**, и выделением для каждой из них отдельного блока аппаратура. Производительность при этом возрастает, так как на различных ступенях конвейера одновременно выполняется <u>несколько команд</u>.

**Конвейеризация** выполнения команд предполагает разбиение процесса на подоперации и выполнении этих подопераций отдельными блоками (ступенями). По каждому синхроимпульсу С проходит продвижение команды на следующую ступень. Между ступенями устанавливаются регистры.

<a href="https://ibb.co/XJLqGmj"><img src="https://i.ibb.co/zfxztKQ/image.png" alt="image" border="0"></a>

При этом сами ступени могут быть комбинационными схемами, и тогда синхросигнал С может и е поступать на них. Для общего случая данные могут поступать и в какую-то отдельную ступень извне, минуя DI: например, если что-то отдельно нужно подать в 3 ступень.

**Конвейеризация** увеличивает **пропускную способность** процессора (количество команд в единицу времени). Мы видели, что если одновременно выполняется несколько шагов, то и результат появляется в несколько раз быстрее. Однако каждая команда по отдельности будет выполняться дольше.

Конвейеризация <u>не сокращает время</u> выполнения отдельной команды, а даже увеличивает время из-за накладных расходов, связанных с управлением конвейерными регистрами:
- время задержки регистра
- время предварительной установки
- задержка распространения сигналов по цепям

## Конфликты  в конвейере

**Конфликты** -- такие ситуации в конвейерной обработке, которые препятствуют выполнению очередной команды в предназначенном для неё такте.

### Классификация конфликтов

**Структурные конфликты** -- это конфликты по ресурсам, возникают в том случае, когда аппаратные средства не могут поддерживать все возможные комбинации команд в режиме одновременного выполнения с совмещением.

**Конфликты по данным** -- это ситуации, когда выполнение одной команды зависит от результата выполнения предыдущих команд.

**Конфликты по управлению** -- это ситуации, которые возникают при конвейеризации команд переходов и других команд, изменяющих содержимое счётчика команд.

### Структурные конфликты

Совмещение операций требует конвейеризации функциональных устройств и дублирования ресурсов для разрешения всех возможных конфликтных комбинаций команд в конвейере. Если какая-нибудь комбинация команд не может быть принята из-за конфликта по ресурсам, то в компьютере имеет место структурный конфликт.

#### Причины
1. Недостаточное дублирование некоторых ресурсов
2. Некоторые ступени конвейера отдельных команд выполняются более одного такта
3. Суперскалярные процессоры, имеющие более одного конвейера


#### 1. Недостаточное дублирование некоторых ресурсов

В компьютере имеет место **единственный конвейер доступа к памяти** -- когда команды и операнды находятся в одном запоминающем устройстве. В данном случае конфликт при обращении различных команд за данными с совмещением выборки следующей команды и записью результата -- в этом случае осуществляется приостановка конвейере ("пузырь", простой). То есть, когда мы одновременно обращаемся к одной единственной памяти за командой и за операндами, конвейер вынужден приостановиться.

**Устранение** -- увеличение количества однотипных функциональных устройств. Например, разделяют кэш-память L1 для хранения команд (инструкций) и данных, используют многопортовую регистровую память (порты для записи и для считывания), введение нескольких АЛУ (для целых чисел, с плавающей запятой, умножения, деления).

<a href="https://ibb.co/8NbVND3"><img src="https://i.ibb.co/S5cp5XT/image.png" alt="image" border="0"></a>

Время выполнения первых двух команд не изменилось, но 2 и 3 команда выполняются с задержкой. Видны простои -- пузыри. Узкое место -- ОП.

Введём две памяти: память команд и память данных. Это позволит исключить приостановки конвейере и пузыри. Видно, что все команды выполняются одно и то же время, и после того, как все ступени будут задействованы, мы получаем каждый результат через Тцикла/4: разделение памяти привело к тому, что мы увеличили производительность в 4 раза.

<a href="https://ibb.co/cgJWH5L"><img src="https://i.ibb.co/Qb9WRBd/image.png" alt="image" border="0"></a>

Здесь пока исключена запись WB.

#### 2. Некоторые ступени конвейера отдельных команд выполняются более одного такта

Например, команды может занимать несколько слов или несколько байт так, что мы не можем одновременно считать всю команду. Кроме того, в АЛУ команды выполняются за разное время: умножение выполняется за несколько тактов, сложение меньше

**Устранение**:
- увеличение времени такта работы ступеней конвейера -- снижает эффект конвейерной обработки, так как этапы будут выполняться дольше.
- использовать аппаратные решения, которые позволяют снизить затраты времени на этапы, но усложняют схемы процессора, например, использовать матричные схемы умножения.

Разработчики ищут компромисс между увеличением длительности такта и усложнением устройства. Но, так как некоторые команды встречаются редко, то разработчики допускают наличие некоторых структурных конфликтов.

Как правило, не полностью конвейерное устройство имеет меньшую задержку, чем полностью конвейерное.

Рассмотрим, к чему могут привести такие конфликты:

<a href="https://ibb.co/jhC4h97"><img src="https://i.ibb.co/D4BK4P3/image.png" alt="image" border="0"></a>

Вторая команда вынуждена ждать, пока первая выполнится в АЛУ. Раз так, то мы не можем извлекать и следующую команды (хотя мб и можем, тут это всё равно)


Другой пример -- когда извлечение команды выполняется в два такта. Изначально мы определили, что команда не однословная, поэтому после ЦУУ мы обращаемся к памяти на досчитывание этой команды. Получается, что АЛУ так же простаивает 3 такта.

<a href="https://ibb.co/h81KDwq"><img src="https://i.ibb.co/Qmj6rt5/image.png" alt="image" border="0"></a>

Как видно, после того, как пузырь проходит, конвейер может и самовосстановиться.

#### 3. Суперскалярные процессоры, имеющие более одного конвейера

**Недостаток** -- необходимость синхронного продвижения команд в каждом из конвейером. Разрешение командам выполняться в конвейерах вне зависимости друг от друга приводит к <u>неупорядоченному выполнению команд</u>. При этом команды, стоящие позже, могут завершиться ранее команд, стоящих впереди.

**Устранение** -- вводятся <u>буферы записи результатов</u> в соответствии с восстановленной последовательностью команд -- запись производится только после выполнения предшествующих команд. Эти буферы работают не просто как FIFO -- с данными поступает номер команды в каком-то порядке, и логика работы этого буфера соответствует исходному порядку выполнения команд.

### Конфликты по данным

Это ситуации, когда выполнение одной команды зависит от результата выполнения предыдущей команды. <u>Производительность</u> конвейерных команд существенно зависит от межкомандных логических зависимостей

#### Классификация конфликтов по данным
- RAW (Read after Write) -- чтение после записи
- WAR (Write after Read) -- запись после чтения
- WAW (Write after Write) -- чтение после чтения

Есть ещё RAR (Read after Read), но тут конфликта нет.

Далее во всех вариантах команда $k$ предшествует команде $N$ ($k < N$).


#### RAW: Read after Write

Команда N пытается прочитать операнд из памяти раньше, чем команда k запишет результат по этому адресу в память, то есть команда N получает старое значение.

<a href="https://ibb.co/H7BwbyM"><img src="https://i.ibb.co/y0dvZCM/image.png" alt="image" border="0"></a>

Пусть команда k+1 выполняет какую-то операцию и записывает результат в аккумулятор А, а команда k+2 использует этот результат. В результате получится, что команда k+2 получит старое значение А, а не новое.

С выхода АЛУ можно, кроме выхода в память, подавать обратно на вход АЛУ. 

При этом мог образоваться пузырь из-за этапа WR команды k+1.

#### WAR: Write after Read

Команда N пытается записать результат в память раньше, чем команда k считает операнд из этого адреса в памяти, то есть команда k получает новое значение операнда вместо старого. Это возможно в системах, допускающих выполнение команд не в порядке их расположения в программе

#### WAW: Write after Write

Команда N пытается записать результат в память раньше, чем команда k запишем результат по этому адресу в память, то есть происходит запись в неверном порядке, и в памяти остаётся старое значение (возможно при записи из многих ступеней и нескольких конвейеров).

<a href="https://ibb.co/3h6C3sH"><img src="https://i.ibb.co/f06xgS7/image.png" alt="image" border="0"></a>

Пузыри появляются из-за шагов записи WR. Но логика нарушается, в памяти остаются старые данные.

#### Устранение конфликтов по данным
- **Методика планирования компилятора** -- планирование команд конвейера. В одном блоке (линейном участке программы) так упорядочивают последовательность команд, чтобы минимизировать перестановки. Например, если есть набор команд a := a + b; a := a + d; c := c + k, то логичнее поменять местами две последние команды, чтобы результат выполнения первой команды стал известен в момент начала выполнения третьей.
- **Буферизация команд**, ожидающих разрешения конфликта, и выдача последующих "в обход" буфера
- Организация **коммутирующих магистралей**, обеспечивающих передачу результата операции непосредственно в буфер, хранящий логически зависимую величину, задержанную из-за конфликта -- осуществляется пересылка или продвижение данных "обходом" или "закороткой". Проверяется, если результат предыдущей команды является источником операнда для следующей команды, то результат с выхода АЛУ поступает по цепи обхода АЛУ, а не операнд, считанный из памяти.

### Конфликты по управлению

Это ситуации, которые возникают при конвейеризации команд переходов и других команд, изменяющих состояние счётчика команд.

<u>Потери производительности</u> конвейерных команд при конфликтах по управлению могут быть значительными, даже больше, чем при конфликтах по данным.

Результатом команд перехода является изменение содержимого счётчика команд. 
- В командах **безусловного перехода** в СК записывается **исполнительный адрес**.
- В командах **условного перехода** анализируется признак, в зависимости от которого **сохраняется** ($СК + \Delta$) или **изменяется** (CK := A пер исп) содержимое.

Если команда условного перехода заменяет содержимое СК, то переход называется **выполняемым**.

#### Безусловный переход на адрес М
Мы выполняем предыдущую команду k, на следующем шаге извлекаем следующую команду, которую мы на следующем шаге анализируем (выполняется дешифрация КОП и формирование Аисп). Одновременно с этим мы можем извлекать k+2 команду. Как только мы вычислили исполнительный адрес k+1 команды, что оказалось командой безусловного перехода, то мы переходим на команду М ⇒  команда k+2 нам оказалась не нужна, из-за чего получился простой.


<a href="https://ibb.co/jJHLmbp"><img src="https://i.ibb.co/3Rk024J/image.png" alt="image" border="0"></a>

При этом команду k+2 надо очистить и удалить из буфера, чтобы не продвигать дальше.

#### Условный переход на адрес М. Очистка очереди

Команда k линейная, как в предыдущий раз. Команда k+1 - команда условного перехода на М. В момент времени, когда мы анализируем команду k +1, надо уже знать признак F, чтобы определить: либо мы идём дальше на k+2, либо мы уходим на адрес М.

Признак тут мы получим только после выполнения команды в АЛУ, поэтому мы вынуждены ждать, пока этот признак мы получим. И только после этого мы сможем выполнить команду k + 1.

<a href="https://ibb.co/cKBvs8k"><img src="https://i.ibb.co/CpctS9m/image.png" alt="image" border="0"></a>

Тут показан именно выполняемый переход, то есть сам переход выполняется, потому что признак F получился равным да. Тут простои уже по три такта, ещё один такт простоя появился в памяти команд, чего не было в безусловном переходе.

Чтобы уменьшить простои, можно начать выполнять команды раньше. Можно предположить, что переход выполняемый (и начать выполнять команду М), а можно предположить и другое, и начать выполнять команду k+2. Получив на нужном шаге F, мы можем или продолжить дальше или перейти по М.

<a href="https://ibb.co/NWDkBw2"><img src="https://i.ibb.co/nQdVJhM/image.png" alt="image" border="0"></a>

Только главное не забыть при невыполняемом переходе очистить очередь. Это, конечно, не значит, что надо стирать прямо всё, однако это самое простое решение.

Проблема очистки очереди довольно серьёзная, и это целая отдельная задача - как сделать так, чтобы у нас никуда не записалось и не запомнилось ничего лишнего.

#### Методы (схемы) снижения потерь
- **Метод выжидания** -- замораживание операций на конвейере, пока не станет известно направление (значение признака F) -- простота метода
- **Метод возврата** -- прогнозировать переход **как невыполняемый (F=0)**, то есть программа выполняется, и если затем признак не совпал, то очистка конвейера от команд после команды условного перехода на всех ступенях
	- Альтернатива -- **выполняемый переход**
- **Задержанный переход** -- изменение порядка команд
- **Предсказание (прогнозирование) направления перехода** до момента условного перехода:
	- статическая стратегия -- фиксируется на всё время выполнения программы
	- динамическая стратегия -- в процессе выполнения на основании информации о предшествующих переходах


# МкПУУ

Основным элементов для схемного устройства управления с жёсткой логикой является датчик состояний. А в микропрограммном устройстве -- память.

## Микропрограммное устройство управления

**МкПУУ** -- блок управления, основой которого является **управляющая память (УП)** или **память микропрограмм**, в которой хранятся последовательности микрокоманд (МК) для микропрограмм (МП) выполнения машинной команды (операции) (КОП). Код МК, считанный из УП, интерпретируется как совокупность совместимых управляющих сигналов УС для выполнения соответствующих микроопераций (МО). В процессе работы МкПУУ происходит формирование последовательности адресов МК для выполнения микропрограмм МП операций с учётом условий и признаков, вырабатываемых по ходу вычислений.

Управление операциями, выполненное посредство считывания МК из УП, называется **микропрограммным управлением**.


При этом код микрокоманды, считанной из управляющей памяти, интерпретируется как совокупность совместимых (одновременно задаваемых) управляющих сигналов для выполнения соответствующих микроопераций.

Раз у нас в памяти содержатся микрокоманды, надо формировать и адреса этих микрокоманд, чтобы понимать, куда перейти после выполнения очередной микрокоманды.

Совокупность микрокоманд образует микропрограмму выполнения машинной операции. Под операцией подразумевается умножение, сложение и так далее.

МУУ схемного типа, однако, является более быстродействующим. Поэтому микропрограммные УУ используются, хоть и широко, но всё же не абсолютно везде.

## Общая структурная схема МкПУУ


<a href="https://imgbb.com/"><img src="https://i.ibb.co/q7bGN5T/image.png" alt="image" border="0"></a>

В основе лежит управляющая память УП. Причём память, как отмечено, -- ПЗУ, то есть она работает только на чтение.

- КОП - код операции
- Fi - сигналы-признаки, по которым проходит ветвление
-  СФАМ - схема формирования адреса микрокоманды. В БУКе подобный блок назывался блоком формирования исполнительного адреса (БФИА).
- СМК - счётчик микрокоманд. Мы рассмотрим, что он может быть выполнен не как счётчик, а как РАМ - регистр адреса микрокоманд, который не увеличивает своё значение, а просто его схема увеличивает значение и загружает его внутрь. Это позволяет упростить схему. У счётчика же может быть вход +1, которым мы управляем
- РМК - регистр микрокоманд. В нём есть три поля

Основное назначение микропрограммного устройства, как и любого устройства управления, - **формирование управляющих сигналов**.

### Структура формата микрокоманды

<a href="https://ibb.co/JQ9g5sp"><img src="https://i.ibb.co/xHNdJ7g/image.png" alt="image" border="0"></a>

- **Адресное поле** содержит адрес следующей микрокоманды.
- **Поле маски признаков, управления** используется для проверки сигналов признаков F, используемых для реализации условных переходов, управления вычислительным процессом и задания длительности микрокоманды.
- **Поле микроопераций** предназначено для задания формируемых **управляющих сигналов УС**. Это самое главное поле в команде.

Мы не рассматривали на примере жёсткой логики, что какие-то микрокоманды можно выполнять за несколько тактов. Для этого можно было бы дополнительно ввести счётчик тактов, который бы не давал переходить датчику состояний в следующее состояние до тех пор, пока он не станет равным 0.

Как работает устройство. В начале поступает КОП - код операции умножения или, например, сложения. По этому коду операции СФАМ формирует начальный адрес микропрограммы (умножения или сложения). Этот начальный адрес поступает в счётчик микрокоманд. По этому адресу из УП считывается первая микрокоманда, которая поступает в РМК. Формируются игреки.

Но кроме того адрес следующей микрокоманды поступает в СФАМ, и он может напрямую перейти с СМК, а может с учётом признаков из поля М - выбираются требуемые признаки Fi на основании поля М, которые могут видоизменить адрес в СФАМ, который в итоге поступит в СМК.

Или адресное поле может не учитываться, а в счётчик команд просто добавляется единица - это можно выполнять на линейный участках: СМК := СМК + 1. Для управления +1 или загрузкой отдельного значения в СМК как раз используется поле маски признаков, управления М.

В данном случае можно УП или ПЗУ рассматривать только как накопитель, а памятью чаще называют, когда есть регистр адреса и регистр микрокоманд. То есть блоком памяти или модулем памяти в данном случае будут называть СМК, ПЗУ и РМК вместе. Для общего случая блок памяти, помимо накопителя, должен содержать ещё регистр адреса и регистр данных.

Когда будем выполнять микропрограммное устройство, то надо не забыть, что внутренних регистров у памяти в хилинхе нет, посему надо выдерживать адрес всё время.

## Классификация МкПУУ

В памяти хранятся именно микрокоманды.

Зачем мы пишем "постоянное запоминающее устройство ПЗУ", чтобы показать, что это и как оно обозначается. Например, мы могли писать "регистр первого операнда RA" - то есть сначала название, а потом обозначение. Поэтому так писать можно, это не ошибка.

У себя надо будет отмечать, что мы выбрали. В нашем случае мы не выбираем статическое или динамическое микропрограммирование, но надо будет указать способ формирования адреса следующей микрокоманды, который мы будем использовать в своих ЦУУ. Это же надо будет говорить и на защите.

Также надо будет выбирать способ формирования управляющих сигналов.

**1. По типу управляющей памяти МК**:
- **Статического микропрограммирования** -- в котором используется постоянное запоминающее устройство ПЗУ
- **Динамического микропрограммирования** -- в котором используется оперативное запоминающее устройство ОЗУ, что позволяет изменять состав микропрограммных модулей
- **Статическо-динамического микропрограммирования** -- в котором используются и ПЗУ, и ОЗУ.

**2. По способу формирования адреса следующей микрокоманды**
- принудительная адресация
- естественная адресация

**3. По способу формирования управляющих сигналов УС**
- горизонтальное микропрограммирование
- вертикальное микропрограммирование
- смешанное микропрограммирование


**4. По способу исполнения микрокоманд**
- однофазное кодирование -- одновременное формирование всех УС в МК
- многофазное кодирование -- формирование УС в МК в разные фазы такта

**5. По способу кодирования**
- прямое кодирование -- закрепление за каждым УС фиксированной функции
- косвенное кодирование -- формирование УС в зависимости от дополнительных полей МК


## Способы формирования управляющих сигналов

### Горизонтальное кодирование

<a href="https://ibb.co/KW0KfXs"><img src="https://i.ibb.co/TtvW7k0/image.png" alt="image" border="0"></a>

Каждому управляющему сигналу YC~i~ соответствует отдельный разряд в поле МО. То есть каждый разряд -- это отдельный управляющий сигнал.

Операционная часть МО содержит N разрядов, где N -- общее количество управляющих сигналов УС.

<u>Достоинство</u> способа: простота формирования управляющих сигналов УС и возможность  одновременного независимого задания любого сочетания разрядов (управляющих сигналов УС) в поле МО.

<u>Недостаток</u> -- большое количество разрядов N в поле МО -- количество которых равно количеству управляющих сигналов УС.

Управляющих сигналов может быть не одна сотня. Поэтому если игреков много, то такие команды называют *слабокодированными* -- "в море нулей островки единиц".

 ### Вертикальное кодирование
 
<a href="https://ibb.co/9b05kb4"><img src="https://i.ibb.co/QPVw3PH/image.png" alt="image" border="0"></a>

На выходе поля микрооперации ставится дешифратор. Количество выходов дешифраторов равно количеству игреков (обозначено N), а разрядов в операционной части будет $k=\log_2 N$.

<u>Достоинство</u> способа: наименьшее количество разрядов в поле МО и эффективное использование управляющей памяти УП.

<u>Недостаток</u>: использование дешифраторов на большое количество выходов N, увеличение задержки на формирование управляющих сигналов УС и главное -- в каждой микрокоманде может быть указан только один управляющий сигнал УС, что приводит к увеличению длины микропрограммы.

Ведь на выходе дешифратора только один сигнал - унитарный код. Поэтому если нам нужно было бы выполнять сдвиг А, сдвиг Б и обнуление РР - это мы бы выполняли за три микрокоманды. Понятно, что это даже не будет работать, если надо одновременно подавать несколько сигналов, управляя КС и каким-нибудь регистром. Поэтому в чистом виде такой подход не применяется. К тому же и будет большой и сложный дешифратор, особенно если он будет на большое количество выходов.

В сравнении с предыдущими, такие команды называются "сильнокодированными" или "максимальнокодированными": то есть нет такого, что островки нулей или островки единиц.

### Смешанное (горизонтально-вертикальное) кодирование

<a href="https://ibb.co/GnYqhCk"><img src="https://i.ibb.co/wBGfvpC/image.png" alt="image" border="0"></a>

N сигналов разбиваются на группы, и для каждой группы вводится вертикальное кодирование, и остаётся одна общая группа для горизонтального.

Такое решение можно принять и в курсаче, но это не обязательно.

Поле микрооперации МО **разбивается на группы**, причём вводится несколько групп для вертикального кодирования и одна для горизонтального кодирования.

Группы, для которых применяется вертикальное кодирование, содержат те управляющие сигналы УС, которые не встречаются вместе в одной МК и такие микрооперации (УС) называются **совместимыми** (или **несовместные**, которые могут формироваться одновременно), и для каждой вертикальной группы вводится свой дешифратор и формируется только один управляющий сигнал УС. При этом общее количество управляющих сигналов УС равно количеству групп. Количество разрядов в группе $m_i=\log_2(m_i+1)$, так как в группе может отсутствовать сигнал УС -- то есть в какой-то микрокоманде может не быть ни одного сигнала, а номер должен быть. Либо можно было задавать Enable, но это всё равном лишний разряд.

В горизонтальную группу вводятся совместные управляющие сигналы YC, которые могут формироваться в микрокомандах одновременно.

## Способы исполнения микрокоманд

### Однофазные

<a href="https://ibb.co/Z8y3VjN"><img src="https://i.ibb.co/nchTbGR/image.png" alt="image" border="0"></a>

### Многофазные

<a href="https://ibb.co/QKz1jf6"><img src="https://i.ibb.co/VqrPptv/image.png" alt="image" border="0"></a>

<a href="https://ibb.co/KxcMTbR"><img src="https://i.ibb.co/gZb5kmH/image.png" alt="image" border="0"></a>

Каждый игрек выполняется на последующем такте. Здесь есть не просто один генератор (главный), а ещё мы формируем три фазы (импульсы), а могли бы быть уровни. Таким образом, генератор разбивается на три фазы. Каждый игрек закрепляется за определённой фазой. Поэтому если в какой-то команде этот игрек не используется, то игрек просто не формируется, однако такт проходит. Поэтому вместо 10 микрокоманд получается 4 МК, но выполняем за 12 тактов. Таким образом, сокращается количество микрокоманд, но самое главное - закрепление за игреком определённой фазы.

Почему стало микрокоманд меньше? В однофазных МК каждая МК содержит только один игрек. В многофазных каждая МК содержит несколько игреков. Поэтому можно сократить количество микрокоманд. Однако длительность увеличится.

А раз происходит сокращение количества микрокоманд, у нас сокращается и объём памяти: вместо 10 ячеек 4 - происходит "обогащение" микрокоманд игреками. Так сокращается количество адресов в микропрограмме.

Можно было бы фазы не закреплять, но тогда бы мы увеличили поля, введя, например, ещё один разряд на каждый игрек и указывать, в какой фазе он должен работать. Как пример косвенного задания игрека - указание того, в какой фазе он выполняется, но в таком случае, конечно, увеличилась бы ширина команды, то есть её разрядность.

В общем случае у однофазных микрокоманд тоже может быть много игреков. Просто сами игреки будут выполняться все сразу.

Первое, что мы будем отражать у себя, - **формирование адреса следующей микрокоманды**.

## Способы формирования адреса следующей микрокоманды

<a href="https://ibb.co/pLzFXtt"><img src="https://i.ibb.co/Tg83hVV/image.png" alt="image" border="0"></a>

**Принудительная** адресация - это тот формат, который мы разбирали. Здесь каждая МК содержит все три поля - адреса следующего, маски и поля управления и поле микрооперации.

При этом в счётчик МК принимается адрес следующей команды из соответствующего поля. Он может загружаться или не загружаться, если там будет какое-то условие.

**Естественная** адресация предполагает два вида МК: управляющие (УМК) и операционные (ОМК).

Для этого вводится разряд признака: например, 1 - управляющая команда, 0 - операционная. Можно и наоборот.

**Управляющая** команда содержит адресное поле и поле маски. **Операционная** - только поле микрооперации. При этом понятно, что общий формат будет выбираться по наибольшей разрядности из двух типов команд. При этом может быть и не одно адресное поле, если переход зависит от условия, но переход всё равно произойдёт.

Надо учитывать, что в общем случае МО - это порядка сотен разрядов, а если в памяти содержится 10 000 ячеек, то в адресной части должно быть 14 разрядов ⇒  будут неравномерности, а значит, свободные поля.

Таким образом, мы сокращаем количество разрядов, но дополняем одним разрядом признака. Если работает УМК, то счётчик микрокоманд, как и в предыдущем случае, подаётся Аслед, но с учетом поле управления.

На линейном же участке (операционные команды) можно просто увеличивать счётчик команд на 1.

Эти два типа мы сравниваем по двум критериям: аппаратным и временным.

В естественной адресации команд будет больше, но только в командах условного и безусловного перехода: у них не будет никаких микрооперацией (NOP). Поэтому достоинством естественной адресации является уменьшение разрядности МК, но увеличивается количество самих МК на команды управления: команды условных и безусловных переходов.

<a href="https://ibb.co/1LSy37K"><img src="https://i.ibb.co/KX14Yb7/image.png" alt="image" border="0"></a>

**Порядок работы МкПУУ**:
- КОП операции, в СФАМ формирование Анач операции, передача в СМК далее в РА, извлечение кода команды и запись в РМК
- Формирование управляющих сигналов У и передача Аслед в СФАМ и далее в СМК = Аслед


**В командах управления**
- проверка по маске М сигналов-признаков F~i~
- Если Fi[M]=0, то CMK := CML + 1
- Если Fi[M]=1, то CMK := Aслед

Тут добавляется стек -- используется в командах возврата, цикла, обращения к подпрограммам

<a href="https://ibb.co/VYFLg3G"><img src="https://i.ibb.co/JjYcvCT/image.png" alt="image" border="0"></a>

Слева всё остаётся одним и тем же. Регистр микрокоманд показа как бы из двух частей - на самом деле он просто по разному воспринимает линейные и операционные команды:  в РМК можно считать УМК или ОМК в зависимости от разряда признака, и далее по разному учитывается содержимое этих микрокоманд.

На выходах мы имеем какие-то наборы единиц и нулей, которые всегда приходят на СФАМ, а СФАМ принимать данные и адрес микрокоманды будет в зависимости от признака: если он равен 1, то он будет учитывать адреса и маски.

Тут ещё можно заметить, что ширина команд и, соответственно, разрядность РМК стала намного меньше.

После загрузки в регистр РМК анализируется **признак П** типа микрокоманды:
- если **П=0**, то это **ОМС** и КС формирует управляющие сигналы УС, а в СФАМ формируется сигнал (+1) и СМК := СМК + 1
- если **П=1**, то это **УМК** и СФАМ формирует Аслед микрокоманды в зависимости от значений полей адреса А и маски М и сигналов-признаков Fi

**Достоинство** МкПУУ с ественной адресаций -- **сокращение разрядности МК**.

**Недостатки**: дополнительная КС для формирования управляющих сигналов У и увеличение задержки, увеличение количества микрокоманд на количество команд перехода

<a href="https://ibb.co/pW50Pvh"><img src="https://i.ibb.co/k3vHygm/image.png" alt="image" border="0"></a>

Количество разрядов уменьшается, а количество ячеек увеличивается на дельту - на команды условных и безусловных переходов.

На данной слайде указаны два основных подхода к формату микрокоманд -- принудительная адресация и естественная. В принудительной каждая МК содержит все три поля, а в естественной есть два формата МК -- управляющая и операционная, и в одних и тех же разрядах можно задавать игреки, адрес следующей команды или маски.

При этом обычно говорят, что принудительная адресация в УП занимает больше места, чем при естественной адресации: добавляется дельта, которая связана с командами условных и безусловных переходов. Как правило, эта дельта меньше N, а разрядность и так меньше.

Для процессоров надо отвечать, почему мы выбрали ту или иную адресацию, и уметь их сравнить по аппаратуре. Надо выбрать - у нас будет принудительная или естественная адресация. Желательно в отчёте сравнить оба варианта - плюсы и минусы обоих реализаций и почему мы выбрали именно такую.

## Способы выработки следующего адреса микрокоманды

Применение различных способов формирования Аслед предназначено для обеспечения компромисса между минимизацией объёма управляющей памяти и сокращением времени формирования следующего адреса.

1. **Принудительное задание** адреса Аслед в адресном поле А текущей микрокоманды. Это принудительная адресация.
2. Применение **счётчика команд** на линейных участках. Несмотря на то, что это может применяться и в принудительной адресации, можно пропускать поле адреса следующей команды и просто инкрементировать счётчик на линейных участках. 
3. **Применение различных способов адресации**: прямая, относительная, косвенная и др., чтобы адрес был коротким. Микрокоманд может быть десятки тысяч в реальных процессорах, и если мы уменьшаем адресное, можно значительно выиграть за счёт того же смещения
4. Организация **условного перехода** на два или несколько направлений. В начале МкПУУ надо описать, что мы выбираем и на сколько направлений у нас будет ветвление
5. Выполнение циклов по количеству итераций -- требуется **счётчик числа повторений** (i)
6. Организация обращений к микроподпрограммам, команд возврата и циклов -- **использование стека**
7. Формирование начального адреса **Анач микропрограммы** выполнения команды по КОП -- надо определить, как его выбрать
8. Формирование начального адреса **Анач микропрограммы обработки прерываний** (это могут быть два разных начальных адреса, по которым мы должны уходить на микропрограмму операции или на прерывание)

## Применение стека

Допустим, мы идём по микропрограмме и в i-ой команде может в стек записать адрес возврата. При этом мы уходим на следующий адрес, который при принудительной адресации может быть не i+1, а любой другой. В каком-то другом адресе можно пойти либо на следующий адрес или вернуться обратно на i, который был записан в стеке.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/3v7sC8W/image.png" alt="image" border="0"></a>

Так же может работать и цикл, но надо будет тогда проверять чему равен признак цикла F.

### Обращение к микроподпрограммам

Или можно так же обращаться к микроподпрограммам: пусть в i адресе мы обращаемся по адресу микроподпрограммы, но при этом мы в стек записываем адрес i+1 (он оказывается на вершине стека) -- адрес возврата (он на 1 больше), а уходим на микроподпрограмму с адресом m, который стоит в поле микрокоманды.

<a href="https://ibb.co/J7SCtbc"><img src="https://i.ibb.co/mqPSTYR/image.png" alt="image" border="0"></a>

Далее выполняем микроподпрограмму, доходим до адреса k и дальше записываем k+1 в стек, если надо обратиться к другой микроподпрограмме, на вершине оказывается k+1

Уходим на какой-то адрес n, выполняем n-ную микроподпрограмму, доходим до последней микрокоманды этой микроподпрограммы и из стека получаем адрес k+1 - он подаётся в счётчик микрокоманд, продолжаем выполнять микроподпрограмму k, выполняем её и в конце извлекаем адрес i+1, При этом i+1 может остаться в вершине, его не обязательно исключать из стека - так же как и адрес возврата в цикле

Количество ячеек или адресов в стеке называется глубиной стека. Это количество вложенных циклов или глубина вложенности микроподпрограмм.

## Организация условного перехода на два направления
Пусть мы выполняем i-ую микрокоманду и проверяется условие F. Если оно равно 0, то, как правило, переход не выполняемый, то есть мы идём на следующий адрес по счётчику адреса микрокоманды СМК. А если F=1, то мы уходим на адрес k, который задаётся в микрокоманде в поле адреса следующей микрокоманды.

Если рассматривать регистр МК, в котором есть поля адреса следующей команды и поле маски, поле маски проверяет Fj, или выбираем его, и в зависимости от результата проверки мы либо при нуле увеличиваем СМК либо загружаем в него значение k из поля адреса следующей микрокоманды

<a href="https://ibb.co/MRtFSXT"><img src="https://i.ibb.co/Vvzf9Ky/image.png" alt="image" border="0"></a>

В начале микропрограммного устройства управления надо написать, что мы выбираем - принудительную или естветвенную, горизонтальное или вертикальное микпропрограммирование для игреков, какое органзуется ветвление и та далее. И подобные рисунки надо будет привести.

Второй вариант (В): мы в микрокоманде i так же проверяем f, но уходим на k или на k+1. Ну а дальше мы с адреса k в общем случае мы не можем идти дальше на k+1, надо уйти на адрес v или на адрес z, поэтому данный вариант больше подходит для принудительной адресации.

Если k мб любым (и чётным, и нечётным) то в схему надо будет добавить сумматор

<a href="https://imgbb.com/"><img src="https://i.ibb.co/6mtzyQ2/image.png" alt="image" border="0"></a>

Причём в схеме вход +1 может остаться чтобы на линейных участках продолжать выполнять команды

А если этот адрес k будет чётным, то можно в такую схему вместо сумматора можно просто поставить элемент ИЛИ на младший разряд

<a href="https://imgbb.com/"><img src="https://i.ibb.co/txH6VGq/image.png" alt="image" border="0"></a>

Понятно что КС и сумматором можно управлять, чтобы они не мешали, когда у нас нет ветвления

При этом не можем сразу перейти либо на v либо на z потому что в адресном поле МК доступен только один адрес

В нашем варианте нужно по любому уйти куда-то в другое место, например, если i+1 чем-то занят.

Будем называть связанными адресами i и (i+1), а также k и (k+1)

<a href="https://ibb.co/cDWsTxY"><img src="https://i.ibb.co/gz0cg64/image.png" alt="image" border="0"></a>

Это нужно чтобы не ошибиться, когда будем составлять блок-схему микропрограммы: если есть ветвление надо всегда проверять куда мы уходим: либо уходим со связанного на связанный, либо с обычного на два связанных. В чисто принудительной адресации на линейном участке адреса могут идти не обязательно подряд, а в естественной адресации чтобы с k перейти на v надо будет использовать команду безусловного перехода

<a href="https://imgbb.com/"><img src="https://i.ibb.co/VTvhhWB/image.png" alt="image" border="0"></a>

можно иногда использовать не счётчик микрокоманд, а регистр адреса микрокоманд. В подходе В как раз можно перейти от СМК к РАМ: если k будет чётным, а это задать нетрудно, то нам надо будет использовать только элемент ИЛИ, убирая тяжеловесный сумматор.

Для общего случая можно рассматривать и два адреса (k и m), оба будут в МК и тогда надо будет поставить мультиплексор в схеме, который будет выбирать адрес k или m

## Организация условного перехода на несколько (4) направлений

Допустим у нас есть условный переход на 4 направления в зависимости от двух признаков. Можно было бы разбить эту проверку на 2 части: сначала проверять F1, уходим на 2 направления, а потом проверяем F2, и разветвляемся ещё на 2 направления.

Вместо ухода на 4 разных адреса можно уходить на 4 связанных адреса

<a href="https://imgbb.com/"><img src="https://i.ibb.co/WWbnG5X/image.png" alt="image" border="0"></a>

Это можно выполнить сумматором, если k любой. Важно отметить, что эти 4 адреса связанные

Поэтому мы можем выбирать сразу 2 признака и на сумматоре их прибавлять

<a href="https://imgbb.com/"><img src="https://i.ibb.co/qjm4X6n/image.png" alt="image" border="0"></a>

В вертикальном столбце (по адресам k, …, k+3) должны стоять команды безусловного перехода. С точки зрения игреков это могут быть дополнительные пустые микрокоманды с естественной адресации. В принудительной это всё делается проще

Если k кратно 4 (двойной чётности), то можно обойтись и без сумматора







<!--stackedit_data:
eyJoaXN0b3J5IjpbMTI5MjgzOTU0MywxMTQxNDkxNTU5LC0xOD
M4NzcyNjk5LDE1ODY4MTMyNDAsMTM0MjQ0NjcyNiwtMTYwNDYy
NTQxMiw1MTM1ODIxNywxODI2MDE4MzE1LC0xMDUxNDUxNTgxLC
0xMzI0OTU4NDM1LC0xNjg0Nzk1NTc2LC0yMDg5MDE2NCwtMTQy
NzQwODc3OSwtNzQwOTg2NDc5LDEyMTcyMDUxNjcsMTEyMDkzOT
A5MSw1Mjc3OTk3OSwtMTQzODY2MDQ4LDIxMDYxMDMzMDUsLTE3
MDE0ODkxODVdfQ==
-->