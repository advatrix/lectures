
# Общая структурная схема процессора


БО -- блок, который непосредственно выполняет арифметико-логические операции.

Управляет блоком операции МУУ -- местное устройство управления. Он формирует управляющие сигналы для выполнения арифметико-логических операций на БО.

ЦУУ -- центральное устройство управления. 

П -- память или система памяти. Она мб показана пунктиром, потому что из системы памяти внутри процессора находится только кэш, а ОП по определению находится вне процессора (максимум только какая-то её часть).

Блок операции и МУУ вместе образуют АЛУ -- арифметико-логическое устройство. Оно выполняет арифметические и логические операции.

Пунктирные блоки -- опциональные -- блок контроля и диагностики и блок связи с каналами (с внешними устройствами).

Блок контроли и диагностика работает при включении компьютера: он выполняет некоторое тестирование. Контроль от диагностики отличается тем, что контроль -- то, что выполняется во время работы процессора при осуществлении операций, а диагностика -- это специальный режим проверки, какой из блоков не работает (например, контроль по чётности -- это когда к данным или командам добавляются дополнительные разряды, которые контролируются в процессе выполнения).

У нас эти пунктирные блоки отсутствуют. Они не входят в состав процессора, так как они опциональные.

Внутри ЦУУ -- устройство, которое занимает верхний уровень в иерархии управления, делится на БУК и БМК.

**БУК** -- блок управления командами. Он формирует **исполнительные** адреса операндов и адреса следующей команды или следующих команд. То есть он управляет последовательностью команд.

**БМК** -- блок формирования (выработки) микрокоманд. Он отвечает за формирование управляющих сигналов для управления другими блоками процессора. Фактически там же формируется $Y_C$.

Можно было ьы считать, что как по аналогии в АЛУ БУК -- это как БО, а БМК -- это как МУУ.

Система памяти состоит из ОП и РОН (регистры общего назначения). Также там может быть кэш нескольких уровней, а ВЗУ -- внешнее запоминающее устройство, обычно реализуется через связи с внешними устройствами.

**Процессор** -- это устройство, осуществляющее процесс обработки данных по заданной программе.

**Центральный процессор** -- это процессор, в состав которого входят устройства управления, АЛУ, и который осуществляет наряду с обработкой данных управление другими устройствами ЭВМ.

ЦУ в иерархии подчинения занимает самое высокое место.

<a href="https://ibb.co/3Nj4mDD"><img src="https://i.ibb.co/C7YmKkk/image.png" alt="image" border="0"></a>

Работа процессора начинается с включения питания. 

После этого может осуществляться автоматический контроль (но он опциональный, это не рассматриваем)

1. Самое первое, что надо выполнить после включения питания, -- сброс (CLR или синхронный сброс). Например, в ПЛИС после загрузки информации проходит сигнал GSR -- global set reset. При этом может очищаться память (хотя раз там нет нужной информации, в этом нет необходимости).

2. Затем надо задать начальный адрес программы $A_{нач}$. Как правило, это выполняется автоматически: задаётся нулевой адрес, из которого можем куда-то переходить. При этом сброс и загрузка начального сброса могут происходит одновременно. 

3. После этого надо задать команду start, чтобы запустить систему. Начальный адрес поступает в SK -- счётчик команд. **Счётчик команд** -- предназначен для хранения текущего адреса программы (продвинутого адреса -- не текущего, а продвинутого на следующую команду). 
4. По определению программа и исходные данные хранятся в ОП, которые могут туда поступить с флешки, диска или с ПЗУ. В оперативную память происходит обращение по начальному адресу из счётчика команд. Вообще говоря, между ОП и процессором может быть кэш нескольких уровней, но в кэш дублируется часть ячеек из ОП.
5. Задаём управляющие сигналы для обращения к памяти Уск от БМК, под действием которых 
6.  Мы считываем из памяти код команды. Он поступает в регистр команды RK. При этом код команды может считываться не за одно обращение. А иногда мы наоборот, за одно обращение может считать и принять в регистр команд несколько команд, если команды короткие, а регистр многоразрядный. Код команды содержит код операции и адреса

<div align="center"><a href="https://imgbb.com/"><img src="https://i.ibb.co/myv1Xq9/image.png" alt="image" border="0"></a></div>

Команда делится на две части -- операционная и адресная. Как правило, эти поля одной и той же размерности (например, А1 имеет больше разрядов, чем Ак). В нашем процессоре двухадресные команды с разным механизмом адресации первого и второго адреса.

При этом в адресном поле могут задаваться указатели адреса или признаки адреса. Например, пусть по два разряда входят в каждый адрес, и они определяют вид адресации.

<div align="center"><a href="https://imgbb.com/"><img src="https://i.ibb.co/VMZbbSV/image.png" alt="image" border="0"></div>

При прямой адресации на адрес отводится как двоичный логарифм $M = \log_2(n)$, где $n$ -- количество байт.

7. Когда мы считали команду, следующее действие -- дешифрация кода операции. Надо определить, какая это команда -- линейная или нелинейная (она же  -- команда перехода). На размерность команды также указывает код операции: при дешифрации мы определяем не только вид команды, то ещё и размерность команды -- количество разрядов и адресов: одноадресная, двухадресная команда, какой тип адресации и так далее. Кроме того, на размерность команды может указывать и признак адреса: если мы указываем обращение к регистровой памяти, а не к оперативной, то адреса будут намного короче. На основании дешифрации определяется размерность команды, назначение полей и какую команду выполняем.

Сначала рассмотрим пример выполнения линейной команды. Для этого следующим действием будет подготовить операнды.

### Линейная команда

8. Извлечь операнды. При этом операндов не один, а несколько и адрес операндов может меняться в зависимости от механизма адресации. Поэтому сначала надо сформировать исполнительные адреса операндов в БУКе, которые поступают уже как в ОП, так и в РОНы: операнды могут находиться и в регистрах. При этом также формируются управляющие сигналы для памяти, а на выходе из неё эти операнды принимаются в буферные регистры Р1 и Р2 (или BP1, BP2, учитывая, что P1 и P2 будут зарезервированы за состояниями датчика состояний, которые находятся внутри МУУ). Эти регистры установлены между ОП и блоком операции. Мы извлекаем эти операнды последовательно так, чтобы оба они были готовы перед началом операции, потому что их мы загружаем в БО одновременно. В общем случае этих буферных регистров может быть гораздо больше там, где работает конвейер (например, в эльбрусе до 14 ступеней -- готовились операнды для выполнения 14 команд). 
9. Данными буферными регистрами управляет БМК с помощью управляющих сигналов УСk
10. Под действием управляющих сигналов выполняется загрузка операндов из памяти в Р1 и Р2.
11. После того, как мы подготовили операнды, надо начать выполнять операцию в АЛУ. Для этого АЛУ нужно сообщить, какую операцию нужно выполнить. Для этого мы сообщаем туда код операции COP': мы передаём не весь код операции, а какую-то его часть. Для наших процессоров, раз выполняется две команды, достаточно только одного бита. А есть ещё и команды перехода, у которых больше разрядов, поэтому в МУУ передаётся только часть разрядов. Поэтому кодирование команд желательно выполнить так, чтобы можно было в МУУ передавать только часть кода операции.
12. Запустить АЛУ, сообщив в его то, что всё подготовлено для опреации. Для этого подаётся SNO -- сигнал начала операции. При этом приостанавливается выполнение команды в ЦУУ и начинает работать АЛУ. (В конвейере ЦУУ после этого может готовить данные для следующей команды). 
13. В соответствии с разработанными алгоритмами выполнения операций COP', МУУ формирует управляющие сигналы Yi. Выполнение команд в БО начинается с того, что мы операнды A и B одновременно загружаем в регистры RA и RB внутри БО под действием Yi с МУУ. 
14. В алгоритме надо учитывать, что на его выполнение влияют сигналы-признаки, в соответствии с которыми могут быть ветвления или переходы $\varphi_i$ -- статусные или осведомительные сигналы. Эти сигналы посылаются в МУУ, на основании которых тот формирует те или иные сигналы $Y_i$ до тех пор, пока не закончится выполнение операции.
15. Когда операция выполнена, в ЦУУ надо сообщить об этом и формируется сигнал конца операции SKO. В регистре результата RR сформирован результат операции. По сигналу SKO завершается работа АЛУ для данной команды и запускается опять ЦУУ, которое продолжает работать над выполнением данной команды. Если ЦУУ чем-то занято, то эта команда может встать в очередь.
16. ЦУУ должно проверить, нужно ли записывать результат. Если результат записывается, то формируется исполнительный адрес результата по той же самой шине 
17. Результат записывается в ОП.
18. Некоторые из команд формируют признаки результата. Их нужно передать из регистра признака RPR в ЦУУ, который будем поступать как правило, в БМК, потому что в зависимости от признака может меняться алгоритм самой программы. При этом некоторая часть может поступать и в БУК, который может сформировать свои признаки фи перехода. Пунктиром показано, что можно решать, что регистр признака может отсутствовать в БО и/или присутствовать свой регистр признака в БУК, и на каждом шаге мы подаём признак результата в RPR в БУКе. Этот же регистр мог быть не регистром признака, а регистром флага -- где на каждый признак свой флаг, а в случае признаков, а не флагов, -- эти признаки кодируются двоичным кодом, который дальше надо дешифрировать.
19. Подготовить адрес следующей команды в счётчике команд. Для этого СК увеличивается на 1, а если команда содержит не одного слово, мы должны добавить дельту, где $\Delta$ -- это размерность команды. Она должна добавляться не обязательно в итоге, она может учитываться уже в адресации операндов, поэтому обычно адрес команды меняется по шагам. $$СК:=СК + 1(\Delta)$$В счётчике команд формируется адрес следующей команды.
Перед выполнением любой команды в счётчике команд уже находится её адрес.

У системы памяти на считывание один адресный вход, а выходных две шины --  для команды и для операндов. Иногда это может быть корректно, потому что кэш может быть L1 инструкций, и L2 данных. Но эти шины могут быть едины, и с ними же может быть соединена шина адреса, потому что всё равно данные передаются в разное время. Но сейчас это всё разделяют для ускорения.

<div align="center"><a href="https://ibb.co/3MDT34W"><img src="https://i.ibb.co/WPbHhGF/image.png" alt="image" border="0"></a></div>

### Цикл выполнения линейной команды
1. **Выборка команды из ОП** и запись в регистр команд РК **(Instruction Fetch -- IF)**
	Увеличение счётчика команд $СК:=СК+1(\Delta)$
2. **Декодирование КОП** команды и способов адресации, формирование **$A_{исп}$ операндов** **(Instruction Decoding -- ID)**
3. **Выборка (считывание) операндов** из ОП или РОН и запись в буферные регистры процессора **(Operand Reading -- OR)**
4. **Выполнение операции** в АЛУ **(Executing -- EX)**
5. **Запись результата** в ОП или РП **(Write Back -- WB)**.

В одноадресных командах результат может оставаться в регистре-аккумуляторе RR. Он может быть в составе РОН.

Увеличение счётчика команд нельзя выполнять в конце, так как адрес следующей команды может учитываться в способах адресации: там может учитываться уже продвинутый адрес, настроенный на следующую команду.

При этом считывать можно побайтно, по 2 байта или по 4, поэтому в способах адресации учитывается уже именно продвинутый адрес.

Среди этих этапов могут быть только 4, потому что в одноадресных командах участвует только один адрес, и результат такой операции записывается в аккумулятор и последнего этапа -- записи в какое-то отдельное место нет.

### Цикл выполнения нелинейной команды (перехода, цикла, возврата, пропуска)

$$\begin{array}{|c|c|c|}\hline СОР& УА&А_{пер}\\\hline\end{array}$$

УА -- указатель адреса, который может задавать способ адресации. Вместо указателя может быть признак адреса.

1. **Выборка кода команды из ОП** и запись в регистр команд РК **(Instruction Fetch -- IF)**. Увеличение счётчика команд $СК := СК + 1 (\Delta)$.
2. **Декодирование КОП** команды и формирование $A_{исп.пер}$ -- исполнительного адреса перехода:
	- **безусловный** переход $СК := A_{пер. исп}$
	- **условный** переход -- проверка условия
		- условие совпадает (признак $\text{PR}_i$ = 1)- $СК := A_{пер. исп}$
		- условие не совпадает $\text{PR}_i=0$ ⇒  $СК := СК + 1(\Delta)$

Пока мы считываем команду, счётчик команд растёт. Поэтому всегда там, где нужно, участвует именно *продвинутый* счётчик команд, настроенный на следующую команду, для того, чтобы не надо было возвращаться на исходный адрес.

При безусловном переходе происходит переход на *исполнительный* адрес перехода -- он зависит от конкретного механизма адресации.

При условном переходе возможны два варианта в зависимости от значения признака операции. Если он равен единице, то в счётчик команд загружается исполнительный адрес перехода -- не тот, который может стоять в коде команды, а уже вычисленный в соответствии с конкретным механизмом адресации с учётом указателя адреса. Иначе -- если он равен 0, то в счётчик команд загружается $\Delta$ -- размерность команды: для общего случая она считается в байтах, в наших случаях -- 4 разряда или полубайты. При этом команды должны быть плотно расположены без пропуска. Эта $\Delta$ добавляется не сразу, а последовательно и постепенно: где-то на 1, где-то на 2: зависит от того, как команды программы "упакованы" в оперативную память. Поскольку команды находятся плотно друг за другом, то приходится добавлять эту разную величину. После добавления дельты, равной размерности команды, получается *продвинутый адрес*.

Память у нас 8-разрядная, поэтому 12-разрядную команду можно записывать в одну ячейку 8 бит, и половину команды в другую ячейку. Потом во второй половине второй ячейки начинается вторая команда: никаких пропусков быть не должно. Поэтому 12-разрядная команда будет занимать полторы ячейки памяти.

Если условие не совпадает, мы, как правило, идём на следующую команду, которая отличается на дельту -- размерность команды. Например, команда имела 100 адрес и занимает три полуслова, значит, мы должны уйти на 103 адрес.

Адреса формируются не в блоке операции. Для этого существуют свои сумматоры и счётчики, которые находятся в БУКе. Аналогично и счётчик команд, который тоже находится в БУКе, тоже может суммировать какое-то смещение, поэтому и у него тоже есть свой сумматор.

Команда пропуска (как правило, с условием) отличается от других команд перехода тем, что в ней нет адресного поля. Она безадресная, и в КОП уже записано, сколько байтов надо пропустить. Таким образом исключается адресное поле. Команда пропуска заключается в том, что мы "перепрыгиваем" через следующую команду -- осуществляется пропуск одной команды заданной размерности.


В команде перехода мы не передали управление в АЛУ. Если в линейной команде после выборки операндов управление передаётся в АЛУ, то все команды перехода выполняются целиком в ЦУУ.

На схемах пересылка данных изображается двойными линиями, управляющих сигналов -- одинарными.

У системы памяти может быть и своё местное устройство управления. Это вообще относится к каждому устройству в процессоре.

В этой схеме условно отмечены, что в каждом блоке могут быть очереди: в процессоре выполняется совмещение команд -- конвейер. Поэтому в регистре команд условно на входе присутствуют очередь. Такая же очередь есть и на выходе этого регистра, такие очереди есть на буферных регистрах операндов. Очереди есть и на выходе регистра результата, чтобы мы не сразу считывали.

Входные данные могут загружаться через флешку или другое внешнее устройство с помощью контроллера ввода вывода в ОП

Здесь показана отдельно шина информации и шиана адреса. ЗДесь шина данных одна, с которой поступает информация как в БУК, так и в буферные регистры операндов. По этой же самой шине результат записывается в ОП.

Чтобы ускорить, шин таких могут быть две: одна на выдачу информации, а другая -- на приём, то есть память может быть двухпортовая с точки зрения памяти и считывания.

Кроме того, могут быть шины из кеша первого уровня L1. Кэш верхнего уровня делится на два блока -- блок инструкций и блок данных, поэтому могут быть отдельные шины, связывающие команды и данные. 

Мы будем разрабатывать два устройства: МУУ схемного типа (БО), а БМК будет выполнено с помощью микропрограмм. На данной схеме БМК раскрыто как устройство схемного типа с жёсткой логикой.

### БУК 

Блок управления командами. В его состав могут входить

#### Счётчик команд

 Счетчик команд (иногда называют регистром инструкций: можно перед регистром поставить сумматор и получить счётчик -- это бывает удобно чтобы прибавлять смещение в относительной адресации). Относительная адресация -- текущее содержимое счётчика команд + смещение, которое написано в самой команде. Поскольку у нас у всех будет смещение в командах перехода, предлагается использовать не *A* (это адрес в ОП) или *R* (это регистр), а, например, *SM* (смещение) или что-то другое.
 
#### Регистр команд

Предназначен для хранения текущей выполняемой программы. На его входе может быть очередь из последующих команд. В команде находится КОП, который указывает на то, какую операцию нужно выполнять, и несколько адресов -- сколько-адресная команда, столько и адресов A~i~ будет. Кроме того, там же могуп быть и признаки, указывающие на то, какая это адресация. В адресах могут быть номера регистров, смещения и так далее.

При проектировании надо будет выбрать свой механизм адресации из книжке на сайте.

Начальный адрес должен загружаться в счётчик команд (это один из первых шагов при запуске процессора). Если мы будем начинать программу с нулевого адреса, можно одновременно с CLR обнулять счётчик команд, и тогда это не понадобится. А в общем случае перед счётчиком команд стоит мультиплексор, который бирает либо начальный адрес, либо следующий адрес команды.

Если адресация *команд* относительная, то нужен сумматор, на который поступают счётчик команд и смещение --  получаем исполнительны адрес, например, следующей команды, который будет передаваться не в память, а через мультиплексор опять в счётчик команд. 

У относительной адресации есть плюс: мы не привязаны к конкретным адресам в памяти: это полезно при многопрограммном режиме (для выполнения нескольких программ просто загружает начальный адрес A~нач~ в счётчик команд). Ещё один плюс -- укорачивание разрядного поля, потому что смещение может быть неполным (коротким, не все разряды) и иметь знак: мы можем идти как вперёд, так и назад.

#### Сумматор

Здесь условно показано: сумматор может суммировать и не два, а три операнда -- это ведь структурная схема. Этот сумматор может быть реализован внутри на двух сумматорах: например, один сумматор, а за ним второй и будет стоять КСЮЮ которая блокирует какие-то операнды.

#### Регистр очереди

Это регистр адресов, которые могут быть как адресами перехода, загружаемые в счётчик команд, так и адресами операндов.

Из регистра индекса (это могут быть самостоятельными регистрами), но в наших процессорах может быть и регистр базы для базового адреса, и они могут быть и в блоке регистров вместе с РОН. Из них в нужный момент можно извлечь информацию для индексной адресации. (считается, что если нужен индекс, то известно, из какого регистра надо брать значение -- это показано шиной между блоком регистров и регистром индекса R~i~). Регистр индекса и смещения могут находиться и внутри в адресе команды.

Исполнительный адрес A~исп~-- база + индекс + смещение (показано). Они полезны для обработки массивов и статистики.

#### Регистр исполнительного адреса

При косвенной адресации (берём адрес из команды -- мы обращаемся по нему в ОП и уже этот адрес, который мы вытащили из ОП, и будет исполнительным), нужен будет дополнительный регистр исполнительного адреса.  В других случаях он может отсутствовать.


Может быть и многоступенчатая косвенная адресация -- это может быть отмечено в признаке адреса, и тогда таких итераций извлечения адресов и хождений по памяти может быть много. Это возможно при выполнении поиска в каких-то системах.

Для общего случая может и блок операций быть не один, а несколько: например, отдельный БО для фиксированной и плавающей запятой, аналогично с РОНами: могут быть РОНы только связанные с адресами, РОНы для плавающих чисел и так далее. Также могут быть отдельные регистры для базы и индекса -- это всё используется для ускорения выполнения команд и параллелизации.

Например, один БО выполняет умножение, а поскольку эти операции длинные, то можно параллельно запускать другой БО. Даже в ПЛИС, учитывая, что умножение используется часто, предусмотрена автоматическая настройка 19 блоков умножения в spartan 6.

### БМК

Назначение БМК -- формировать управляющие сигналы, которые могут управлять, в первую очередь, БУКом и плюс другими блоками в процессоре: сигналы могут идти в память, на блоки ввода-вывода и идти в АЛУ. БМК может быть только один -- это централизованное устройство управления, а может быть децентрализованное: много местных устройств управления в каждом блоке, а БМК только посылает на них сигналы начала работы и принимает сигналы конца.

В данном случае мы рассматриваем БМК жёсткой логики

Код операции поступает из регистра команд и дешифрируется -- на выходе имеем унитарный код.

Комбинационная схема формирует игреки: на каждом элементе внутри от того, какую нужно выполнять операцию, от того, в каком состоянии находится РИЦ (распределитель импульсов цикла в унитарном коде: на каком такте на каком шаге цикла мы находимся) и от фи для ветвлений подаются управляющие сигналы Y. В ней как минимум столько элементов, сколько игреков может быть. Таким образом, $$Y = f(РИЦ, ДШКОП, \varphi)$$Такие жёсткие схемы быстрые, потому что у них внутри задержка только одного элемента. Но они более сложные, потому что при внесении изменении нужно перепроектировать чуть ли не всю схему. А микропрограммные схемы зато проще.

#### Генератор импульсов (Главный генератор импульсов)

Может быть всего один ГГИ -- он будет находиться в БМК, и по нему можно формировать уже отдельные импульсы (С1 С2 как а лабе про регистры). Из этого главного генератора могут вырабатываться сколько других фаз импульсов. От него можно делить частоту.

В ПЛИС можно настраивать сдвиг этих импульсов от ГГИ с точностью до десятков пикосекунд. Важно, чтобы они потом не встретились на одном синхровходе. Они могут даже накладываться, если импульсы приходят на разные синхровходы разных блоков.

#### Схема пуска-останова (СПО)

Она обязательно присутствует в каждом местном устройстве. Она разрешает проходить синхроимпульсам между сигналами СНО и СКО, вырезая пачку импульсов из бесконечной последовательности от генератора между СНО  и СКО. А может и не вырезать эту пачку импульсов, а просто запрещать работать. В любому случае, там внутри стоит триггер, который переключается по СНО и СКО. Например, этот триггер потом будет разрешать или запрещать формирование игреков внутри КС. А можно вырезать пачку импульсов (как СЕ). Тогда КС может оказаться проще, чтобы не ставить у каждого элемента, отвечающего за Y, соединение с этим триггером: можно просто запретить синхроимпульсам проходить внутрь блока.


#### Блок очереди

В нём хранится очередь кодов операций. Мы могли из команды отправить адреса на формирование -- но мы их ещё не извлекли, операнды не сформировали, и пока это происходит, надо ждать и хранить код операции в очереди до тех пор, пока операнды не придут.

Внутри отдельно могут сотять счётчики циклов и счётчики тактов, еасли микрокоманда выполняется несколько тактов. Счётчик циклов отвечает за подсчёт i в циклах. Такие счётчики могут находиться в каждом местном устройстве управления.

### Память

Она показана как часть системы памяти -- это может быть ОП, до 4 уровней кэша.

ОП по определению в состав процессора не входит, но на кристалле самого процессора есть L1 кэш инструкций и L1 кэш данных, а L2 опционально. 

ОП -- как правило, динамическая память, в которой хранение информации происходит на конденсаторах.

Ещё один вариант построения БМК -- микропрограммный: она содержит управляющую память.

В памяти показаны условно регистр информации или регистр данных (хотя отсюда можно считывать и команды) и регистр адреса. В наших процессорах их не будет: адрес мы поддерживаем, и память при считывании будет работать как КС: память строится на лутах, на входах которых мы задаём адреса. С выходов памяти мы загружаем информацию в буферные регистры.

Также контроллер ввода-вывода может соединяться шиной прямого доступа с памятью.

По определению вся программа и все данные находятся в ОП, поэтому прежде чем процессор начнёт работать, данные надо загрузить в кэш данных, а команды в кэш команд. 

При этом в кэшах информация может быть согласована (когерентная), потому что она дублируется, а в какие-то моменты времени в зависимости от методов записи она может и не совпадать.

У нас будут двухпортовые памяти: одна на запись, другая на считывание. А тут показано, что считыванием и пишем через одну и ту же шину.

Подобную схему можно посмотреть на 4-6 странице в учебном пособии по проектированию процессора.

## Принципы организации управления

1. Уровень управления
	- Программный -- алгоритмы представлены наборами команд
	- Микропрограммные -- алгоритмы представлены микропрограммами выполнения команд

2. Централизованный или децентрализованный принцип
3. По типу (принципу) построения
	- с жёсткой логикой ("схемного типа" СхУУ) -- основой является РИЦ и КС
	- микропрограммное УУ (МкУУ) -- основой является управляющая память

4. Способ организации
- синхронный
- асинхронный (полусинхронный)

**Микрооперация** -- элементарная функциональная микрооперация

**Микрокоманда** -- совокупность совместимых микроопераций, выполняемых одновременно (например, RA := A, RB := B, RR := 0)

**Микропрограмма** -- последовательность микрокоманд, обеспечивающих выполнение машинной команды

**Централизованное УУ** общее для всех блоков

**Децентрализованное УУ** -- когда ЦУУ и МУУ:
- ЦУУ  формирует подготовительные сигналы: запуск
- МУУ формирует исполнительные сигналы
	- сокращает количество шин, расположено ближе к блоку
	- проще проектирование и реализация: меньше сигналов ⇒ меньше вероятность ошибиться
	- легче реализовать совмещение команд: можно запускать несколько блоков сразу
	- может иметь место сокращение аппаратных средств. Иногда какие-то блоки, например, триггеры пуска-остановка, РИЦ ставить в каждом блоке, поэтому сокращение не гарантировано.

**Синхронный способ** -- предполагает выбор фиксированного **постоянного такта T = const** выполнения микрокоманд, равного *максимальному* времени выполнения МК

**Асинхронный способ** -- длительность такта имеет **переменную величину такта Ti = vary**, необходимую для каждой МК

**Полусинхронный способ** -- каждая К-я МК выполняется за **необходимое количество тактов** генератора Ti = Ki * t, где t -- период генератора


**Разрабатываемый процессор**:
- на уровне микрокоманд -- синхронный
- на уровне микропрограмм -- полусинхронный (асинхронный): умножение выполняется, например, за 10 тактов, а сложение -- за 4. 

# Характеристики процессора и способы адресации

### Основные характеристики процессора

**1. Внутренний язык** -- система команд, форматы команд и данных. 

**2. Способы адресации**

**3. Конвейеризация команд** (количество команд и ступеней (этапов) в конвейере). Конвейеризация позволяет параллельное выполнение нескольких команд. Конвейеризация позволяет разбивать команду на несколько этапов (одновременно работают все блоки), а параллелизация -- разбивает на несколько блоков (параллельно работают одинаковые блоки). Для этого используется буферная память FIFO.

**4. ОЗУ** (ёмкость, организация, статическая, динамическая). При этом *физический* адрес -- это адрес при обращении к памяти (то есть к ячейкам), а *логический* -- адрес до байта. При этом если мы считываем два байта, адрес должен быть обязательно чётным: если мы хотим считать 0 и 1 байты, логическим адресом будет 0. Если мы хотим считать 4 слова, то чётность адреса должна быть двойная (в конце адреса должны быть сразу два нуля). Это делается, потому что обмен между памятью и процессором идёт блоками. Если мы будем указывать рандомные адреса, то тогда у нас может получиться так, что считываемые нами данные окажутся в разных блоках.

**5. Наличие и организация СОЗУ (Сверхоперативного ЗУ)**:
- **РОН** (количество и разрядность; для фиксированной и плавающей запятых): будут ли РОНы единые или отдельные для ПЗ и ФЗ. Если они единые, то тогда при работе с ПЗ будут заниматься два регистра сразу. В современных процессорах 32 или 64 регистра, при этом 4 или 8 регистров могут быть выделены для отдельной работы с плавающей запятой.
- **Служебные регистры** (базы, индекса, сегмента, страниц, ...) -- присутствуют ли отдельно эти регистры или же они находятся в РОНах. В наших вариантах процессора они располагаются в РОНах. Кроме того, на входах этих регистров могут стоять буферы.
- **Стек** для выполнения арифметических операций: в стек мы можем записывать результат предыдущих операций и брать операнды оттуда же. При этом команды работы со стеком могут быть безадресными и содержать только коды операции. Также стек используется для организации циклов.
- **Кэш** (иерархия: до 4 уровней L1-L4, ёмкость и организация, методы записи и замещения, где находятся кэши разных уровней -- на кристалле или на плате).

**5. Быстродействие и производительность**. Быстродействие (частота генератора: например, 4 ГГц), а производительность -- количество операций в секунду.

Чтобы оценить быстродействие АЛУ, надо будет подключить макет на отдельной странице: важно, что мы подключаем выходы всех элементов (например, регистры результата или регистры признака) к выходным индикаторам, то размещение может получиться неудачным, так как эти связи могут быть просто удалены. Кроме того, при размещении надо будет привести количество ЛУТов и триггеров в отчёте или как отдельной главой, или в МУУ (АЛУ), где будет приводиться оценка временных параметров.

### Формат команды

Набор операций должен быть функционально полным, чтобы можно было выполнить любые программы. При этом можно определять, какие команды выполняются арифметически, а какие -- с помощью микропрограмм: можно "подкачивать" те или иные микрокоманды. Например, команду деления можно не включать в набор команд процессора, а выполнять отдельно как подпрограмму, записанную в отдельное запоминающее устройство. Таким образом, можно определить, какие команды выполняются аппаратно, а какие -- программно.

Набор команд может быть различным. Существуют две тенденции развития процессоров -- RISC и CISC:
- **RISC -- Reduced Instruction Set Computer** --  уменьшенный набор команд
- **CISC -- Complete Instruction Set Computer** -- полный набор команд процессора

При этом в универсальных процессорах CISC могло содержаться до 600 команд (IBM/370) ради преемственности поколений: если программы работали на одном процессоре, то было бы хорошо, чтобы они продолжали работать и на более новых версиях процессоров. Однако из этих команд большинство никто никогда не применял.


### Набор команд или операций делится на группы

Чтобы можно было декодировать не все разряды, а только какую-то часть (группу), где старшие разряды определяют, к какой группе команд относится команда, а младшие -- какая это конкретно команда:
- арифметические (фиксированная и плавающая запятая, дробные и целые)
- десятичная арифметика
- логические, работа над битами и строками, сдвиги
- обмен, передача данных
- управление и переходы безусловные и условные, пропуски, циклы

**Эффективность набора команд характеризуется**:
- аппаратными затратами на размещение программ и данных
- затратами времени на реализацию алгоритмов (тесты для сравнения). Например,
- удобством для пользователей (хорошее понимание, усвоение)


При этом нужно определять, все ли операции выполнять аппаратно, то есть включать в код операции, или реализовывать их как подпрограммы.

### Размещение в памяти

Надо определить, где будут располагаться программа, операнды, константы и рабочие ячейки. Важно, что между этими блоками, кроме программы, могут быть свободные места, но в программах пропусках быть не должно.

<a href="https://ibb.co/F4Mpxk5"><img src="https://i.ibb.co/nMvpgq7/image.png" alt="image" border="0"></a>

Программы упаковываются плотно, на уровне слов (байтов) между командами пропусков нет.

При этом в первом считываемом байте должен находиться код операции, потому что он определяет размерность команды. За одно обращение (одна строка здесь -- это ячейка памяти) мы считываем два слова -- одну ячейку. А логический адрес -- это тот, который будет в счётчике команд, поэтому у первой команды будет адрес 0, а у второй -- 3.

В отличие от пособия, предлагается чётные адреса располагать в левой части: например, в 8-разрядной памяти слева будет 7 разряд, а справа -- нулевой, учитывая, что память, которую мы будем заполнять (logic block), считывается так, что старший разряд находится слева. Поэтому чётные -- это 7-4 разряды, а нечётные -- это 3-0 разряды.

В отличие от команд, данные могут располагаться с пропусками.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/HYfWyx0/image.png" alt="image" border="0"></a>

При этом в наших примерах операнд будет занимать 1 слово, а результат -- 8, причём пишутся они в одну ячейку. Поэтому операнды обязательно находятся в одной ячейке.

При этом при работе транслятора мы должны были описать С как двухсловную ячейку, и он должен был отвести сразу два слова под них.

В БУКе самое главное -- не запутаться с разрядами, размечая память операндами и командами, -- где старший разряд, а гле младший.

При этом если старшие разряды не равны нулю, в программе нужно вводить какое-то масштабирование, потому что восьмиразрядное число мы уже не можем складывать и умножать.

### Адресность

**Адресность** -- количество адресов в команде (0А -- безадресная, 1А, 2А и 3А)

**Адрес** характеризуется разрядностью и количество разрядов


Например, нам нужно вычислить функцию Y = A*B + (C-D) * E/F

Например, для трёхадресных команд мы выполняем 5 команд. Р1, Р2 -- это рабочие ячейки: там нельзя написать А или В, потому они будут испорчены, а они могут понадобиться в других операциях. Для этого мы вводим дополнительные рабочие ячейки, в которых будем хранить промежуточные результаты вычислений.

В двухадресной команде результат записывается по адресу одного из операндов. Поэтому мы на первом шаге производим считывание в рабочую ячейку А, а результат записывается по адресу первого операнда, хотя в наших заданиях это может быть и не так. Команд уже стало 8.

В одноадресной команде используется регистр-аккумулятор Ra.

<a href="https://ibb.co/fQVs0WJ"><img src="https://i.ibb.co/PtsdCyk/image.png" alt="image" border="0"></a>

### Способы и механизмы адресации

**Способ адресации** устанавливает процедуру (порядок) вычисления адреса оперативной памяти, по которому проводится фактическое обращение -- называется исполнительным адресом А~исп~ (А~физ~)

Эффективность способов адресации характеризуется
- затратами оборудования на обеспечение доступа к памяти (схема формирования А~исп~)
- затратами времени на формирование А~исп~ и времени доступа к ячейке памяти по этому адресу (считывание или запись)

### Прямая адресация

В своих отчётах также надо будте рисовать свою адресацию. Вместо "Адрес" пишем А1 (адрес первого операнда), R, если номер регистра, или SM, если смещение.

В отчётах на каждой шине (стрелке) должна будет стоять разрядность.

Никаких аппаратных затрат на формирование адреса нет, а время цикла равно времени обращения к оперативной памяти.

Вместо "Память" надо будет писать ОП.

<a href="https://ibb.co/L8bsMLS"><img src="https://i.ibb.co/dr1HSdB/image.png" alt="image" border="0"></a>

Может быть и короткая прямая адресация: чтобы сократить адресное поле, адресация может дополняться старшими разрядами, на что может указывать старший разряд адреса (0 или 1  будет указывать, чем конкретно дополняется адрес). Если мы дополнили адрес единицей, то это все адреса будут расположены во второй половине памяти. Поэтому операнды мы можем располагать, например, во второй половине памяти и тем самым выиграть один разряд адреса операндов, не указывая их старший разряд (1).

### Регистровая адресация

<a href="https://imgbb.com/"><img src="https://i.ibb.co/PrVWfsN/image.png" alt="image" border="0"></a>

R -- номер регистра. Если он относится ко второму операнду, то мы пишем R2.

Время обращения будет маленьким, потому что регистровая память будет быстрее. Хотя в наших процессорах что регистры, что ОП находятся на одном и том же кристалле, поэтому мы этого не увидим

<a href="https://ibb.co/HPR3m23"><img src="https://i.ibb.co/mydgQBg/image.png" alt="image" border="0"></a>

Ёмкость ОП намного больше ёмкость РП, поэтому количество разрядов для адресации в ОП значительно больше, чем в РП.

### Непосредственная адресация

Операнд извлекаем не из ОП, а из команды.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/Wpz3vsz/image.png" alt="image" border="0"></a>

В качестве второго операнда может быть константа (и тогда это поле можно будет уменьшать).

### Неявная адресация

В команде нет соответсвующего адреса. Он может подразумеваться, например, кодом операции. Например, таим адресом может быть регистр аккумулятора.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/0GT12xM/image.png" alt="image" border="0"></a>

### Косвенная прямая адресация

<a href="https://ibb.co/GsGq17f"><img src="https://i.ibb.co/ZHv0wdR/image.png" alt="image" border="0"></a>

Адрес указывает не на операнд, а на другой адрес. В данном случае будет 2 цикла обращения к ОП. При этом нужен будет внутри дополнительно регистр исполнительного адреса: адрес, который извлекли в первый раз, запомнили в этом регистре, а потом использовали этот адрес при втором обращении к памяти.

Любой адрес в команде, по которому мы обращаемся напрямую, должен быть полным.

### Многоступенчатая косвенная адресация

Ещё один разр





<!--stackedit_data:
eyJoaXN0b3J5IjpbMTkxMjQ3NjM5MywtNzQwOTg2NDc5LDEyMT
cyMDUxNjcsMTEyMDkzOTA5MSw1Mjc3OTk3OSwtMTQzODY2MDQ4
LDIxMDYxMDMzMDUsLTE3MDE0ODkxODUsLTExMDA2MTYyMywtOD
M5OTg5MDMzLDM2NDU5MTM5MiwtMTYyNTMyMDAyMywxMjE5NTI0
OTQ1LDEyMTM1Mjk0OSwtMjA5NzU0NTIyOSw2MzIyODI0NjUsMT
c1MzI0NTMzMCwtMTI1MTMxODcsMTU1MjQ0NTQ4XX0=
-->