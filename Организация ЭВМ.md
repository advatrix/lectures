
# Общая структурная схема процессора


БО -- блок, который непосредственно выполняет арифметико-логические операции.

Управляет блоком операции МУУ -- местное устройство управления. Он формирует управляющие сигналы для выполнения арифметико-логических операций на БО.

ЦУУ -- центральное устройство управления. 

П -- память или система памяти. Она мб показана пунктиром, потому что из системы памяти внутри процессора находится только кэш, а ОП по определению находится вне процессора (максимум только какая-то её часть).

Блок операции и МУУ вместе образуют АЛУ -- арифметико-логическое устройство. Оно выполняет арифметические и логические операции.

Пунктирные блоки -- опциональные -- блок контроля и диагностики и блок связи с каналами (с внешними устройствами).

Блок контроли и диагностика работает при включении компьютера: он выполняет некоторое тестирование. Контроль от диагностики отличается тем, что контроль -- то, что выполняется во время работы процессора при осуществлении операций, а диагностика -- это специальный режим проверки, какой из блоков не работает (например, контроль по чётности -- это когда к данным или командам добавляются дополнительные разряды, которые контролируются в процессе выполнения).

У нас эти пунктирные блоки отсутствуют. Они не входят в состав процессора, так как они опциональные.

Внутри ЦУУ -- устройство, которое занимает верхний уровень в иерархии управления, делится на БУК и БМК.

**БУК** -- блок управления командами. Он формирует **исполнительные** адреса операндов и адреса следующей команды или следующих команд. То есть он управляет последовательностью команд.

**БМК** -- блок формирования (выработки) микрокоманд. Он отвечает за формирование управляющих сигналов для управления другими блоками процессора. Фактически там же формируется $Y_C$.

Можно было ьы считать, что как по аналогии в АЛУ БУК -- это как БО, а БМК -- это как МУУ.

Система памяти состоит из ОП и РОН (регистры общего назначения). Также там может быть кэш нескольких уровней, а ВЗУ -- внешнее запоминающее устройство, обычно реализуется через связи с внешними устройствами.

**Процессор** -- это устройство, осуществляющее процесс обработки данных по заданной программе.

**Центральный процессор** -- это процессор, в состав которого входят устройства управления, АЛУ, и который осуществляет наряду с обработкой данных управление другими устройствами ЭВМ.

ЦУ в иерархии подчинения занимает самое высокое место.

<a href="https://ibb.co/3Nj4mDD"><img src="https://i.ibb.co/C7YmKkk/image.png" alt="image" border="0"></a>

Работа процессора начинается с включения питания. 

После этого может осуществляться автоматический контроль (но он опциональный, это не рассматриваем)

1. Самое первое, что надо выполнить после включения питания, -- сброс (CLR или синхронный сброс). Например, в ПЛИС после загрузки информации проходит сигнал GSR -- global set reset. При этом может очищаться память (хотя раз там нет нужной информации, в этом нет необходимости).

2. Затем надо задать начальный адрес программы $A_{нач}$. Как правило, это выполняется автоматически: задаётся нулевой адрес, из которого можем куда-то переходить. При этом сброс и загрузка начального сброса могут происходит одновременно. 

3. После этого надо задать команду start, чтобы запустить систему. Начальный адрес поступает в SK -- счётчик команд. **Счётчик команд** -- предназначен для хранения текущего адреса программы (продвинутого адреса -- не текущего, а продвинутого на следующую команду). 
4. По определению программа и исходные данные хранятся в ОП, которые могут туда поступить с флешки, диска или с ПЗУ. В оперативную память происходит обращение по начальному адресу из счётчика команд. Вообще говоря, между ОП и процессором может быть кэш нескольких уровней, но в кэш дублируется часть ячеек из ОП.
5. Задаём управляющие сигналы для обращения к памяти Уск от БМК, под действием которых 
6.  Мы считываем из памяти код команды. Он поступает в регистр команды RK. При этом код команды может считываться не за одно обращение. А иногда мы наоборот, за одно обращение может считать и принять в регистр команд несколько команд, если команды короткие, а регистр многоразрядный. Код команды содержит код операции и адреса

<div align="center"><a href="https://imgbb.com/"><img src="https://i.ibb.co/myv1Xq9/image.png" alt="image" border="0"></a></div>

Команда делится на две части -- операционная и адресная. Как правило, эти поля одной и той же размерности (например, А1 имеет больше разрядов, чем Ак). В нашем процессоре двухадресные команды с разным механизмом адресации первого и второго адреса.

При этом в адресном поле могут задаваться указатели адреса или признаки адреса. Например, пусть по два разряда входят в каждый адрес, и они определяют вид адресации.

<div align="center"><a href="https://imgbb.com/"><img src="https://i.ibb.co/VMZbbSV/image.png" alt="image" border="0"></div>

При прямой адресации на адрес отводится как двоичный логарифм $M = \log_2(n)$, где $n$ -- количество байт.

7. Когда мы считали команду, следующее действие -- дешифрация кода операции. Надо определить, какая это команда -- линейная или нелинейная (она же  -- команда перехода). На размерность команды также указывает код операции: при дешифрации мы определяем не только вид команды, то ещё и размерность команды -- количество разрядов и адресов: одноадресная, двухадресная команда, какой тип адресации и так далее. Кроме того, на размерность команды может указывать и признак адреса: если мы указываем обращение к регистровой памяти, а не к оперативной, то адреса будут намного короче. На основании дешифрации определяется размерность команды, назначение полей и какую команду выполняем.

Сначала рассмотрим пример выполнения линейной команды. Для этого следующим действием будет подготовить операнды.

### Линейная команда

8. Извлечь операнды. При этом операндов не один, а несколько и адрес операндов может меняться в зависимости от механизма адресации. Поэтому сначала надо сформировать исполнительные адреса операндов в БУКе, которые поступают уже как в ОП, так и в РОНы: операнды могут находиться и в регистрах. При этом также формируются управляющие сигналы для памяти, а на выходе из неё эти операнды принимаются в буферные регистры Р1 и Р2 (или BP1, BP2, учитывая, что P1 и P2 будут зарезервированы за состояниями датчика состояний, которые находятся внутри МУУ). Эти регистры установлены между ОП и блоком операции. Мы извлекаем эти операнды последовательно так, чтобы оба они были готовы перед началом операции, потому что их мы загружаем в БО одновременно. В общем случае этих буферных регистров может быть гораздо больше там, где работает конвейер (например, в эльбрусе до 14 ступеней -- готовились операнды для выполнения 14 команд). 
9. Данными буферными регистрами управляет БМК с помощью управляющих сигналов УСk
10. Под действием управляющих сигналов выполняется загрузка операндов из памяти в Р1 и Р2.
11. После того, как мы подготовили операнды, надо начать выполнять операцию в АЛУ. Для этого АЛУ нужно сообщить, какую операцию нужно выполнить. Для этого мы сообщаем туда код операции COP': мы передаём не весь код операции, а какую-то его часть. Для наших процессоров, раз выполняется две команды, достаточно только одного бита. А есть ещё и команды перехода, у которых больше разрядов, поэтому в МУУ передаётся только часть разрядов. Поэтому кодирование команд желательно выполнить так, чтобы можно было в МУУ передавать только часть кода операции.
12. Запустить АЛУ, сообщив в его то, что всё подготовлено для опреации. Для этого подаётся SNO -- сигнал начала операции. При этом приостанавливается выполнение команды в ЦУУ и начинает работать АЛУ. (В конвейере ЦУУ после этого может готовить данные для следующей команды). 
13. В соответствии с разработанными алгоритмами выполнения операций COP', МУУ формирует управляющие сигналы Yi. Выполнение команд в БО начинается с того, что мы операнды A и B одновременно загружаем в регистры RA и RB внутри БО под действием Yi с МУУ. 
14. В алгоритме надо учитывать, что на его выполнение влияют сигналы-признаки, в соответствии с которыми могут быть ветвления или переходы $\varphi_i$ -- статусные или осведомительные сигналы. Эти сигналы посылаются в МУУ, на основании которых тот формирует те или иные сигналы $Y_i$ до тех пор, пока не закончится выполнение операции.
15. Когда операция выполнена, в ЦУУ надо сообщить об этом и формируется сигнал конца операции SKO. В регистре результата RR сформирован результат операции. По сигналу SKO завершается работа АЛУ для данной команды и запускается опять ЦУУ, которое продолжает работать над выполнением данной команды. Если ЦУУ чем-то занято, то эта команда может встать в очередь.
16. ЦУУ должно проверить, нужно ли записывать результат. Если результат записывается, то формируется исполнительный адрес результата по той же самой шине 
17. Результат записывается в ОП.
18. Некоторые из команд формируют признаки результата. Их нужно передать из регистра признака RPR в ЦУУ, который будем поступать как правило, в БМК, потому что в зависимости от признака может меняться алгоритм самой программы. При этом некоторая часть может поступать и в БУК, который может сформировать свои признаки фи перехода. Пунктиром показано, что можно решать, что регистр признака может отсутствовать в БО и/или присутствовать свой регистр признака в БУК, и на каждом шаге мы подаём признак результата в RPR в БУКе. Этот же регистр мог быть не регистром признака, а регистром флага -- где на каждый признак свой флаг, а в случае признаков, а не флагов, -- эти признаки кодируются двоичным кодом, который дальше надо дешифрировать.
19. Подготовить адрес следующей команды в счётчике команд. Для этого СК увеличивается на 1, а если команда содержит не одного слово, мы должны добавить дельту, где $\Delta$ -- это размерность команды. Она должна добавляться не обязательно в итоге, она может учитываться уже в адресации операндов, поэтому обычно адрес команды меняется по шагам. $$СК:=СК + 1(\Delta)$$В счётчике команд формируется адрес следующей команды.
Перед выполнением любой команды в счётчике команд уже находится её адрес.

У системы памяти на считывание один адресный вход, а выходных две шины --  для команды и для операндов. Иногда это может быть корректно, потому что кэш может быть L1 инструкций, и L2 данных. Но эти шины могут быть едины, и с ними же может быть соединена шина адреса, потому что всё равно данные передаются в разное время. Но сейчас это всё разделяют для ускорения.

<div align="center"><a href="https://ibb.co/3MDT34W"><img src="https://i.ibb.co/WPbHhGF/image.png" alt="image" border="0"></a></div>

### Цикл выполнения линейной команды
1. **Выборка команды из ОП** и запись в регистр команд РК **(Instruction Fetch -- IF)**
	Увеличение счётчика команд $СК:=СК+1(\Delta)$
2. **Декодирование КОП** команды и способов адресации, формирование **$A_{исп}$ операндов** **(Instruction Decoding -- ID)**
3. **Выборка (считывание) операндов** из ОП или РОН и запись в буферные регистры процессора **(Operand Reading -- OR)**
4. **Выполнение операции** в АЛУ **(Executing -- EX)**
5. **Запись результата** в ОП или РП **(Write Back -- WB)**.

В одноадресных командах результат может оставаться в регистре-аккумуляторе RR. Он может быть в составе РОН.

Увеличение счётчика команд нельзя выполнять в конце, так как адрес следующей команды может учитываться в способах адресации: там может учитываться уже продвинутый адрес, настроенный на следующую команду.

При этом считывать можно побайтно, по 2 байта или по 4, поэтому в способах адресации учитывается уже именно продвинутый адрес.

Среди этих этапов могут быть только 4, потому что в одноадресных командах участвует только один адрес, и результат такой операции записывается в аккумулятор и последнего этапа -- записи в какое-то отдельное место нет.

### Цикл выполнения нелинейной команды (перехода, цикла, возврата, пропуска)

$$\begin{array}{|c|c|c|}\hline СОР& УА&А_{пер}\\\hline\end{array}$$

УА -- указатель адреса, который может задавать способ адресации. Вместо указателя может быть признак адреса.

1. **Выборка кода команды из ОП** и запись в регистр команд РК **(Instruction Fetch -- IF)**. Увеличение счётчика команд $СК := СК + 1 (\Delta)$.
2. **Декодирование КОП** команды и формирование $A_{исп.пер}$ -- исполнительного адреса перехода:
	- **безусловный** переход $СК := A_{пер. исп}$
	- **условный** переход -- проверка условия
		- условие совпадает (признак $\text{PR}_i$ = 1)- $СК := A_{пер. исп}$
		- условие не совпадает $\text{PR}_i=0$ ⇒  $СК := СК + 1(\Delta)$

Пока мы считываем команду, счётчик команд растёт. Поэтому всегда там, где нужно, участвует именно *продвинутый* счётчик команд, настроенный на следующую команду, для того, чтобы не надо было возвращаться на исходный адрес.

При безусловном переходе происходит переход на *исполнительный* адрес перехода -- он зависит от конкретного механизма адресации.

При условном переходе возможны два варианта в зависимости от значения признака операции. Если он равен единице, то в счётчик команд загружается исполнительный адрес перехода -- не тот, который может стоять в коде команды, а уже вычисленный в соответствии с конкретным механизмом адресации с учётом указателя адреса. Иначе -- если он равен 0, то в счётчик команд загружается $\Delta$ -- размерность команды: для общего случая она считается в байтах, в наших случаях -- 4 разряда или полубайты. При этом команды должны быть плотно расположены без пропуска. Эта $\Delta$ добавляется не сразу, а последовательно и постепенно: где-то на 1, где-то на 2: зависит от того, как команды программы "упакованы" в оперативную память. Поскольку команды находятся плотно друг за другом, то приходится добавлять эту разную величину. После добавления дельты, равной размерности команды, получается *продвинутый адрес*.

Память у нас 8-разрядная, поэтому 12-разрядную команду можно записывать в одну ячейку 8 бит, и половину команды в другую ячейку. Потом во второй половине второй ячейки начинается вторая команда: никаких пропусков быть не должно. Поэтому 12-разрядная команда будет занимать полторы ячейки памяти.

Если условие не совпадает, мы, как правило, идём на следующую команду, которая отличается на дельту -- размерность команды. Например, команда имела 100 адрес и занимает три полуслова, значит, мы должны уйти на 103 адрес.

Адреса формируются не в блоке операции. Для этого существуют свои сумматоры и счётчики, которые находятся в БУКе. Аналогично и счётчик команд, который тоже находится в БУКе, тоже может суммировать какое-то смещение, поэтому и у него тоже есть свой сумматор.

Команда пропуска (как правило, с условием) отличается от других команд перехода тем, что в ней нет адресного поля. Она безадресная, и в КОП уже записано, сколько байтов надо пропустить. Таким образом исключается адресное поле. Команда пропуска заключается в том, что мы "перепрыгиваем" через следующую команду -- осуществляется пропуск одной команды заданной размерности.


В команде перехода мы не передали управление в АЛУ. Если в линейной команде после выборки операндов управление передаётся в АЛУ, то все команды перехода выполняются целиком в ЦУУ.

На схемах пересылка данных изображается двойными линиями, управляющих сигналов -- одинарными.

У системы памяти может быть и своё местное устройство управления. Это вообще относится к каждому устройству в процессоре.

В этой схеме условно отмечены, что в каждом блоке могут быть очереди: в процессоре выполняется совмещение команд -- конвейер. Поэтому в регистре команд условно на входе присутствуют очередь. Такая же очередь есть и на выходе этого регистра, такие очереди есть на буферных регистрах операндов. Очереди есть и на выходе регистра результата, чтобы мы не сразу считывали.

Входные данные могут загружаться через флешку или другое внешнее устройство с помощью контроллера ввода вывода в ОП

Здесь показана отдельно шина информации и шиана адреса. ЗДесь шина данных одна, с которой поступает информация как в БУК, так и в буферные регистры операндов. По этой же самой шине результат записывается в ОП.

Чтобы ускорить, шин таких могут быть две: одна на выдачу информации, а другая -- на приём, то есть память может быть двухпортовая с точки зрения памяти и считывания.

Кроме того, могут быть шины из кеша первого уровня L1. Кэш верхнего уровня делится на два блока -- блок инструкций и блок данных, поэтому могут быть отдельные шины, связывающие команды и данные. 

Мы будем разрабатывать два устройства: МУУ схемного типа (БО), а БМК будет выполнено с помощью микропрограмм. На данной схеме БМК раскрыто как устройство схемного типа с жёсткой логикой.

### БУК 

Блок управления командами. В его состав могут входить
- Счетчик команд (регистр и

<!--stackedit_data:
eyJoaXN0b3J5IjpbLTk5MDk1OTIxMCwxMjE5NTI0OTQ1LDEyMT
M1Mjk0OSwtMjA5NzU0NTIyOSw2MzIyODI0NjUsMTc1MzI0NTMz
MCwtMTI1MTMxODcsMTU1MjQ0NTQ4XX0=
-->