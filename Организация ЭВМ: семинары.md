

демонстрация АЛУ: показать БО и МУУ, соединённые друг с другом.

на тестировании с четверга вручную задаём все снешние входы, задаём а и б в двоочином виде, регистры ра рб рр в двоичном виде, шины тоже

всё задавать в двоичном виде

выводим все шины которые есть
при этом не перепутать старший и младший разряды

выводим все а и б, игреки и дальше начинаем записывать реигстр а,  регистр б

если стоят преобразователи на входах то можно до регисра а и б показать входы

регистры должны обязательно иметь свои имена

шина на наше усмотрение -- удобно дать имена связанные с тем куда они идут

бо 
внешние входы
игреки


клеар
с
а б
игреки
ра
рб
(перед ра и рб могут быть преобразователи)
шины SA SB
шина на выходе сумматора или входы RR
одни из последних сигналов -- RR и регистр признаков

демонстрируем сначала блок операций

в алу ничего не изменится, только игреки будут не нами нарисованные, а будут выходами МУУ

надо вывести фи после рб

при этом регистры и шины в свёрнутом двоичном виде чтобы на экране на одном слайде было не больше 10 шагов

при алу те же самые входы и выходы того что мы уже игреки не задаём сами а они будут сниматься с муу

те же тесты пропускаем и через алу, хотя мб придётся какой-то дополнительный тест добавлять

осовные ошибки в бо -- перепутали разряды, по какой-то цепи дважды назвать а1 а1 пропустиив а2 и так далее

в муу с алу ошибки -- по графу выполнить неправильный переход при анализе признака который ещё не сформироваться. Поэтому там могут быть и пустые микрокоманды

для бука выведено что должно включать минимальный набор на сайте кафедры 

бмк обязательно дб спроектирован и какие между блоками

временное моделирование -- требования к генератору импульсов, в отчёте будет результат -- сколько операций мы выполняем: умножение -- 8млн, сложение -- 5 млн, переход -- какое-то другое количетсво. Эти оценки надо давать для временного моделирования

В команде перехода мы не передали управление в АЛУ. Если в линейной команде после выборки операндов управление передаётся в АЛУ, то все команды перехода выполняются целиком в ЦУУ.

к следующему разу читаем вторую главу -- МУУ


какой размер на кристалле мы занимаем алу и в дальнейшем всем процессором

лучше чтобы первый пример после сложения имел признак ненулевой а значит после этого признак должен сохраняться если мы делаем умножение

## Проектирование МУУ схемного типа с жёсткой логикой

Первое, что надо определить -- взаимосвязи МУУ с блоками процессора (БО и ЦУУ).

<a href="https://ibb.co/BfnNhWY"><img src="https://i.ibb.co/tHLX0j1/image.png" alt="image" border="0"></a>

Функциональная схема стандартная, но она тоже должна быть приведена с конкретным указанием $\varphi$, сколько состояний у датчика состояний, сколько выходов.

<a href="https://ibb.co/L6BztL3"><img src="https://i.ibb.co/rMqG6CV/image.png" alt="image" border="0"></a>

Определившись с общей функциональной схемой, исходными данными для МУУ будут алгоритмы микропрограмм.

Пусть нам задан такой алгоритм -- микропрограмма алгоритма умножения:

<a href="https://ibb.co/7QLWdWL"><img src="https://i.ibb.co/sCzwdwz/image.png" alt="image" border="0"></a>

В этом алгоритме имеются 6 микрокоманд, которые являются **операторными вершинами**, а проверка условий -- **условные вершины**, которые могут присоединяться либо к предыдущей, либо к следующей микрокоманде.

В данном алгоритме отсутствует изменение счётчика. $\varphi_c$ -- это признак счётчика. Изменение счётчика можно добавить в М5. Но в таком случае мы должны указывать, где может изменяться признак FС.

А раз изначально FC указаны выше, то изменение $i$ должно находится в каждом из блоков М2, М3 или М4, либо наоборот, FC переносить ниже в М5.

<a href="https://ibb.co/5F6k6Gk"><img src="https://i.ibb.co/YZ3X3PX/image.png" alt="image" border="0"></a>

Кроме того, надо задать начальное значение $i$ в микрокоманде М0. В М1 этого делать нельзя, так как она входит в тело цикла.

При ветвлении алгоритмов влево стрелку надо указывать всегда, вправо -- не обязательно.

Теперь нам нужно реализовать такой алгоритм. Все вершины в алгоритме делятся на операторные М (или как в пособии H) и условные вершины. Построим граф переходов операторных вершин. В него надо не забыть добавить *SNO* -- входной сигнал.

Надо отметить, что в М0 мы может переходить не только по *SNO*, но и по окончанию выполнения любого алгоритма по завершению также возвращаться сюда.

Из М0 мы всегда переходим в М1. А из М1 мы можем перейти в М2, М3 или М4. Из каждой из них мы переходим либо в М5, либо завершаем работу.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/YZYvfH5/image.png" alt="image" border="0"></a>

Каждая вершина в этом графе соответствует своей микрокоманде. При этом при SKO мы также могли переходить в М0, поэтому для следующей команды мы уже бы сразу находились в начальном состоянии.

Пунктиром показано, что условные вершины F1 и F2 присоединены к М1, а условная вершина FC присоединена к М2, М3 и М4.

<a href="https://ibb.co/253zdHq"><img src="https://i.ibb.co/rv2BHNk/image.png" alt="image" border="0"></a>

Можно было граф нарисовать и так:

<a href="https://imgbb.com/"><img src="https://i.ibb.co/ZGT86J7/image.png" alt="image" border="0"></a>

Но вместо цифр типа 01 лучше было бы написать $\overline \varphi_0 \varphi_1$

На модифицированном алгоритме нужно определиться, к каким операторным вершинам будут присоединяться условные вершины. В данном случае показано, что условные вершины присоединены к предыдущей команде. Таким образом, в М1 анализируется $\varphi$, а в М2, М3 и М4 анализируется FC.

В этом варианте в графе условные вершины привязаны к предыдущей операторной вершине. 

Теперь попробуем по-другому. Условные вершины можно присоединять и к следующим командам:

<a href="https://ibb.co/CVndm2D"><img src="https://i.ibb.co/qmRG75V/image.png" alt="image" border="0"></a>

Пусть у нас к вершине P2 будут привязаны условия F1, F2 и FC. Но надо обратить внимание на то, что если мы это всё вместе объединим, то F1 и F2 будут влиять на переход: мы из P1 переходим в P2 (P -- это состояние датчика состояний), в котором выполняются M2, M3 и M4. Эти три команды будут выполняться в зависимости от комбинации F1 F2 в рамках одного состояния датчика состояний. В игреке должны быть указаны, при каких условиях они выполняются.

Условие, которое стоит после операторной вершины --  FC, будет указывать на переход -- прееход в М5 или уход на конец.

Кроме того, предлагается продублировать сдвиг RA. В предыдущем алгоритме было только сдвиг RB в М5, а здесь ещё и сдвиг RA. Поэтому надо исправить: чтобы не дублировать лишний раз сдвиг RA, мы получаем выигрыш в n-1 шаг, укорачивая цикл:

<a href="https://ibb.co/Rycp4D8"><img src="https://i.ibb.co/PQgZz6k/image.png" alt="image" border="0"></a>

В итоге у нас осталось только 4 вершины, и граф будет выглядеть так:

<a href="https://imgbb.com/"><img src="https://i.ibb.co/C6BhLsS/image.png" alt="image" border="0"></a>

Как видно, он гораздо проще.

Самое главное: на переходы влияют условия, которые находятся **в конце** вершины. Условия, которые находятся **перед** операторной вершиной, будут влиять на формирование игреков.

При этом надо не забыть сигнал SKO (он должен быть указан в полях с игреками):

<a href="https://ibb.co/sR02rkv"><img src="https://i.ibb.co/QQ2fGzF/image.png" alt="image" border="0"></a>

Кроме того, нужно включить дополнительный сигнал Y для увеличения счётчика.

Обнуление счётчика можно выполнить с помощью сигнала *SNO* -- при этом не надо будет вводить дополнительный сигнал обнуления. Это надо не забыть. Либо возможен сигнал YL~ct~, по которому будет загружаться какое-то конкретное число в счётчик, если в разных командах нужно разное количество итераций.

При выработке SKO на графе переходов могут быть несколько переходов:
- из P2 всё равно перейти в P3 -- при этом достаточно будет блокировать сигнал P3, который может мешать, а можно и не блокировать в нашем случае
- из P2 перейти в PO, тогда не надо будет на каждом шаге принимать SNO
- из P2 перейти в 0 -- все состояния равны 0. При этом можно не заводить сигнал Enable на все игреки

Эта особенность описана на 35 странице: En можно заводить, а можно не заводить. Но есть там находится сдвиг RR, то эту команду обязательно надо блокировать.

Если мы перейдём в P0, надо блокировать установку в 0. Поэтому можно блокировать либо все сигналы, как в пособии, либо какие-то отдельные.

И ещё надо не забыть оформить по ГОСТу: поставить сетку

<a href="https://ibb.co/HNM2sct"><img src="https://i.ibb.co/RhMSmX3/image.png" alt="image" border="0"></a>

Операция сложения что в пособии, что здесь, одна и та же, то алгоритм не меняется и точно такой же, как и в пособии

<a href="https://ibb.co/qNcmSZz"><img src="https://i.ibb.co/MctPvXb/image.png" alt="image" border="0"></a>

Предлагается на первом же шаге сделать привязку к датчику состояний. В данном случае у этого датчика состояния будет 4 вершины. H можно не писать, но лучше оставить обозначения микрокоманд (M~i~). При этом F3 формируется и проверяется в одной и той же вершине -- это могло быть выполнено в двухфазной системе -- когда мы в ВД для БО формировали игреки по спаду, но работать мы будем в однофазном. В одной и той же вершине нельзя изменять условие и проверять: потому что к фронту сигнала уже нужно знать, чему равно F3, чтобы перейти в нужное состояние датчику состояния.

Однако то же самое было и в умножении, где FC формируется и там же проверяется.

Поэтому нужно разорвать эту связь, дополнив алгоритм пустой микрокомандой:

<a href="https://imgbb.com/"><img src="https://i.ibb.co/dLnmbd8/image.png" alt="image" border="0"></a>

При этом в алгоритме F3 будет относиться не к P2, а присоединяться к команде после неё, и E1 будет выполняться при F3 = 1 (это надо будет показать так: Y8 (F3)).

При этом в NOP нет никаких игреков и никакое действие не выполняется. Однако эти пустые операции желательно исключить.

Нужно ли нам в таком случае возвращаться в умножение и включать NOP, чтобы всё работало? Но там мы берём не новое FC, а предыдущее FC, которое было на предыдущем шаге. Но если бы i + 1 было в М5, мы бы брали то FC, которое сформировалось в P3.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/gRDm0M6/image.png" alt="image" border="0"></a>

Получился пропуск одного такта.

Как сделать так, чтобы пропуска не было? Для этого можно дублировать операции:

<a href="https://imgbb.com/"><img src="https://i.ibb.co/ZYV6GYK/image.png" alt="image" border="0"></a>

Вместо NOP будем повторять H3. При этом лучше написать SKO ($\overline {F3}$), и если этого даже нет в алгоритме, это должно быть расписано в таблице формирования игреков.

<a href="https://ibb.co/9bbP1Wy"><img src="https://i.ibb.co/qNN6cpm/image.png" alt="image" border="0"></a>

Можно не писать много красивых слов в этом графе, а просто оставить P~i~ внутри состояний

<a href="https://ibb.co/1fR8zvZ"><img src="https://i.ibb.co/d0kGmWB/image.png" alt="image" border="0"></a>

При этом там в варианте C неудачно указано NF: оно имеет отношение к Yn, а не к Ym. Ym будет выполняться всегда, и признак F там проверяться не будет.

КС1 формирует код перехода и режим датчика состояний. У датчика состояний могут быть два режима.

В данной функциональной схеме исчезает дешифратор кода операции -- раз у нас только две операции, он становится вырожденным. Кроме того, F могут приходить по длинным связям на КС2 и КС4 (хотя лучше это показать единым блоком): разрешение считать счётчику циклов и загружать какое-то число + формирование внешних выходных сигналов.

### Датчик состояний

Перед ним надо разработать КС1, которая разрешает работать датчику состояний (SNO может приходить на КС1 или напрямую на ДС).

В пособии, в отличие от графа на 4 вершины, показано, что для умножения нужно 3 состояния для умножения и 4 состояния для сложения.

**Датчик состояний** нужен для выработки и распределения состояний P в определённом порядке.  На выходе датчика состояний -- унитарный код.

Реализовать его можно либо с обычным двоичным счётчиком и дешифратором (но тогда чтобы иголки ничего не испортили, они должны появляться по спаду)

<a href="https://ibb.co/c6Zx3ck"><img src="https://i.ibb.co/sKNtRvb/image.png" alt="image" border="0"></a>

Можно также использовать регистр сдвига, по которому будет циркулировать единичка, или регистр хранения.

У регистра сдвиге при сдвиге тоже могут быть иголки. Но любым из решений нужно управлять -- есть режим и код загрузки.

В начальный момент в счётчик мы загружаем нулевой код, в регистры сдвига -- единичку на P0. А дальше надо обеспечить последовательное изменение состояний в соответствии с графом.

В регистрах или счётчика могут быть переходы -- соседние и несоседние. Например, это переходы P0-P1 -- соседние, а переходы в другую сторону или перепрыгивания -- несоседние.

Соседние переходы можно обеспечить простым счётом (+1), а несоседние -- загрузкой.

Для регистра -- соседние переходы выполняются с помощью сдвига, а несоседние -- загрузкой.

В регистре хранения -- оба загрузкой.

Таким образом, при каждой реализации получаются два режима работы -- при соседних и при несоседних переходах.

На входе ДС стоит КС1, которой мы должны обеспечить управление этим датчиком, формируя код перехода. В пособии разбирается вариант с использованием регистра хранения. 

Для этого в таблице переходов DS нужно выписать возможные переходы для выходов КС 1. Введём кодирование COP0.

Выписываем все возможные переходы в соответствии с графом переходов.

После завершения операции (формирование SKO), датчик состояния остается в P2. Поэтому при тестировании надо не забыть: вначале мы будем начинать в P0, а завершать в P2, поэтому надо посмотреть работу МУУ при нескольких примерах подряд.

Для второй операции аналогично. Из P3 мы никуда не уходим

В строчках таблицы переходов DS заполняются: коды операций, FC, F3, текущее состояние (P0-P3) и что мы должны сформировать на выходе КС -- D0-D3.

Разберём первую строчку. Для умножения (COP0 = 0) мы находимся в нулевом состоянии (0001). Переход P0->P не зависит ни от F3, ни от FC, поэтому мы формируем переход в P1 (D = 0010).

Переход P1 -> P2 зависит от COP0 и от FC. Но если FC будет равно 1, то можно писать неопределённое состояние, либо можно написать ещё одну строчку, что мы при FC = 1 хотим переходить в нулевое состояние ⇒ можно включить ещё один переход P1 -> P0.

<a href="https://ibb.co/7JSJXZ1"><img src="https://i.ibb.co/d0f0rV5/image.png" alt="image" border="0"></a>

Тут есть опечатка: переход R2 -> R3 должен быть при F3 = 1.

Теперь рассмотрим датчик состояний на регистре сдвига. На нём надо обеспечить два режима: режим соседнего перехода и несоседнего перехода. Причём несоседний переход у нас только один: P3 -> P2.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/RQzyNLp/image.png" alt="image" border="0"></a>

<a href="https://ibb.co/W0QFxv2"><img src="https://i.ibb.co/kJp0H2S/image.png" alt="image" border="0"></a>

Нужно обеспечить переход P2 -> P1. Поэтому проектирование на регистре сдвига может оказаться значительно проще.

При этом добавлена начальная загрузка по SNO.

<a href="https://ibb.co/9v2735N"><img src="https://i.ibb.co/j5GSZXT/image.png" alt="image" border="0"></a>

На самом деле это таблица сигналов на выходах КС2 и КС4. Заполняем из модифицированного алгоритма -- так указано, какие игреки на каком Р формируются. 

При этом Y12 -- это +1 в счётчик на увеличение *i*.

### Однофазная синхронизация

По фронту формируем и игреки

По С прежде всего происходит переход в следующее состояние Р (лучше показать это в шине в десятичном виде). На ВД блока операций мы записывали CLR, C, A, B и игреки. Теперь надо будет задать SNO и до игреков (это же выходы МУУ) задать сначала P, а перед ними или после них режимы работы ДС.

<a href="https://ibb.co/R77kH4N"><img src="https://i.ibb.co/b77MdRF/image.png" alt="image" border="0"></a>

МУУ завершается игреками.

По синхросигналу переключается P, формируются игреки, а в RR мы принимаем RR + RA иил не RA. Идёт длительное врремя SM (лучше задать его в двоичном виде), получается новое значение, которое по следующему синхросигналу принимаем в результат. При этом между правильным значением суммы и значением С должно быть выдержано время предустановки. При оценивании времени синхроимпульсов нужно будет построить примерно такую диаграмму и оценить эти временные параметры задержек и времён предустановки -- они и будут определять быстродействие АЛУ.

По синхровходу из 0 в 1 формируются как игреки, так и исполняется предыдущее значение. Например, на предыдущем P мы должны были сдвигать, и пока формируется новый игрек, мы исполняем старый.

### Схема пуска-останова и счётчик циклов

SNO нужно формировать **с задержкой**, чтобы в следующий момент С мы запускали схему пуска останова --- когда SNO захватывает уже следующий фронт.

По этому же SNO надо перейти и в P0.



<a href="https://ibb.co/R77kH4N"><img src="https://i.ibb.co/b77MdRF/image.png" alt="image" border="0"></a>

В соответствии с графами переходов мы переходим Р1 -> Р2 -> P1 -> P2 -> P1 - на этом состоянии вырабатываем SKO и всё равно переходим в P2.

Мы завершаем либо самым последним состоянием, либо всеми нулями.

Счётчик циклов работает в микропрограмме в состоянии P2 (Y12). Так как Y12 тоже задержан, он переходит в следующее состояние по следующему фронту. По FC  формируется SKO.

В интервал времени SNO - SKO ЦУУ не работает, работает только АЛУ.

Шину P лучше развернуть. Либо задавать P0 = 0001, P1 = 0010 и так далее.

В какой момент мы должны задать А и когда мы получаем результат? Результат получится в последнем импульсе.

# Измерение временных параметров АЛУ

В отчёт можно включить схему соединения БО и МУУ: можно не расписывать входы, а можно показывать отдельные входы, игреки можно показать единой шиной.

<a href="https://ibb.co/QDdFZGD"><img src="https://i.ibb.co/Z2m63C2/image.png" alt="image" border="0"></a>

## Подготовка к исследованию временных параметров

### Что нужно ввести в модель АЛУ?

Главное -- подключить элементы стенда. В них самое основное -- разводка на 84 контактах кристалла. На эти выводы должно быть что-то обязательно подключено, а что -- системе не особо важно.

При этом самое главное -- подключить **генератор** от стенда.

**Элементы стенда**:
- генератор импульсов (внешние входы C и CLR). CLR при начальное загрузке, конечно, выполняется, но мы можем попробовать задать несколько разных команд
- клавишные регистры (внешние входы) -- А, В, код операции и SNO. Имеет смысл А и В задать на отдельных клавишных регистрах (они всё равно по 4 разряда), а SNO и КОП на разных сторонах одного клавишного регистра, чтобы их было удобнее переключать.
- элементы индикации
	- внешние выходы: R, PR, SKO
	- при сдаче надо уметь сказать, что выполняется в конкретный момент времени, поэтому надо ещё вывести выходы внутренних регистров, которые содержатся как в блоке операций, так и во внешнем устройстве: RA, RB, RR, RPR. Тут можно что-то исключить, если есть избыточность. Из МУУ подаются датчик состояний, счётчик циклов и триггер пуска-останова.
	- внутренние сигналы-признаки: F1 из БО и FC из МУУ
	- внутренние шины: SA, SB, SM, КСi и так далее -- для отладки.
	- управляющие сигналы для отладки -- Y~m~, Y~ct~ и так далее.


При этом сдача АЛУ может происходить так: рандомно посылаем несколько синхроимпульсов, а дальше по индикации надо определить, какая операция будет выполняться дальше и что будет меняться. Аналогично можно спросить подобные вопросы на ВД, расширяя её так, чтобы не было видно предыдущих операций.

Выше перечислено то, что принципиально *можно* выводить, но надо подумать, чего выводить по минимуму.

За счёт дополнительного вывода элементов на индикацию может измениться трассировка путей, из-за чего могут измениться временные параметры АЛУ.

А и В мы не выводим на индикацию, потому что мы их можем наблюдать на клавишном регистре.

При том у нас на стенде 24 элемента индикации, и их может не хватать. Поэтому надо будет дополнительно ввести мультиплексоры для индикации и управлять ими с клавишных регистров.

### Схема подключения АЛУ к стенду

После того, как мы определились, что куда подавать и как подключать индикацию, надо привести схему подключения АЛУ к стенду.

<a href="https://ibb.co/qmNwC01"><img src="https://i.ibb.co/JrvPqxk/image.png" alt="image" border="0"></a>

Здесь надо показать генератор с его входами, клавишные регистры и сама индикация. Возможно, понадобятся мультиплексоры.

Предлагается поместить элементы индикации горизонтально, как на стенде в три строки. При этом надо учитывать, что третий выход находится слева.

Что обязательно надо выводить и не не подключать к мультиплексорам? Триггер пуска и останова -- чтобы можно было сказать, будет работать устройство, или нет; датчик состояний. А счётчик можно постоянно не выводить: наоборот, можно вывести сигналы фи (кстати, их можно вообще не выводить, раз мы их берём с регистра RB), а вывести FC.

Подключение к стенду оформляется на дополнительном листе. АЛУ нужно сохранить в отдельном проекте, а процессор уже начать делать в новом проекте.

Мультиплексоры к клавишным регистрам можно подключить не через имена, а прямо подвести к ним линию.

## Отчёт об используемых ресурсах ПЛИС

<a href="https://ibb.co/pQTrmdM"><img src="https://i.ibb.co/T1GqCt7/image.png" alt="image" border="0"></a>

Кроме этой распечатка надо привести и размещение схемы на кристалле:

<a href="https://ibb.co/vB70hkG"><img src="https://i.ibb.co/hMP3cVj/image.png" alt="image" border="0"></a>

## Определение параметров системы синхронизации и времени выполнения операций в АЛУ

 Это может быть в третьем разделе с АЛУ или там, где мы тестируем МУУ.


В качестве параметров системы синхронизации надо определить параметры синхроимпульса -- частоту и период.

### Этапы

1. Отчёт системы Xilinx по параметрам системы синхронизации
2. Определение динамических параметров АЛУ и критические пути с помощью Timing Alanyzer. Здесь приводятся максимально возможные пути прохождения сигналов, даже те, которые не появляются при работе АЛУ.
3. Временное моделирование для **выбранных** значений операндов

Для ВД надо определить, какие комбинации операндов приведут к максимальному времени выполнения команды -- а именно, при каких операндах перенос в сумматоре будет идти больше всего.

**Время выполнения операций** -- количество тактов и времени (нс). Это можно выразить через целое число периодов синхроимпульсов, потому что микрооперации у нас синхронные и занимают ровно один такт. Это надо определить для каждой операции.

Также надо определить **производительность** -- количество операций в секунду.

Это можно оформить в виде таблички.

### Отчёт системы Xilinx по параметрам системы синхронизации (с 96)


<a href="https://ibb.co/z8zKJCP"><img src="https://i.ibb.co/f8smvZr/image.png" alt="image" border="0"></a>

Тут как раз определяется период -- это то, что выдаёт система.

### Определение критического пути с помощью Timing Analyzer

<a href="https://ibb.co/2NgGQZ9"><img src="https://i.ibb.co/5FBbyK0/image.png" alt="image" border="0"></a>

Тут надо заметить, что есть задержка **net** -- задержка лини межсоединений CLB.

Кроме того, чтобы было понятно, через какие элементы проходит сигнал по критическому пути, надо всему задать имена.

Здесь же система приводит оценки времени и частоты.

### Временное моделирование

Для ручного временного моделирования нужно выбрать комбинации операндов такие, чтобы датчик состояний переключался с максимальным количеством тактов, чтобы сумматор работал дольше всего и т.д.

**Выбор комбинаций операндов, обеспечивающих**:
- максимальное количество изменений датчика состояний (тактов)
- изменений сигналов на выходах регистра
- максимальное время суммирования чисел на сумматоре !!!

**Этапы моделирования**
- начальная точка частоты сигнала С -- отчёт системы Xilinx
- увеличение частоты генератора С (уменьшение периода) до момента нарушения времени предварительной установки триггеров

<a href="https://ibb.co/KxcvMhm"><img src="https://i.ibb.co/jk9XcfH/image.png" alt="image" border="0"></a>

Данные распечатки с нарушением (лучше 100-200 пс, потому что точность задания периода 200 пс) надо приводить в отчёте. Сначала получаем ошибку, а потом увеличиваем период на величину сообщения и проверяем работу.

Так проделываем для обоих операций. В отчёте должно быть две размеченных диаграммы, где приводятся нарушения времени предустановки.

На первые 50нс можно задать CLR. Только надо не забыть, что при изменении частоты надо укорачивать сигнал SNO, чтобы он случайно не задел два синхроимпульса.


В итоге надо найти одну микрокоманду, которая и определяет частоту, и в общем надо привести 2 верных диаграммы и одну ошибочную со сбоем.

### Анализ путей распространения сигналов в БО

<a href="https://ibb.co/80pkWJ2"><img src="https://i.ibb.co/XbgHh9p/image.png" alt="image" border="0"></a>

Например, в этом случае 5 различных путей, которые влияют на определение периода.

Путь мы определяем между источником и приёмником в рамках одного такта.

### Анализ путей распространения сигналов в МУУ

<a href="https://imgbb.com/"><img src="https://i.ibb.co/RQnWr7c/image.png" alt="image" border="0"></a>


В итоге надо найти один самый длинный путь -- критический путь.

### Критический путь

<a href="https://ibb.co/7j6MRmy"><img src="https://i.ibb.co/WGY8PJK/image.png" alt="image" border="0"></a>

Когда мы получили ошибку в 100 нс, то надо выделить значение Add all, и тогда эти нарушения будут показываться красным.

Надо показать, какая микрооперация является определяющей для генератора импульсов (в нашем случае --  RR := RR RA) и какой путь сигнал при этом проходит (DS -> Y5 -> ...)

Можно ещё дополнительно показать время предустановки, которое нарушилось.

<a href="https://ibb.co/ypr8CCF"><img src="https://i.ibb.co/HCjryyT/image.png" alt="image" border="0"></a>

## Блок операций

### БО с закреплённым набором микроопераций


<a href="https://ibb.co/jTcB4nH"><img src="https://i.ibb.co/Y3zYjHb/image.png" alt="image" border="0"></a>

Закрепленный набор микроопераций: за каждый блоком закреплён свой набор микроопераций.

Если бы нам понадобилоась использовать этот БО для работы с ПЗ, то надо было добавлять много однотипных микроопераций сдвига влево-вправо для нормализации и денормализации. аким образом, будет увеличиваться набор оборудования из-за дублирования операций. Но плюс том, что происходит параллельное -- "быстрое" выполнение микроопераций.

При этом сдвиги на регистрах могут быть не обязательно на один разряд.

### БО с общим набором микроопераций (магистральная структура)

Ввести набор регистров, каждый из которых выполняет только одну конкретную микрооперацию (сдвига влево, сдвиг вправо и так далее).

На входе регистров первого и второго операндов предлагается поставить такой набор регистров. Также на регистрах, помимо свдвига, можно вводить операции И, ИЛИ, XOR и так далее.

<a href="https://ibb.co/HtNhbcs"><img src="https://i.ibb.co/T4KW7QS/image.png" alt="image" border="0"></a>

Есть входной коммутатор К, на который поступают данные извне, с любого из регистров или с сумматора (для общего случая можно передавать и с одного из регистров Р1 - Р3).

Таким образом, на каждом регистре Рг выполняется одна из микроопераций.

При этом арифметический сдвиг вправо можно было выполнить "сокой передачей", соединяя выход блока регистров с Р1 или Р2. 

<a href="https://imgbb.com/"><img src="https://i.ibb.co/mDYxs9z/image.png" alt="image" border="0"></a>


Фактически, можно этих регистров и не иметь, а поставит большой МУХ, на который данные со входного коммутатора будут передаваться так, как необходимо: со сдвигом, с маской И. ИЛИ или XOR и так далее..

<a href="https://imgbb.com/"><img src="https://i.ibb.co/7JvjCPw/image.png" alt="image" border="0"></a>

Какие минусы здесь появляются? Мы не можем выполнять операции паралелльно: мы можем выполнять любую микрооперацию над любым регистром или входом, но если надо будет сдвинуть, например, оба регистра, то надо будет делать это последовательно.

<a href="https://ibb.co/yq99XFx"><img src="https://i.ibb.co/NKvvs2G/image.png" alt="image" border="0"></a>

# Проектирование БУК

## УГО БУК

Основное назначение БУК -- подготовка операндов. В нашем случае и ОП, и РОН как память входят в состав БУК.

FP -- Фи признака. Сам признак PR двухразрядный. Внутри БУКа стоит КС, которая проверяет этот признак на ноль, а на выходе формируется один сигнал FP. Местное устройство не анализирует эти признаки.

Из БМК в БУК должны приходить управляющие сигналы YC (мы пока не знаем, сколько их, пока мы не разработали сам БУК). Чтобы работали все элементы, в БУК также нужно подать синхросигнал и сигнал CLR.

Кроме того, для общего случая, чтобы БУК работал, можно подать на него начальный адрес.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/CzhcXST/image.png" alt="image" border="0"></a>

По сигналу СТАРТ в процессоре запускается схема пуска-останова БМК, а останавливаться или приостанавливаться она будет по SNO (если нет совмещения конвейера). По этому же SNO запускается схема пуска-останова в МУУ. По SKO наоборот, останавливается СПО в МУУ и возобновляет работу СПО в БМК до следующего SNO.

## Порядок проектирования БУК
- выполнить размещение командной информации в заданных форматах команд
- составить алгоритмы выполнения команд
- разработать функциональную схему БУК
- выполнить логическое проектирование БУК в заданном элементном базисе
- составить алгоритмы микропрограмм, реализующих заданные команды

Цикл команды состоит из следующих этапов
- выборки команды и формирования адреса следующей команды (sk := sk + 1  или sk := sk + delta)
- декодирование команды
- формирование исполнительных адресов операндов
- выборка операндов
- исполнение операции
- запись результата (может не выполняться в одноадресных командах, там результат может оставаться в регистре-аккумуляторе)

<a href="https://ibb.co/1mLt7Kx"><img src="https://i.ibb.co/5R6gGvV/image.png" alt="image" border="0"></a>


## 1. Разработка форматов команд

Начинаем с рассмотрения способов адресации. У нас в задании есть относительная и регистровая адресации.

В наших заданиях не указано, сколько ячеек занимает команда в ОП. И размеры тут другие (у нас 16х8 и 8х4)

Надо определить, сколько разрядов проходит по каждой связи и разработать форматы команд.

### Относительная

<a href="https://imgbb.com/"><img src="https://i.ibb.co/yW2cZ0h/image.png" alt="image" border="0"></a>

Вверху короткое смещение, которое можно расширить нулями, единицам или знаком. Внизу показаны связи (разрядности шин). Разрядности зависят от ёмкости памяти (log~2~).

Прежде всего, мы должны определить разрядность адреса в памяти, раз он и так зависит как log от ёмкости памяти, измеряемой в полубайтах (4 бита). В задании таких слов 16 штук, поэтому разрядность адреса операнда будет равна log~2~(16) = 4.

В обычных процессорах, однако обращение идёт к байту.

Счётчик команд должен содержать те же 4 разряда, потому что эти команды расположены плотно друг к другу, и они тоже определяются по разрядности слов.

Разрядность смещения может быть <= 4 (это зависит от того, будем ли мы расширять его)

Причём стрелка к операнду -- то, что мы получаем на входе памяти -- это то самое Аисп. При этом лчше писать не Память, а OP, не КОП, а COP и так далее.

Если вариант будет без расширения знака, надо учитывать разрядность при рисовании этих прямоугольников: они должны быть одной ширины при одинаковой разрядности, это дополнительная подсказка.

### Регистровая

<a href="https://imgbb.com/"><img src="https://i.ibb.co/5T5LWrM/image.png" alt="image" border="0"></a>


<a href="https://imgbb.com/"><img src="https://i.ibb.co/Jqd1X7M/image.png" alt="image" border="0"></a>

### Форматы команд


Мы в формате команд указываем, к  какому операнду относятся какая часть. Например, можно показать Ab как а базовое, Ri как регистр индекса и так далее, и показать, сколько разрядов относится к какому операнду.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/2WZczvF/image.png" alt="image" border="0"></a>

В команде перехода есть только код операции и адрес перехода, причём по заданию он имеет прямую адресацию, поэтому под него отводится 4 разряда.

Под код операции отводится 2 бита, но могло быть и 3, если мы кодировали бы эти команды в унитарном коде.
 
В конце команды перехода 2 пустых бита. Эти пустые биты можно поменять местами и с адресом перехода:

<a href="https://imgbb.com/"><img src="https://i.ibb.co/ZTpWfFm/image.png" alt="image" border="0"></a>

Раз мы считываем по словам, ва в команде содержится по два слова, то надо обязательно указать разрядность этих команд 7-0 (выдавать будем именно в таком виде на шине из памяти), и поскольку считывать мы будем по словам, а разрядность регистра команд 8 разрядная, то предлагается провести пунктир и сказать, в какой регистр куда будут загружаться части команд. Так что надо показать, в каком регистре что будет располагаться. В пособии этого нет, потому что там 16-разрядная память и команды тоже 16-разрядные. 

<a href="https://imgbb.com/"><img src="https://i.ibb.co/0VjtZd1/image.png" alt="image" border="0"></a>

(RK1, RK2 -- размещение в регистре команд), у большинства ещё будет RK3 и может быть КЛ4/

### Размещение в памяти

Если брать линеную команду, то смещение будте разбиваться на две ячейки и с любыми адресами будет находиться в двух последовательных чейках.

Если выбрать первый вариант команды перехода, то адрес перехода разбивается между ячейками, а во втором он полностью располагается во второй ячейке -- и именно так удобно записывать в память по 4 разряда.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/K003Gjg/image.png" alt="image" border="0"></a>

С точки зрения считывания это, наверное, всё равно, но для заполнения памяти это удобнее. Также удобно, чтобы адреса находились не в старших разрядах, а привязывались к младшим (сдвигать в правую часть, например, если нужны три разряда, можно было бы писать 0 и три адреса разряда). Вместо прочерка лучше писать нули.

Данные будут располагаться в память просто в своих ячейках. 

ПРи этом если операнд большой, то адрес операнда обязательно должен быть чётным (в формате команды, например, адрес R2)

<a href="https://imgbb.com/"><img src="https://i.ibb.co/X4xWG4N/image.png" alt="image" border="0"></a>

Исходно операнд можно считать и из чётного, и из нечётного слова (можно младшую и старшую половину поменять местами), но адрес при обращении к памяти всё равно считать из чётного адреса. Если получается нечётный адрес, то к нему мы будем прибавлять единичку.


Если вместо операнда пишем восьмиразрядный результат, то он обязательно имеет чётный адрес.

Кроме того, в этом же пункте надо задать окдирование COP

### Кодирование COP

Есть несколько возможных вариантов

<a href="https://ibb.co/rfd4K99"><img src="https://i.ibb.co/QjDr700/image.png" alt="image" border="0"></a>

Мы уже определили COP0 в АЛУ: чтобы не ставить инверсию, нам подходят только 1, 2 и 4 варианты.

2 вариант неудобен тем, что обе операции умножения и сложения имеют противоположные COP1, и поэтому для проверки на линейность команды надо будет анализировать два бита кода операции. В первом варианте достаточно было бы проверять только COP1: если COP1, то это линейная команда, иначе -- команда перехода.

4 вариант удобен тем, что коды операций сами по себе идут подряд, и так же, как и в 1 варианте, для определения принадлежности команды к конкретной группе команд достаточно анализировать только первый бит.

Принимаем 4 вариант.

<a href="https://ibb.co/T01wG3j"><img src="https://i.ibb.co/1XM0NWy/image.png" alt="image" border="0"></a>


Далее надо представить размещение команд в памяти и кодирования кода операций.



## Пример из пособия

<a href="https://ibb.co/80zSpvt"><img src="https://i.ibb.co/wRJxXGj/image.png" alt="image" border="0"></a>

В отличие от наших вариантов, в пособии разбирается пример, когда ОП состоит из 16 16-разрядных ячеек (или по другому 16 четырёхразрядных слов), а регистровой памяти вообще нет.

**Условный переход**: команда содержит код маски КМ -- и в своём варианте, если указано КМ, то надо везде писать именно КМ, а не например М или что-то другое.

Если мы проверяем признак 2, то в КМ надо проверять именно тот разряд, который соответствует этому признаку. Соответствие разрядов и номеров признаков указано либо в задании (например, тут 0 1 2 3), либо мы определяем его сами.

Также тут предлагается сделать команду ОСТАНОВ, но она не обязательна. Вообще эта команда нужна для отладки процессора, чтобы можно было тестировать программу по чуть чуть, но и даже в таком случае вместо останова можно просто использовать команду перехода, которая передаёт управление на саму себя.

### Организация памяти

<a href="https://ibb.co/vHbdPTP"><img src="https://i.ibb.co/TkZ0878/image.png" alt="image" border="0"></a>

В пособии предложена такая организация памяти. В организации памяти первое число -- количество ячеек (то есть того, что мы считываем из памяти за одно обращение): их 16, и этому соответствует **физическая** организация памяти. Второе число -- размер каждой ячейки, который может измеряться в разрядах (битах), байтах или словах. Например, если бы мы измеряли ячейки в словах, то можно было бы сказать, что данная организация памяти -- 16х4 слова.

Раз мы за одно обращение считываем ячейку, то за один раз мы считаем 4 слова. На конкретные слова в ячейке будут указывать **младшие** разряды адреса -- им соответствует **логическая** адресация -- тот адрес, который используется в программе -- адрес с точностью до байта (в нашем случае до полубайта или до слова). Старшие разряды при этом указывают на саму ячейку памяти, то есть физический адрес.

Поскольку память суммарно имеет 16х4 = 64 слова -- а мы адресуемся в программе именно к словам, то адрес должен иметь log~2~64 = 6 разрядов. Таким образом 4 старших разряда выбирают одну из 15 **ячеек** памяти, а два младших выбирают одно из 4 **слов** в выбранной ячейке.

В пособии показано, как эти слова размещаются в памяти.

Физический адрес не обязательно показывать как на рисунке. Можно просто столбик с адресами показать рядом с адресацией логической памяти и подписать, что этот столбик -- адресация физической памяти.

Однако такой способ адресации неудобен, когда нулевой полубайт находится справа: в случае, когда команда из памяти считывается по частям, КОП должен располагаться в той части команды, которая считывается из ОП первой. Поэтому лучше использовать такой способ адресации:

<a href="https://imgbb.com/"><img src="https://i.ibb.co/RHn6fNP/image.png" alt="image" border="0"></a>

В противном случае КОП будет находиться в другой стороне (не слева, а справа), это неудобно.

Организацию памяти можно совместить с размещением команд в памяти. А можно начать с размещения памяти перед всеми форматами, как в пособии.

### Способы адресации

<a href="https://imgbb.com/"><img src="https://i.ibb.co/Tm74W5c/image.png" alt="image" border="0"></a>

Для косвенной адресации тоже 6, потому что любой адрес, который обращается (полный адрес, а не короткий), должен обращаться до слова. При этом эти 6 разрядов не могут быть любыми: адрес в памяти в косвенной адресации тоже должен быть 6-разрядным ⇒ надо будет обращаться к двум словам, поэтому адрес к косвенной адресации должен быть чётным, потому что адрес внутри памяти занимает два слова. При этом надо понимать, что если 3210, то мы будем считывать из нечётного адреса старший разряд, а из чётного младший, а если 0123, то наоборот, но самое главное что этот адрес должен быть чётным, так как обращаемся за адресом который должен быть шестиразрядным.

### Форматы команд

<a href="https://imgbb.com/"><img src="https://i.ibb.co/MspNzBK/image.png" alt="image" border="0"></a>

Поле первого адреса линейной команды содержит 7 разрядов (6 разрядов на сам адрес + 1 разряд на признак адреса). Поле второго адреса содержит 6 адресов. 

При этом мы договариваемся, что в полях то, что относится к первому операнду, помечаем цифрой 1 (ПА1, А1), а то, что ко второму -- цифрой 2 (А2).

На КОП остаётся 3 разряда.


В команде перехода ошибка: стоит М вместо КМ. Здесь предложено адрес перехода задать в конце команды, хотя можно было бы и наоборот: чтобы сначала после КОП шёл адрес перехода, и только потом код маски. Но иногда в наших вариантах будет удобно, чтобы размещение каких-то адресов совпадало в разных форматах команд, особенно если они приходят в память через коммутатор: если бы мы выбрали какие-то другие разряды для размещения адреса перехода, то пришлось бы поставить коммутатор на три входа, который бы передавал А1 и А2 из линейной команды и адрес перехода из команды перехода. Поэтому желательно, чтобы  в разных форматах адреса размещались на одних и тех же разрядах.

КМ удобнее расположить именно так, потому что получится, что два слова XX Апер все вместе будут указывать логический адрес -- это удобнее для кодировки и записи в память в двоичном виде. В противном случае было бы чуть чуть сложнее кодировать.

Вместо Х лучше писать тире, а ещё лучше просто два нуля.

Ещё приведён пример кодировки команды останова. Он неудачный, потому что там очень много пустых бит (Х): такую команду надо было брать безадресной. А если бы в команде перехода было бы не 3 пустых разряда, а 4, то надо было брать не четырёхсловную, а двухсловную команду, потому что команды плотно располагаются в памяти и между ними не должно быть свободных мест.

В пособии только один регистр команд, поэтому распределение по этим регистрам тут не расписывается. Зато приведена нумерация разрядов -- и это именно нумерация разрядов **в регистре команд**, а не разрядов самой команды.

### Кодирование COP

<a href="https://imgbb.com/"><img src="https://i.ibb.co/wd7FrVZ/image.png" alt="image" border="0"></a>

В данном случае, учитывая, что всё равно есть свободные разряды (а в задании было сказано, что команда по любому занимает 16 разрядов, даже команда останова), то предложено под КОП отвести 3 разряда (понятно, что если бы мы использовали 4 разряда, то мы бы не смогли упаковать линейную команду), хотя можно было бы использовать и 2 разряда, так как команд у нас всего 4.

Кодирование останова не совсем удачное: раз нам доступны три разряда, то было бы логичнее закодировать останов как 100 как ещё одну группу команд, это бы упростило распределение на группы.


### Размещение данных в памяти

<a href="https://ibb.co/DCFTJG8"><img src="https://i.ibb.co/KqgSPNL/image.png" alt="image" border="0"></a>

В команде сложения (или, в общем случае, в команде в четырёхразрядным результатом) операнд может находиться в любом из полубайтов, и в этот же любой полубайт пишется результат (выделено жирным). Дма младших разряда адреса и будут указывать, с какого полубайта берётся операнд и в какой полубайт результат будет записываться, если, конечно, он записывается в ОП. В примере из пособия регистровой памяти нет, поэтому все результаты записываются в оперативную.




<!--stackedit_data:
eyJoaXN0b3J5IjpbNjQyNjEzNjA2LC04MjQ1MzYyNCwtMTk3MT
k0NDc5NSw4Njg1Njg2Ml19
-->