
# Схемотехника
<a href="https://ibb.co/tJ65KTQ"><img src="https://i.ibb.co/QKVGQ3p/image.png" alt="image" border="0"></a>

<a href="https://ibb.co/QFwz8cx"><img src="https://i.ibb.co/TB3pKTN/image.png" alt="image" border="0"></a>

6 лаб. (первая - вводная, все в сборнике лаб). 6 -- состязания

Лабы в чт по подгруппам, 513 тоже буде разбита на подгруппы.

Каждая работа
Синтезировать схему, разрабатывать схему на языке VHDL (пишем дома, отлаживаем в универе).

В каждой лабе надо строить временные диаграммы
во 2 и третьей строить руками (вручную или в excel, но не через xilinx) с учетом временных параметров

завтра два семинара вместо лаб по построению временных диаграмм для всех лабораторных

готовимся с опережением удалённо: на вводную работу 2 занятия не считая завтрашнего

на комб схемы 2 занятия

счётчики и триггеры по 3 занятия

состязание -- 1 занятие

каждая лаба предусматривает 
на входе проверяем подготовку заранее высланную на почту (на 3 неделе высылаем подгтовку и на 4 неделе приходим с готовой 2 лабой)

пишем входной тест: 15 минут входной тест на каждую лабу на оценку

после выполнения всех пунктов в описании лабы и отчитывании пишется зачётный тест на полчаса (3-5 вопросов), чтобы защитить тест надо больше 50%. в один день только один тест.

не написали входной тест -- не допущены

входной тест: читаем подготовку к лабе с теорией (можно смотреть и в сборнике задач), а зачетный тест -- оценка задержек, небольшой синтез , посложнее

после ответа на тесты сдаём отчеты по лабораторной работе

в лабах подключаем элементы стенда и работаем с осциллографом (см приложение в сборнике лаб, там есть описание работы с осциллографом). в приложении кроме того приведены условные обозначения элементов, которые тоже надо знать, они будут в тестах

лаба вводная, лаба 2 и приложение 1 ⇒ это всё будет во входном тесте ко второй лабе

работы фронтально -- по расписанию, долги остаются на потом

расчёт параметров временных диаграмм, задержек тоже нужен в каждой работе

к 10 сентября надо овладеть стендом, вспомнить xilinx, работу с осциллографом


6-7 неделя: бдз на проектирование процессора, которое завершается 1 июня защитой курсового проекта
задание на два семестра
начинаем проектировать блок операций, который будет выполнять умножение (много разных алгоритмов)

книжка проектирование процессора 2006 а4 -- по ней два семестра готовимся к защите

в этом семестре сдать в электронном виде первую часть -- блок операций

на каждом семинаре выдаются дз, которые надо сделать заранее: к понедельнику вечером присылаются отчеты по заданиям

6 часов в неделю, 96 часов нагрузка в семестр + домашняя подготовка

на семинарах говорится что как делать в лабах, будут некоторые уточнения, изменения в схемах

в лабах набираем схему заново

<a href="https://ibb.co/v1YPrtQ"><img src="https://i.ibb.co/0qtMWwF/image.png" alt="image" border="0"></a>
ПС -- схемы с обратной связью: сигналы с выходов поступают на вход. ПС -- схемы с предысторией.

<a href="https://ibb.co/kmjfPtv"><img src="https://i.ibb.co/VwRZks5/image.png" alt="image" border="0"></a>

Комбинации И-ИЛИ-НЕ, И-НЕ (штрих Шеффера), ИЛИ-НЕ (стрелка Пирса) по отдельности являются логическими базисами. 

"Исключающее ИЛИ" -- желательно в статьях писать именно так. Сумма по модулю два -- это тоже самоею

XOR -- неравнозначность, XNOR -- равнозначность.

Эти элементы будут входить в экзамен. Достаточный материал для подготовки приведён в сборнике задач.

**Триггер** -- элемент, имеющий два устойчивых состояния. Предназначен для хранения одного бита информации.

Набор триггеров может образовывать регистр или счётчик. На регистрах и счётчиках можно строить делители частоты, формирователи импульсов, и так далее.

<a href="https://ibb.co/GpF5wt2"><img src="https://i.ibb.co/W5s29Py/image.png" alt="image" border="0"></a>

AND -- логическое умножение, конъюнкция. Обозначается в виде прямоугольника, где в верхней части рисуется обозначение функции. В системе Xilinx это полулуна.

Между элементами, как и между всеми связями не менее 5 мм. Любая документация должна иметь и печатную версию и в ней надо увеличивать именно так.

Функцию можно записывать через точку, а можно её пропускать, но тогда надо оставлять немного места. Все обозначения пишем заглавными буквами. Можно обозначать $\land$ или `and`, как в языке VHDL.

Входы и выходы в таблице истинности было бы лучше отделить двойной линией.

> И: если среди входов есть хотя бы один сигнал с 0, даёт 0.

высокий уровень (больше 2.4 В) = логическая 1
низкий уровень (0): меньше 0.4 В

Схема И: когда все единицы, то результат единица, что для отладки может быть неудобно: слово ВСЕ означает, что как бы надо проверять все входы. А лучше бы смотреть, где встречаются нули: 

### ИЛИ
Четверть луны, 1. А + В, галочка V или `or`.

Правило: если есть хотя бы одна единица, то даёт единицу.


### Инвертор
Раньше на стенде писали всегда 1. Важно, что на выходе рисуется инверсия. В Xilinx рисуется треугольник с кружочком. 
Инверсию ещё можно писать над элементом. Гораздо удобнее набирать `A'`, можно писать `nB`.

<a href="https://ibb.co/3v80X09"><img src="https://i.ibb.co/LrqCwCX/image.png" alt="image" border="0"></a>

И-НЕ: правило: если хотя бы один 0, то на выходе 1. В VHDL `nand` можно написать только для 2 входов. Иначе написать `not (A and B and C and ... )`


В NAND и NOR указывается количество входов.

ИЛИ-НЕ: есть хотя бы одна единица ⇒ даёт 0.

Для перехода между ними можно применять т. де Моргана

<a href="https://ibb.co/5cBXKqX"><img src="https://i.ibb.co/9YsmZRm/image.png" alt="image" border="0"></a>

<a href="https://ibb.co/ftgdJjn"><img src="https://i.ibb.co/92DHPQV/image.png" alt="image" border="0"></a>

### XOR 

Имеет несколько обозначений: в отечественных =1, М2 (сумма по модулю 2), плюс в кружочке.

В Xilinx -- дополнительная дуга у четверти луны.

Также описана реализация этой функции в базисе И, ИЛИ, НЕ. Высший приоритет имеют инверторы, далее реализуем слагаемые (термы или импликанты) на конъюнкторах, затем импликанты объединяем по И.

Управляемый инвертор: А -- вход управления, то при 0 передаём значение В, а при 1 передаём инверсию В. Мы управляем передачей В.

### XNOR

Обозначается как XOR с инверсией, но подписывается XNOR.

<a href="https://ibb.co/wgFb9xz"><img src="https://i.ibb.co/6w7p3fW/image.png" alt="image" border="0"></a>

Схемные решения сравниваем по двум параметрам:
- по аппаратным затратам (число элементов). В этих двум схемах одинаково для 8 входов
- по временным параметрам (задержка входного сигнала по поступления на выход)

Видно, что в каскадной схеме каждый вход задержан на три элемента. А в последовательной задержка бОльшая и достигает 7 элементов.

Можно отметить, что каждый входной сигнал схемы может приходить не одновременно. Например, зная, что сигнал D5 придёт поздно, его можно подать на последовательную схему и он задержится только на 1 элемент. В этом случае последовательная структура может быть предпочтительней по быстродействию.

<a href="https://ibb.co/mzDXYHz"><img src="https://i.ibb.co/cTgCpNT/image.png" alt="image" border="0"></a>

Вход и выход могут быть прямой (только прямой или только  инверсный) или парафазный (поступает и прямой, и инверсный)

Прямой динамический вход: элемент работает по фронту из 0 в 1 синхросигнала (диагональ вверх в отечественном обозначении). В Xilinx показывается треугольник

Инверсный динамический вход: элемент срабатывает по фронту из 1 в 0. (спад). В отечественной версии треугольник может стоять снаружи.

Не логический вход: аналоговые сигналы

СЕ: разрешает работать синхросигнал, Е -- просто разрешение

CLR и PRE -- установки в 0 и в 1 асинхронно, R, S -- синхронно

UP у счётчика (плюс или минус)
LEFT -- разрешение сдвига влево/вправо
SLI, SRI -- вход последовательного приёма влево/вправо (shift left input/ shift right input)
TC -- terminal counter -- последнее состояние счётчика

входы для памяти:
WR (1 или 2 входа) -- запись

RAS или CAS -- строки адреса строки или столбца
A -- вход памяти
D -- вход данных

В отечественном обозначении элемент делится на три части: слева входы, в центре функция, которую выполняет элемент, справа выходы.

# Лекция 2. Основные логические элементы

## Дешифратор

<a href="https://ibb.co/D5PRx8L"><img src="https://i.ibb.co/pJ6LtRn/image.png" alt="image" border="0"></a>

Плюс унитарного (унарного) кода: всегда потребляется одна и та же энергия. Минус: он избыточен, 4 выходами можно задать только 4 разных кода.

УГО имеет на входе К адресных входов $A_i$ и $N$ выходов. Если $N = 2^k$, то дешифратор называется полным.

Пример неполного дешифратора: 4 входа и 10 выходов (например, для двоично-десятичной системы).

$E$ -- Enable: прямой вход разрешения. Дешифратору разрешается работать при $E = 1$. При $E = 0$ независимо от адресных входов на всех выходах будут нули.

Считаем, что нулевой разряд -- младший (А0), а n-ный -- старший (А1). В случае $A1 = 0$, $A0 = 0$, задаётся двоичный ноль и на выходе сигнал должен быть на нулевом выходе.

Аналогично для других комбинаций входов.

Для каждой единицы можно записать функцию от входов: $D0 = E*\overline {A1}*\overline {A0},\quad D1 = E*\overline{A1}* A0$ и так далее.

Для дешифратора будем придерживаться обозначения Xilinx: D2_4E (Decoder с 2 входами, 4 выходами и со входом Е).

Могут быть инверсные входы/выходы и инверсный вход разрешения. Вход Е может и вовсе отсутствовать.

### Логическая схема дешифратора

<a href="https://ibb.co/7NDDJ0g"><img src="https://i.ibb.co/1JNNf4s/image.png" alt="image" border="0"></a>

Мы не рисуем внешние входы и выходы, а ставим add label.

Если у элемента есть инверсный вход, он указывается через В и далее идёт их количество (AND3B2). Инверсные входы рисуются снизу

Данная схема -- линейная: количество элементов равно $2^k$, каждый из которых содержит $k + 1$ вход.
<a href="https://ibb.co/VB9mLyc"><img src="https://i.ibb.co/C082wd3/image.png" alt="image" border="0"></a>
#### Линейная структура

<a href="https://ibb.co/j4Nm28R"><img src="https://i.ibb.co/f0gf5Xv/image.png" alt="image" border="0"></a>
#### Пирамидальная структура
<a href="https://ibb.co/QYQdwjc"><img src="https://i.ibb.co/NWCSBn3/image.png" alt="image" border="0"></a>

#### Матричная структура
<a href="https://ibb.co/PgHK77Y"><img src="https://i.ibb.co/NKB5883/image.png" alt="image" border="0"></a>

На входа используется 2 маленьких дешифратора. С одного подаются горизонтальные линии, с другого -- вертикальные и выбираются элементы И, которые находятся на пересечении этих линий.

#### Каскадная структура


<a href="https://imgbb.com/"><img src="https://i.ibb.co/0QdJgMX/image.png" alt="image" border="0"></a>
Строим на готовых элементах

#### Каскадная структура с матричным выходом

<a href="https://imgbb.com/"><img src="https://i.ibb.co/NTjcZFv/image.png" alt="image" border="0"></a>

На один из входов Е подана VCC (константа 1), поэтому нижний дешифратор всегда выбирает какую-то единицу и подаёт сигнал на какую-то вертикаль, а верхний дешифратор может и не работать, если Е не подан.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/MGvNNM2/image.png" alt="image" border="0"></a>
Один из разрядов адреса заблокируем: возьмём один из адресных входов $A_i$ и заблокируем его по входу Е: если Е = 0, то на обоих выходах $E.NA_i$  (инверсный) и $E.A_I$ (прямой) будут нули ⇒ эта переменная блокируется. Правда, добавляется дополнительный уровень задержки в виде двух элементов И после инвертора. Таким образом, вместо N элементов, связанных со всеми переменными, можно блокировать только одну переменную (задавать оба нуля на прямом и на инверсном выходе).



Для структуры D4_16 нужно будет 16 элементов 5И (если нет входа Е, надо будет 4И) и 4 инвертора в линейной структуре  = 84 входа. (68 без Е).

Для пирамидальной структуры D4_16 нужно будет 4 + 8 + 16 = 28 2И + 4 инвертора = 60 входов.

Для матричной структуры: (4 * 4 + 4 + 4 = 24 элемента 2И) + 4 инвертора = 52 входа.

**Одно из назначений дешифратора**: разрешить работу одному из нескольких абонентов/блоков по входному коду. 

Если перепутать порядок подачи сигналов на дешифратор, он выдаст сигнал на другом выходе -_-


Мы получаем, что у нас есть два входа (4 возможных простых термы) и каждый выход зависит от одного термы. Таким образом, на дешифраторе можно реализовать вычитатель

<a href="https://ibb.co/rFtxYqy"><img src="https://i.ibb.co/GnJWyGP/image.png" alt="image" border="0"></a>

На дешифраторе реализуется $2^k$ простых термов и с помощью ИЛИ можно объединять необходимые нам термы. Таким образом на дешифраторе можно реализовать любую логическую функцию.

## Мультиплексор

<a href="https://ibb.co/mNz20rm"><img src="https://i.ibb.co/KKyfDcY/image.png" alt="image" border="0"></a>

Мультиплексор передаёт на выход один из входов. Двоичный код на адресных входах указывает номер информационного входа, который надо передать на выход мультиплексора.

При этом число адресных входов $k = ceil(\log_2 n)$

<a href="https://ibb.co/wsLywT8"><img src="https://i.ibb.co/pyP2RgN/image.png" alt="image" border="0"></a>

В Xilinx обозначается М2_1Е (2 -- число информационных входов D, 1 -- число выходов S (select), E -- наличие входа разрешения).

Здесь приведена не полная, а сокращённая таблица истинности (4 входа ⇒ дб 16 строк). А у нас только 5. Поэтому никакой минимизации здесь уже не надо проводить. Мы имеем два терма, на которых результат будет единицей

<a href="https://ibb.co/r3d58Jc"><img src="https://i.ibb.co/jzJ30FW/image.png" alt="image" border="0"></a>

### Увеличение разрядности мультиплексора
#### Пирамидальная структура
<a href="https://imgbb.com/"><img src="https://i.ibb.co/BTNmCjz/image.png" alt="image" border="0"></a>

Е можно было бы подать только на последний элемент.

#### С дешифратором на входе
<a href="https://ibb.co/Hr0cV2W"><img src="https://i.ibb.co/jLdCT5c/image.png" alt="image" border="0"></a>

<a href="https://ibb.co/kDyfLt1"><img src="https://i.ibb.co/z25Y3zJ/image.png" alt="image" border="0"></a>

У мультиплексора каждый информационный вход является термом. Поэтому на мультиплексоре можно реализовывать функции
<a href="https://ibb.co/z7zY9ZC"><img src="https://i.ibb.co/1dk5yTB/image.png" alt="image" border="0"></a>

Мажоритарный элемент: если на входе 2 или больше единиц, даёт единицу на выход.

Мы можем для реализации функции от $k$ переменных использовать мультиплексор от $2^k$ переменных. 

В данной таблице истинности мы видим, что у нас либо есть зависимость от младшей переменной, либо нет:

<a href="https://ibb.co/x8NhX8f"><img src="https://i.ibb.co/gFxymFP/image.png" alt="image" border="0"></a>

Если бы мы использовали первый подход, нужно было бы 2 мультиплексора для функций CO и S. 

У итогового мультиплексора две группы входов I1 и I2. I1 передают сигнал на CO, I2 -- на S в зависимости от сигналов А и В. Здесь А и В -- адресные входы первого и второго мультиплексора, но каждый из мультиплексоров имеет свой инверсный вход разрешения G1 или G2.

Здесь показан второй подход: реализовать на мультиплексоре с 2^k-1^ входами, попарно объединив входные наборы. 

Также можно заметить, что сверху таблицы И(Х1, Х0), на втором -- ИЛИ(Х1, Х0) и поставить эти оба элемента на информационные входы мультиплексору, а Х2 подать на адресный вход.

## Демультиплексор
<a href="https://ibb.co/9y4bP8Y"><img src="https://i.ibb.co/HGPtZFg/image.png" alt="image" border="0"></a>

Передаёт информационный вход на нужный выход в зависимости от адресного входа. По сути демультиплексор -- это то же самое, что и дешифратор, только информационный вход D играет роль входа разрешения Е.

Можно соединить мультиплексор и демультиплексор и получить шину передачи данных.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/SykTrmv/image.png" alt="image" border="0"></a>

Если мы фиксируем S и А. Тогда мы можем с одного из входов D (от одного абонента) передать сигнал к третьему абоненту на дешифраторе F3. Таким образом, мы можем последовательно передавать информацию.

Меняя информацию на входах S и последовательно меняя D, мы можем передать параллельный код последовательно одному абоненту. Изменение сигналов на S позволяет передавать сигналы с D0 -- D3 последовательно (сначала D0, потом D1 и так далее).

Если мы зафиксируем S и будем менять А сможем передавать входы D последовательно передавать на F и последовательный код преобразовать в параллельный.

Количество входов, подключаемых к одному выходу, зависит от токов и допустимых токов на входах подключаемых элементов.

Элемент buff повторяет значение со входа на выход. Также его можно использовать, если надо задать разные имена шине.
# Триггеры
<a href="https://ibb.co/TPZMc2B"><img src="https://i.ibb.co/mhm5JTC/image.png" alt="image" border="0"></a>

В лабнике два триггера - двухступенчатой и с динамической записью. Но вместо триггера с динамической записью выполняем два триггера (если что, в задачнике есть доп теория), берём два готовых триггера

Логика может быть и отрицательной: высокий уровень = 0, низкий = 1.

В xilinx предложен только однофазный выход, а не парафазный, потому что дальше этот выход поступает, как правило, на КС -- элементы И, ИЛИ, и т.д. реализуются на lut -- просто записывается таблица истинности, а там можно учесть и инверсные выходы. а их можно реализовать и на инверторах. Поэтому в реальных заказных схемах лучше использовать и прямой, и инверсный выход. Но в xilinx в КС может быть инверсный вход, потому что все КС реализуются на lut.

Ограничение (бистабильные схемы): на прямом и инверсном выходе не может быть одновременно двух нулей и единиц, кроме переходных процессов.

Последовательностная схема -- выходы определяются как сигналами на входе, так и предысторией -- триггер как раз соответствует этому определению.

Триггер может переходить из одного состояния в другое. Считаем, что есть два входа -- set (установка в 1) и reset (сброс, установка в 0).

В отличие от КС (может быть описана таблицей истинности или функцией), триггер описывается таблицей/матрицей переходов, графом переходов или характеристическими уравнениями.

<a href="https://ibb.co/pKpYgHd"><img src="https://i.ibb.co/5jVbdQL/image.png" alt="image" border="0"></a>

В основе любого триггера лежит запоминающая ячейка, а точнее запоминающий элемент. Элемент -- это триггер, а ячейка -- это то, что считывается из памяти за одно обращение, поэтому лучше называть то, что в триггере ЗЭ.

Вместо $\overline Q$ лучше писать NQ, обозначая инверсные входы.

СУ преобразует логические сигналы: (Е1, Е2, а может быть и только один Е), синхросигнал С (если он есть, то триггер синхронный) во входы установки в 0 или в 1 ЗЭ.

У ЗЭ есть два входа внутри установки в 1 и сброса в 0, причём они могут быть как прямыми, так и инверсными. Если вход инверсный, то он исполняется при переходе из 1 в 0.

В лабе про двухступенчатые триггеры мы будем использовать ЗЭ на элементах 2И-НЕ.

<a href="https://ibb.co/xXXcZG7"><img src="https://i.ibb.co/q77469r/image.png" alt="image" border="0"></a>

Всегда стоить иметь перед глазами таблицу истинности, таблицы и матрицы переходов в лабораторных работах.

Предположим, что на входы R и S поступают два нуля. У данной схемы два входа + раз есть обратные связи, то они тоже считаются за входы. Считаем, что триггер изначально в состоянии 0. Что произойдёт?

Можно показать, что при подаче нулей триггер остаётся в таком же состоянии.

Пусть триггер находится в 0 (NQ = 0, у нас бистабильный триггер) и подаём S=0, R=1. Тогда мы смотрим, что на выходе верхнего элемента будет 0 ⇒ он придёт на нижний элемент, а S = 0 ⇒ на NQ будет 1 ⇒ независимо от того, в каком состоянии находился триггер, при 01 он переходит в 0.

Таким образом, 1 на R сбрасывает триггер.

Так как схема симметрична, то 1 на S устанавливает ноль на NQ и соответственно 1 на Q.

Если мы подали две единицы на входы, то Q будет равно 0 и NQ тоже будет равно 0 ⇒ на выходах будет два нуля, и такого быть не может ⇒ данная комбинация запрещённая (Х).

Поэтому часто рисуют не полную таблицу переходов, а пользуются сокращённой таблицей переходов: 00 ⇒ Q(t), 01 ⇒ 0, 10 ⇒ 1, 11 ⇒ X.

Если нарисовать для данного триггера УГО (отечественная версия), в основном поле вверху указано Т (триггер), а в дополнительном поле слева указаны называния входов S и R, причём эти входы прямые: переходы в новые состояний осуществляются по единице. 

Триггеры охвачены обратной связью ⇒ может быть нарисовано два последовательных элемента, а с выхода второго элемента идёт провод ко входу первого и наоборот. В лабах мы не сможем нарисовать связи под углом, поэтому придётся иногда делать так.

На картинке обозначено УГО асинхронного триггера, потому что нет входа C.

<a href="https://ibb.co/88rKp17"><img src="https://i.ibb.co/RH3vmRD/image.png" alt="image" border="0"></a>

Если мы подали 00, то это запрещённая комбинация -- на обоих выходах будут единицы.

Если мы подали 01, то на выходе верхнего будет 1, она придёт вниз, внизу на выходе будет 0 ⇒ при $\overline S = 0$ мы всегда переходим в единицу вне зависимости от состояния триггера.

С $\overline R$ симметрично, $\overline R$ устанавливает триггер в 0.

При единицах на обоих входах состояние триггера не меняется.

Данную полную таблицу можно преобразовать в обычную таблицу переходов $\overline S \overline R$ триггера. Если входы инверсные, то переключение идёт по нулю на входе.

На рисунке приведено УГО асинхронного $\overline R\overline S$ триггера (можно говорить $\overline S\overline R$, всё равно)

<a href="https://ibb.co/k1PsShM"><img src="https://i.ibb.co/Vmkcqv3/image.png" alt="image" border="0"></a>

В зависимости от логики наиболее часто используемые 5 триггеров. 

1 вход -- D, T триггеры (всего 25 штук)
2 входа (625 штук), RS, DV, JK

По способу записи информации: синхронные и асинхронные
- у асинхронного триггера состояние зависит только от логических входов: подали новый сигнал и состояние изменилось сразу же, как в КС
- у синхронного изменение состояния происходит по синхросигналу, новая входная информация принимается и обрабатывается по сигналу синхронизации
	- с динамическим управлением: информация принимается по перепаду сигнала, то есть по его изменению
	- со статическим управлением: управляется уровнем: информация принимается, когда синхровход соответствует уровню логической единицы или нуля, если он инверсный, **в течение всей длительности сигнала С**.
		- одноступенчатые (Т)
		- двухступенчатые (ТТ)

В сборнике лаб об этом подробно написано порядка 30 страниц текста.

## RS-триггер

<a href="https://ibb.co/By84CnG"><img src="https://i.ibb.co/qNb0rJC/image.png" alt="image" border="0"></a>

Триггер состоит из элементарной ЗЭ на И-НЕ, поэтому у него входы $\overline S'$ и $\overline R'$ (то есть входы именно запоминающей ячейки обозначаются со штрихом). Раз они инверсные, то на ЗЯ стоит триггер $\overline R\overline S$, а на входе стоит КС -- схема входной логики, на которую приходят логические сигналы и синхросигнал.

Раз вход $S$ прямой, то по единице триггер переходит в 1, а при R = 1 триггер переходит в 0, как видно в таблице. Поэтому для триггера в целом будет данная таблица перехода, а для внутреннего триггера в ЗЯ работает другая таблица для $\overline R\overline S$.

Раз внутри у нас инверсные входы, то нам надо обеспечить ноль либо на $\overline S$, либо на $\overline R$ю Если мы подаём на вход СУ два нуля, то эти два нуля у входных элементов И-НЕ выдадут единицы на инверсные входы внутренней ЗЯ ⇒ триггер внутри сохранит своё значение.

Теперь подаём S = 1, но пока на С стоит 0, элемента И-НЕ по-прежнему сохраняют подачу единиц на входы ЗЯ. Когда С станет равным 1, И-НЕ выдаст 0 на $\overline S$ ⇒ уровень С переключил $\overline S$ на 0 и он, в свою очередь переключил Q в единицу.

Когда мы подаём единицу на R, при С = 1 он переключит $\overline R$  ⇒ $\overline Q$ ⇒ Q.

Следующий импульс отрабатывает аналогично второму.

Заметим, что в первую очередь в триггере переключается выход, который из 0 переходит в 1, а затем уже переключается обратный ему из 1 в 0.

На рисунке приведено УГО синхронного статического прямого RS триггера.

## D-триггер

<a href="https://ibb.co/fqPN4hW"><img src="https://i.ibb.co/GnbMcKD/image.png" alt="image" border="0"></a>
D-триггер (Delay) -- триггер задержки. Он вход D с задержкой передаёт на выход.

В основе любых триггеров лежит синхронный RS-триггер, в том числе и здесь. Мы подаём D и C.

Вход D мы специально дополнительно инвертируем, потому что подавать две единицы на триггер -- запрещённая комбинация. Поэтому при подаче 1 на D за счёт инвертора внизу будет 0 ⇒ мы из RS триггера введением этого инвертора получаем D триггер.

При C = 0 триггер просто будет хранить информацию.

По задержкам: в RS триггере по синхросигналу идёт переключение двух элементов напрямую. Добавляя инвертор впереди, получаем переключение уже трёх элементов напрямую ⇒ задержка больше.

Можно поставить не инвертор, а сделать дополнительную связь (нижний рисунок), поэтому при D = 1 мы получаем 0 на входе RS и 1 на нижнем входе ⇒ триггер может работать, но время срабатывания будет поменьше. 

Но данная схема при моделировании может не работать, хотя реально всё будет ок. Потому что при D = 0 у нас будет 1 на входе S и R и всё норм. Если D = 1 и приходит синхросигнал, до его прихода на выходе верхнего И-НЕ стояла единица и ноль внизу ⇒ по приходе синхросигнала мы получаем 0 с задержкой вверху и в какой-то момент времени у нас будут находиться два нуля на обоих входах RS ⇒ система моделирования может сломаться, потому что это запрещённая комбинация.

Чтобы это отловить, можно перейти к моделированию Unit, которое работает каждую пикосекунду и может найти подобные кратковременные явления генерации (возбуждения).

### DV-триггер
Вход V -- вход разрешения для триггера (работает как вход СЕ) и фактически у всех триггеров в Xilinx есть. При V = 0 он запрещает работу триггера (он просто хранит информацию), а при V = 1 он работает как D триггер, передавая D на выход.

В принципе, при C = 0 D триггер тоже хранит информацию, а при C = 1 работает, поэтому V можно подавать параллельно С.

Это всё одноступенчатые триггеры

###  T-триггер (toggle)

<a href="https://ibb.co/R7bM2Kr"><img src="https://i.ibb.co/fQFKMW6/image.png" alt="image" border="0"></a>

Тот же RS триггер с добавленными двумя связями. При T = 0 триггер хранит информацию, при T = 1 выводит её инверсию.

Минус: триггер работать не будет:

при 0 всё хорошо, триггер будет хранить информацию и на входах R и S будут единицы.

При подаче T и C на выходах И-НЕ впереди будут единицы ⇒ Q = 0 ⇒ верхний И-НЕ = 1 ⇒ $\overline Q$ = 0 ⇒ и так далее ⇒  будет генериться сигнал в течение всего времени, пока С = 1 ⇒ на выходах триггера будет дудос и когда C станет равным 0, нельзя будет понять, в каком состоянии триггер окажется.

Это одноступенчатый триггер (буква Т в УГО стоит одна). 

Все СУ для триггеров будут справедливы и для двухступенчатых триггеров.

### JK (Jump-keep) триггер
При J = 1 мы прыгаем (лучше переходим) в единицу. А при k = 1 переходим в 0 ⇒ J и K напоминают прямые входы S и R. Но отличие от RS-триггера в том, что в JK-триггере комбинация 11 не запрещённая, при этом он работает как Т-триггер.

В основе берём синхронный RS-триггер, где вместо входа S написан J, а вместо R написан K и остаётся только реализовать комбинацию 11 так же, как и в Т триггере с помощью обратной связи.

Чтобы элементарная триггерная ячейка (ЗЭ) внутри переключилась, надо передавать на её входы нули, то есть переключение идёт именно по нулю.

Представлено УГО синхронного статического одноступенчатого JK-триггера. Минус такой же: при двух единицах на выходе может быть генерация сигналов, поэтому одноступенчатый JK-триггер мб неработоспособен.


В основе одноступенчатых триггеров лежит элементарная триггерная ячейка на элементах И-НЕ или ИЛИ-НЕ, они отличаются друг от друга схемой управления на входе.

Т-триггеры или JK-триггеры можно представить графами с двумя вершинами -- 0 или 1 и переходами по сигналам

### Двухступенчатые триггеры
<a href="https://ibb.co/YbBn9Jy"><img src="https://i.ibb.co/Fn4Zvc0/image.png" alt="image" border="0"></a>

Это схема из двух частей - двух последовательно соединенных триггеров, каждый из них со статической записью. Если считать, что это 2 одинаковых триггера, то обязательно второй прямой синхронный триггер RS, а на первом -- асинхронный RS у которого может быть логика управления E1-E2. 

Одновременный приём информации в два триггера запрещается инвертором по С внизу: в первую ступень запись идёт по С = 1, во вторую ступень информация будет записываться при С = 0.

После завершения приёма информации в первой ступени она передаётся во вторую.

В УГО у двухступенчатых триггеров ставятся буквы ТТ.

Может быть обратная связь состояния выхода второй ступени на вход (пунктир). Раз передаётся вторая ступень, то при С = 1 она не может изменяться и поэтому тот недостаток, который был у D и JK триггера здесь исключен.

Этот триггер также называют MS: первую ступень называют master (работает по уровню 1), а вторую slave (работает по уровню 0).

Вместо Е1 Е2 могут быть входы D, V, J, K, CE и так далее.


<a href="https://ibb.co/DpmkbKp"><img src="https://i.ibb.co/TLJRThL/image.png" alt="image" border="0"></a>

Если не обращать на пунктир внимания, то там видно два одинаковых RS триггера. Первый работает при С = 1, второй при С = 0.

Вход S можно рассматривать как J, а R как К, тогда можно будет провести пунктиры и этот триггер будет работать как JK.

В лабнике это рисунки 3.8 и 3.9

Считаем, что в начальный момент времени триггер установлен в 0 и синхровход равен 0. Отметим, что при С = 0 оба триггера находятся в одинаковом состоянии.

На С приходит 1. При этом на D1 D2 ничего не меняется, потому что для переключения первой ступени нужно обеспечить один из нулей на D1 или D2, а таких импульсов нет, потому что S = R = 0.

На S приходит 1. В первой ступени формируется ноль на D1 ⇒ D3 =Q' переходит в 1 ⇒ по обратной связи NQ' переключается в 0.

Когда C перейдёт в 0, D1 переходит в 0 ⇒ первая ступень переходит в режим хранения. Надо изменить состояние второго: C ⇒ NC ⇒ D9 ⇒ D5 ⇒ Q = 1 ⇒ NQ = 0.

Задержка у триггера: когда переключается выход триггера после прихода синхросигнала? В таком триггере переключение происходит, когда C = 0. Значение первой ступени переходит во вторую.

Симметрично происходит при подаче R = 1, S = 0. Сначала для первой ступени вырабатывается 0 на D2, а затем переключается C ⇒  NC ⇒ D6 ⇒ D8 ⇒ D7.

Поэтому лучше в лабе делать инвертор, потому что с ним задержка при переходе от 0 в 1 будет на один элемент меньше, а из 1 в 0 больше из-за доп. элемента в обратной связи.

<a href="https://ibb.co/jVGX28y"><img src="https://i.ibb.co/WDFJwHk/image.png" alt="image" border="0"></a>

Смотрим на УГО: ТТ ⇒ двухступенчатый триггер ⇒ он статический (это видно ещё и по тому, что в С входе нет наклонной линии). По логике работы там нарисован JK-триггер (заведены обратные связи), но тут нарисованы немного другие связи, есть две новых D1-D5 и D2-D6. Он немного быстрее, в книжке можно почитать, как это работает, но он так же срабатывает по С = 0.

Заметим, что дополнительно введены два асинхронных входа для предварительной установки его в начальные состояния 0 или 1.

Как обеспечить переход в единицу выхода Q? Можно подать в предыдущем триггере дополнительный независимый сигнал на D7 для второй ступени и на D3 для первой ступени. Но раз асинхронный вход можно подать в любой момент времени, то возможно появление запрещённой комбинации: если мы подаём ноль на D7, а в это время был ещё и ноль с D6, то это запрещённая комбинация, поэтому этот асинхронный сигнал мы подаём сразу на несколько элементов, чтобы они были согласованы. Как раз это видно в двухступенчатом JK-триггере ($\overline S$ подан сразу на несколько элементов).

Вообще эти связи можно было бы не делать, только если этот сигнал можно было бы подавать НЕ в любой момент времени, а только по синхросигналу. Но если сигнал асинхронный, надо его связывать со всеми элементами, чтобы не было запрещённых комбинаций на входах.

Когда мы подаём $\overline S$ = 0, меняется D3, потом одновременно D4, D5 ⇒ D6 => Q ⇒ $\overline Q$. На диаграмме видно, что в какой-то момент времени на входах Q и NQ могут быть две единицы -- когда один выход уже переключился с нуля в единицу, а второй ещё не успел переключиться с единицы на ноль.

В лабах будет предложено использовать ступень из RS триггера (схема 3.10 в лабнике). В 3.10 и 3.11 описано, как работают асинхронные входы. Если начать моделировать раньше то при построении диаграмм вручную мы считаем, что изначально оба триггера находятся в нуле.

А во время лабы надо будет проверять: сначала подать короткий $\overline S$, по которому можно будет видеть, что триггер переключился в 1, а уже за ним передаём $\overline R$, чтобы увидеть, что триггер переключился в 0 -- видно, что обе ступени сначала переключились в единицу, а потом в 0, а потом уже после всего этого подавать C.

Такая же схема приведена в рисунках 3.22 и 3.24, где
есть входы $\overline S$ и $\overline R$ и вместо нижнего инвертора по С инверсный вход NС

### Динамические параметры
У КС динамический параметр только один -- это задержка, у триггеров их 4

<a href="https://ibb.co/K05J9Kc"><img src="https://i.ibb.co/3rTn0R5/image.png" alt="image" border="0"></a>

Задержка мб как по изменению синхровхода, так и по асинхронным входам установки.

Время предварительной установки: насколько раньше надо подать логический и управляющий сигналы: минимальный интервал до активного синхросигнала. Активным изменением мб либо уровень, либо фронт. То есть как рано передать J или K. 

Все эти параметры так же описаны в лабнике, но приведены для разных схем.

Длительность: насколько коротким дб импульс: потому что если он будет коротким, мы можем не успеть переключить все ступени.

<a href="https://ibb.co/m8zY6qW"><img src="https://i.ibb.co/GTP1c2S/image.png" alt="image" border="0"></a>

Здесь показано, как идёт срабатывание.

Входы E1, E2, CE (V), L (load)-- здесь могут быть какие-то другие входы, например, та же самая картинка справедлива и для регистров. С одной стороны, CE можно считать логическим, а с другой -- как вход управления clock enable.

Все параметры считаются относительно активного фронта.

tuC -- длительности импульса С или асинхронного входа. Показывает, насколько он должен быть коротким, длительность импульса должна быть больше или равна этой паспортной величины.

Tуст -- насколько раньше нужно подать логические сигналы относительно фронта. Если бы это был уровень, то мы подаём не относительно начала уровня, а относительно снятия сигнала С, то есть момента, когда заканчивается импульс С.

Удержание -- так же, если относительно уровня, то до момента снятия.

Тпер -- время, через которое переключается уровень.

Если tuC >=, паспортному, то и остальные характеристики >= паспортным величинам, кроме задержки переключения, она <. Все эти параметры рассмотрены в третьей лабе, но отдельно друг от друга.

Так же мы будем эти параметры измерять в 5 лабе про регистры, там про эти параметры тоже можно почитать. На третьей лабе будем считать только время переключения, то есть задержку переключения выхода.

<a href="https://ibb.co/3m5btt4"><img src="https://i.ibb.co/WvNXSSG/image.png" alt="image" border="0"></a>

В Xilinx почти у всех триггеров входы прямые, в том числе и инверсные

<a href="https://ibb.co/Yc3JchB"><img src="https://i.ibb.co/McsKc7k/image.png" alt="image" border="0"></a>

В триггерах с динамическом записью видно отличие в черте у С. В Xilinx у С в динамических триггерах стоит треугольник внутри, а при инверсном на входе ещё и кружок инверсии.

<a href="https://ibb.co/cwGcDYs"><img src="https://i.ibb.co/3vDyBRP/image.png" alt="image" border="0"></a>

У триггеров стоит буква F (Flip-Flop). Следующая буква обозначает логику работы (какие логические входы у него есть). Затем -- обозначение установочного входа.

Preset и Clear -- асинхронные входы в Xilinx, а S и R -- это синхронные. До этого мы таких различий не делали.

Е может присутствовать, а может и нет -- это означает, что есть вход разрешения работы СЕ.

1 после обозначения означает, что у входа С есть инверсия, то есть триггер будет срабатывать по спаду, если он динамический.

Есть группы входоы:
- логика работы (J, K, D)
- CE -- можно считать за вход управления, хотя тоже мб логикой
- С -- исполнительный вход, по нему исполняется работа. CLR -- тоже исполнительный вход, потому что по нему тоже исполняется работа. Заметим, что в таком случае синхронные входы S и R -- не исполнительные, потому что работа происходит не по их изменению.

Асинхронный вход имеет наивысший приоритет: например, CLR независимо остальных входов заставит перейти в 0. Все микрооперации триггер выполняет только при CLR = 0.

Если CE = 0, то независимо от остальные входов кроме CLR триггер просто хранит информацию, в противном случае он работает как D триггер. CE сигнал следующего приоритета.

<a href="https://ibb.co/G3hYL9n"><img src="https://i.ibb.co/Kz14kDb/image.png" alt="image" border="0"></a>

Это сложный триггер, выполняет сразу две таблицы: работает и как Т триггер, но ещё имеет вход L -- load (это и написано в его обозначении), который разрешает работать Т входу -- аналог входа V в DV триггере.

При CLR = 0 (наивысший приоритет) устанавливается 0.

Следующий приоритет --  L: при L = 1 независимо от СЕ и Т значение D передаётся на выход: он разрешает работать D, L будет означать "загрузить D на выход".

Следующий -- СЕ. При СЕ = 0 триггер будет хранить информацию независимо от других входов, а при СЕ = 1 как D-триггер.

Любой триггер в Xilinx реализуется на D триггере, если посмотреть их внутреннюю структуру. А если нажать на этот D триггер, то внутри он раскрывается до D триггера без входа СЕ.

Этот триггер должен при L = 1 разрешить работу. При L = 1 мультиплексор разрешает пройти D входу внутрь триггера.

При L = 0 надо разрешить работу триггера -- нужно пропустить СЕ. При СЕ = 1 и L = 0 работает нулевой вход мультиплексора -- от выхода триггера подаётся сигнал на XOR TQ -- управляемый инвертор, который инвертирует Q при T = 1, что и происходит. При T = 0 триггер просто хранит сигнал, потому что инверсии не происходит.

Так параллельно работают Т и D триггер.

Так как L и CE должны разрешить работать синхровходу, стоит элемент ИЛИ. Если L и CE равны 1, будет всё равно работать L, потому что L имеет высший, чем СЕ, приоритет.

Раз на триггере D можно реализовать любой другой, можно реализовать любую таблицу переходов на D триггере, на вход которого можно поставить мультиплексор, а на входе мультиплексора задать требуемые переходы, управлять которым можно с помощью адресных входов.

<a href="https://ibb.co/gMmq0Dh"><img src="https://i.ibb.co/1f7yC9j/image.png" alt="image" border="0"></a>

Это описано ещё и в задачнике.

<a href="https://ibb.co/DL0RhQs"><img src="https://i.ibb.co/kMNSjXk/image.png" alt="image" border="0"></a>

Эта матрица переходов нигде не приведена, а описана словами в сборнике задач и лабнике в 4 лабе для DV триггера

Посмотрим на RS триггер со знакомой нам табличкой. Предположим, нам надо подать такое воздействие, чтобы триггер, находясь в 0, остался в 0. Какие комбинации нам можно подать?

В случае 10 триггер будет поставлен в 0, это нам подходит. А ещё нам подходит и комбинация 11, раз триггер уже до этого был в 0. Поэтому чтобы триггер остался в нуле, подходят две комбинации -- 10 или 11  ⇒ нам важно на NS подать единичку, а NR может быть любым. В матрице переходов X -- это не запрещённая комбинация, а любое значение, и при минимизации это означает, что мы можем выиграть и сократить схему.

Далее для переходов 0 -> 1 и 1 -> 0 подходят только по одной комбинации.

Для перехода 1 -> 1 ситуация симметрична переходу 0 -> 0. В принципе, можно приводить не всю матрицу переходов, а только её результат с Х.

Посмотрим, как сформировать матрицы переходов триггера по таблице переходов. Это есть в задачнике и в 4 лабе в лабнике.

Рассмотрим JK триггер.

0-0: подходят комбинации 00 и 01 ⇒ на J мы подаём 0, на К -- любой сигнал.
0-1: подходят 01 и 11 ==> комбинация Х1
1-0: 01 и 11 ⇒ X1
1-1: 10 и 00 ⇒ X0.

<a href="https://ibb.co/029zW4s"><img src="https://i.ibb.co/qjg24qJ/image.png" alt="image" border="0"></a>

Это будет сложно для DV

0-0: 00, 01, 10 подходят, но минимизация тут не очень поможет, поэтому можно задать эти три комбинации по другому: A, $\overline AB$, где А и B независимы друг от друга

Два других перехода простые с одной строчкой.

Переход 1-1: подходят 00 01 и 11 и тут можно их представить без инверсии: A2, A2*B2.

В третьей лабе предлагается применить этот подход: на с 63 начинается проектирование триггере по таблице перехода

<a href="https://ibb.co/KqyZwT1"><img src="https://i.ibb.co/vPz5Y0t/image.png" alt="image" border="0"></a>

Мы берём уже готовые триггеры, не реализуя начинку

<a href="https://ibb.co/kmvd0ZC"><img src="https://i.ibb.co/8Yth2kZ/image.png" alt="image" border="0"></a>

Для триггера от трёх переменных надо обеспечить переход в нужное состояние в соответствие с вариантом (столбец Q(t+1)), далее записываем переходы из JK и DV триггеров.

В таблице истинности мы пишем индексы, соответствующие номерам набора. По такой таблице проводить минимизацию

<a href="https://imgbb.com/"><img src="https://i.ibb.co/p16JTMk/image.png" alt="image" border="0"></a>

мы задаём сигналы Аi и Bi произвольно, но так, чтобы было проще минимизировать.

Дальше можно (но необязательно) перейти в базис и-не.

ДЗ

с 133 №3. Там опечатка: мультиплексор М4_1, а не 16.
с 138 №2

когда иначнём готовиться, на с 78 в лабнике приведена подобная таблица переходов, только в ней написано Q, 1, 0, NQ -- там надо поменять местами 1 и 0: во второй строке должен стоять 0, а в третьей 1

в табличку на с 79 в лабнике предлагается ввести два столбца Q(t+1) и переход


е1 е2 будут меняться как у счетчика на с 92 но это другая история

<a href="https://ibb.co/kqm1bw4"><img src="https://i.ibb.co/7rk4MZn/image.png" alt="image" border="0"></a>

<a href="https://ibb.co/wKSHdNP"><img src="https://i.ibb.co/xM1v2SB/image.png" alt="image" border="0"></a>


в лабе 4 делаем не всё задание как в лабнике, а также будем реализовывать делитель частоты, лучше смотреть в задачнике

<a href="https://ibb.co/9TRm6MZ"><img src="https://i.ibb.co/zRKWpk6/image.png" alt="image" border="0"></a>

Часто забывают что такое период или модуль счёта. Это число разрешенных устойчивых различимых состояний счетчика. 

вход, по которому считают входные сигналы, называется счётным. В лабе это будет C, с точки зрения счетчика -- это счётный вход, хотя это синхровход.

в лабе сигналы берём от генератора, он работает периодически. А на стенде передаём вручную, там импульсы приходят не периодически

<a href="https://ibb.co/jHBBbnR"><img src="https://i.ibb.co/V3rrJfm/image.png" alt="image" border="0"></a>

классификация
по способу кодирования

- позиционный счетчик -- каждая позиция или разряд счётчика имеет определённый вес. Например, в двоичном счётчике слева направо веса идут 8 4 2 1, но в общем случае и что будет в лабе веса не обязательно степень двойки. Могут быть веса 4 2 2 1, 1 3 5 1 -- каждая позиция по определению имеет свой вес, но **любой**.
- непозиционный: вес зависит не от позиции, а от чего-то другого. Например, в римской СС зависимость не только от позиции, но и от значения соседнего разряда.

по модулю счёта
- двоичные (веса 8 4 2 1), могут быть 16ричными, 4 2 1 -- мб восьмеричными или **с естественными весами разрядов**.
- двоично-десятичные (декада): наборы как правило от 0 до 9, где веса разрядов так же 8 4 2 1. в лабах мб десятичный счётчик (декада), модуль равен 10
- произвольный модуль счёта -- мб постоянным или переменным (программируемым), например, в зависимости от какого-то условия, например, входа Y, модуль счётчика может меняться
- прочие счётчики -- код Грея -- когда каждое следующее состояние от предыдущего отличается только в одном разряде: в обычном случае при переходе, например, 01 -> 10 могут быть состязания: нужно, чтобы младший разряд переключился в 1, а старший в ноль. Если сначала переключится младший, то будет переход 01 -> 00 -> 10; в противоположном случае 01 -> 11 -> 10. В коде Грея последовательность другая: 00, 01, 11, 10, 110 и т.д.
- кольцевой счетчик: выход последнего разряда соединяем со входом первого
- счётчик Джонсона (Мёбиуса): последний разряд переходит в первый но в инверсном виде
- Код 1 из N (единичного кодирования, пример: выход дешифратора или унитарный/унарный код). Например, код 1 из 4, плюс которого -- одинаковое потребление энергии на каждом разряде и относительно легко проверять на сбои: не мб двух единиц и не мб всех нулей.


по направлению счёта
- суммирующие: переход в одну сторону 
- вычитающие: переход в другую сторону
- реверсивные: в обе стороны
<a href="https://ibb.co/F3T6fvM"><img src="https://i.ibb.co/h9zsn5j/image.png" alt="image" border="0"></a>

по способу переключения триггера: раз это последовательностная схема, то она строится на основе триггеров
- синхронная: все синхровходы соединены друг с другом
- асинхронная

способу организации межразрядных связей
- как организуется перенос между разрядами, он же перенос между группами разрядов


<a href="https://ibb.co/94rWx7h"><img src="https://i.ibb.co/PW6g2dM/image.png" alt="image" border="0"></a>

Это позиционный счётчик, поэтому веса разрядов заранее известны: 8 4 2 1. 

На последнем состоянии формируется сигнал переполнения (carry output, P), который зависит от входного разрешения счёта CE и может формироваться сигнал CEO -- сигнал в Xilinx clock enable output и ещё TC (terminal counter). CEO зависит от TC и CE: CEO = TC * CE (написано в задачнике).

У счётчика должен быть сигнал начальной установки. Но начальная установка может идти в случае двоичного счётчика в нулевое состояние, но можно в какое-то другое (например, в лабах: счётчик может кроме счёта хранить значение и дальше чем-то управлять и в начале загружаем в счётчик 5 и затем переходим в 8: не для двоичного счётчика состояния -- это номера состояний, а не номера двоичных наборов на выходе. В лабах эти наборы могут идти в произвольном порядке, но в двоичном счётчике они всегда идут подряд)



<a href="https://ibb.co/dDG1BpL"><img src="https://i.ibb.co/vkZg1dQ/image.png" alt="image" border="0"></a>
инкремент и декремент можно рассматривать как переход на любое следующее состояние, не обязательно на какую-то константу

когда код не выдаётся, выход в третьем состоянии или открытый коллектор, а плюсы в том, что эти выходы можно объединять монтажным или **открытым коллектором**.

У счётчика мб логический выход (всегда есть), мб выход в третьем состоянии (Z), он импедансный (высокое сопротивление на выходах) или с открытым коллектором (ОК)

в лабе надо будет считать быстродействие -- с какой максимальной частотой могут поступать импульсы. в лабе будет 4 секции как показано в лабнике: счетчик, два делителя и vhdl и для них надо определить частоту и период, с которыми импульсы могут поступать. Надо найти минимальный период <= паспортной

время установки кодов на выходах счётчика -- задержки на каждом выходе <= паспортному

время формирования переноса или заёма (когда счётчик вычитает и при первом/начальном состоянии он формируется) <= паспортному

длительность счётного импульса -- берётся из характеристик для триггера, чтобы он успел переключиться. Она должна быть больше или равна паспортному значению в триггере

S1 -- это номера **состояний**, а не наборов!

для установки в начальное состояние можно использовать R как в триггере или S синхронно в единицу. Когда доходим до последнего состояния в суммировании, формируем сигнал переноса. Если установились в начальное состояние и надо из него вычитать, сразу как только пришли в начальное состояние формируется сигнал BO (заём)

важно, что разряды счётчиков могут строить на двухступенчатых триггерах (статических, управляемых уровнем), то есть нельзя использовать статические одноступенчатые и асинхронные триггера, а также бывают на триггерах с динамической записью

как правило триггеры работают в счётном режиме⇒ каждый триггера работает как счетчик по модулю 2 и как правило каждый триггер работает как Т триггер

например если бы мы хотели на Jk триггере то можно сделать объелинение входов j и k и получить Т триггер

<a href="https://ibb.co/gjHyYH7"><img src="https://i.ibb.co/FxN6pNW/image.png" alt="image" border="0"></a>

этот счётчик асинхронный, так как синхровходы не соединены между собой (С слева это счётный вход) Счётный вход поступает только на один триггер. Диаграмму можно строить независимо для каждого из триггеров, потому что нет обратных связей.

Всегда сначала надо подавать CLR.

На входе C стоит треугольник без инверсии ⇒ элементы срабатывают по фронту

Если объединить в шину отдельно выходы триггера, то видим, что счётчик считает 7 6 5 4 ...  ⇒ он работает в вычитающем режиме.

Видно, что в переходе 0 - 7 есть неустойчивое состояние за счёт не одновременного переключения разрядов.

Как видно по изменению разрядов, это действительно двоичный счётчик (подряд), при этом сигнал выхода Q2 будет являться заёмом для следующего.


чему будет равно время установки кода -- когда будет установлен код на всех триггерах. tкода = n * tтриггера. При этом tтриггера -- максимальное время из t01 и t10, n -- количество триггеров.

Время установки кода заёма так же равно n * tтриггера

<a href="https://ibb.co/SxXKnyt"><img src="https://i.ibb.co/BPVgZ3y/image.png" alt="image" border="0"></a>

это пример jk триггеров (как раз тут j и k входы объединены) ⇒ получается они работают как Т триггеры.

на с вход подаются инверторы -- то есть мы как бы берём сигналы с инверсных выходов триггеров, а на этот инвертор может потребоваться целый lut. В unit на нём так же будет задержка, хотя в реале на плис транслятор может увидеть, что инвертор стоит прямо перед входов tj1 и сделать вместо этого tj1 инверсный вход и задержки не будет

если стоят инверторы, то лучше для своего контроля построить, как работают инверторы на временной диаграмме. За счёт инвертора первый триггер работает не по фронту, а по спаду. А нулевой работает по фронту. Аналогично по спаду идёт срабатывание второго триггера

можно было бы показать инверторы на временной диаграмме (видно, что задержка на триггерах два пикселя)

это асинхронный суммирующий счётчик с теми же задержками (не считая инвертора); а если учитывать инверторы, то время установки будет равно nTтриггера + (n-1)Tинвертора

прямой -- вычитающий, инверсный -- суммирующий

чтобы сделать реверсивный счётчик на вход каждого элемента можно поставить мультиплексор 

этот счётчик -- у него межразрядные связи с последовательным или на непосредственной связи: они последовательно напрямую соединены когда выход одного триггера непосредственно соединен со входом другого

нужно как можно быстрее перейти требуемое состояние и постараться уменьшить задержки

<a href="https://ibb.co/fQvTY12"><img src="https://i.ibb.co/4Jd0Zm7/image.png" alt="image" border="0"></a>

вводим элементы и и счётный вход поступает на следующий элемент и и на него же поступает выход первого, аналогично дальше

синхросигнал со сквозным переносом проходит через весь счетчик

используя так же предыдущий Т триггер поставили инвертор и получили суммирующий счетчик (можно просто показать что у триггеров другой фронт работы по спау и нарисовать просто кружок на входе С с треугольником)

это счётчик со **сквозным** переносом, поэтому время установки кода равно (n-1)Tand + Tтриггера (или ещё + Тинвертора если учитывать инвертор)

второй параметр -- время установки переноса будет равно n * Тand 

данная схема быстрее по сравнению с предыдущей

<a href="https://ibb.co/7vdzWnm"><img src="https://i.ibb.co/zsT5RXv/image.png" alt="image" border="0"></a>

каждый последующий элемент И объединяет значения предыдущих разрядов и на каждый из них приходит счётный вход ⇒ данная схема называется с параллельным переносом

время установки кода в этой схеме будет ещё меньше: Тand + Ттриггера -- синхросигнал приходит одновременно на все триггера, поэтому оно не зависит от числа элементов

но при этом размер схемы растёт

время установки переноса равно Tand

Это асинхронный суммирующий с параллельным переносом, самый быстрый счётчик

можно объединять в группы счетчиков: внутри группы можно организовать параллельный перенос а между группами может быть сквозной / последовательный перенос, а можно тоже организовать параллельный перенос

<a href="https://ibb.co/NKjzxdj"><img src="https://i.ibb.co/njcSrNc/image.png" alt="image" border="0"></a>

синхронный счетчик с произвольным кодированием

попробуем посмотреть как работает данный счетчик. что нужно чтобы построить вд

нужно знать работу каждого элемента у нас есть JK триггер, инвертор и элемент И который можно дополнительно встроить потом как кобминационную схему

остальные элементы надо строить последовательно потому что еасть обратная связь

jk триггер: 00 хранит, 10 - 1, 01 - 0, 11 меняет значение на противоположное. Это счётчик не просто с произвольным кодированием, а главное что синхронный, потому что у него объединены синхровходы

значит любое изменение С одновременно приходит на каждый триггер а значит можно независимо рассмратривать каждый триггер при том состоянии кторое было до этого события

но прежде всего надо посмотреть установку в начальное состояние 
когда приходит clr (установка в начальное состояния) устанавливает в 1 нулевой и первый триггер а второй в 0 ⇒   по clr счётчик устанавливается в 0 1 1 = 3


теперь приходит синхросигнал, нехависимо рассматриваем каждый триггер

нулевой триггер: j вход соединен с Q2 = 0 ⇒ на j = 0; k = Q1 = 1 ⇒ 10 ⇒ триггер переходит в 0

первый триггер: он работает как d триггер (у него один вход прямой, другой инверсный) ⇒ этот триггер с инвертором на входе можно рассматривать как d триггер, j = 1 до прихода C ⇒ k = 0 ⇒ 10 триггер остаётся в единице

второй триггер 0 остаётся без изменений

можно представить граф переходов, он произвольный

модуль счётчика равен 8: видно 8 разных состояний
начальное состояние 3, последнее 5 -- на нём вырабатывается перенос CR (carry)

в заключительном тесте будет стоять что-то подобное, надо ответить, какие наборы проходит счётчик. Можно строить диаграмму, а можно таблицу состояний

исходное состояние 3. куда переходим можно писать рядом, а можно принципиально считать что следующее состояние будет на следующей строчке (можно строить только один столбик)

мы находимся в состоянии 3, на триггере 01 ⇒ он перешёл в 0; на первом триггере 10 ⇒ 1 и так далее

триггера мы рассматриваем в любом порядке независимо

так мы вычисляем совокупность состояний на каждом наборе


чему равно время установки кода в данной схеме: в данном случае только Ттриггера, так как синхровход приходит одновременно на все и каждый триггер переключается одновременно в соответствии с таблицей перехода.

важно бывает посчитать быстродействие -- через какое время мы можем подать следующий синхросигнал или период Тсинхроимпульса. надо проанализировать все переходные процессы. Код устанавливается за Ттриггера. Что ещё может переключаться -- инверторы за триггерами, а в общем случае там мб не инверторы, а какие-то схемы ⇒ надо будет учитывать ещё время переключения данных КС на информационных входах триггеров; потом после переключения КС + время предварительной установки вхдов триггеров.

Т = Ттриггера + ТКС + Тпред. уст. триггера

только после этого можно подать следующий фронт, а частота = 1/Т

в лабе надо будет определить частоту счётчика или делителя при параллельном режиме.

для построения временных диаграмм можно строить таблицу состояний, это позволит ускорить анализ схемы: рассматриваем текущее состояние и для каждого из триггеров рассматриваем таблицу и определяем, какое состояние будет следующим.

в 4 лабе в задании мы должны реализовать делитель частоты либо на двоичном

<img src="https://i.ibb.co/fCTwyJ9/image.png" alt="image" border="0">

Порядок срабатывания или приоритет соответсвует порядку указывания букв в обозначении: C > L > E > D.

Из обозначения букв можно построить УГО в системе Xilinx. 
- C -- это просто счётчик, но учитывая, что они все синхронные в Xilinx, то мы можем уже построить синхровход. Если бы вход был инверсный, в конце обозначения было бы _1, и тогда
- B -- двоичный счётчик
- 2 -- в обозначении уже можем отметить два выхода
- C -- можем построить CLR
- E -- вход CE
- L -- вход Load

<img src="https://i.ibb.co/MRZYZ1n/image.png" alt="image" border="0">

Количество входов D равно количеству выходов: в счётчик можно сразу загрузить некоторое состояние по сигналу L.

Высшим приоритетом обладает вход CLR, затем L (работает по фронту, синхронный сигнал), затем CE.

Можно отметить, что в Xilinx есть счётчики суммирующие или реверсивные, чисто вычитающих счётчиков нет.

В состав счётчика включается 2 триггера. CLR объединён у двух триггеров. Для загрузки работают входы D0 D1, которые подаются на триггеры. L загружает на оба триггера.

Счётчик должен считать: младший разряд всегда в счётном режиме, поэтому на Т подаём VCC. 

У триггеров есть вход CE, но в таблице отмечено, что и при L, и CE должны работать по фронту 01 ⇒ включается дополнительный элемент ИЛИ, который объединяет CE и L, выход которого подключается к CE триггеров.

У всех счё 
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTM4NzQ3MTMyMCwzNTYxMDIxNDYsLTE1NT
g2MTEyMjUsLTE1NTY2ODYyOF19
-->