
# Схемотехника
<a href="https://ibb.co/tJ65KTQ"><img src="https://i.ibb.co/QKVGQ3p/image.png" alt="image" border="0"></a>

<a href="https://ibb.co/QFwz8cx"><img src="https://i.ibb.co/TB3pKTN/image.png" alt="image" border="0"></a>

6 лаб. (первая - вводная, все в сборнике лаб). 6 -- состязания

Лабы в чт по подгруппам, 513 тоже буде разбита на подгруппы.

Каждая работа
Синтезировать схему, разрабатывать схему на языке VHDL (пишем дома, отлаживаем в универе).

В каждой лабе надо строить временные диаграммы
во 2 и третьей строить руками (вручную или в excel, но не через xilinx) с учетом временных параметров

завтра два семинара вместо лаб по построению временных диаграмм для всех лабораторных

готовимся с опережением удалённо: на вводную работу 2 занятия не считая завтрашнего

на комб схемы 2 занятия

счётчики и триггеры по 3 занятия

состязание -- 1 занятие

каждая лаба предусматривает 
на входе проверяем подготовку заранее высланную на почту (на 3 неделе высылаем подгтовку и на 4 неделе приходим с готовой 2 лабой)

пишем входной тест: 15 минут входной тест на каждую лабу на оценку

после выполнения всех пунктов в описании лабы и отчитывании пишется зачётный тест на полчаса (3-5 вопросов), чтобы защитить тест надо больше 50%. в один день только один тест.

не написали входной тест -- не допущены

входной тест: читаем подготовку к лабе с теорией (можно смотреть и в сборнике задач), а зачетный тест -- оценка задержек, небольшой синтез , посложнее

после ответа на тесты сдаём отчеты по лабораторной работе

в лабах подключаем элементы стенда и работаем с осциллографом (см приложение в сборнике лаб, там есть описание работы с осциллографом). в приложении кроме того приведены условные обозначения элементов, которые тоже надо знать, они будут в тестах

лаба вводная, лаба 2 и приложение 1 ⇒ это всё будет во входном тесте ко второй лабе

работы фронтально -- по расписанию, долги остаются на потом

расчёт параметров временных диаграмм, задержек тоже нужен в каждой работе

к 10 сентября надо овладеть стендом, вспомнить xilinx, работу с осциллографом


6-7 неделя: бдз на проектирование процессора, которое завершается 1 июня защитой курсового проекта
задание на два семестра
начинаем проектировать блок операций, который будет выполнять умножение (много разных алгоритмов)

книжка проектирование процессора 2006 а4 -- по ней два семестра готовимся к защите

в этом семестре сдать в электронном виде первую часть -- блок операций

на каждом семинаре выдаются дз, которые надо сделать заранее: к понедельнику вечером присылаются отчеты по заданиям

6 часов в неделю, 96 часов нагрузка в семестр + домашняя подготовка

на семинарах говорится что как делать в лабах, будут некоторые уточнения, изменения в схемах

в лабах набираем схему заново

<a href="https://ibb.co/v1YPrtQ"><img src="https://i.ibb.co/0qtMWwF/image.png" alt="image" border="0"></a>
ПС -- схемы с обратной связью: сигналы с выходов поступают на вход. ПС -- схемы с предысторией.

<a href="https://ibb.co/kmjfPtv"><img src="https://i.ibb.co/VwRZks5/image.png" alt="image" border="0"></a>

Комбинации И-ИЛИ-НЕ, И-НЕ (штрих Шеффера), ИЛИ-НЕ (стрелка Пирса) по отдельности являются логическими базисами. 

"Исключающее ИЛИ" -- желательно в статьях писать именно так. Сумма по модулю два -- это тоже самоею

XOR -- неравнозначность, XNOR -- равнозначность.

Эти элементы будут входить в экзамен. Достаточный материал для подготовки приведён в сборнике задач.

**Триггер** -- элемент, имеющий два устойчивых состояния. Предназначен для хранения одного бита информации.

Набор триггеров может образовывать регистр или счётчик. На регистрах и счётчиках можно строить делители частоты, формирователи импульсов, и так далее.

<a href="https://ibb.co/GpF5wt2"><img src="https://i.ibb.co/W5s29Py/image.png" alt="image" border="0"></a>

AND -- логическое умножение, конъюнкция. Обозначается в виде прямоугольника, где в верхней части рисуется обозначение функции. В системе Xilinx это полулуна.

Между элементами, как и между всеми связями не менее 5 мм. Любая документация должна иметь и печатную версию и в ней надо увеличивать именно так.

Функцию можно записывать через точку, а можно её пропускать, но тогда надо оставлять немного места. Все обозначения пишем заглавными буквами. Можно обозначать $\land$ или `and`, как в языке VHDL.

Входы и выходы в таблице истинности было бы лучше отделить двойной линией.

> И: если среди входов есть хотя бы один сигнал с 0, даёт 0.

высокий уровень (больше 2.4 В) = логическая 1
низкий уровень (0): меньше 0.4 В

Схема И: когда все единицы, то результат единица, что для отладки может быть неудобно: слово ВСЕ означает, что как бы надо проверять все входы. А лучше бы смотреть, где встречаются нули: 

### ИЛИ
Четверть луны, 1. А + В, галочка V или `or`.

Правило: если есть хотя бы одна единица, то даёт единицу.


### Инвертор
Раньше на стенде писали всегда 1. Важно, что на выходе рисуется инверсия. В Xilinx рисуется треугольник с кружочком. 
Инверсию ещё можно писать над элементом. Гораздо удобнее набирать `A'`, можно писать `nB`.

<a href="https://ibb.co/3v80X09"><img src="https://i.ibb.co/LrqCwCX/image.png" alt="image" border="0"></a>

И-НЕ: правило: если хотя бы один 0, то на выходе 1. В VHDL `nand` можно написать только для 2 входов. Иначе написать `not (A and B and C and ... )`


В NAND и NOR указывается количество входов.

ИЛИ-НЕ: есть хотя бы одна единица ⇒ даёт 0.

Для перехода между ними можно применять т. де Моргана

<a href="https://ibb.co/5cBXKqX"><img src="https://i.ibb.co/9YsmZRm/image.png" alt="image" border="0"></a>

<a href="https://ibb.co/ftgdJjn"><img src="https://i.ibb.co/92DHPQV/image.png" alt="image" border="0"></a>

### XOR 

Имеет несколько обозначений: в отечественных =1, М2 (сумма по модулю 2), плюс в кружочке.

В Xilinx -- дополнительная дуга у четверти луны.

Также описана реализация этой функции в базисе И, ИЛИ, НЕ. Высший приоритет имеют инверторы, далее реализуем слагаемые (термы или импликанты) на конъюнкторах, затем импликанты объединяем по И.

Управляемый инвертор: А -- вход управления, то при 0 передаём значение В, а при 1 передаём инверсию В. Мы управляем передачей В.

### XNOR

Обозначается как XOR с инверсией, но подписывается XNOR.

<a href="https://ibb.co/wgFb9xz"><img src="https://i.ibb.co/6w7p3fW/image.png" alt="image" border="0"></a>

Схемные решения сравниваем по двум параметрам:
- по аппаратным затратам (число элементов). В этих двум схемах одинаково для 8 входов
- по временным параметрам (задержка входного сигнала по поступления на выход)

Видно, что в каскадной схеме каждый вход задержан на три элемента. А в последовательной задержка бОльшая и достигает 7 элементов.

Можно отметить, что каждый входной сигнал схемы может приходить не одновременно. Например, зная, что сигнал D5 придёт поздно, его можно подать на последовательную схему и он задержится только на 1 элемент. В этом случае последовательная структура может быть предпочтительней по быстродействию.

<a href="https://ibb.co/mzDXYHz"><img src="https://i.ibb.co/cTgCpNT/image.png" alt="image" border="0"></a>

Вход и выход могут быть прямой (только прямой или только  инверсный) или парафазный (поступает и прямой, и инверсный)

Прямой динамический вход: элемент работает по фронту из 0 в 1 синхросигнала (диагональ вверх в отечественном обозначении). В Xilinx показывается треугольник

Инверсный динамический вход: элемент срабатывает по фронту из 1 в 0. (спад). В отечественной версии треугольник может стоять снаружи.

Не логический вход: аналоговые сигналы

СЕ: разрешает работать синхросигнал, Е -- просто разрешение

CLR и PRE -- установки в 0 и в 1 асинхронно, R, S -- синхронно

UP у счётчика (плюс или минус)
LEFT -- разрешение сдвига влево/вправо
SLI, SRI -- вход последовательного приёма влево/вправо (shift left input/ shift right input)
TC -- terminal counter -- последнее состояние счётчика

входы для памяти:
WR (1 или 2 входа) -- запись

RAS или CAS -- строки адреса строки или столбца
A -- вход памяти
D -- вход данных

В отечественном обозначении элемент делится на три части: слева входы, в центре функция, которую выполняет элемент, справа выходы.

# Лекция 2. Основные логические элементы

## Дешифратор

<a href="https://ibb.co/D5PRx8L"><img src="https://i.ibb.co/pJ6LtRn/image.png" alt="image" border="0"></a>

Плюс унитарного (унарного) кода: всегда потребляется одна и та же энергия. Минус: он избыточен, 4 выходами можно задать только 4 разных кода.

УГО имеет на входе К адресных входов $A_i$ и $N$ выходов. Если $N = 2^k$, то дешифратор называется полным.

Пример неполного дешифратора: 4 входа и 10 выходов (например, для двоично-десятичной системы).

$E$ -- Enable: прямой вход разрешения. Дешифратору разрешается работать при $E = 1$. При $E = 0$ независимо от адресных входов на всех выходах будут нули.

Считаем, что нулевой разряд -- младший (А0), а n-ный -- старший (А1). В случае $A1 = 0$, $A0 = 0$, задаётся двоичный ноль и на выходе сигнал должен быть на нулевом выходе.

Аналогично для других комбинаций входов.

Для каждой единицы можно записать функцию от входов: $D0 = E*\overline {A1}*\overline {A0},\quad D1 = E*\overline{A1}* A0$ и так далее.

Для дешифратора будем придерживаться обозначения Xilinx: D2_4E (Decoder с 2 входами, 4 выходами и со входом Е).

Могут быть инверсные входы/выходы и инверсный вход разрешения. Вход Е может и вовсе отсутствовать.

### Логическая схема дешифратора

<a href="https://ibb.co/7NDDJ0g"><img src="https://i.ibb.co/1JNNf4s/image.png" alt="image" border="0"></a>

Мы не рисуем внешние входы и выходы, а ставим add label.

Если у элемента есть инверсный вход, он указывается через В и далее идёт их количество (AND3B2). Инверсные входы рисуются снизу

Данная схема -- линейная: количество элементов равно $2^k$, каждый из которых содержит $k + 1$ вход.
<a href="https://ibb.co/VB9mLyc"><img src="https://i.ibb.co/C082wd3/image.png" alt="image" border="0"></a>
#### Линейная структура

<a href="https://ibb.co/j4Nm28R"><img src="https://i.ibb.co/f0gf5Xv/image.png" alt="image" border="0"></a>
#### Пирамидальная структура
<a href="https://ibb.co/QYQdwjc"><img src="https://i.ibb.co/NWCSBn3/image.png" alt="image" border="0"></a>

#### Матричная структура
<a href="https://ibb.co/PgHK77Y"><img src="https://i.ibb.co/NKB5883/image.png" alt="image" border="0"></a>

На входа используется 2 маленьких дешифратора. С одного подаются горизонтальные линии, с другого -- вертикальные и выбираются элементы И, которые находятся на пересечении этих линий.

#### Каскадная структура


<a href="https://imgbb.com/"><img src="https://i.ibb.co/0QdJgMX/image.png" alt="image" border="0"></a>
Строим на готовых элементах

#### Каскадная структура с матричным выходом

<a href="https://imgbb.com/"><img src="https://i.ibb.co/NTjcZFv/image.png" alt="image" border="0"></a>

На один из входов Е подана VCC (константа 1), поэтому нижний дешифратор всегда выбирает какую-то единицу и подаёт сигнал на какую-то вертикаль, а верхний дешифратор может и не работать, если Е не подан.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/MGvNNM2/image.png" alt="image" border="0"></a>
Один из разрядов адреса заблокируем: возьмём один из адресных входов $A_i$ и заблокируем его по входу Е: если Е = 0, то на обоих выходах $E.NA_i$  (инверсный) и $E.A_I$ (прямой) будут нули ⇒ эта переменная блокируется. Правда, добавляется дополнительный уровень задержки в виде двух элементов И после инвертора. Таким образом, вместо N элементов, связанных со всеми переменными, можно блокировать только одну переменную (задавать оба нуля на прямом и на инверсном выходе).



Для структуры D4_16 нужно будет 16 элементов 5И (если нет входа Е, надо будет 4И) и 4 инвертора в линейной структуре  = 84 входа. (68 без Е).

Для пирамидальной структуры D4_16 нужно будет 4 + 8 + 16 = 28 2И + 4 инвертора = 60 входов.

Для матричной структуры: (4 * 4 + 4 + 4 = 24 элемента 2И) + 4 инвертора = 52 входа.

**Одно из назначений дешифратора**: разрешить работу одному из нескольких абонентов/блоков по входному коду. 

Если перепутать порядок подачи сигналов на дешифратор, он выдаст сигнал на другом выходе -_-


Мы получаем, что у нас есть два входа (4 возможных простых термы) и каждый выход зависит от одного термы. Таким образом, на дешифраторе можно реализовать вычитатель

<a href="https://ibb.co/rFtxYqy"><img src="https://i.ibb.co/GnJWyGP/image.png" alt="image" border="0"></a>

На дешифраторе реализуется $2^k$ простых термов и с помощью ИЛИ можно объединять необходимые нам термы. Таким образом на дешифраторе можно реализовать любую логическую функцию.

## Мультиплексор

<a href="https://ibb.co/mNz20rm"><img src="https://i.ibb.co/KKyfDcY/image.png" alt="image" border="0"></a>

Мультиплексор передаёт на выход один из входов. Двоичный код на адресных входах указывает номер информационного входа, который надо передать на выход мультиплексора.

При этом число адресных входов $k = ceil(\log_2 n)$

<a href="https://ibb.co/wsLywT8"><img src="https://i.ibb.co/pyP2RgN/image.png" alt="image" border="0"></a>

В Xilinx обозначается М2_1Е (2 -- число информационных входов D, 1 -- число выходов S (select), E -- наличие входа разрешения).

Здесь приведена не полная, а сокращённая таблица истинности (4 входа ⇒ дб 16 строк). А у нас только 5. Поэтому никакой минимизации здесь уже не надо проводить. Мы имеем два терма, на которых результат будет единицей

<a href="https://ibb.co/r3d58Jc"><img src="https://i.ibb.co/jzJ30FW/image.png" alt="image" border="0"></a>

### Увеличение разрядности мультиплексора
#### Пирамидальная структура
<a href="https://imgbb.com/"><img src="https://i.ibb.co/BTNmCjz/image.png" alt="image" border="0"></a>

Е можно было бы подать только на последний элемент.

#### С дешифратором на входе
<a href="https://ibb.co/Hr0cV2W"><img src="https://i.ibb.co/jLdCT5c/image.png" alt="image" border="0"></a>

<a href="https://ibb.co/kDyfLt1"><img src="https://i.ibb.co/z25Y3zJ/image.png" alt="image" border="0"></a>

У мультиплексора каждый информационный вход является термом. Поэтому на мультиплексоре можно реализовывать функции
<a href="https://ibb.co/z7zY9ZC"><img src="https://i.ibb.co/1dk5yTB/image.png" alt="image" border="0"></a>

Мажоритарный элемент: если на входе 2 или больше единиц, даёт единицу на выход.

Мы можем для реализации функции от $k$ переменных использовать мультиплексор от $2^k$ переменных. 

В данной таблице истинности мы видим, что у нас либо есть зависимость от младшей переменной, либо нет:

<a href="https://ibb.co/x8NhX8f"><img src="https://i.ibb.co/gFxymFP/image.png" alt="image" border="0"></a>

Если бы мы использовали первый подход, нужно было бы 2 мультиплексора для функций CO и S. 

У итогового мультиплексора две группы входов I1 и I2. I1 передают сигнал на CO, I2 -- на S в зависимости от сигналов А и В. Здесь А и В -- адресные входы первого и второго мультиплексора, но каждый из мультиплексоров имеет свой инверсный вход разрешения G1 или G2.

Здесь показан второй подход: реализовать на мультиплексоре с 2^k-1^ входами, попарно объединив входные наборы. 

Также можно заметить, что сверху таблицы И(Х1, Х0), на втором -- ИЛИ(Х1, Х0) и поставить эти оба элемента на информационные входы мультиплексору, а Х2 подать на адресный вход.

## Демультиплексор
<a href="https://ibb.co/9y4bP8Y"><img src="https://i.ibb.co/HGPtZFg/image.png" alt="image" border="0"></a>

Передаёт информационный вход на нужный выход в зависимости от адресного входа. По сути демультиплексор -- это то же самое, что и дешифратор, только информационный вход D играет роль входа разрешения Е.

Можно соединить мультиплексор и демультиплексор и получить шину передачи данных.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/SykTrmv/image.png" alt="image" border="0"></a>

Если мы фиксируем S и А. Тогда мы можем с одного из входов D (от одного абонента) передать сигнал к третьему абоненту на дешифраторе F3. Таким образом, мы можем последовательно передавать информацию.

Меняя информацию на входах S и последовательно меняя D, мы можем передать параллельный код последовательно одному абоненту. Изменение сигналов на S позволяет передавать сигналы с D0 -- D3 последовательно (сначала D0, потом D1 и так далее).

Если мы зафиксируем S и будем менять А сможем передавать входы D последовательно передавать на F и последовательный код преобразовать в параллельный.

Количество входов, подключаемых к одному выходу, зависит от токов и допустимых токов на входах подключаемых элементов.

Элемент buff повторяет значение со входа на выход. Также его можно использовать, если надо задать разные имена шине.
# Триггеры
<a href="https://ibb.co/TPZMc2B"><img src="https://i.ibb.co/mhm5JTC/image.png" alt="image" border="0"></a>

В лабнике два триггера - двухступенчатой и с динамической записью. Но вместо триггера с динамической записью выполняем два триггера (если что, в задачнике есть доп теория), берём два готовых триггера

Логика может быть и отрицательной: высокий уровень = 0, низкий = 1.

В xilinx предложен только однофазный выход, а не парафазный, потому что дальше этот выход поступает, как правило, на КС -- элементы И, ИЛИ, и т.д. реализуются на lut -- просто записывается таблица истинности, а там можно учесть и инверсные выходы. а их можно реализовать и на инверторах. Поэтому в реальных заказных схемах лучше использовать и прямой, и инверсный выход. Но в xilinx в КС может быть инверсный вход, потому что все КС реализуются на lut.

Ограничение (бистабильные схемы): на прямом и инверсном выходе не может быть одновременно двух нулей и единиц, кроме переходных процессов.

Последовательностная схема -- выходы определяются как сигналами на входе, так и предысторией -- триггер как раз соответствует этому определению.

Триггер может переходить из одного состояния в другое. Считаем, что есть два входа -- set (установка в 1) и reset (сброс, установка в 0).

В отличие от КС (может быть описана таблицей истинности или функцией), триггер описывается таблицей/матрицей переходов, графом переходов или характеристическими уравнениями.

<a href="https://ibb.co/pKpYgHd"><img src="https://i.ibb.co/5jVbdQL/image.png" alt="image" border="0"></a>

В основе любого триггера лежит запоминающая ячейка, а точнее запоминающий элемент. Элемент -- это триггер, а ячейка -- это то, что считывается из памяти за одно обращение, поэтому лучше называть то, что в триггере ЗЭ.

Вместо $\overline Q$ лучше писать NQ, обозначая инверсные входы.

СУ преобразует логические сигналы: (Е1, Е2, а может быть и только один Е), синхросигнал С (если он есть, то триггер синхронный) во входы установки в 0 или в 1 ЗЭ.

У ЗЭ есть два входа внутри установки в 1 и сброса в 0, причём они могут быть как прямыми, так и инверсными. Если вход инверсный, то он исполняется при переходе из 1 в 0.

В лабе про двухступенчатые триггеры мы будем использовать ЗЭ на элементах 2И-НЕ.

<a href="https://ibb.co/xXXcZG7"><img src="https://i.ibb.co/q77469r/image.png" alt="image" border="0"></a>

Всегда стоить иметь перед глазами таблицу истинности, таблицы и матрицы переходов в лабораторных работах.

Предположим, что на входы R и S поступают два нуля. У данной схемы два входа + раз есть обратные связи, то они тоже считаются за входы. Считаем, что триггер изначально в состоянии 0. Что произойдёт?

Можно показать, что при подаче нулей триггер остаётся в таком же состоянии.

Пусть триггер находится в 0 (NQ = 0, у нас бистабильный триггер) и подаём S=0, R=1. Тогда мы смотрим, что на выходе верхнего элемента будет 0 ⇒ он придёт на нижний элемент, а S = 0 ⇒ на NQ будет 1 ⇒ независимо от того, в каком состоянии находился триггер, при 01 он переходит в 0.

Таким образом, 1 на R сбрасывает триггер.

Так как схема симметрична, то 1 на S устанавливает ноль на NQ и соответственно 1 на Q.

Если мы подали две единицы на входы, то Q будет равно 0 и NQ тоже будет равно 0 ⇒ на выходах будет два нуля, и такого быть не может ⇒ данная комбинация запрещённая (Х).

Поэтому часто рисуют не полную таблицу переходов, а пользуются сокращённой таблицей переходов: 00 ⇒ Q(t), 01 ⇒ 0, 10 ⇒ 1, 11 ⇒ X.

Если нарисовать для данного триггера УГО (отечественная версия), в основном поле вверху указано Т (триггер), а в дополнительном поле слева указаны называния входов S и R, причём эти входы прямые: переходы в новые состояний осуществляются по единице. 

Триггеры охвачены обратной связью ⇒ может быть нарисовано два последовательных элемента, а с выхода второго элемента идёт провод ко входу первого и наоборот. В лабах мы не сможем нарисовать связи под углом, поэтому придётся иногда делать так.

На картинке обозначено УГО асинхронного триггера, потому что нет входа C.

<a href="https://ibb.co/88rKp17"><img src="https://i.ibb.co/RH3vmRD/image.png" alt="image" border="0"></a>

Если мы подали 00, то это запрещённая комбинация -- на обоих выходах будут единицы.

Если мы подали 01, то на выходе верхнего будет 1, она придёт вниз, внизу на выходе будет 0 ⇒ при $\overline S = 0$ мы всегда переходим в единицу вне зависимости от состояния триггера.

С $\overline R$ симметрично, $\overline R$ устанавливает триггер в 0.

При единицах на обоих входах состояние триггера не меняется.

Данную полную таблицу можно преобразовать в обычную таблицу переходов $\overline S \overline R$ триггера. Если входы инверсные, то переключение идёт по нулю на входе.

На рисунке приведено УГО асинхронного $\overline R\overline S$ триггера (можно говорить $\overline S\overline R$, всё равно)

<a href="https://ibb.co/k1PsShM"><img src="https://i.ibb.co/Vmkcqv3/image.png" alt="image" border="0"></a>

В зависимости от логики наиболее часто используемые 5 триггеров. 

1 вход -- D, T триггеры (всего 25 штук)
2 входа (625 штук), RS, DV, JK

По способу записи информации: синхронные и асинхронные
- у асинхронного триггера состояние зависит только от логических входов: подали новый сигнал и состояние изменилось сразу же, как в КС
- у синхронного изменение состояния происходит по синхросигналу, новая входная информация принимается и обрабатывается по сигналу синхронизации
	- с динамическим управлением: информация принимается по перепаду сигнала, то есть по его изменению
	- со статическим управлением: управляется уровнем: информация принимается, когда синхровход соответствует уровню логической единицы или нуля, если он инверсный, **в течение всей длительности сигнала С**.
		- одноступенчатые (Т)
		- двухступенчатые (ТТ)

В сборнике лаб об этом подробно написано порядка 30 страниц текста.

## RS-триггер

<a href="https://ibb.co/By84CnG"><img src="https://i.ibb.co/qNb0rJC/image.png" alt="image" border="0"></a>

Триггер состоит из элементарной ЗЭ на И-НЕ, поэтому у него входы $\overline S'$ и $\overline R'$ (то есть входы именно запоминающей ячейки обозначаются со штрихом). Раз они инверсные, то на ЗЯ стоит триггер $\overline R\overline S$, а на входе стоит КС -- схема входной логики, на которую приходят логические сигналы и синхросигнал.

Раз вход $S$ прямой, то по единице триггер переходит в 1, а при R = 1 триггер переходит в 0, как видно в таблице. Поэтому для триггера в целом будет данная таблица перехода, а для внутреннего триггера в ЗЯ работает другая таблица для $\overline R\overline S$.

Раз внутри у нас инверсные входы, то нам надо обеспечить ноль либо на $\overline S$, либо на $\overline R$ю Если мы подаём на вход СУ два нуля, то эти два нуля у входных элементов И-НЕ выдадут единицы на инверсные входы внутренней ЗЯ ⇒ триггер внутри сохранит своё значение.

Теперь подаём S = 1, но пока на С стоит 0, элемента И-НЕ по-прежнему сохраняют подачу единиц на входы ЗЯ. Когда С станет равным 1, И-НЕ выдаст 0 на $\overline S$ ⇒ уровень С переключил $\overline S$ на 0 и он, в свою очередь переключил Q в единицу.

Когда мы подаём единицу на R, при С = 1 он переключит $\overline R$  ⇒ $\overline Q$ ⇒ Q.

Следующий импульс отрабатывает аналогично второму.

Заметим, что в первую очередь в триггере переключается выход, который из 0 переходит в 1, а затем уже переключается обратный ему из 1 в 0.

На рисунке приведено УГО синхронного статического прямого RS триггера.

## D-триггер

<a href="https://ibb.co/fqPN4hW"><img src="https://i.ibb.co/GnbMcKD/image.png" alt="image" border="0"></a>
D-триггер (Delay) -- триггер задержки. Он вход D с задержкой передаёт на выход.

В основе любых триггеров лежит синхронный RS-триггер, в том числе и здесь. Мы подаём D и C.

Вход D мы специально дополнительно инвертируем, потому что подавать две единицы на триггер -- запрещённая комбинация. Поэтому при подаче 1 на D за счёт инвертора внизу будет 0 ⇒ мы из RS триггера введением этого инвертора получаем D триггер.

При C = 0 триггер просто будет хранить информацию.

По задержкам: в RS триггере по синхросигналу идёт переключение двух элементов напрямую. Добавляя инвертор впереди, получаем переключение уже трёх элементов напрямую ⇒ задержка больше.

Можно поставить не инвертор, а сделать дополнительную связь (нижний рисунок), поэтому при D = 1 мы получаем 0 на входе RS и 1 на нижнем входе ⇒ триггер может работать, но время срабатывания будет поменьше. 

Но данная схема при моделировании может не работать, хотя реально всё будет ок. Потому что при D = 0 у нас будет 1 на входе S и R и всё норм. Если D = 1 и приходит синхросигнал, до его прихода на выходе верхнего И-НЕ стояла единица и ноль внизу ⇒ по приходе синхросигнала мы получаем 0 с задержкой вверху и в какой-то момент времени у нас будут находиться два нуля на обоих входах RS ⇒ система моделирования может сломаться, потому что это запрещённая комбинация.

Чтобы это отловить, можно перейти к моделированию Unit, которое работает каждую пикосекунду и может найти подобные кратковременные явления генерации (возбуждения).

### DV-триггер
Вход V -- вход разрешения для триггера (работает как вход СЕ) и фактически у всех триггеров в Xilinx есть. При V = 0 он запрещает работу триггера (он просто хранит информацию), а при V = 1 он работает как D триггер, передавая D на выход.

В принципе, при C = 0 D триггер тоже хранит информацию, а при C = 1 работает, поэтому V можно подавать параллельно С.

Это всё одноступенчатые триггеры

###  T-триггер (toggle)

<a href="https://ibb.co/R7bM2Kr"><img src="https://i.ibb.co/fQFKMW6/image.png" alt="image" border="0"></a>

Тот же RS триггер с добавленными двумя связями. При T = 0 триггер хранит информацию, при T = 1 выводит её инверсию.

Минус: триггер работать не будет:

при 0 всё хорошо, триггер будет хранить информацию и на входах R и S будут единицы.

При подаче T и C на выходах И-НЕ впереди будут единицы ⇒ Q = 0 ⇒ верхний И-НЕ = 1 ⇒ $\overline Q$ = 0 ⇒ и так далее ⇒  будет генериться сигнал в течение всего времени, пока С = 1 ⇒ на выходах триггера будет дудос и когда C станет равным 0, нельзя будет понять, в каком состоянии триггер окажется.

Это одноступенчатый триггер (буква Т в УГО стоит одна). 

Все СУ для триггеров будут справедливы и для двухступенчатых триггеров.

### JK (Jump-keep) триггер
При J = 1 мы прыгаем (лучше переходим) в единицу. А при k = 1 переходим в 0 ⇒ J и K напоминают прямые входы S и R. Но отличие от RS-триггера в том, что в JK-триггере комбинация 11 не запрещённая, при этом он работает как Т-триггер.

В основе берём синхронный RS-триггер, где вместо входа S написан J, а вместо R написан K и остаётся только реализовать комбинацию 11 так же, как и в Т триггере с помощью обратной связи.

Чтобы элементарная триггерная ячейка (ЗЭ) внутри переключилась, надо передавать на её входы нули, то есть переключение идёт именно по нулю.

Представлено УГО синхронного статического одноступенчатого JK-триггера. Минус такой же: при двух единицах на выходе может быть генерация сигналов, поэтому одноступенчатый JK-триггер мб неработоспособен.


В основе одноступенчатых триггеров лежит элементарная триггерная ячейка на элементах И-НЕ или ИЛИ-НЕ, они отличаются друг от друга схемой управления на входе.

Т-триггеры или JK-триггеры можно представить графами с двумя вершинами -- 0 или 1 и переходами по сигналам

### Двухступенчатые триггеры
<a href="https://ibb.co/YbBn9Jy"><img src="https://i.ibb.co/Fn4Zvc0/image.png" alt="image" border="0"></a>

Это схема из двух частей - двух последовательно соединенных триггеров, каждый из них со статической записью. Если считать, что это 2 одинаковых триггера, то обязательно второй прямой синхронный триггер RS, а на первом -- асинхронный RS у которого может быть логика управления E1-E2. 

Одновременный приём информации в два триггера запрещается инвертором по С внизу: в первую ступень запись идёт по С = 1, во вторую ступень информация будет записываться при С = 0.

После завершения приёма информации в первой ступени она передаётся во вторую.

В УГО у двухступенчатых триггеров ставятся буквы ТТ.

Может быть обратная связь состояния выхода второй ступени на вход (пунктир). Раз передаётся вторая ступень, то при С = 1 она не может изменяться и поэтому тот недостаток, который был у D и JK триггера здесь исключен.

Этот триггер также называют MS: первую ступень называют master (работает по уровню 1), а вторую slave (работает по уровню 0).

Вместо Е1 Е2 могут быть входы D, V, J, K, CE и так далее.


<a href="https://ibb.co/DpmkbKp"><img src="https://i.ibb.co/TLJRThL/image.png" alt="image" border="0"></a>

Если не обращать на пунктир внимания, то там видно два одинаковых RS триггера. Первый работает при С = 1, второй при С = 0.

Вход S можно рассматривать как J, а R как К, тогда можно будет провести пунктиры и этот триггер будет работать как JK.

В лабнике это рисунки 3.8 и 3.9

Считаем, что в начальный момент времени триггер установлен в 0 и синхровход равен 0. Отметим, что при С = 0 оба триггера находятся в одинаковом состоянии.

На С приходит 1. При этом на D1 D2 ничего не меняется, потому что для переключения первой ступени нужно обеспечить один из нулей на D1 или D2, а таких импульсов нет, потому что S = R = 0.

На S приходит 1. В первой ступени формируется ноль на D1 ⇒ D3 =Q' переходит в 1 ⇒ по обратной связи NQ' переключается в 0.

Когда C перейдёт в 0, D1 переходит в 0 ⇒ первая ступень переходит в режим хранения. Надо изменить состояние второго: C ⇒ NC ⇒ D9 ⇒ D5 ⇒ Q = 1 ⇒ NQ = 0.

Задержка у триггера: когда переключается выход триггера после прихода синхросигнала? В таком триггере переключение происходит, когда C = 0. Значение первой ступени переходит во вторую.

Симметрично происходит при подаче R = 1, S = 0. Сначала для первой ступени вырабатывается 0 на D2, а затем переключается C ⇒  NC ⇒ D6 ⇒ D8 ⇒ D7.

Поэтому лучше в лабе делать инвертор, потому что с ним задержка при переходе от 0 в 1 будет на один элемент меньше, а из 1 в 0 больше из-за доп. элемента в обратной связи.

<a href="https://ibb.co/jVGX28y"><img src="https://i.ibb.co/WDFJwHk/image.png" alt="image" border="0"></a>

Смотрим на УГО: ТТ ⇒ двухступенчатый триггер ⇒ он статический (это видно ещё и по тому, что в С входе нет наклонной линии). По логике работы там нарисован JK-триггер (заведены обратные связи), но тут нарисованы немного другие связи, есть две новых D1-D5 и D2-D6. Он немного быстрее, в книжке можно почитать, как это работает, но он так же срабатывает по С = 0.

Заметим, что дополнительно введены два асинхронных входа для предварительной установки его в начальные состояния 0 или 1.

Как обеспечить переход в единицу выхода Q? Можно подать в предыдущем триггере дополнительный независимый сигнал на D7 для второй ступени и на D3 для первой ступени. Но раз асинхронный вход можно подать в любой момент времени, то возможно появление запрещённой комбинации: если мы подаём ноль на D7, а в это время был ещё и ноль с D6, то это запрещённая комбинация, поэтому этот асинхронный сигнал мы подаём сразу на несколько элементов, чтобы они были согласованы. Как раз это видно в двухступенчатом JK-триггере ($\overline S$ подан сразу на несколько элементов).

Вообще эти связи можно было бы не делать, только если этот сигнал можно было бы подавать НЕ в любой момент времени, а только по синхросигналу. Но если сигнал асинхронный, надо его связывать со всеми элементами, чтобы не было запрещённых комбинаций на входах.

Когда мы подаём $\overline S$ = 0, меняется D3, потом одновременно D4, D5 ⇒ D6 => Q ⇒ $\overline Q$. На диаграмме видно, что в какой-то момент времени на входах Q и NQ могут быть две единицы -- когда один выход уже переключился с нуля в единицу, а второй ещё не успел переключиться с единицы на ноль.

В лабах будет предложено использовать ступень из RS триггера (схема 3.10 в лабнике). В 3.10 и 3.11 описано, как работают асинхронные входы. Если начать моделировать раньше то при построении диаграмм вручную мы считаем, что изначально оба триггера находятся в нуле.

А во время лабы надо будет проверять: сначала подать короткий $\overline S$, по которому можно будет видеть, что триггер переключился в 1, а уже за ним передаём $\overline R$, чтобы увидеть, что триггер переключился в 0 -- видно, что обе ступени сначала переключились в единицу, а потом в 0, а потом уже после всего этого подавать C.

Такая же схема приведена в рисунках 3.22 и 3.24, где
есть входы $\overline S$ и $\overline R$ и вместо нижнего инвертора по С инверсный вход NС

### Динамические параметры
У КС динамический параметр только один -- это задержка, у триггеров их 4

<a href="https://ibb.co/K05J9Kc"><img src="https://i.ibb.co/3rTn0R5/image.png" alt="image" border="0"></a>

Задержка мб как по изменению синхровхода, так и по асинхронным входам установки.

Время предварительной установки: насколько раньше надо подать логический и управляющий сигналы: минимальный интервал до активного синхросигнала. Активным изменением мб либо уровень, либо фронт. То есть как рано передать J или K. 

Все эти параметры так же описаны в лабнике, но приведены для разных схем.

Длительность: насколько коротким дб импульс: потому что если он будет коротким, мы можем не успеть переключить все ступени.

<a href="https://ibb.co/m8zY6qW"><img src="https://i.ibb.co/GTP1c2S/image.png" alt="image" border="0"></a>

Здесь показано, как идёт срабатывание.

Входы E1, E2, CE (V), L (load)-- здесь могут быть какие-то другие входы, например, та же самая картинка справедлива и для регистров. С одной стороны, CE можно считать логическим, а с другой -- как вход управления clock enable.

Все параметры считаются относительно активного фронта.

tuC -- длительности импульса С или асинхронного входа. Показывает, насколько он должен быть коротким, длительность импульса должна быть больше или равна этой паспортной величины.

Tуст -- насколько раньше нужно подать логические сигналы относительно фронта. Если бы это был уровень, то мы подаём не относительно начала уровня, а относительно снятия сигнала С, то есть момента, когда заканчивается импульс С.

Удержание -- так же, если относительно уровня, то до момента снятия.

Тпер -- время, через которое переключается уровень.

Если tuC >=, паспортному, то и остальные характеристики >= паспортным величинам, кроме задержки переключения, она <. Все эти параметры рассмотрены в третьей лабе, но отдельно друг от друга.

Так же мы будем эти параметры измерять в 5 лабе про регистры, там про эти параметры тоже можно почитать. На третьей лабе будем считать только время переключения, то есть задержку переключения выхода.

<a href="https://ibb.co/3m5btt4"><img src="https://i.ibb.co/WvNXSSG/image.png" alt="image" border="0"></a>

В Xilinx почти у всех триггеров входы прямые, в том числе и инверсные

<a href="https://ibb.co/Yc3JchB"><img src="https://i.ibb.co/McsKc7k/image.png" alt="image" border="0"></a>

В триггерах с динамическом записью видно отличие в черте у С. В Xilinx у С в динамических триггерах стоит треугольник внутри, а при инверсном на входе ещё и кружок инверсии.

<a href="https://ibb.co/cwGcDYs"><img src="https://i.ibb.co/3vDyBRP/image.png" alt="image" border="0"></a>

У триггеров стоит буква F (Flip-Flop). Следующая буква обозначает логику работы (какие логические входы у него есть). Затем -- обозначение установочного входа.

Preset и Clear -- асинхронные входы в Xilinx, а S и R -- это синхронные. До этого мы таких различий не делали.

Е может присутствовать, а может и нет -- это означает, что есть вход разрешения работы СЕ.

1 после обозначения означает, что у входа С есть инверсия, то есть триггер будет срабатывать по спаду, если он динамический.

Есть группы входоы:
- логика работы (J, K, D)
- CE -- можно считать за вход управления, хотя тоже мб логикой
- С -- исполнительный вход, по нему исполняется работа. CLR -- тоже исполнительный вход, потому что по нему тоже исполняется работа. Заметим, что в таком случае синхронные входы S и R -- не исполнительные, потому что работа происходит не по их изменению.

Асинхронный вход имеет наивысший приоритет: например, CLR независимо остальных входов заставит перейти в 0. Все микрооперации триггер выполняет только при CLR = 0.

Если CE = 0, то независимо от остальные входов кроме CLR триггер просто хранит информацию, в противном случае он работает как D триггер. CE сигнал следующего приоритета.

<a href="https://ibb.co/G3hYL9n"><img src="https://i.ibb.co/Kz14kDb/image.png" alt="image" border="0"></a>

Это сложный триггер, выполняет сразу две таблицы: работает и как Т триггер, но ещё имеет вход L -- load (это и написано в его обозначении), который разрешает работать Т входу -- аналог входа V в DV триггере.

При CLR = 0 (наивысший приоритет) устанавливается 0.

Следующий приоритет --  L: при L = 1 независимо от СЕ и Т значение D передаётся на выход: он разрешает работать D, L будет означать "загрузить D на выход".

Следующий -- СЕ. При СЕ = 0 триггер будет хранить информацию независимо от других входов, а при СЕ = 1 как D-триггер.

Любой триггер в Xilinx реализуется на D триггере, если посмотреть их внутреннюю структуру. А если нажать на этот D триггер, то внутри он раскрывается до D триггера без входа СЕ.

Этот триггер должен при L = 1 разрешить работу. При L = 1 мультиплексор разрешает пройти D входу внутрь триггера.

При L = 0 надо разрешить работу триггера -- нужно пропустить СЕ. При СЕ = 1 и L = 0 работает нулевой вход мультиплексора -- от выхода триггера подаётся сигнал на XOR TQ -- управляемый инвертор, который инвертирует Q при T = 1, что и происходит. При T = 0 триггер просто хранит сигнал, потому что инверсии не происходит.

Так параллельно работают Т и D триггер.

Так как L и CE должны разрешить работать синхровходу, стоит элемент ИЛИ. Если L и CE равны 1, будет всё равно работать L, потому что L имеет высший, чем СЕ, приоритет.

Раз на триггере D можно реализовать любой другой, можно реализовать любую таблицу переходов на D триггере, на вход которого можно поставить мультиплексор, а на входе мультиплексора задать требуемые переходы, управлять которым можно с помощью адресных входов.

<a href="https://ibb.co/gMmq0Dh"><img src="https://i.ibb.co/1f7yC9j/image.png" alt="image" border="0"></a>

Это описано ещё и в задачнике.

<a href="https://ibb.co/DL0RhQs"><img src="https://i.ibb.co/kMNSjXk/image.png" alt="image" border="0"></a>

Эта матрица переходов нигде не приведена, а описана словами в сборнике задач и лабнике в 4 лабе для DV триггера

Посмотрим на RS триггер со знакомой нам табличкой. Предположим, нам надо подать такое воздействие, чтобы триггер, находясь в 0, остался в 0. Какие комбинации нам можно подать?

В случае 10 триггер будет поставлен в 0, это нам подходит. А ещё нам подходит и комбинация 11, раз триггер уже до этого был в 0. Поэтому чтобы триггер остался в нуле, подходят две комбинации -- 10 или 11  ⇒ нам важно на NS подать единичку, а NR может быть любым. В матрице переходов X -- это не запрещённая комбинация, а любое значение, и при минимизации это означает, что мы можем выиграть и сократить схему.

Далее для переходов 0 -> 1 и 1 -> 0 подходят только по одной комбинации.

Для перехода 1 -> 1 ситуация симметрична переходу 0 -> 0. В принципе, можно приводить не всю матрицу переходов, а только её результат с Х.

Посмотрим, как сформировать матрицы переходов триггера по таблице переходов. Это есть в задачнике и в 4 лабе в лабнике.

Рассмотрим JK триггер.

0-0: подходят комбинации 00 и 01 ⇒ на J мы подаём 0, на К -- любой сигнал.
0-1: подходят 01 и 11 ==> комбинация Х1
1-0: 01 и 11 ⇒ X1
1-1: 10 и 00 ⇒ X0.

<a href="https://ibb.co/029zW4s"><img src="https://i.ibb.co/qjg24qJ/image.png" alt="image" border="0"></a>

Это будет сложно для DV

0-0: 00, 01, 10 подходят, но минимизация тут не очень поможет, поэтому можно задать эти три комбинации по другому: A, $\overline AB$, где А и B независимы друг от друга

Два других перехода простые с одной строчкой.

Переход 1-1: подходят 00 01 и 11 и тут можно их представить без инверсии: A2, A2*B2.

В третьей лабе предлагается применить этот подход: на с 63 начинается проектирование триггере по таблице перехода

<a href="https://ibb.co/KqyZwT1"><img src="https://i.ibb.co/vPz5Y0t/image.png" alt="image" border="0"></a>

Мы берём уже готовые триггеры, не реализуя начинку

<a href="https://ibb.co/kmvd0ZC"><img src="https://i.ibb.co/8Yth2kZ/image.png" alt="image" border="0"></a>

Для триггера от трёх переменных надо обеспечить переход в нужное состояние в соответствие с вариантом (столбец Q(t+1)), далее записываем переходы из JK и DV триггеров.

В таблице истинности мы пишем индексы, соответствующие номерам набора. По такой таблице проводить минимизацию

<a href="https://imgbb.com/"><img src="https://i.ibb.co/p16JTMk/image.png" alt="image" border="0"></a>

мы задаём сигналы Аi и Bi произвольно, но так, чтобы было проще минимизировать.

Дальше можно (но необязательно) перейти в базис и-не.

ДЗ

с 133 №3. Там опечатка: мультиплексор М4_1, а не 16.
с 138 №2

когда иначнём готовиться, на с 78 в лабнике приведена подобная таблица переходов, только в ней написано Q, 1, 0, NQ -- там надо поменять местами 1 и 0: во второй строке должен стоять 0, а в третьей 1

в табличку на с 79 в лабнике предлагается ввести два столбца Q(t+1) и переход


е1 е2 будут меняться как у счетчика на с 92 но это другая история

<a href="https://ibb.co/kqm1bw4"><img src="https://i.ibb.co/7rk4MZn/image.png" alt="image" border="0"></a>

<a href="https://ibb.co/wKSHdNP"><img src="https://i.ibb.co/xM1v2SB/image.png" alt="image" border="0"></a>


в лабе 4 делаем не всё задание как в лабнике, а также будем реализовывать делитель частоты, лучше смотреть в задачнике

<a href="https://ibb.co/9TRm6MZ"><img src="https://i.ibb.co/zRKWpk6/image.png" alt="image" border="0"></a>

Часто забывают что такое период или модуль счёта. Это число разрешенных устойчивых различимых состояний счетчика. 

вход, по которому считают входные сигналы, называется счётным. В лабе это будет C, с точки зрения счетчика -- это счётный вход, хотя это синхровход.

в лабе сигналы берём от генератора, он работает периодически. А на стенде передаём вручную, там импульсы приходят не периодически

<a href="https://ibb.co/jHBBbnR"><img src="https://i.ibb.co/V3rrJfm/image.png" alt="image" border="0"></a>

классификация
по способу кодирования

- позиционный счетчик -- каждая позиция или разряд счётчика имеет определённый вес. Например, в двоичном счётчике слева направо веса идут 8 4 2 1, но в общем случае и что будет в лабе веса не обязательно степень двойки. Могут быть веса 4 2 2 1, 1 3 5 1 -- каждая позиция по определению имеет свой вес, но **любой**.
- непозиционный: вес зависит не от позиции, а от чего-то другого. Например, в римской СС зависимость не только от позиции, но и от значения соседнего разряда.

по модулю счёта
- двоичные (веса 8 4 2 1), могут быть 16ричными, 4 2 1 -- мб восьмеричными или **с естественными весами разрядов**.
- двоично-десятичные (декада): наборы как правило от 0 до 9, где веса разрядов так же 8 4 2 1. в лабах мб десятичный счётчик (декада), модуль равен 10
- произвольный модуль счёта -- мб постоянным или переменным (программируемым), например, в зависимости от какого-то условия, например, входа Y, модуль счётчика может меняться
- прочие счётчики -- код Грея -- когда каждое следующее состояние от предыдущего отличается только в одном разряде: в обычном случае при переходе, например, 01 -> 10 могут быть состязания: нужно, чтобы младший разряд переключился в 1, а старший в ноль. Если сначала переключится младший, то будет переход 01 -> 00 -> 10; в противоположном случае 01 -> 11 -> 10. В коде Грея последовательность другая: 00, 01, 11, 10, 110 и т.д.
- кольцевой счетчик: выход последнего разряда соединяем со входом первого
- счётчик Джонсона (Мёбиуса): последний разряд переходит в первый но в инверсном виде
- Код 1 из N (единичного кодирования, пример: выход дешифратора или унитарный/унарный код). Например, код 1 из 4, плюс которого -- одинаковое потребление энергии на каждом разряде и относительно легко проверять на сбои: не мб двух единиц и не мб всех нулей.


по направлению счёта
- суммирующие: переход в одну сторону 
- вычитающие: переход в другую сторону
- реверсивные: в обе стороны
<a href="https://ibb.co/F3T6fvM"><img src="https://i.ibb.co/h9zsn5j/image.png" alt="image" border="0"></a>

по способу переключения триггера: раз это последовательностная схема, то она строится на основе триггеров
- синхронная: все синхровходы соединены друг с другом
- асинхронная

способу организации межразрядных связей
- как организуется перенос между разрядами, он же перенос между группами разрядов


<a href="https://ibb.co/94rWx7h"><img src="https://i.ibb.co/PW6g2dM/image.png" alt="image" border="0"></a>

Это позиционный счётчик, поэтому веса разрядов заранее известны: 8 4 2 1. 

На последнем состоянии формируется сигнал переполнения (carry output, P), который зависит от входного разрешения счёта CE и может формироваться сигнал CEO -- сигнал в Xilinx clock enable output и ещё TC (terminal counter). CEO зависит от TC и CE: CEO = TC * CE (написано в задачнике).

У счётчика должен быть сигнал начальной установки. Но начальная установка может идти в случае двоичного счётчика в нулевое состояние, но можно в какое-то другое (например, в лабах: счётчик может кроме счёта хранить значение и дальше чем-то управлять и в начале загружаем в счётчик 5 и затем переходим в 8: не для двоичного счётчика состояния -- это номера состояний, а не номера двоичных наборов на выходе. В лабах эти наборы могут идти в произвольном порядке, но в двоичном счётчике они всегда идут подряд)



<a href="https://ibb.co/dDG1BpL"><img src="https://i.ibb.co/vkZg1dQ/image.png" alt="image" border="0"></a>
инкремент и декремент можно рассматривать как переход на любое следующее состояние, не обязательно на какую-то константу

когда код не выдаётся, выход в третьем состоянии или открытый коллектор, а плюсы в том, что эти выходы можно объединять монтажным или **открытым коллектором**.

У счётчика мб логический выход (всегда есть), мб выход в третьем состоянии (Z), он импедансный (высокое сопротивление на выходах) или с открытым коллектором (ОК)

в лабе надо будет считать быстродействие -- с какой максимальной частотой могут поступать импульсы. в лабе будет 4 секции как показано в лабнике: счетчик, два делителя и vhdl и для них надо определить частоту и период, с которыми импульсы могут поступать. Надо найти минимальный период <= паспортной

время установки кодов на выходах счётчика -- задержки на каждом выходе <= паспортному

время формирования переноса или заёма (когда счётчик вычитает и при первом/начальном состоянии он формируется) <= паспортному

длительность счётного импульса -- берётся из характеристик для триггера, чтобы он успел переключиться. Она должна быть больше или равна паспортному значению в триггере

S1 -- это номера **состояний**, а не наборов!

для установки в начальное состояние можно использовать R как в триггере или S синхронно в единицу. Когда доходим до последнего состояния в суммировании, формируем сигнал переноса. Если установились в начальное состояние и надо из него вычитать, сразу как только пришли в начальное состояние формируется сигнал BO (заём)

важно, что разряды счётчиков могут строить на двухступенчатых триггерах (статических, управляемых уровнем), то есть нельзя использовать статические одноступенчатые и асинхронные триггера, а также бывают на триггерах с динамической записью

как правило триггеры работают в счётном режиме⇒ каждый триггера работает как счетчик по модулю 2 и как правило каждый триггер работает как Т триггер

например если бы мы хотели на Jk триггере то можно сделать объелинение входов j и k и получить Т триггер

<a href="https://ibb.co/gjHyYH7"><img src="https://i.ibb.co/FxN6pNW/image.png" alt="image" border="0"></a>

этот счётчик асинхронный, так как синхровходы не соединены между собой (С слева это счётный вход) Счётный вход поступает только на один триггер. Диаграмму можно строить независимо для каждого из триггеров, потому что нет обратных связей.

Всегда сначала надо подавать CLR.

На входе C стоит треугольник без инверсии ⇒ элементы срабатывают по фронту

Если объединить в шину отдельно выходы триггера, то видим, что счётчик считает 7 6 5 4 ...  ⇒ он работает в вычитающем режиме.

Видно, что в переходе 0 - 7 есть неустойчивое состояние за счёт не одновременного переключения разрядов.

Как видно по изменению разрядов, это действительно двоичный счётчик (подряд), при этом сигнал выхода Q2 будет являться заёмом для следующего.


чему будет равно время установки кода -- когда будет установлен код на всех триггерах. tкода = n * tтриггера. При этом tтриггера -- максимальное время из t01 и t10, n -- количество триггеров.

Время установки кода заёма так же равно n * tтриггера

<a href="https://ibb.co/SxXKnyt"><img src="https://i.ibb.co/BPVgZ3y/image.png" alt="image" border="0"></a>

это пример jk триггеров (как раз тут j и k входы объединены) ⇒ получается они работают как Т триггеры.

на с вход подаются инверторы -- то есть мы как бы берём сигналы с инверсных выходов триггеров, а на этот инвертор может потребоваться целый lut. В unit на нём так же будет задержка, хотя в реале на плис транслятор может увидеть, что инвертор стоит прямо перед входов tj1 и сделать вместо этого tj1 инверсный вход и задержки не будет

если стоят инверторы, то лучше для своего контроля построить, как работают инверторы на временной диаграмме. За счёт инвертора первый триггер работает не по фронту, а по спаду. А нулевой работает по фронту. Аналогично по спаду идёт срабатывание второго триггера

можно было бы показать инверторы на временной диаграмме (видно, что задержка на триггерах два пикселя)

это асинхронный суммирующий счётчик с теми же задержками (не считая инвертора); а если учитывать инверторы, то время установки будет равно nTтриггера + (n-1)Tинвертора

прямой -- вычитающий, инверсный -- суммирующий

чтобы сделать реверсивный счётчик на вход каждого элемента можно поставить мультиплексор 

этот счётчик -- у него межразрядные связи с последовательным или на непосредственной связи: они последовательно напрямую соединены когда выход одного триггера непосредственно соединен со входом другого

нужно как можно быстрее перейти требуемое состояние и постараться уменьшить задержки

<a href="https://ibb.co/fQvTY12"><img src="https://i.ibb.co/4Jd0Zm7/image.png" alt="image" border="0"></a>

вводим элементы и и счётный вход поступает на следующий элемент и и на него же поступает выход первого, аналогично дальше

синхросигнал со сквозным переносом проходит через весь счетчик

используя так же предыдущий Т триггер поставили инвертор и получили суммирующий счетчик (можно просто показать что у триггеров другой фронт работы по спау и нарисовать просто кружок на входе С с треугольником)

это счётчик со **сквозным** переносом, поэтому время установки кода равно (n-1)Tand + Tтриггера (или ещё + Тинвертора если учитывать инвертор)

второй параметр -- время установки переноса будет равно n * Тand 

данная схема быстрее по сравнению с предыдущей

<a href="https://ibb.co/7vdzWnm"><img src="https://i.ibb.co/zsT5RXv/image.png" alt="image" border="0"></a>

каждый последующий элемент И объединяет значения предыдущих разрядов и на каждый из них приходит счётный вход ⇒ данная схема называется с параллельным переносом

время установки кода в этой схеме будет ещё меньше: Тand + Ттриггера -- синхросигнал приходит одновременно на все триггера, поэтому оно не зависит от числа элементов

но при этом размер схемы растёт

время установки переноса равно Tand

Это асинхронный суммирующий с параллельным переносом, самый быстрый счётчик

можно объединять в группы счетчиков: внутри группы можно организовать параллельный перенос а между группами может быть сквозной / последовательный перенос, а можно тоже организовать параллельный перенос

<a href="https://ibb.co/NKjzxdj"><img src="https://i.ibb.co/njcSrNc/image.png" alt="image" border="0"></a>

синхронный счетчик с произвольным кодированием

попробуем посмотреть как работает данный счетчик. что нужно чтобы построить вд

нужно знать работу каждого элемента у нас есть JK триггер, инвертор и элемент И который можно дополнительно встроить потом как кобминационную схему

остальные элементы надо строить последовательно потому что еасть обратная связь

jk триггер: 00 хранит, 10 - 1, 01 - 0, 11 меняет значение на противоположное. Это счётчик не просто с произвольным кодированием, а главное что синхронный, потому что у него объединены синхровходы

значит любое изменение С одновременно приходит на каждый триггер а значит можно независимо рассмратривать каждый триггер при том состоянии кторое было до этого события

но прежде всего надо посмотреть установку в начальное состояние 
когда приходит clr (установка в начальное состояния) устанавливает в 1 нулевой и первый триггер а второй в 0 ⇒   по clr счётчик устанавливается в 0 1 1 = 3


теперь приходит синхросигнал, нехависимо рассматриваем каждый триггер

нулевой триггер: j вход соединен с Q2 = 0 ⇒ на j = 0; k = Q1 = 1 ⇒ 10 ⇒ триггер переходит в 0

первый триггер: он работает как d триггер (у него один вход прямой, другой инверсный) ⇒ этот триггер с инвертором на входе можно рассматривать как d триггер, j = 1 до прихода C ⇒ k = 0 ⇒ 10 триггер остаётся в единице

второй триггер 0 остаётся без изменений

можно представить граф переходов, он произвольный

модуль счётчика равен 8: видно 8 разных состояний
начальное состояние 3, последнее 5 -- на нём вырабатывается перенос CR (carry)

в заключительном тесте будет стоять что-то подобное, надо ответить, какие наборы проходит счётчик. Можно строить диаграмму, а можно таблицу состояний

исходное состояние 3. куда переходим можно писать рядом, а можно принципиально считать что следующее состояние будет на следующей строчке (можно строить только один столбик)

мы находимся в состоянии 3, на триггере 01 ⇒ он перешёл в 0; на первом триггере 10 ⇒ 1 и так далее

триггера мы рассматриваем в любом порядке независимо

так мы вычисляем совокупность состояний на каждом наборе


чему равно время установки кода в данной схеме: в данном случае только Ттриггера, так как синхровход приходит одновременно на все и каждый триггер переключается одновременно в соответствии с таблицей перехода.

важно бывает посчитать быстродействие -- через какое время мы можем подать следующий синхросигнал или период Тсинхроимпульса. надо проанализировать все переходные процессы. Код устанавливается за Ттриггера. Что ещё может переключаться -- инверторы за триггерами, а в общем случае там мб не инверторы, а какие-то схемы ⇒ надо будет учитывать ещё время переключения данных КС на информационных входах триггеров; потом после переключения КС + время предварительной установки вхдов триггеров.

Т = Ттриггера + ТКС + Тпред. уст. триггера

только после этого можно подать следующий фронт, а частота = 1/Т

в лабе надо будет определить частоту счётчика или делителя при параллельном режиме.

для построения временных диаграмм можно строить таблицу состояний, это позволит ускорить анализ схемы: рассматриваем текущее состояние и для каждого из триггеров рассматриваем таблицу и определяем, какое состояние будет следующим.

в 4 лабе в задании мы должны реализовать делитель частоты либо на двоичном

<img src="https://i.ibb.co/fCTwyJ9/image.png" alt="image" border="0">

Порядок срабатывания или приоритет соответсвует порядку указывания букв в обозначении: C > L > E > D.

Из обозначения букв можно построить УГО в системе Xilinx. 
- C -- это просто счётчик, но учитывая, что они все синхронные в Xilinx, то мы можем уже построить синхровход. Если бы вход был инверсный, в конце обозначения было бы _1, и тогда
- B -- двоичный счётчик
- 2 -- в обозначении уже можем отметить два выхода
- C -- можем построить CLR
- E -- вход CE
- L -- вход Load

<img src="https://i.ibb.co/MRZYZ1n/image.png" alt="image" border="0">

Количество входов D равно количеству выходов: в счётчик можно сразу загрузить некоторое состояние по сигналу L.

Высшим приоритетом обладает вход CLR, затем L (работает по фронту, синхронный сигнал), затем CE.

Можно отметить, что в Xilinx есть счётчики суммирующие или реверсивные, чисто вычитающих счётчиков нет.

В состав счётчика включается 2 триггера. CLR объединён у двух триггеров. Для загрузки работают входы D0 D1, которые подаются на триггеры. L загружает на оба триггера.

Счётчик должен считать: младший разряд всегда в счётном режиме, поэтому на Т подаём VCC. 

единичка сверху поступает на нижний триггер, чтобы разрешить счёт в старшем разряде

У триггеров есть вход CE, но в таблице отмечено, что и при L, и CE должны работать по фронту 01 ⇒ включается дополнительный элемент ИЛИ, который объединяет CE и L, выход которого подключается к CE триггеров.

У всех счётчиков всегда принято, что на последнем состоянии надо собирать выход TC. Раз счётчик суммирующий, то последнее состояние -- 3 (11), поэтому на выходе стоит 2И для выработки этого сигнала.

Выход CEO формируется как TC * CE. 

<img src="https://i.ibb.co/p3D0SFY/image.png" alt="image" border="0"><

Появилось обозначение D (direction) ⇒ появился новый вход UP.

У синхронных счетчиков в Xilinx можно воспринимать как вход разрешения счёта.

Вход UP имеет низший приоритет, поэтому в таблице он показан справа.

У элементов хранения (регистры, счётчики) можно выделить три группы сигналов
- задающие микрооперацию (up, l , ce)
- исполняющие микрооперацию (c, clr)
- информационные входы (do, d1)

тут как в предыдущем случае + дополнился мультиплексор: при UP = 1 единица с верхнего триггера приходит на нижний и разрешает ему считать, а при UP = 0 при 0 на Q инверсное значение передаётся вниз (переход 0 -> 3).

ТС формируется в этом случае, когда придут два нуля при UP = 0 или две единицы при UP = 1.

Последнее состояние умножается на СЕ и получается СЕО.

**ДЗ с 163 №1**

 <a href="https://ibb.co/W2ydgkK"><img src="https://i.ibb.co/d523GPK/image.png" alt="image" border="0"></a>

на примере 3 двухразрядных счётчиков строится шестиразрядный счётчик CB6CE

младший счётчик считает быстрее всего (Q0), но в лабе лучше показывать все что относится к одной секции показывать принадлежащими к нему, здесь они показаны ниже (TC0, CEO0). На 3 состоянии эти сигналы равны 1, но они заведены на вход следующего счётчика. Как только этими сигналами ему разрешается счёт, срабатывает один счёт среднего счётчика. Дальше стоят нули и состояние среднего счётчика сохраняется. Когда средний счётчик достигнет 3, сформируются сигналы ТС1 и СЕ01 (однако на выходе СЕО1 сигнал будет сформирован только после 15 импульса, потому что только в этот момент на средний счётчик придёт СЕО0). Этот сигнал разрешает работать старшему счётчику, и он переключается только после 15 импульса.

Таким образом, на выходе последнего счётчика ТС2 стоит уже 16 наборов, и только на последнем 63 импульсе будет сформирован сигнал СЕО2.

Все выходы ТС можно было бы собрать в одном месте и получить точно такой же сигнал СЕО2, отличие было бы в том, что таким образом собранный ТС был бы быстрее, так как СЕО проходит через все элементы последовательно, и там задерживается.

на выходах как ТС, так и СЕО, мб состязания потому что сначала может переключиться первый триггер, а только потом переключится второй, и эти состязания за счёт разных связей

<a href="https://ibb.co/pjVw2ZQ"><img src="https://i.ibb.co/Wv85nF0/image.png" alt="image" border="0"></a><br />

в первую очередь это можно сделать за счёт реализации межразрядных связей (тут не указано), а указано про управление модулем за счёт использования входов управления на готовых счётчиках

можно загрузкой загрузить в счётчик значение К по load, дойти до конца (М-1 можно считать последним набором с одними 1111111) и тогда выходов ТС можно обнулить

<img src="https://i.ibb.co/9gRc8Zs/image.png" alt="image" border="0">

это двоично-десятичный счётчик (CD)

по синхронному входу R устанавливается счётчик в 0, далее он начинает считать до 3 и на данном элементе И (сверху справа) выбрано третье состояние, и формируется значение L ⇒ по следующему синхросигналу L имеет высший приоритет и поэтому значение, которое стоит на входах D (7: 0111) загружается в счётчик и по следующему синхроимпульсу счётчик переходит в состояние 7, а L стал равен 0. Далее счётчик опять переходит в режим счёта, считает до 9 и на 9 формируется сигнал TC (9, потому что это двоично-**десятичный** счётчик).

В данном случае связь TC-OR2 можно было бы не заводить, потому что после состояния 9 у счётчика и так идёт состояние 0, поэтому можно было бы просто подавать R, но так, чтобы он включал в себя синхросигнал (потому что R синхронный).

Так образом реализован счётчик 0 1 2 3 7 8 9. **В тестах когда указываем последовательность состояний надо начинать с наименьшего набора и не повторять его в конце**.

Могли бы быть любые другие наборы, например, можно было бы пропустить другие наборы. для этого можно поставить на выходе счётчика какую-нибудь минимизированную КС и тогда уже обязательно понадобился бы элемент OR2 на входе R.

R -- это вход управления, а не исполнитель. Исполнитель это CLR.

Если была бы заведена связь TC - OR2 и вход CLR, то модуль счётчика будет равен 6 (на 9 будет неустойчивое состояние и TC придёт сразу на CLR и счётчик асинхронно сбросится в 0), а могло бы быть и ещё меньше, если бы мы переходили из 7 состояния в 8 через 9. Поэтому в этот момент времени принципиально возможна иголка.

В unit это может не получиться, потому что по паспортным всё может быть ок и состязаний не будет, а в реале всё сложнее.

<a href="https://ibb.co/12hwM50"><img src="https://i.ibb.co/Lpb2rW0/image.png" alt="image" border="0"></a>

<a href="https://ibb.co/7tzg5Kz"><img src="https://i.ibb.co/jk5V2D5/image.png" alt="image" border="0"></a>


В Xilinx в option -> preference можно задавать частоту. за счёт задания b0 b1 b2 частота будет делиться каждый раз в два раза.

счётчик повторяет что-то, поэтому у него есть частота. Как правило частоту делят на значение модуля М счётчика. Если частот счётчика повторяется, то он мб делителем.

скважность у синхросигнала на ФД это меандр (скважность = 2), и на ФД каждый следующий выход счётчика делит частоту вдвое.

<img src="https://i.ibb.co/5ncF9rM/image.png" alt="image" border="0">

данный счётчик работает по спаду (на входах кружочки)

QA -- триггер, он делит частоту на 2
QB-QD -- счётчик по модулю 5, считает от 0 до 4.

здесь мы сделали не синхронный счётчик, с выхода триггера QA подаётся сигнал на вход счётчика CKB.

по спаду сигнала QA счётчик переключается, CKB для него это счётный вход

таким образом если суммарно все выходы рассмотреть как один счётчик, то он считает наборы 0 1 2 3 4 5 6 7 8 9 и работает как обычный двоичный счётчик

второй вариант: на CKB зададим счётный вход с внешних импульсов, а старший выход счётчика подадим на вход триггера. Счётчик будет считать от 0 до 4 и после перехода из последнего состояния (по спаду сигнала QD) на выходе триггера появится 1. В следующий раз триггер обнулится.

Таким образом, мы проходим наборы 0 2 4 6 8 1 3 5 7 и т.д.

на верхнем делителе: исходная частота tau, а у QA частота 0.5 tau, S (скважность) равна 2, QB не равномерный ⇒ скважность посчитать нельзя
QC: 6 нулей, 4 единицы ⇒ S = 10/4 = 2.5
QD: 8 нулей и 2 единицы ⇒ S = 10 / 2 = 5


при втором подключении
QA: 5 нулей, 5 единиц S = 10 / 5 = 2
QB: 01 01 00 10 10⇒ он неравномерно периодический, можно считать модуль 10 или модуль 5, но скважности нет. если этот сигнал мы будем пускать на вход Х осциллографа, то на экране будет фигня, потому что задержки между сигналами разные
QC: 00110 T = 5, S = 2/5 = 5/2
QD: 00001 M=5, S = 5/1 = 5

в лабе надо спроектировать на заданном счётчике счётчик с заданным модулем и скважностью, наборы можно выбирать любые; в первой части они заданы

можно расписать таблицу состояний 
<img src="https://i.ibb.co/zFPYXFG/image.png" alt="image" border="0">

тут повторение через 8 ⇒ как минимум на 8 поделить можно

но другие сигналы (Q2, Q1, Q0) не периодические

во 2-4 частях лабы можно задать произвольные наборы, но важно помнить, что один из выходов счётчика должен быть выходом делителя. Никакой комбинации на входе быть не должно, потому что могут быть состязания. **Выход делителя -- один выходов счётчика**.


надо собрать
- десятичный счётчик
- делитель на триггерах
- делитель на заданном счётчике
- делитель на vhdl

наборы определяем сами, для этого можно посмотреть на таблицу состояний.

<img src="https://i.ibb.co/BsRjjCt/image.png" alt="image" border="0">

Первое, для чего предназначен регистр, -- это хранение чисел.

Цепи переноса можно назвать цепями передачи между разрядами, то есть межразрядные связи. В счётчиках они тоже бывают, потому что счётчик это набор триггеров, так же как и регистр. Последовательные регистры могут принимать сигналы, прежде чем его сдвинуть.

Сдвиг может происходить не обязательно на один разряд. При этом времена задержки могут быть разные, если используются разные по скорости элементы. Также время задержки в схемах содержит не только от задержки элементов, но и от цепи передачи информации. Поэтому приходится выдерживать время прохождения информации до триггеров, время предустановки, и только потом подавать синхросигналы. Поэтому в сдвиговых регистрах должны использоваться либо триггеры с динамическим управлением записью, либо двухступенчатые.

<img src="https://i.ibb.co/t8fkmj4/image.png" alt="image" border="0">

В системе Xilinx есть и те, и другие типы регистров, но больше параллельные.

Триггеры с третьим состоянием на выходе или открытым коллектором можно соединить "монтажным" выходом. Там всего один контакт, и он может работать как на выход, так и на вход. Обычно это используются в сетях - шинные формирователи. Это случай, когда один контакт вида I/O, куда можно и писать, и откуда можно читать. То есть здесь надо соединять выход со входом. Для этого выход триггера должен быть с третьим состоянием или открытым коллектором (высокое сопротивление). В этом случае выход -- разрыв между замлёй и питанием. Это третье состояние: 0, 1 и открытый коллектор. Это закрытый коллектор, у которого сопротивление порядка кОм между землёй и транзистором, и такое же между транзистором и питанием. При этом можно даже напрямую соединять выходы с разных триггеров в регистре, такое соединение называется монтажным ИЛИ. В ПЛИС такое есть: 84 контакта, где все контакты, кроме генератора I/O и питания, можно программировать как вход, так и как выход, а можно и как I/O (в один момент он работает на приём, а в другой на выход, например, по управляющему сигналу Y)

Мы рассматриваем триггеры и с прямым и с инверсным выходами, в Xilinx сейчас как правило прямые входы, потому что любую инверсию можно реализовать на входе следующих схем за счёт задания инверсии на входе. Как правило, выходы регистров поступают на какие-то КС, где сигнал уже можно проинвертировать. Но в общем случае, например, в ТТ в лабах, можно передавать и прямой, и инверсный выход, что позволит не делать инверсию отдельно.

<a href="https://ibb.co/VNtgr6t"><img src="https://i.ibb.co/GJ0WBm0/image.png" alt="image" border="0"></a>

Какую микрооперацию забывают чаще всего? **Хранение данных**. Но чтобы что-то хранить, надо сначала выполнить ввод (приём, запись, загрузка) данных.

Последовательно данные вводятся при сдвиге. При этом мы можем получить преобразование последовательного кода в параллельный (на вводе) и наоборот при выводе.

В Xilinx нет регистров со сдвигом чисто вправо. В этом случае можно поступить так: выполнять сдвиг на регистре со сдвигом влево и переставить разряды в другом порядке на входной шине: вместо младших старшие, вместо старших младшие и таким образом сдвиг на выходе будет работать правильно.

Сдвиг влево -- это сдвиг в сторону **старших** разрядов.

Сдвиг на заданное число разрядов важен при работе с числами с плавающей запятой, где надо проводить нормализацию и денормализацию мантисс, поэтому идут на затраты схем, но зато нормализацию и денормализацию можно выполнить за один такт.

Важно, что в 5 лабе регистр должен обеспечивать хранение, даже если этого в варианте не указано.

Данные в принципе можно не выдавать, если выходы будут находиться с третьем состоянии.

Можно написать сброс как отдельную микрооперацию, потому что начальное состояние не обязательно может быть нулевое.

<img src="https://i.ibb.co/GFWyCQN/image.png" alt="image" border="0">

**Сдвиг** -- это одновременное перемещение двоичного слова в разрядной сетке с сохранением порядка следования единиц и нулей.

Операции сдвига позволяют реализовать различные преобразования данных, например, из одного кода в другой: ПК, ОК, ДК, работать с отдельными битами (выдвигать его и проверять).

Сдвиг влево выполняет арифметическую операцию умножения на 2 в степени. Сдвиг вправо -- деление на 2 в степени, которое может быть со знаком (арифметический сдвиг).

Также операции сдвига применяются для нормализации и денормализации чисел.

**Логический сдвиг вправо**: внутри все разряды сдвигаются вправо. Но при этом младший разряд выдвигается и теряется. При этом в старший разряд вдвигается либо 0, либо 1 в зависимости того, что будет подано на вход SRI - **shift right input** -- вход последовательного ввода.

Аналогично при сдвиге влево теряется выдвигаемый старший разряд; все разряды внутри передаются соседним, а в младший разряд вдвигается информация внешнего входа SLI (**shift left input**).

Поэтому в системе Xilinx всегда есть вход SLI; SRI есть только в реверсивных.

На входы **последовательного** ввода SLI или SRI подаётся 0 или 1.

Это можно применять для беззнакового умножения или деления чисел.

**Циклический сдвиг**: информация, которая до этого выдвигалась, теперь загружается внутри цепи (не на вход SRI) и вдвигается. При этом мы уже не можем управлять вдвигаемым разрядом, потому что сдвигается только то, что находится внутри. Между старшим и младшим разрядом установлена кольцевая связь.

**Арифметический сдвиг**: в числе знак -- старший левый разряд при сдвиге **вправо** так же, как и при логическом сдвиге младший разряд выдвигается и теряется, а знаковый разряд **остаётся на месте**. Однако если младший разряд теряется, старший разряд при сдвиге вправо заполняется знаком или нулём, в зависимости то знака.

В Xilinx в явном виде арифметических сдвигов нет.

При сдвиге влево в младший разряд мы вдвигаем 0 в ПК и ДК и знак в ОК. При этом старший разряд после знака теряется, а не переходит в знаковый. При этом знаковый разряд остаётся на месте.

В арифметическом сдвиге нет дополнительных кодов SRI или SLI, потому что заполнение идёт изнутри.

Нужно проверять переполнение: например, если число не помещается в разрядную сетку, при сдвиге надо анализировать знаковый и старший разряды до сдвига, и если будет превышение максимально возможного, должно фиксироваться переполнение. При этом конкретный результат не играет роли, потому что он всё равно неправильный.

Например, если взять число 0.100 = 4 и сдвинуть его вправо (что равносильно его умножению на два), то после сдвига оно должно будет равно 8, а 8 в трёх числовых разрядах записать нельзя.

<a href="https://ibb.co/3zyRVSs"><img src="https://i.ibb.co/FVbHc8W/image.png" alt="image" border="0"></a>
Параллельный регистр. Буква F в УГО обозначает триггер: регистры хранения реализуются только на триггерах.

У этих 4 триггеров объединены входы управления C, CE, CLR, есть 4 входа параллельной загрузки (параллельного приёма, параллельной записи) и 4 выхода. Он никак не преобразует информацию, у него у каждого триггера свой независимый вход и его же одноимённый выход. Задавать порядок разрядов в него можно в любом порядке, на D0 X3, на D1 X0 и так далее.

Здесь использованы **динамические** триггеры (треугольник), а могли бы использоваться и статические (так как они не передают информацию никуда дальше, это бы ничему не помешало)


<a href="https://ibb.co/pPXTH2L"><img src="https://i.ibb.co/n0kyXrL/image.png" alt="image" border="0"></a>

Асинхронный сбром ⇒ есть вход CLR, Раз регистр, то у него обязательно будет вход C.

Вход разрешения тактового сигнала ⇒ CE

параллельные выходы ⇒ 4 выхода
параллельные входы ⇒ 4 входа

Последовательный вход ⇒ SLI


В сдви

SR4CLE
- SR: shift register. Shift ⇒ должен быть вход C, так как все синхровходы дб объединены, а также вход SLI последовательной загрузки. В Xilinx SLI всегда присутствует, а SRI может быть только вместе с SLI в реверсивных регистрах.
- 4 ⇒ только 4 выхода
- C ⇒ есть вход CLR; если бы стояло R, это бы означали **синхронную загрузку**
- L ⇒ у регистра есть входы параллельной загрузки. Но этой параллельной загрузкой нужно управлять входом L (load)
- E ⇒ есть вход CE. Регистр выполняет не только операции сдвига и загрузки, но ещё и хранения. А раз имеется три микрооперации, нужно иметь два управляющих входа.

Этот регистр сдвигает сверху вниз, от Q0 к Q3.

Из обозначений следует, что высший приоритет у входа CLR. Если CLR = 1, то все остальные операции не работают. Если регистр не работает, надо проверять, что приходит на его вход CLR.

По умолчанию в Xilinx загружается 0, даже если не подать CLR, потому что в начале работы при загрузке на кристалл проходит сигнал GSR (Global Set Reset), который поступает на все входы CLR, S, Reset. Потому что если бы этого не происходило, то при записи конфигурации элементов выходы могут быть подключены к внешним устройствам, поэтому предусматривается автоматическое установление в 0. Поэтому все элементы не имеют двух входов, а только один, чтобы подать сигнал GSR, который виден при временном моделировании в лабе. Но CLR всё равно рекомендуется подавать.

Далее высший приоритет у входа L. Если L = 1, то независимо от входов CE, SLI, но по фронту C загружается состояние со входов параллельной загрузки.

Если CE = 1, выполняется сдвиг (внутри это логический сдвиг, хотя это можно отдельно не говорить, потому что внешние связи могут быть такие, что логический сдвиг превратится в арифметический сдвиг в каком-то коде). Происходит сдвиг слева направо 0 -> 1, 1->2, 2-> 3, 3 теряется; в 0 загружается SLI.

Если на входах L и CЕ поданы 0, то регистр хранит информацию.

Тогда в соответствии с таблицей регистр выполняет следующие операции
- обнуление
- загрузка
- сдвиг влево на 1 разряд
- сдвиг влево на 1 разряд
- хранение

На входе перед триггерами стоит многовыходная КС: однотипные схемы перед 1-3 тирггерами, а в нулевом разряде стоит мультиплексор, в который можно загрузить SLI или D0; а на следующих загружается либо Di, либо значение предыдущего разряда.

На МQ0 при L = 1 происходит загрузка D, при L = 0 поступают сигналы с предыдущих триггеров при i = 1, 2, 3 и для нулевого -- сигнал с SLI.

Информационные входы (входы данных) -- SLI, Di
входы управления -- L, CE 
исполнительные входы -- C, CLR. По ним исполняется установка в 0, загрузка или сдвиг.

Наконец, объединяются все входы управления CE триггеров. Мы должны загружать параллельный или последовательный код по входу CE, который зависит от внешних входов CE или L.

C, CLR также объединены у всех триггеров. 

КС, которые информационные (MUX) и КС управления входом CE (OR2 вверху).

Если задать CE = 1, и L = 1, то будет выполняться загрузка, потому что она имеет высший приоритет.

На этом же регистре можно было бы сформировать последовательный вывод. Его можно было бы считать на Q3.

Если сдвиг идёт на 2 разряда, то входов загрузки SLI надо было бы сделать два для заполнения обоих пустых разрядов.

Хранение можно обеспечить за счёт передачи сигнала с выхода триггеров на входы триггеров. Для этого можно сделать дополнительный вход. Это тратит больше энергии, потому что идёт переключение.

Условно можно считать, что внутри триггера стоит элемент И, на который приходят CE и C, Таким образом, хранение можно обеспечить за счёт подачи 0 на CE.

<a href="https://ibb.co/9tXmF9x"><img src="https://i.ibb.co/m8srLCn/image.png" alt="image" border="0"></a>

В обозначение добавилась буква D -- Direction ⇒ это реверсивный регистр, и надо управлять направлением ⇒ появился вход LEFT ⇒ появился вход SRI

Сдвиг влево -- сверху вниз; вправо -- снизу вверх.

L = 1 ⇒ загрузка.

CE = 1 ⇒ может быть сдвиг либо вправо, либо влево. CE фактически управляет сдвигом: если LEFT = 0, то сдвиг выполняется вправо с входа SRI передаётся на Q3, все остальные сдвигаются вверх, Q0 теряется.; при LEFT = 1 -- наоборот.

В связи с этим появился второй набор мультиплексоров. Для сдвига влево MDL; для сдвига вправо MDR.  Теперь при сдвиге вверх появляется мультиплескор MDR3, на который приходит SRI, аналогично нулевому мультиплексору в MDL.

Вход L управляет первой группой, LEFT -- второй группой.

<a href="https://ibb.co/34vS6Q3"><img src="https://i.ibb.co/9chyKSD/image.png" alt="image" border="0"></a>

Здесь приведён пример увеличения разрядности реверсивного счётчика. Все входы управления в каждом регистре объединены. Входы C, CLR также объединены, но это исполнительные входы.

Входы SLI, SRI и D -- информационные входы.

Если D0-D3 -- младшие разряды, то на выходе регистра третий разряд не теряется, а переходит в следующий разряд следующего счётчика. При сдвиге в другую сторону 8 разряд переходит на SRI предыдущего, 4 на SRI нулевого, а Q0 теряется.

В своих регистрах в БО можно будет использовать, например, один триггер для сдвига. На 4 работе, если не удаётся реализовать на одном счётчике (например, нужен счётчик на 5 разрядов), то можно дополнить счётчик дополнительными триггером, а не соединять два счётчика.

На регистрах сдвига можно реализовать счётчик. За счёт управления входом SRI или SLI можно реализовать счётчик. В счётчке мы ставили КС на входах D, которая зависела от выходов и для текущего состояния мы готовили, в какое состояние должен переключиться счётчик и ставили соответствующую КС.

При сдвиге входы D отключены и при CE равном единицу сходы SLI. Из нулевого состояния регистр может перейти в состояние, равное тому, чему равно SLI, то есть либо в 0, либо в 1.

Из первого состояния можно перейти либо во второе, либо в третье.

Можно подготовить КС на входе SLI, на вход которой подаём выход.

<a href="https://ibb.co/Br4mLns"><img src="https://i.ibb.co/xfmyhF5/image.png" alt="image" border="0"></a>

Строим граф переходов. Например, в 5 состоянии (101) если приходит 0, но мы переходим во второе состояние (010), а если 1, то в третье состояние (011).

На вход SLI ставится КС, на входы которой поступают выходы схемы.

Предложен счётчик 0 1 3 6 4. Если провести минимизацию (это пропущено), то в результате минимизации будет получен элемент NOR2. За счёт этой комбинационной схемы (NOR2), синтезированной на основании графа переходов, синтезирован счётчик по модулю 5.

Но так можно сделать не с любыми наборами. С какими-то наборами, не входящими в граф переходов, пришлось бы пользоваться входами установки.

Это же можно реализовать и на триггерах. Данный регистр: вход только последовательной загрузки и 4 параллельных выхода, внутри из себя представляет 3 последовательно соединённых между собой триггера ⇒ вариант а) это внутренняя схема данного регистра за исключением отсутствия CLR (поэтому обозначение у триггера только FD) и отсутствия входа CE (то есть он всегда работает, но по фронту). Такой триггер не рекомендуется использовать, лучше использовать триггера с СЕ, потому что такие триггеры без СЕ могут не срабатывать. 

Вход T0 можно считать в данном случае входом SLI для регистры.

Тот же самый счётчик можно реализовать не на регистре сдвига, а на регистре хранения (в). На таком регистре очень просто реализовать сдвиг, ведь на регистре хранения можно входы D исключить и завести связи между триггерами. На данном регистре хранения Q0 -- вход SLI, на который подаётся NOR2, с 0 разряда передаётся 1, а 3 разряд выдвигается.

На регистре хранения можно реализовать сдвиг, но у него тогда будут отсутствовать напрямую входы загрузки (они будут заняты связями между разрядами для сдвига).

В данном случае в графе мы не используем состояния 2, 3 и 7. Если мы случайно в результате сбоя попадём в один из этих наборов, что будет? Например, если попали во 2 набор (010), на NOR 2 будет 0 ⇒ перейдём в 100 (4) и вернёмся в граф.

Из 5 (101) получаем на входе SLI 0 ⇒ 010 ⇒ 100
7 (111) ⇒ 0 ⇒ 6 (110)

В схемах всегда нужно рассматривать возврат в требуемый режим. Либо надо принудительно задавать сброс и начальную загрузку. Часто стоит вопрос, как быстро нужно вернуться в начальное состояние -- за один такт или за несколько.

В системе Xilinx есть регистры сдвига только влево или реверсивные. Можно задать разряды в другом порядке и получать сдвиг в другую сторону. Но сдвиг в Xilinx только логический, если нужен циклический, нужно заводить отдельные связи, для арифметического надо смотреть отдельно, в некоторых кодах надо добавлять отдельные триггера.

В готовых регистрах 4 разряд Q3 не используется, и в Implementation будет выдаваться предупреждение, что выход Q3 не задействован. при размещении на кристалле этот выход удаляется и нигде не используется. Q0 не удаляется, потому что он используется внутри схемы.

Принципиально можно на 8-разрядном регистре создавать 6-разрядные, потому что лишние неиспользуемые элементы будут удаляться.

<a href="https://ibb.co/z58Jn8k"><img src="https://i.ibb.co/N31SV14/image.png" alt="image" border="0"></a>


Таким образом можно получить счётчик по модулю до 8.

Особая группа -- кольцевые счётчики, на вход SLI у них подаётся выход последнего разряда, то есть образуется кольцевая связь. Таким образом, будет N состояний и в каждом из состояний будет одна единичка (если мы записали одну единицу в начале). Дешифрирование состояний счётчика очень простое.

Если подать выход не со старшего состояния, а с какого-то другого, то он будет использовать просто меньше разрядов и меньше состояний. Но при этом надо не забыть загрузить начальное состояние, иначе счётчик будет гонять нули по кругу.

На основании такого кольцевого счётчика строится распределитель тактов. Унитарный код можно получить , поставив на выход счётчика дешифратор. Минус у такой схемы -- могут быть иголки, когда счётчик переключается 01 -> 00 -> 10, когда триггеры переключаются не одновременно.

Распределители тактов
- распределители уровней (импульсы друг за другом без пауз)
- распределители импульсов (импульсы стробируются входным генератором)

Распределители импульсов реализуются за счёт конъюнкторов (элементов И).

<a href="https://ibb.co/tm50KxD"><img src="https://i.ibb.co/smrTR6q/image.png" alt="image" border="0"></a>

С выходы U3 заводим связь на SLI ⇒ счётчик по модулю 4. На выходах будут уровни -- сигналы идут подряд без промежутков. Из уровней можно получить импульсы, добавив конъюнкторы: один вход у них соединён с распределителем уровней, а вторые подключены к синхровходу. Регистр срабатывает **по спаду** за счёт инвертора после С, чтобы исключить иголки.

Как в этом счётчике задать начальное состояние? Для этого надо задать входы D и выполнять начальную загрузку. Но можно дополнить регистр-счётчик сбросить в 0, и когда у нас все нули, на вход надо подать единицу один раз, а потом одни нули. Предложено поставить элементы NOR4, которые будут формировать 1, как только на него придут все нули. На диаграмме показано, что по входу CLR можно сбросить счётчик в нулевое состояние, в нуле на выходе NOR4 формируется единица, которая будет загружена на выход U0 по спаду С. Счётчик переходит из U4 в U0 и дальше идут сдвиги. Как только счётчик опять получает значение 4 нуля, опять формируется единица. Таки образом, за счёт этого элемента мы получили не только начальную загрузку счётчика, но, если посмотреть на диаграмму, то счётчик можно считать пятиразрядным, у которого есть пятый выход уровня U4.

Регистр если имеет N триггеров, то будет иметь N состояний в нитарном коде, но, дополнив его одним элементом NOR, можно получить ещё одно состояние.

Все выходы U поступают на 5 конъюнкторов и стробируются (вырезаются) с помощью сигнала С.

Когда в тексте пишутся латинские буквы, обычно они пишутся курсивом.

NOR4 -- самовосстановление, то есть данный регистр-счётчик при сбое, например, из состояния 2 перешли в 3 (1, 01 и вдруг 0011). Поскольку 2 единицы дают 0, то перейдём 3 - 6 - 12 - 8 - 0 и сформируется единичка на выходе. За счёт этого элемента мы возвращаемся в наш граф переходов после сбоев за несколько шагов. 

Если мы загрузили в регистр какое-то число и сдвигаем его связями, надо ответить на вопрос, что мы будем наблюдать в той или иной точке. Аналогично объяснить на экране осциллографа, почему тот или иной триггер перешёл в то или иное состояние.

На с. 99 86 рисунок показан с ошибкой. Что будет на выходах элементов, если мы инвертор удалим?  Если U будут переключаться по фронту, то если мы посмотрим на выходы U,  U1 и U2 могут завершиться и начаться соответственно не одновременно, так как счётчик может переходить как 01 -> 11 -> 10. Здесь иголок нет, потому что мы переключаемся по спаду и подачу C мы уже прекратили, а в противном случае на одном из выходов могут быть иголки. Так как если при переходе через два состояния появляются некоторые промежуточноые **и в то же время подан синхросигнал**, то на выходах C будут иголки, потому что они будут срабатывать сразу.

Если мы загрузим тройку за счёт входов D, то мы перейдём 3 -6 - 12 - будет 4 состояния, но не в унитарном коде. Состояний может оказаться меньше, например, 5 - 10 - 5 (0101) - (1010)

<a href="https://ibb.co/bRS74TL"><img src="https://i.ibb.co/mFLSnkt/image.png" alt="image" border="0"></a>


Если в обычном кольцевом счётчике мы заводили связь  со старшего разряда на SLI напрямую, то в счётчике Джонсона мы подаём **инверсный** сигнал.

Плюс: каждый раз переключается один разряд. Особенность: в счётчике распространяется волна единиц и волна нулей на каждом разряде (это видно на временной диаграмме).

При этом выход не представлен в коде 1 из N, поэтому, чтобы сказать, в каком состоянии находится счётчик, надо его декодировать. Нужно выделить определённую комбинацию

<a href="https://ibb.co/Bnv2nz0"><img src="https://i.ibb.co/y4KF4fH/image.png" alt="image" border="0"></a>

Если мы завели обратную связь и счётчик в начальный момент установили в 0, то после нуля на ход SLI будет приходить единица, пока они не дойдут до последнего разряда. Поэтому будут наборы 0 - 1 - 3 - 7 - 15. При 15 единичка пришла на выход Q3, инвертируется и начиная с этого момент на вход SLI начинают приходить единицы: 14 - 12 - 8 - 0. Получается, всего 8 наборов.

В коде Грея при n триггеров будет 2^n^ наборов, а тут только 8 (2n) наборов. На каждом переходе изменяется только один разряд. Как видноЮ наборы не подряд идущие. У счётчика можно определить по выходам, сколько импульсов уже прошло. Например, если состояние 8, надо уметь посчитать, сколько состояний уже прошло. Для этого можно было бы поставить более сложную КС, которая могла бы данный код счётчика Джонсона (Мёбиуса) переводить в двоичный код. А можно перевести в унитарный код, в котором удобно смотреть, какое состояние прошло, а самое главное -- эти выходы очень удобно использовать для построения распределителей уровней или импульсов. В данном случае показано распределение уровней (между ними нет промежутка, а импульсы **стробируются** или вырезаются синхросигналом). При этом, конечно, могут быть задержки, но переключается всегда один из выходов, поэтому иголок не будет. Тогда, например, из таблицы переходов можно было бы увидеть, что можно определить, что такое первый уровень, первый выход D1. Для этого нужно смотреть набор хх01 -- он больше нигде не встречается. Аналогично для остальный наборов это можно получить. Можно было бы также провести минимизацию для каждого выхода, расписать минимизацию и показать, что данный выход нужен при данной комбинации выходов счётчика, при этом остальные комбинации равны 0, а 8 отсутствующих комбинаций равны х. Таким же образом можно сказать, что нулевой набор -- это код хх00, потому что ни у кого больше не встречается комбинация двух нулей в младших разрядах. При этом на выходе получается распределитель уровней. Если дальше из него нужно стробировать, нужно поставить элемент И на выходе и инвертор для предотвращения иголок.

Если рассматривать граф переходов для счётчика, то он проходит уже показанный состояния (1 - 3 - 5 - 7 - 15 - 14...), но нету восьми других состояни.

<a href="https://ibb.co/hCJ2T0G"><img src="https://i.ibb.co/pnB4kqH/image.png" alt="image" border="0"></a>

Если  мы попадём в неправильное состояние (например, 2), то счётчик будет циркулировать по графу б) и не будет самовосстановления.

Поэтому если мы в них попадаем, то надо провести минимизацию и дополнить схему. В таком случае мы будем возвращаться в исходный граф, но не с первого перехода. То есть для самовосстановления надо доопределить состояния.


В лабе надо продумать, как организовывать циклическийй сдвиг.

Кольцевой счётчик это как циклический сдвиг. В лабе надо ориентироваться, что будем наблюдать при загрузке и сдвиге информации. Этот счётчик будет использоваться потом для распределителей тактов и распределителей импульсов.

Чтобы на осциллографе наблюдать всю временную диаграмму счётчика Джонсона, надо на вход Х осциллографа подать спад Q3 или фронт Q0. Начиная со спада Q3 мы запускаемся и видим все ступеньки. А если запускаемся по фронту Q0, то мы начнём наблюдать с D1.


Когда мы будем смотреть Q0, Q1 или выходы D в режиме внутренней синхронизации (запуску от наблюдаемого сигнала, когда вход X отключается, в запускается внутренний генератор от самого исследуемого сигнала, осциллограф работает по наблюдаемому сигналу), то если мы будем наблюдать один из $D_i$, то вид для любого из сигналов будет как Do (если это фронт), или как D1 (если это спад),

Поэтому если на осциллографе что-то не совпадает, в первую очередь надо проверить, какая синхронизация.

Для сигналов Qi мы также будем наблюдать одинаковую картинку (если наблюдает по фронту, то будем видеть 11110000, если по спаду -- 00001111). 

Вид картинки при внутренней и внешней синхронизации зависит от того, что приходит на вход синхронизации. 

В кольцевом счётчике как правило свдигается одна единица ⇒ n состояний

в счётчике джонсона будет 2n состояний

здесь чтобы определить какое состояние стоит например на 15 наборе, он по счёту будет только четвёртым. Для этого для каждого выхода построить распределитель уровней -- КС для каждого выхода, построить диаграмму вейча и определить что будет за элемент для d0

по вд можно заметить, что можно построить 8 диаграмм вейча ⇒ 8 состояний ⇒ 8 иксов ⇒ после минимизации мы бы получили nq0 nq3.  

заметим что для счётчика джонсона если мы попадаем в неправильное состония, попадаем в другой граф, неправилньый, из которого уже не вытйи

чтобы сема восстанавливалась, хоть и не за один шаг, можно провести другую минимизацию, чтобы мы возвращались в состояние из правильного графа и получить схему счетчика с самовосстановление

<a href="https://ibb.co/R0kS8Ww"><img src="https://i.ibb.co/gTL7YCK/image.png" alt="image" border="0"></a>

<a href="https://ibb.co/cFNGJMc"><img src="https://i.ibb.co/swF0jkv/image.png" alt="image" border="0"></a>

каждое последующее состояние почти не зависит от предыдущего. Но через какое-то время мы всё равно начнём повторяться, но хорошие генераторы имеют большой модуль

в хороших генераторах типа генераторов случайных, а не псевдослучайных последовательностей, вероятность появления следующего значения равновероятна

на основе этих генераторов строятся ключи защиты: подаём на вход в канал нужную информацию совместно с генератором ПСП, передаём их вместе через xor в шину, а у приёмника на первом входе стоит xor, а на втором сам ключ ⇒ на выходе получим

для этого в сборнике задач предложено использовать регистр сдвига 4 разрядный. У него объединяем по ксору два выхода -- один из них последний, второй может быть каким-то из предыдущих. Когда неизвестно, что это будут за разряды, а если их ещё и много, то можно будет генерировать последовательности. При n счётчиках получается модуль счёта 2^n^- 1, при этом нулевая комбинация исключается.

С каждого выхода генератора Х идёт какая-то конкретная последовательность нулей и единиц, которая является псевдослучайной, но на некоторых выходах эта последовательность может совпадать с точностью до сдвига.

Вход старт нужен для запуска регистра. 

НО в нашем случае из нуля регистр ни в какое состояние не перейдёт (на SLI из-за XOR3 будет подан ноль), а одноразовый короткий сигнал старт даёт единичку, которая переходит в SLI.

Мы видим сдвиговый регистр с входом только последовательного приёма, а входов D нет, поэтому нет и входа L.

Справа предложена самозапускающаяся схема. Здесь нет нулевого состояния. Когда схема вдруг сбилась и перешла в нулевое состояние, её нужно восстановить -- для этого ставится элемент 4или-не, который в данном случае будет аналогом входа START.

На этот элемент XORR мы объединяем старший разряд и какой-нибудь из младших (например, Q0). ПРи этом на этот же элемент прихолит выход элемента 4или-не, который равен 1 только окгда схема сбилась, а всё остальное время он равен 0 и не мешает xor.

Таким образом, получается какая-то другая случайная последовательность. Чем больше n, тем больше длина последовательности. Если разрядов будет 20, то модуль этого счётчика равен примерно миллиону. (1 048 575)

При этом если период генератора известен, то например есть 15 тестов для проверки генератора. ПРоверяется количество 0 или 1, вероятность появления пары или тройки, количество групп подряд идущих единиц и нулей, есть визуальные методы проверки качества этих генераторов.


 <a href="https://ibb.co/XXMw5c1"><img src="https://i.ibb.co/TcdC096/image.png" alt="image" border="0"></a>


в лр было приведено на рис 5.4 как можно реализовать внутренний регистр сдвига на который на вход d можно поставить мультиплексор, на которых реализуется либо параллельная загрузка (L = 1) или сдвиг (L = 0). При последовательной загрузке работает вход SLI, который дальше назвали DP0.



# Сумматоры
<a href="https://ibb.co/YLSGTwG"><img src="https://i.ibb.co/TgG5qd5/image.png" alt="image" border="0"></a><br />

Арифметическое сложение: в нём присутствуют цепи межразрядного сложения, в отличие от логического сложения (ИЛИ) и сложения по модулю (XOR, но мб по любому модулю, например, по модулю 3 -- это будет остаток от деления на 3.

<a href="https://ibb.co/9yc9rmh"><img src="https://i.ibb.co/2cW7k0S/image.png" alt="image" border="0"></a><br />


Полусумматор --  у него нет входного переноса, а у одноразрядного полного сумматора он есть. Полусумматор всё равно может использоваться в многоразрядных сумматорах в младшем разряде.

Сумматор для последовательных операндов: мы сдвигаем всегда операнды, для них используется одноразрядный полный сумматор и быстродействие там не нужно, обработка происходит редко.

Накопительный сумматор -- это сумматор, у которого на выходе стоит регистр, накапливающий результат: его мы применяем при умножении

<a href="https://ibb.co/X4BChKB"><img src="https://i.ibb.co/W392bM9/image.png" alt="image" border="0"></a>

Переполнение разрядной сетки в дальнейшем мы будем называть переносом.

Суммируются два разряда, и в отличие от логического сложения и сложения по модулю 2, перенос не пропадает и формируется на выходе Carry Output.

Тут кстати есть ошибка: $HS = \overline A B \vee A \overline B = A \oplus B$

В отличие от полусумматора, у полного сумматора появляется вход CI.

<a href="https://ibb.co/rs5RScd"><img src="https://i.ibb.co/hf2JjZY/image.png" alt="image" border="0"></a>

Здесь есть три входа ⇒ 8 строк в таблице истинности. Из этой таблицы можно извлечь правило: если нечётное количество единиц на входе, то выход S будет равен 1.

Если единицы на двух или более входах (в данном случае на двух или трёх), то CO будет равен 1.

Если не проводить минимизацию, то можно выписать СДНФ, выписывая единицы -- элементарные конъюнкции или термы, для S и для переноса CO. Если их реализовывать без всякой минимизации, можно получить приведённую на рисунке схему (её называют классической схемой сумматора) в базисе И ИЛИ НЕ.

На экзамене также нужно будет писать ТИ, писать минимизацию и реализовывать схему.

Если посмотреть только на таблицу, то видно, что CO и S с 1 по 6 наборы отличаются инверсией. Если бы мы написали $S = \overline {CO}$, то надо было бы это дополнить 7 набором: $S = \overline{CO} \vee A B CI$ и запретить нулевой набор, дописав ещё $\overline {CO} (A \vee B \vee CI)$

По аналогии с вычтателем, функцию S нельзя минимизировать. Если посмотреть на $CO$ из диаграммы Вейча, можно любой набор склеить с 7, получив B CI + A CI + A B, то есть перенос можно было бы реализовать как три двухвходовых элемента И без инверсии, то есть это было бы ещё быстрее. Если посмотреть на исходную схему, то время появления сигнала на выходе CO с инверсией будет равно 3, а без неё -- 2.

<img src="https://i.ibb.co/D8n8kq7/image.png" alt="image" border="0">

Свойство самодвойственности видно на 0 и 7 строках. Чтобы выиграть время переноса между разрядами, можно использовать и те, и другие выходы в каждом разряде: и инверсные, и прямые поочерёдно.

Чем отличаются схемы друг от друга: мы увидели два варианта аппаратной реализации: без минимизации (на элементах) и с минимизацией. Рассмотрим, как меняется быстродействие: если меняется информация на каком-то входе, через какое время это изменения поступит на выходы S и CO.

Рассмотрим это на схеме выше. От А, B и CI сигналы проходят на СO сразу, но на сумму оно будет приходить медленнее, так там есть связь с CO, но от A, B и CI связи к двум выходам идут одинаковые, и в общем случае у них задержки одинаковые. Считаем, что задержки от А до S и от A до CO такие же, как и у B.

Задержка до CO будет равная 2, а от входа до S будет равна 4, то есть задержка на СО меньше, чем на сумме.

Если вернуться на классическую схему, то на любом выходе задержка будет равна 3 элементам: инвертор, И и ИЛИ.

Задача -- сделать так, чтобы СО сформировался быстрее, пусть даже выход S будет медленнее.

Если бы мы не заметили свойство в ТИ, можно было бы попробовать провести минимизацию CO и получить её. Считая, что есть А, В, CI и реализовав уже CO, можно было бы сделать S как функцию от 4 переменных.

<a href="https://ibb.co/3rfWSnf"><img src="https://i.ibb.co/FxsJ8Fs/image.png" alt="image" border="0"></a>


В ТИ стоит на 1 наборе X на S, потому что при трёх нулях не может быть CO, то есть данная комбинация входов невозможна.

Чтобы легче заполнять табличку, воспользуемся не диаграммой Вейча, а картой Карно. В карте Карно, в отличие от диаграммы Вейча, наборы переменных строго фиксированы: это код Грея по каждой стороне: каждая соседняя пара переменных отличается только в одном разряде. 

Эту же схему можно было бы реализовать так:

<a href="https://imgbb.com/"><img src="https://i.ibb.co/d65twQh/image.png" alt="image" border="0"></a>

В левом случае задержка от каждого входа до каждого выхода равна 2.

Количество единиц для выхода S можно посчитать с помощью двух последовательных XOR. Задержку в XOR и AND сравнивать, если та схема реализована не на ПЛИС, нельзя, потому что это элементы их разных базисов. Понятно, что в XOR задержка будет намного больше, так как внутри него также содержатся элементы.

Также можно построить сумматор на основе полусумматоров и схемы ИЛИ. Это надо будет пояснить на экзамене: как работают оба полусумматора и как они формируют выходы. Есть две пары переменных, каждый из полусумматоров фактически определяет количество единиц в каждой паре.

Если у готового сумматора переставить местами А, В и CI (внешние входы), результат от этого не изменится. С точки зрения быстродействия: желательно при объединении разрядов это не путать, потому что связь CI-CO может быть реализована быстрее.

### Сумматор для последовательных операндов

Схема взята из Угрюмова.

<a href="https://ibb.co/kq9MSMC"><img src="https://i.ibb.co/44YJVJr/image.png" alt="image" border="0"></a>

при подготовке в лабах лучше не менять входы местами: если CI идёт сверху, то надо его делать сверху, чтобы не делать лишних ошибок.

Есть два операнда А и В, многоразрядные (n разрядов). Если мы суммируем, то на выходе у нас получается число из n+1 разряда (учитывается перенос из старшего разряда, который превращается в n разряд). А можно было бы не менять разрядность выхода, и просто снимать перенос с отдельного триггера.

Сумматор -- одноразрядный полный комбинационный. Не рассматриваем вариант, как мы записали в эти регистры А и В значения (могли бы записывать и параллельно, и последовательно за n тактов). У регистра суммы показан вход последовательного приёма SLI.

На выходах в соответствии с ТИ появляется и сумма, и CO. CO приходит на триггер, чтобы запомнить его







<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE0MjM2Mjc4MzAsLTg0NzU2MDY2MiwtMT
Q1Mzg3NDMwOCwtMTIxNDgwMDUxNCwxMjQwMTI0MTg1LC0yNzE2
MDM3NjAsMTMzOTA3NDA0OCwtMTAyODYwNzc0LDMwMTU0MTg3NS
wtNjkwMDQ2MjczLDg5NzkyMjM1MiwxNzM0Mjc2OTAsMTU2NjM1
ODAzMCw3NDAyNzgyNTksMTQ1Mzc2MDk5MCwtMTg5NDkwMDQ2MC
wtNTIyMTQzNzc1LDM1Nzc4NzI3NSwtMzg1NDI4NzMwLC00NzYz
NzU3ODhdfQ==
-->