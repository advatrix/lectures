
# Схемотехника
<a href="https://ibb.co/tJ65KTQ"><img src="https://i.ibb.co/QKVGQ3p/image.png" alt="image" border="0"></a>

<a href="https://ibb.co/QFwz8cx"><img src="https://i.ibb.co/TB3pKTN/image.png" alt="image" border="0"></a>

6 лаб. (первая - вводная, все в сборнике лаб). 6 -- состязания

Лабы в чт по подгруппам, 513 тоже буде разбита на подгруппы.

Каждая работа
Синтезировать схему, разрабатывать схему на языке VHDL (пишем дома, отлаживаем в универе).

В каждой лабе надо строить временные диаграммы
во 2 и третьей строить руками (вручную или в excel, но не через xilinx) с учетом временных параметров

завтра два семинара вместо лаб по построению временных диаграмм для всех лабораторных

готовимся с опережением удалённо: на вводную работу 2 занятия не считая завтрашнего

на комб схемы 2 занятия

счётчики и триггеры по 3 занятия

состязание -- 1 занятие

каждая лаба предусматривает 
на входе проверяем подготовку заранее высланную на почту (на 3 неделе высылаем подгтовку и на 4 неделе приходим с готовой 2 лабой)

пишем входной тест: 15 минут входной тест на каждую лабу на оценку

после выполнения всех пунктов в описании лабы и отчитывании пишется зачётный тест на полчаса (3-5 вопросов), чтобы защитить тест надо больше 50%. в один день только один тест.

не написали входной тест -- не допущены

входной тест: читаем подготовку к лабе с теорией (можно смотреть и в сборнике задач), а зачетный тест -- оценка задержек, небольшой синтез , посложнее

после ответа на тесты сдаём отчеты по лабораторной работе

в лабах подключаем элементы стенда и работаем с осциллографом (см приложение в сборнике лаб, там есть описание работы с осциллографом). в приложении кроме того приведены условные обозначения элементов, которые тоже надо знать, они будут в тестах

лаба вводная, лаба 2 и приложение 1 ⇒ это всё будет во входном тесте ко второй лабе

работы фронтально -- по расписанию, долги остаются на потом

расчёт параметров временных диаграмм, задержек тоже нужен в каждой работе

к 10 сентября надо овладеть стендом, вспомнить xilinx, работу с осциллографом


6-7 неделя: бдз на проектирование процессора, которое завершается 1 июня защитой курсового проекта
задание на два семестра
начинаем проектировать блок операций, который будет выполнять умножение (много разных алгоритмов)

книжка проектирование процессора 2006 а4 -- по ней два семестра готовимся к защите

в этом семестре сдать в электронном виде первую часть -- блок операций

на каждом семинаре выдаются дз, которые надо сделать заранее: к понедельнику вечером присылаются отчеты по заданиям

6 часов в неделю, 96 часов нагрузка в семестр + домашняя подготовка

на семинарах говорится что как делать в лабах, будут некоторые уточнения, изменения в схемах

в лабах набираем схему заново

<a href="https://ibb.co/v1YPrtQ"><img src="https://i.ibb.co/0qtMWwF/image.png" alt="image" border="0"></a>
ПС -- схемы с обратной связью: сигналы с выходов поступают на вход. ПС -- схемы с предысторией.

<a href="https://ibb.co/kmjfPtv"><img src="https://i.ibb.co/VwRZks5/image.png" alt="image" border="0"></a>

Комбинации И-ИЛИ-НЕ, И-НЕ (штрих Шеффера), ИЛИ-НЕ (стрелка Пирса) по отдельности являются логическими базисами. 

"Исключающее ИЛИ" -- желательно в статьях писать именно так. Сумма по модулю два -- это тоже самоею

XOR -- неравнозначность, XNOR -- равнозначность.

Эти элементы будут входить в экзамен. Достаточный материал для подготовки приведён в сборнике задач.

**Триггер** -- элемент, имеющий два устойчивых состояния. Предназначен для хранения одного бита информации.

Набор триггеров может образовывать регистр или счётчик. На регистрах и счётчиках можно строить делители частоты, формирователи импульсов, и так далее.

<a href="https://ibb.co/GpF5wt2"><img src="https://i.ibb.co/W5s29Py/image.png" alt="image" border="0"></a>

AND -- логическое умножение, конъюнкция. Обозначается в виде прямоугольника, где в верхней части рисуется обозначение функции. В системе Xilinx это полулуна.

Между элементами, как и между всеми связями не менее 5 мм. Любая документация должна иметь и печатную версию и в ней надо увеличивать именно так.

Функцию можно записывать через точку, а можно её пропускать, но тогда надо оставлять немного места. Все обозначения пишем заглавными буквами. Можно обозначать $\land$ или `and`, как в языке VHDL.

Входы и выходы в таблице истинности было бы лучше отделить двойной линией.

> И: если среди входов есть хотя бы один сигнал с 0, даёт 0.

высокий уровень (больше 2.4 В) = логическая 1
низкий уровень (0): меньше 0.4 В

Схема И: когда все единицы, то результат единица, что для отладки может быть неудобно: слово ВСЕ означает, что как бы надо проверять все входы. А лучше бы смотреть, где встречаются нули: 

### ИЛИ
Четверть луны, 1. А + В, галочка V или `or`.

Правило: если есть хотя бы одна единица, то даёт единицу.


### Инвертор
Раньше на стенде писали всегда 1. Важно, что на выходе рисуется инверсия. В Xilinx рисуется треугольник с кружочком. 
Инверсию ещё можно писать над элементом. Гораздо удобнее набирать `A'`, можно писать `nB`.

<a href="https://ibb.co/3v80X09"><img src="https://i.ibb.co/LrqCwCX/image.png" alt="image" border="0"></a>

И-НЕ: правило: если хотя бы один 0, то на выходе 1. В VHDL `nand` можно написать только для 2 входов. Иначе написать `not (A and B and C and ... )`


В NAND и NOR указывается количество входов.

ИЛИ-НЕ: есть хотя бы одна единица ⇒ даёт 0.

Для перехода между ними можно применять т. де Моргана

<a href="https://ibb.co/5cBXKqX"><img src="https://i.ibb.co/9YsmZRm/image.png" alt="image" border="0"></a>

<a href="https://ibb.co/ftgdJjn"><img src="https://i.ibb.co/92DHPQV/image.png" alt="image" border="0"></a>

### XOR 

Имеет несколько обозначений: в отечественных =1, М2 (сумма по модулю 2), плюс в кружочке.

В Xilinx -- дополнительная дуга у четверти луны.

Также описана реализация этой функции в базисе И, ИЛИ, НЕ. Высший приоритет имеют инверторы, далее реализуем слагаемые (термы или импликанты) на конъюнкторах, затем импликанты объединяем по И.

Управляемый инвертор: А -- вход управления, то при 0 передаём значение В, а при 1 передаём инверсию В. Мы управляем передачей В.

### XNOR

Обозначается как XOR с инверсией, но подписывается XNOR.

<a href="https://ibb.co/wgFb9xz"><img src="https://i.ibb.co/6w7p3fW/image.png" alt="image" border="0"></a>

Схемные решения сравниваем по двум параметрам:
- по аппаратным затратам (число элементов). В этих двум схемах одинаково для 8 входов
- по временным параметрам (задержка входного сигнала по поступления на выход)

Видно, что в каскадной схеме каждый вход задержан на три элемента. А в последовательной задержка бОльшая и достигает 7 элементов.

Можно отметить, что каждый входной сигнал схемы может приходить не одновременно. Например, зная, что сигнал D5 придёт поздно, его можно подать на последовательную схему и он задержится только на 1 элемент. В этом случае последовательная структура может быть предпочтительней по быстродействию.

<a href="https://ibb.co/mzDXYHz"><img src="https://i.ibb.co/cTgCpNT/image.png" alt="image" border="0"></a>

Вход и выход могут быть прямой (только прямой или только  инверсный) или парафазный (поступает и прямой, и инверсный)

Прямой динамический вход: элемент работает по фронту из 0 в 1 синхросигнала (диагональ вверх в отечественном обозначении). В Xilinx показывается треугольник

Инверсный динамический вход: элемент срабатывает по фронту из 1 в 0. (спад). В отечественной версии треугольник может стоять снаружи.

Не логический вход: аналоговые сигналы

СЕ: разрешает работать синхросигнал, Е -- просто разрешение

CLR и PRE -- установки в 0 и в 1 асинхронно, R, S -- синхронно

UP у счётчика (плюс или минус)
LEFT -- разрешение сдвига влево/вправо
SLI, SRI -- вход последовательного приёма влево/вправо (shift left input/ shift right input)
TC -- terminal counter -- последнее состояние счётчика

входы для памяти:
WR (1 или 2 входа) -- запись

RAS или CAS -- строки адреса строки или столбца
A -- вход памяти
D -- вход данных

В отечественном обозначении элемент делится на три части: слева входы, в центре функция, которую выполняет элемент, справа выходы.

# Лекция 2. Основные логические элементы

## Дешифратор

<a href="https://ibb.co/D5PRx8L"><img src="https://i.ibb.co/pJ6LtRn/image.png" alt="image" border="0"></a>

Плюс унитарного (унарного) кода: всегда потребляется одна и та же энергия. Минус: он избыточен, 4 выходами можно задать только 4 разных кода.

УГО имеет на входе К адресных входов $A_i$ и $N$ выходов. Если $N = 2^k$, то дешифратор называется полным.

Пример неполного дешифратора: 4 входа и 10 выходов (например, для двоично-десятичной системы).

$E$ -- Enable: прямой вход разрешения. Дешифратору разрешается работать при $E = 1$. При $E = 0$ независимо от адресных входов на всех выходах будут нули.

Считаем, что нулевой разряд -- младший (А0), а n-ный -- старший (А1). В случае $A1 = 0$, $A0 = 0$, задаётся двоичный ноль и на выходе сигнал должен быть на нулевом выходе.

Аналогично для других комбинаций входов.

Для каждой единицы можно записать функцию от входов: $D0 = E*\overline {A1}*\overline {A0},\quad D1 = E*\overline{A1}* A0$ и так далее.

Для дешифратора будем придерживаться обозначения Xilinx: D2_4E (Decoder с 2 входами, 4 выходами и со входом Е).

Могут быть инверсные входы/выходы и инверсный вход разрешения. Вход Е может и вовсе отсутствовать.

### Логическая схема дешифратора

<a href="https://ibb.co/7NDDJ0g"><img src="https://i.ibb.co/1JNNf4s/image.png" alt="image" border="0"></a>

Мы не рисуем внешние входы и выходы, а ставим add label.

Если у элемента есть инверсный вход, он указывается через В и далее идёт их количество (AND3B2). Инверсные входы рисуются снизу

Данная схема -- линейная: количество элементов равно $2^k$, каждый из которых содержит $k + 1$ вход.
<a href="https://ibb.co/VB9mLyc"><img src="https://i.ibb.co/C082wd3/image.png" alt="image" border="0"></a>
#### Линейная структура

<a href="https://ibb.co/j4Nm28R"><img src="https://i.ibb.co/f0gf5Xv/image.png" alt="image" border="0"></a>
#### Пирамидальная структура
<a href="https://ibb.co/QYQdwjc"><img src="https://i.ibb.co/NWCSBn3/image.png" alt="image" border="0"></a>

#### Матричная структура
<a href="https://ibb.co/PgHK77Y"><img src="https://i.ibb.co/NKB5883/image.png" alt="image" border="0"></a>

На входа используется 2 маленьких дешифратора. С одного подаются горизонтальные линии, с другого -- вертикальные и выбираются элементы И, которые находятся на пересечении этих линий.

#### Каскадная структура


<a href="https://imgbb.com/"><img src="https://i.ibb.co/0QdJgMX/image.png" alt="image" border="0"></a>
Строим на готовых элементах

#### Каскадная структура с матричным выходом

<a href="https://imgbb.com/"><img src="https://i.ibb.co/NTjcZFv/image.png" alt="image" border="0"></a>

На один из входов Е подана VCC (константа 1), поэтому нижний дешифратор всегда выбирает какую-то единицу и подаёт сигнал на какую-то вертикаль, а верхний дешифратор может и не работать, если Е не подан.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/MGvNNM2/image.png" alt="image" border="0"></a>
Один из разрядов адреса заблокируем: возьмём один из адресных входов $A_i$ и заблокируем его по входу Е: если Е = 0, то на обоих выходах $E.NA_i$  (инверсный) и $E.A_I$ (прямой) будут нули ⇒ эта переменная блокируется. Правда, добавляется дополнительный уровень задержки в виде двух элементов И после инвертора. Таким образом, вместо N элементов, связанных со всеми переменными, можно блокировать только одну переменную (задавать оба нуля на прямом и на инверсном выходе).



Для структуры D4_16 нужно будет 16 элементов 5И (если нет входа Е, надо будет 4И) и 4 инвертора в линейной структуре  = 84 входа. (68 без Е).

Для пирамидальной структуры D4_16 нужно будет 4 + 8 + 16 = 28 2И + 4 инвертора = 60 входов.

Для матричной структуры: (4 * 4 + 4 + 4 = 24 элемента 2И) + 4 инвертора = 52 входа.

**Одно из назначений дешифратора**: разрешить работу одному из нескольких абонентов/блоков по входному коду. 

Если перепутать порядок подачи сигналов на дешифратор, он выдаст сигнал на другом выходе -_-


Мы получаем, что у нас есть два входа (4 возможных простых термы) и каждый выход зависит от одного термы. Таким образом, на дешифраторе можно реализовать вычитатель

<a href="https://ibb.co/rFtxYqy"><img src="https://i.ibb.co/GnJWyGP/image.png" alt="image" border="0"></a>

На дешифраторе реализуется $2^k$ простых термов и с помощью ИЛИ можно объединять необходимые нам термы. Таким образом на дешифраторе можно реализовать любую логическую функцию.

## Мультиплексор

<a href="https://ibb.co/mNz20rm"><img src="https://i.ibb.co/KKyfDcY/image.png" alt="image" border="0"></a>

Мультиплексор передаёт на выход один из входов. Двоичный код на адресных входах указывает номер информационного входа, который надо передать на выход мультиплексора.

При этом число адресных входов $k = ceil(\log_2 n)$

<a href="https://ibb.co/wsLywT8"><img src="https://i.ibb.co/pyP2RgN/image.png" alt="image" border="0"></a>

В Xilinx обозначается М2_1Е (2 -- число информационных входов D, 1 -- число выходов S (select), E -- наличие входа разрешения).

Здесь приведена не полная, а сокращённая таблица истинности (4 входа ⇒ дб 16 строк). А у нас только 5. Поэтому никакой минимизации здесь уже не надо проводить. Мы имеем два терма, на которых результат будет единицей

<a href="https://ibb.co/r3d58Jc"><img src="https://i.ibb.co/jzJ30FW/image.png" alt="image" border="0"></a>

### Увеличение разрядности мультиплексора
#### Пирамидальная структура
<a href="https://imgbb.com/"><img src="https://i.ibb.co/BTNmCjz/image.png" alt="image" border="0"></a>

Е можно было бы подать только на последний элемент.

#### С дешифратором на входе
<a href="https://ibb.co/Hr0cV2W"><img src="https://i.ibb.co/jLdCT5c/image.png" alt="image" border="0"></a>

<a href="https://ibb.co/kDyfLt1"><img src="https://i.ibb.co/z25Y3zJ/image.png" alt="image" border="0"></a>

У мультиплексора каждый информационный вход является термом. Поэтому на мультиплексоре можно реализовывать функции
<a href="https://ibb.co/z7zY9ZC"><img src="https://i.ibb.co/1dk5yTB/image.png" alt="image" border="0"></a>

Мажоритарный элемент: если на входе 2 или больше единиц, даёт единицу на выход.

Мы можем для реализации функции от $k$ переменных использовать мультиплексор от $2^k$ переменных. 

В данной таблице истинности мы видим, что у нас либо есть зависимость от младшей переменной, либо нет:

<a href="https://ibb.co/x8NhX8f"><img src="https://i.ibb.co/gFxymFP/image.png" alt="image" border="0"></a>

Если бы мы использовали первый подход, нужно было бы 2 мультиплексора для функций CO и S. 

У итогового мультиплексора две группы входов I1 и I2. I1 передают сигнал на CO, I2 -- на S в зависимости от сигналов А и В. Здесь А и В -- адресные входы первого и второго мультиплексора, но каждый из мультиплексоров имеет свой инверсный вход разрешения G1 или G2.

Здесь показан второй подход: реализовать на мультиплексоре с 2^k-1^ входами, попарно объединив входные наборы. 

Также можно заметить, что сверху таблицы И(Х1, Х0), на втором -- ИЛИ(Х1, Х0) и поставить эти оба элемента на информационные входы мультиплексору, а Х2 подать на адресный вход.

## Демультиплексор
<a href="https://ibb.co/9y4bP8Y"><img src="https://i.ibb.co/HGPtZFg/image.png" alt="image" border="0"></a>

Передаёт информационный вход на нужный выход в зависимости от адресного входа. По сути демультиплексор -- это то же самое, что и дешифратор, только информационный вход D играет роль входа разрешения Е.

Можно соединить мультиплексор и демультиплексор и получить шину передачи данных.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/SykTrmv/image.png" alt="image" border="0"></a>

Если мы фиксируем S и А. Тогда мы можем с одного из входов D (от одного абонента) передать сигнал к третьему абоненту на дешифраторе F3. Таким образом, мы можем последовательно передавать информацию.

Меняя информацию на входах S и последовательно меняя D, мы можем передать параллельный код последовательно одному абоненту. Изменение сигналов на S позволяет передавать сигналы с D0 -- D3 последовательно (сначала D0, потом D1 и так далее).

Если мы зафиксируем S и будем менять А сможем передавать входы D последовательно передавать на F и последовательный код преобразовать в параллельный.

Количество входов, подключаемых к одному выходу, зависит от токов и допустимых токов на входах подключаемых элементов.

Элемент buff повторяет значение со входа на выход. Также его можно использовать, если надо задать разные имена шине.
# Триггеры
<a href="https://ibb.co/TPZMc2B"><img src="https://i.ibb.co/mhm5JTC/image.png" alt="image" border="0"></a>

В лабнике два триггера - двухступенчатой и с динамической записью. Но вместо триггера с динамической записью выполняем два триггера (если что, в задачнике есть доп теория), берём два готовых триггера

Логика может быть и отрицательной: высокий уровень = 0, низкий = 1.

В xilinx предложен только однофазный выход, а не парафазный, потому что дальше этот выход поступает, как правило, на КС -- элементы И, ИЛИ, и т.д. реализуются на lut -- просто записывается таблица истинности, а там можно учесть и инверсные выходы. а их можно реализовать и на инверторах. Поэтому в реальных заказных схемах лучше использовать и прямой, и инверсный выход. Но в xilinx в КС может быть инверсный вход, потому что все КС реализуются на lut.

Ограничение (бистабильные схемы): на прямом и инверсном выходе не может быть одновременно двух нулей и единиц, кроме переходных процессов.

Последовательностная схема -- выходы определяются как сигналами на входе, так и предысторией -- триггер как раз соответствует этому определению.

Триггер может переходить из одного состояния в другое. Считаем, что есть два входа -- set (установка в 1) и reset (сброс, установка в 0).

В отличие от КС (может быть описана таблицей истинности или функцией), триггер описывается таблицей/матрицей переходов, графом переходов или характеристическими уравнениями.

<a href="https://ibb.co/pKpYgHd"><img src="https://i.ibb.co/5jVbdQL/image.png" alt="image" border="0"></a>

В основе любого триггера лежит запоминающая ячейка, а точнее запоминающий элемент. Элемент -- это триггер, а ячейка -- это то, что считывается из памяти за одно обращение, поэтому лучше называть то, что в триггере ЗЭ.

Вместо $\overline Q$ лучше писать NQ, обозначая инверсные входы.

СУ преобразует логические сигналы: (Е1, Е2, а может быть и только один Е), синхросигнал С (если он есть, то триггер синхронный) во входы установки в 0 или в 1 ЗЭ.

У ЗЭ есть два входа внутри установки в 1 и сброса в 0, причём они могут быть как прямыми, так и инверсными. Если вход инверсный, то он исполняется при переходе из 1 в 0.

В лабе про двухступенчатые триггеры мы будем использовать ЗЭ на элементах 2И-НЕ.

<a href="https://ibb.co/xXXcZG7"><img src="https://i.ibb.co/q77469r/image.png" alt="image" border="0"></a>

Всегда стоить иметь перед глазами таблицу истинности, таблицы и матрицы переходов в лабораторных работах.

Предположим, что на входы R и S поступают два нуля. У данной схемы два входа + раз есть обратные связи, то они тоже считаются за входы. Считаем, что триггер изначально в состоянии 0. Что произойдёт?

Можно показать, что при подаче нулей триггер остаётся в таком же состоянии.

Пусть триггер находится в 0 (NQ = 0, у нас бистабильный триггер) и подаём S=0, R=1. Тогда мы смотрим, что на выходе верхнего элемента будет 0 ⇒ он придёт на нижний элемент, а S = 0 ⇒ на NQ будет 1 ⇒ независимо от того, в каком состоянии находился триггер, при 01 он переходит в 0.

Таким образом, 1 на R сбрасывает триггер.

Так как схема симметрична, то 1 на S устанавливает ноль на NQ и соответственно 1 на Q.

Если мы подали две единицы на входы, то Q будет равно 0 и NQ тоже будет равно 0 ⇒ на выходах будет два нуля, и такого быть не может ⇒ данная комбинация запрещённая (Х).

Поэтому часто рисуют не полную таблицу переходов, а пользуются сокращённой таблицей переходов: 00 ⇒ Q(t), 01 ⇒ 0, 10 ⇒ 1, 11 ⇒ X.

Если нарисовать для данного триггера УГО (отечественная версия), в основном поле вверху указано Т (триггер), а в дополнительном поле слева указаны называния входов S и R, причём эти входы прямые: переходы в новые состояний осуществляются по единице. 

Триггеры охвачены обратной связью ⇒ может быть нарисовано два последовательных элемента, а с выхода второго элемента идёт провод ко входу первого и наоборот. В лабах мы не сможем нарисовать связи под углом, поэтому придётся иногда делать так.

На картинке обозначено УГО асинхронного триггера, потому что нет входа C.

<a href="https://ibb.co/88rKp17"><img src="https://i.ibb.co/RH3vmRD/image.png" alt="image" border="0"></a>

Если мы подали 00, то это запрещённая комбинация -- на обоих выходах будут единицы.

Если мы подали 01, то на выходе верхнего будет 1, она придёт вниз, внизу на выходе будет 0 ⇒ при $\overline S = 0$ мы всегда переходим в единицу вне зависимости от состояния триггера.

С $\overline R$ симметрично, $\overline R$ устанавливает триггер в 0.

При единицах на обоих входах состояние триггера не меняется.

Данную полную таблицу можно преобразовать в обычную таблицу переходов $\overline S \overline R$ триггера. Если входы инверсные, то переключение идёт по нулю на входе.

На рисунке приведено УГО асинхронного $\overline R\overline S$ триггера (можно говорить $\overline S\overline R$, всё равно)

<a href="https://ibb.co/k1PsShM"><img src="https://i.ibb.co/Vmkcqv3/image.png" alt="image" border="0"></a>

В зависимости от логики наиболее часто используемые 5 триггеров. 

1 вход -- D, T триггеры (всего 25 штук)
2 входа (625 штук), RS, DV, JK

По способу записи информации: синхронные и асинхронные
- у асинхронного триггера состояние зависит только от логических входов: подали новый сигнал и состояние изменилось сразу же, как в КС
- у синхронного изменение состояния происходит по синхросигналу, новая входная информация принимается и обрабатывается по сигналу синхронизации
	- с динамическим управлением: информация принимается по перепаду сигнала, то есть по его изменению
	- со статическим управлением: управляется уровнем: информация принимается, когда синхровход соответствует уровню логической единицы или нуля, если он инверсный, **в течение всей длительности сигнала С**.
		- одноступенчатые (Т)
		- двухступенчатые (ТТ)

В сборнике лаб об этом подробно написано порядка 30 страниц текста.

## RS-триггер

<a href="https://ibb.co/By84CnG"><img src="https://i.ibb.co/qNb0rJC/image.png" alt="image" border="0"></a>

Триггер состоит из элементарной ЗЭ на И-НЕ, поэтому у него входы $\overline S'$ и $\overline R'$ (то есть входы именно запоминающей ячейки обозначаются со штрихом). Раз они инверсные, то на ЗЯ стоит триггер $\overline R\overline S$, а на входе стоит КС -- схема входной логики, на которую приходят логические сигналы и синхросигнал.

Раз вход $S$ прямой, то по единице триггер переходит в 1, а при R = 1 триггер переходит в 0, как видно в таблице. Поэтому для триггера в целом будет данная таблица перехода, а для внутреннего триггера в ЗЯ работает другая таблица для $\overline R\overline S$.

Раз внутри у нас инверсные входы, то нам надо обеспечить ноль либо на $\overline S$, либо на $\overline R$ю Если мы подаём на вход СУ два нуля, то эти два нуля у входных элементов И-НЕ выдадут единицы на инверсные входы внутренней ЗЯ ⇒ триггер внутри сохранит своё значение.

Теперь подаём S = 1, но пока на С стоит 0, элемента И-НЕ по-прежнему сохраняют подачу единиц на входы ЗЯ. Когда С станет равным 1, И-НЕ выдаст 0 на $\overline S$ ⇒ уровень С переключил $\overline S$ на 0 и он, в свою очередь переключил Q в единицу.

Когда мы подаём единицу на R, при С = 1 он переключит $\overline R$  ⇒ $\overline Q$ ⇒ Q.

Следующий импульс отрабатывает аналогично второму.

Заметим, что в первую очередь в триггере переключается выход, который из 0 переходит в 1, а затем уже переключается обратный ему из 1 в 0.

На рисунке приведено УГО синхронного статического прямого RS триггера.

## D-триггер

<a href="https://ibb.co/fqPN4hW"><img src="https://i.ibb.co/GnbMcKD/image.png" alt="image" border="0"></a>
D-триггер (Delay) -- триггер задержки. Он вход D с задержкой передаёт на выход.

В основе любых триггеров лежит синхронный RS-триггер, в том числе и здесь. Мы подаём D и C.

Вход D мы специально дополнительно инвертируем, потому что подавать две единицы на триггер -- запрещённая комбинация. Поэтому при подаче 1 на D за счёт инвертора внизу будет 0 ⇒ мы из RS триггера введением этого инвертора получаем D триггер.

При C = 0 триггер просто будет хранить информацию.

По задержкам: в RS триггере по синхросигналу идёт переключение двух элементов напрямую. Добавляя инвертор впереди, получаем переключение уже трёх элементов напрямую ⇒ задержка больше.

Можно поставить не инвертор, а сделать дополнительную связь (нижний рисунок), поэтому при D = 1 мы получаем 0 на входе RS и 1 на нижнем входе ⇒ триггер может работать, но время срабатывания будет поменьше. 

Но данная схема при моделировании может не работать, хотя реально всё будет ок. Потому что при D = 0 у нас будет 1 на входе S и R и всё норм. Если D = 1 и приходит синхросигнал, до его прихода на выходе верхнего И-НЕ стояла единица и ноль внизу ⇒ по приходе синхросигнала мы получаем 0 с задержкой вверху и в какой-то момент времени у нас будут находиться два нуля на обоих входах RS ⇒ система моделирования может сломаться, потому что это запрещённая комбинация.

Чтобы это отловить, можно перейти к моделированию Unit, которое работает каждую пикосекунду и может найти подобные кратковременные явления генерации (возбуждения).

### DV-триггер
Вход V -- вход разрешения для триггера (работает как вход СЕ) и фактически у всех триггеров в Xilinx есть. При V = 0 он запрещает работу триггера (он просто хранит информацию), а при V = 1 он работает как D триггер, передавая D на выход.

В принципе, при C = 0 D триггер тоже хранит информацию, а при C = 1 работает, поэтому V можно подавать параллельно С.

Это всё одноступенчатые триггеры

###  T-триггер (toggle)

<a href="https://ibb.co/R7bM2Kr"><img src="https://i.ibb.co/fQFKMW6/image.png" alt="image" border="0"></a>

Тот же RS триггер с добавленными двумя связями. При T = 0 триггер хранит информацию, при T = 1 выводит её инверсию.

Минус: триггер работать не будет:

при 0 всё хорошо, триггер будет хранить информацию и на входах R и S будут единицы.

При подаче T и C на выходах И-НЕ впереди будут единицы ⇒ Q = 0 ⇒ верхний И-НЕ = 1 ⇒ $\overline Q$ = 0 ⇒ и так далее ⇒  будет генериться сигнал в течение всего времени, пока С = 1 ⇒ на выходах триггера будет дудос и когда C станет равным 0, нельзя будет понять, в каком состоянии триггер окажется.

Это одноступенчатый триггер (буква Т в УГО стоит одна). 

Все СУ для триггеров будут справедливы и для двухступенчатых триггеров.

### JK (Jump-keep) триггер
При J = 1 мы прыгаем (лучше переходим) в единицу. А при k = 1 переходим в 0 ⇒ J и K напоминают прямые входы S и R. Но отличие от RS-триггера в том, что в JK-триггере комбинация 11 не запрещённая, при этом он работает как Т-триггер.

В основе берём синхронный RS-триггер, где вместо входа S написан J, а вместо R написан K и остаётся только реализовать комбинацию 11 так же, как и в Т триггере с помощью обратной связи.

Чтобы элементарная триггерная ячейка (ЗЭ) внутри переключилась, надо передавать на её входы нули, то есть переключение идёт именно по нулю.

Представлено УГО синхронного статического одноступенчатого JK-триггера. Минус такой же: при двух единицах на выходе может быть генерация сигналов, поэтому одноступенчатый JK-триггер мб неработоспособен.


В основе одноступенчатых триггеров лежит элементарная триггерная ячейка на элементах И-НЕ или ИЛИ-НЕ, они отличаются друг от друга схемой управления на входе.

Т-триггеры или JK-триггеры можно представить графами с двумя вершинами -- 0 или 1 и переходами по сигналам

### Двухступенчатые триггеры
<a href="https://ibb.co/YbBn9Jy"><img src="https://i.ibb.co/Fn4Zvc0/image.png" alt="image" border="0"></a>

Это схема из двух частей - двух последовательно соединенных триггеров, каждый из них со статической записью. Если считать, что это 2 одинаковых триггера, то обязательно второй прямой синхронный триггер RS, а на первом -- асинхронный RS у которого может быть логика управления E1-E2. 

Одновременный приём информации в два триггера запрещается инвертором по С внизу: в первую ступень запись идёт по С = 1, во вторую ступень информация будет записываться при С = 0.

После завершения приёма информации в первой ступени она передаётся во вторую.

В УГО у двухступенчатых триггеров ставятся буквы ТТ.

Может быть обратная связь состояния выхода второй ступени на вход (пунктир). Раз передаётся вторая ступень, то при С = 1 она не может изменяться и поэтому тот недостаток, который был у D и JK триггера здесь исключен.

Этот триггер также называют MS: первую ступень называют master (работает по уровню 1), а вторую slave (работает по уровню 0).

Вместо Е1 Е2 могут быть входы D, V, J, K, CE и так далее.


<a href="https://ibb.co/DpmkbKp"><img src="https://i.ibb.co/TLJRThL/image.png" alt="image" border="0"></a>

Если не обращать на пунктир внимания, то там видно два одинаковых RS триггера. Первый работает при С = 1, второй при С = 0.

Вход S можно рассматривать как J, а R как К, тогда можно будет провести пунктиры и этот триггер будет работать как JK.

В лабнике это рисунки 3.8 и 3.9

Считаем, что в начальный момент времени триггер установлен в 0 и синхровход равен 0. Отметим, что при С = 0 оба триггера находятся в одинаковом состоянии.

На С приходит 1. При этом на D1 D2 ничего не меняется, потому что для переключения первой ступени нужно обеспечить один из нулей на D1 или D2, а таких импульсов нет, потому что S = R = 0.

На S приходит 1. В первой ступени формируется ноль на D1 ⇒ D3 =Q' переходит в 1 ⇒ по обратной связи NQ' переключается в 0.

Когда C перейдёт в 0, D1 переходит в 0 ⇒ первая ступень переходит в режим хранения. Надо изменить состояние второго: C ⇒ NC ⇒ D9 ⇒ D5 ⇒ Q = 1 ⇒ NQ = 0.

Задержка у триггера: когда переключается выход триггера после прихода синхросигнала? В таком триггере переключение происходит, когда C = 0. Значение первой ступени переходит во вторую.

Симметрично происходит при подаче R = 1, S = 0. Сначала для первой ступени вырабатывается 0 на D2, а затем переключается C ⇒  NC ⇒ D6 ⇒ D8 ⇒ D7.

Поэтому лучше в лабе делать инвертор, потому что с ним задержка при переходе от 0 в 1 будет на один элемент меньше, а из 1 в 0 больше из-за доп. элемента в обратной связи.

<a href="https://ibb.co/jVGX28y"><img src="https://i.ibb.co/WDFJwHk/image.png" alt="image" border="0"></a>

Смотрим на УГО: ТТ ⇒ двухступенчатый триггер ⇒ он статический (это видно ещё и по тому, что в С входе нет наклонной линии). По логике работы там нарисован JK-триггер (заведены обратные связи), но тут нарисованы немного другие связи, есть две новых D1-D5 и D2-D6. Он немного быстрее, в книжке можно почитать, как это работает, но он так же срабатывает по С = 0.

Заметим, что дополнительно введены два асинхронных входа для предварительной установки его в начальные состояния 0 или 1.

Как обеспечить переход в единицу выхода Q? Можно подать в предыдущем триггере дополнительный независимый сигнал на D7 для второй ступени и на D3 для первой ступени. Но раз асинхронный вход можно подать в любой момент времени, то возможно появление запрещённой комбинации: если мы подаём ноль на D7, а в это время был ещё и ноль с D6, то это запрещённая комбинация, поэтому этот асинхронный сигнал мы подаём сразу на несколько элементов, чтобы они были согласованы. Как раз это видно в двухступенчатом JK-триггере ($\overline S$ подан сразу на несколько элементов).

Вообще эти связи можно было бы не делать, только если этот сигнал можно было бы подавать НЕ в любой момент времени, а только по синхросигналу. Но если сигнал асинхронный, надо его связывать со всеми элементами, чтобы не было запрещённых комбинаций на входах.

Когда мы подаём $\overline S$ = 0, меняется D3, потом одновременно D4, D5 ⇒ D6 => Q ⇒ $\overline Q$. На диаграмме видно, что в какой-то момент времени на входах Q и NQ могут быть две единицы -- когда один выход уже переключился с нуля в единицу, а второй ещё не успел переключиться с единицы на ноль.

В лабах будет предложено использовать ступень из RS триггера (схема 3.10 в лабнике). В 3.10 и 3.11 описано, как работают асинхронные входы. Если начать моделировать раньше то при построении диаграмм вручную мы считаем, что изначально оба триггера находятся в нуле.

А во время лабы надо будет проверять: сначала подать короткий $\overline S$, по которому можно будет видеть, что триггер переключился в 1, а уже за ним передаём $\overline R$, чтобы увидеть, что триггер переключился в 0 -- видно, что обе ступени сначала переключились в единицу, а потом в 0, а потом уже после всего этого подавать C.

Такая же схема приведена в рисунках 3.22 и 3.24, где
есть входы $\overline S$ и $\overline R$ и вместо нижнего инвертора по С инверсный вход NС

### Динамические параметры
У КС динамический параметр только один -- это задержка, у триггеров их 4

<a href="https://ibb.co/K05J9Kc"><img src="https://i.ibb.co/3rTn0R5/image.png" alt="image" border="0"></a>

Задержка мб как по изменению синхровхода, так и по асинхронным входам установки.

Время предварительной установки: насколько раньше надо подать логический и управляющий сигналы: минимальный интервал до активного синхросигнала. Активным изменением мб либо уровень, либо фронт. То есть как рано передать J или K. 

Все эти параметры так же описаны в лабнике, но приведены для разных схем.

Длительность: насколько коротким дб импульс: потому что если он будет коротким, мы можем не успеть переключить все ступени.

<a href="https://ibb.co/m8zY6qW"><img src="https://i.ibb.co/GTP1c2S/image.png" alt="image" border="0"></a>

Здесь показано, как идёт срабатывание.

Входы E1, E2, CE (V), L (load)-- здесь могут быть какие-то другие входы, например, та же самая картинка справедлива и для регистров. С одной стороны, CE можно считать логическим, а с другой -- как вход управления clock enable.

Все параметры считаются относительно активного фронта.

tuC -- длительности импульса С или асинхронного входа. Показывает, насколько он должен быть коротким, длительность импульса должна быть больше или равна этой паспортной величины.

Tуст -- насколько раньше нужно подать логические сигналы относительно фронта. Если бы это был уровень, то мы подаём не относительно начала уровня, а относительно снятия сигнала С, то есть момента, когда заканчивается импульс С.

Удержание -- так же, если относительно уровня, то до момента снятия.

Тпер -- время, через которое переключается уровень.

Если tuC >=, паспортному, то и остальные характеристики >= паспортным величинам, кроме задержки переключения, она <. Все эти параметры рассмотрены в третьей лабе, но отдельно друг от друга.

Так же мы будем эти параметры измерять в 5 лабе про регистры, там про эти параметры тоже можно почитать. На третьей лабе будем считать только время переключения, то есть задержку переключения выхода.

<a href="https://ibb.co/3m5btt4"><img src="https://i.ibb.co/WvNXSSG/image.png" alt="image" border="0"></a>

В Xilinx почти у всех триггеров входы прямые, в том числе и инверсные

<a href="https://ibb.co/Yc3JchB"><img src="https://i.ibb.co/McsKc7k/image.png" alt="image" border="0"></a>

В триггерах с динамическом записью видно отличие в черте у С. В Xilinx у С в динамических триггерах стоит треугольник внутри, а при инверсном на входе ещё и кружок инверсии.

<a href="https://ibb.co/cwGcDYs"><img src="https://i.ibb.co/3vDyBRP/image.png" alt="image" border="0"></a>

У триггеров стоит буква F (Flip-Flop). Следующая буква обозначает логику работы (какие логические входы у него есть). Затем -- обозначение установочного входа.

Preset и Clear -- асинхронные входы в Xilinx, а S и R -- это синхронные. До этого мы таких различий не делали.

Е может присутствовать, а может и нет -- это означает, что есть вход разрешения работы СЕ.

1 после обозначения означает, что у входа С есть инверсия, то есть триггер будет срабатывать по спаду, если он динамический.

Есть группы входоы:
- логика работы (J, K, D)
- CE -- можно считать за вход управления, хотя тоже мб логикой
- С -- исполнительный вход, по нему исполняется работа. CLR -- тоже исполнительный вход, потому что по нему тоже исполняется работа. Заметим, что в таком случае синхронные входы S и R -- не исполнительные, потому что работа происходит не по их изменению.

Асинхронный вход имеет наивысший приоритет: например, CLR независимо остальных входов заставит перейти в 0. Все микрооперации триггер выполняет только при CLR = 0.

Если CE = 0, то независимо от остальные входов кроме CLR триггер просто хранит информацию, в противном случае он работает как D триггер. CE сигнал следующего приоритета.

<a href="https://ibb.co/G3hYL9n"><img src="https://i.ibb.co/Kz14kDb/image.png" alt="image" border="0"></a>

Это сложный триггер, выполняет сразу две таблицы: работает и как Т триггер, но ещё имеет вход L -- load (это и написано в его обозначении), который разрешает работать Т входу -- аналог входа V в DV триггере.

При CLR = 0 (наивысший приоритет) устанавливается 0.

Следующий приоритет --  L: при L = 1 независимо от СЕ и Т значение D передаётся на выход: он разрешает работать D, L будет означать "загрузить D на выход".

Следующий -- СЕ. При СЕ = 0 триггер будет хранить информацию независимо от других входов, а при СЕ = 1 как D-триггер.

Любой триггер в Xilinx реализуется на D триггере, если посмотреть их внутреннюю структуру. А если нажать на этот D триггер, то внутри он раскрывается до D триггера без входа СЕ.

Этот триггер должен при L = 1 разрешить работу. При L = 1 мультиплексор разрешает пройти D входу внутрь триггера.

При L = 0 надо разрешить работу триггера -- нужно пропустить СЕ. При СЕ = 1 и L = 0 работает нулевой вход мультиплексора -- от выхода триггера подаётся сигнал на XOR TQ -- управляемый инвертор, который инвертирует Q при T = 1, что и происходит. При T = 0 триггер просто хранит сигнал, потому что инверсии не происходит.

Так параллельно работают Т и D триггер.

Так как L и CE должны разрешить работать синхровходу, стоит элемент ИЛИ. Если L и CE равны 1, будет всё равно работать L, потому что L имеет высший, чем СЕ, приоритет.

Раз на триггере D можно реализовать любой другой, можно реализовать любую таблицу переходов на D триггере, на вход которого можно поставить мультиплексор, а на входе мультиплексора задать требуемые переходы, управлять которым можно с помощью адресных входов.

<a href="https://ibb.co/gMmq0Dh"><img src="https://i.ibb.co/1f7yC9j/image.png" alt="image" border="0"></a>

Это описано ещё и в задачнике.

<a href="https://ibb.co/DL0RhQs"><img src="https://i.ibb.co/kMNSjXk/image.png" alt="image" border="0"></a>

Эта матрица переходов нигде не приведена, а описана словами в сборнике задач и лабнике в 4 лабе для DV триггера

Посмотрим на RS триггер со знакомой нам табличкой. Предположим, нам надо подать такое воздействие, чтобы триггер, находясь в 0, остался в 0. Какие комбинации нам можно подать?

В случае 10 триггер будет поставлен в 0, это нам подходит. А ещё нам подходит и комбинация 11, раз триггер уже до этого был в 0. Поэтому чтобы триггер остался в нуле, подходят две комбинации -- 10 или 11  ⇒ нам важно на NS подать единичку, а NR может быть любым. В матрице переходов X -- это не запрещённая комбинация, а любое значение, и при минимизации это означает, что мы можем выиграть и сократить схему.

Далее для переходов 0 -> 1 и 1 -> 0 подходят только по одной комбинации.

Для перехода 1 -> 1 ситуация симметрична переходу 0 -> 0. В принципе, можно приводить не всю матрицу переходов, а только её результат с Х.

Посмотрим, как сформировать матрицы переходов триггера по таблице переходов. Это есть в задачнике и в 4 лабе в лабнике.

Рассмотрим JK триггер.

0-0: подходят комбинации 00 и 01 ⇒ на J мы подаём 0, на К -- любой сигнал.
0-1: подходят 01 и 11 ==> комбинация Х1
1-0: 01 и 11 ⇒ X1
1-1: 10 и 00 ⇒ X0.

<a href="https://ibb.co/029zW4s"><img src="https://i.ibb.co/qjg24qJ/image.png" alt="image" border="0"></a>

Это будет сложно для DV

0-0: 00, 01, 10 подходят, но минимизация тут не очень поможет, поэтому можно задать эти три комбинации по другому: A, $\overline AB$, где А и B независимы друг от друга

Два других перехода простые с одной строчкой.

Переход 1-1: подходят 00 01 и 11 и тут можно их представить без инверсии: A2, A2*B2.

В третьей лабе предлагается применить этот подход: на с 63 начинается проектирование триггере по таблице перехода

<a href="https://ibb.co/KqyZwT1"><img src="https://i.ibb.co/vPz5Y0t/image.png" alt="image" border="0"></a>

Мы берём уже готовые триггеры, не реализуя начинку

<a href="https://ibb.co/kmvd0ZC"><img src="https://i.ibb.co/8Yth2kZ/image.png" alt="image" border="0"></a>

Для триггера от трёх переменных надо обеспечить переход в нужное состояние в соответствие с вариантом (столбец Q(t+1)), далее записываем переходы из JK и DV триггеров.

В таблице истинности мы пишем индексы, соответствующие номерам набора. По такой таблице проводить минимизацию

<a href="https://imgbb.com/"><img src="https://i.ibb.co/p16JTMk/image.png" alt="image" border="0"></a>

мы задаём сигналы Аi и Bi произвольно, но так, чтобы было проще минимизировать.

Дальше можно (но необязательно) перейти в базис и-не.

ДЗ

с 133 №3. Там опечатка: мультиплексор М4_1, а не 16.
с 138 №2

когда иначнём готовиться, на с 78 в лабнике приведена подобная таблица переходов, только в ней написано Q, 1, 0, NQ -- там надо поменять местами 1 и 0: во второй строке должен стоять 0, а в третьей 1

в табличку на с 79 в лабнике предлагается ввести два столбца Q(t+1) и переход


е1 е2 будут меняться как у счетчика на с 92 но это другая история

<a href="https://ibb.co/kqm1bw4"><img src="https://i.ibb.co/7rk4MZn/image.png" alt="image" border="0"></a>

<a href="https://ibb.co/wKSHdNP"><img src="https://i.ibb.co/xM1v2SB/image.png" alt="image" border="0"></a>


в лабе 4 делаем не всё задание как в лабнике, а также будем реализовывать делитель частоты, лучше смотреть в задачнике

<a href="https://ibb.co/9TRm6MZ"><img src="https://i.ibb.co/zRKWpk6/image.png" alt="image" border="0"></a>

Часто забывают что такое период или модуль счёта. Это число разрешенных устойчивых различимых состояний счетчика. 

вход, по которому считают входные сигналы, называется счётным. В лабе это будет C, с точки зрения счетчика -- это счётный вход, хотя это синхровход.

в лабе сигналы берём от генератора, он работает периодически. А на стенде передаём вручную, там импульсы приходят не периодически

<a href="https://ibb.co/jHBBbnR"><img src="https://i.ibb.co/V3rrJfm/image.png" alt="image" border="0"></a>

классификация
по способу кодирования

- позиционный счетчик -- каждая позиция или разряд счётчика имеет определённый вес. Например, в двоичном счётчике слева направо веса идут 8 4 2 1, но в общем случае и что будет в лабе веса не обязательно степень двойки. Могут быть веса 4 2 2 1, 1 3 5 1 -- каждая позиция по определению имеет свой вес, но **любой**.
- непозиционный: вес зависит не от позиции, а от чего-то другого. Например, в римской СС зависимость не только от позиции, но и от значения соседнего разряда.

по модулю счёта
- двоичные (веса 8 4 2 1), могут быть 16ричными, 4 2 1 -- мб восьмеричными или **с естественными весами разрядов**.
- двоично-десятичные (декада): наборы как правило от 0 до 9, где веса разрядов так же 8 4 2 1. в лабах мб десятичный счётчик (декада), модуль равен 10
- произвольный модуль счёта -- мб постоянным или переменным (программируемым), например, в зависимости от какого-то условия, например, входа Y, модуль счётчика может меняться
- прочие счётчики -- код Грея -- когда каждое следующее состояние от предыдущего отличается только в одном разряде: в обычном случае при переходе, например, 01 -> 10 могут быть состязания: нужно, чтобы младший разряд переключился в 1, а старший в ноль. Если сначала переключится младший, то будет переход 01 -> 00 -> 10; в противоположном случае 01 -> 11 -> 10. В коде Грея последовательность другая: 00, 01, 11, 10, 110 и т.д.
- кольцевой счетчик: выход последнего разряда соединяем со входом первого
- счётчик Джонсона (Мёбиуса): последний разряд переходит в первый но в инверсном виде
- Код 1 из N (единичного кодирования, пример: выход дешифратора или унитарный/унарный код). Например, код 1 из 4, плюс которого -- одинаковое потребление энергии на каждом разряде и относительно легко проверять на сбои: не мб двух единиц и не мб всех нулей.


по направлению счёта
- суммирующие: переход в одну сторону 
- вычитающие: переход в другую сторону
- реверсивные: в обе стороны
<a href="https://ibb.co/F3T6fvM"><img src="https://i.ibb.co/h9zsn5j/image.png" alt="image" border="0"></a>

по способу переключения триггера: раз это последовательностная схема, то она строится на основе триггеров
- синхронная: все синхровходы соединены друг с другом
- асинхронная

способу организации межразрядных связей
- как организуется перенос между разрядами, он же перенос между группами разрядов


<a href="https://ibb.co/94rWx7h"><img src="https://i.ibb.co/PW6g2dM/image.png" alt="image" border="0"></a>

Это позиционный счётчик, поэтому веса разрядов заранее известны: 8 4 2 1. 

На последнем состоянии формируется сигнал переполнения (carry output, P), который зависит от входного разрешения счёта CE и может формироваться сигнал CEO -- сигнал в Xilinx clock enable output и ещё TC (terminal counter). CEO зависит от TC и CE: CEO = TC * CE (написано в задачнике).

У счётчика должен быть сигнал начальной установки. Но начальная установка может идти в случае двоичного счётчика в нулевое состояние, но можно в какое-то другое (например, в лабах: счётчик может кроме счёта хранить значение и дальше чем-то управлять и в начале загружаем в счётчик 5 и затем переходим в 8: не для двоичного счётчика состояния -- это номера состояний, а не номера двоичных наборов на выходе. В лабах эти наборы могут идти в произвольном порядке, но в двоичном счётчике они всегда идут подряд)



<a href="https://ibb.co/dDG1BpL"><img src="https://i.ibb.co/vkZg1dQ/image.png" alt="image" border="0"></a>
инкремент и декремент можно рассматривать как переход на любое следующее состояние, не обязательно на какую-то константу

когда код не выдаётся, выход в третьем состоянии или открытый коллектор, а плюсы в том, что эти выходы можно объединять монтажным или **открытым коллектором**.

У счётчика мб логический выход (всегда есть), мб выход в третьем состоянии (Z), он импедансный (высокое сопротивление на выходах) или с открытым коллектором (ОК)

в лабе надо будет считать быстродействие -- с какой максимальной частотой могут поступать импульсы. в лабе будет 4 секции как показано в лабнике: счетчик, два делителя и vhdl и для них надо определить частоту и период, с которыми импульсы могут поступать. Надо найти минимальный период <= паспортной

время установки кодов на выходах счётчика -- задержки на каждом выходе <= паспортному

время формирования переноса или заёма (когда счётчик вычитает и при первом/начальном состоянии он формируется) <= паспортному

длительность счётного импульса -- берётся из характеристик для триггера, чтобы он успел переключиться. Она должна быть больше или равна паспортному значению в триггере

S1 -- это номера **состояний**, а не наборов!

для установки в начальное состояние можно использовать R как в триггере или S синхронно в единицу. Когда доходим до последнего состояния в суммировании, формируем сигнал переноса. Если установились в начальное состояние и надо из него вычитать, сразу как только пришли в начальное состояние формируется сигнал BO (заём)

важно, что разряды счётчиков могут строить на двухступенчатых триггерах (статических, управляемых уровнем), то есть нельзя использовать статические одноступенчатые и асинхронные триггера, а также бывают на триггерах с динамической записью

как правило триггеры работают в счётном режиме⇒ каждый триггера работает как счетчик по модулю 2 и как правило каждый триггер работает как Т триггер

например если бы мы хотели на Jk триггере то можно сделать объелинение входов j и k и получить Т триггер

<a href="https://ibb.co/gjHyYH7"><img src="https://i.ibb.co/FxN6pNW/image.png" alt="image" border="0"></a>

этот счётчик асинхронный, так как синхровходы не соединены между собой (С слева это счётный вход) Счётный вход поступает только на один триггер. Диаграмму можно строить независимо для каждого из триггеров, потому что нет обратных связей.

Всегда сначала надо подавать CLR.

На входе C стоит треугольник без инверсии ⇒ элементы срабатывают по фронту

Если объединить в шину отдельно выходы триггера, то видим, что счётчик считает 7 6 5 4 ...  ⇒ он работает в вычитающем режиме.

Видно, что в переходе 0 - 7 есть неустойчивое состояние за счёт не одновременного переключения разрядов.

Как видно по изменению разрядов, это действительно двоичный счётчик (подряд), при этом сигнал выхода Q2 будет являться заёмом для следующего.


чему будет равно время установки кода -- когда будет установлен код на всех триггерах. tкода = n * tтриггера. При этом tтриггера -- максимальное время из t01 и t10, n -- количество триггеров.

Время установки кода заёма так же равно n * tтриггера

<a href="https://ibb.co/SxXKnyt"><img src="https://i.ibb.co/BPVgZ3y/image.png" alt="image" border="0"></a>

это пример jk триггеров (как раз тут j и k входы объединены) ⇒ получается они работают как Т триггеры.

на с вход подаются инверторы -- то есть мы как бы берём сигналы с инверсных выходов триггеров, а на этот инвертор может потребоваться целый lut. В unit на нём так же будет задержка, хотя в реале на плис транслятор может увидеть, что инвертор стоит прямо перед входов tj1 и сделать вместо этого tj1 инверсный вход и задержки не будет

если стоят инверторы, то лучше для своего контроля построить, как работают инверторы на временной диаграмме. За счёт инвертора первый триггер работает не по фронту, а по спаду. А нулевой работает по фронту. Аналогично по спаду идёт срабатывание второго триггера

можно было бы показать инверторы на временной диаграмме (видно, что задержка на триггерах два пикселя)

это асинхронный суммирующий счётчик с теми же задержками (не считая инвертора); а если учитывать инверторы, то время установки будет равно nTтриггера + (n-1)Tинвертора

прямой -- вычитающий, инверсный -- суммирующий

чтобы сделать реверсивный счётчик на вход каждого элемента можно поставить мультиплексор 

этот счётчик -- у него межразрядные связи с последовательным или на непосредственной связи: они последовательно напрямую соединены когда выход одного триггера непосредственно соединен со входом другого

нужно как можно быстрее перейти требуемое состояние и постараться уменьшить задержки

<a href="https://ibb.co/fQvTY12"><img src="https://i.ibb.co/4Jd0Zm7/image.png" alt="image" border="0"></a>

вводим элементы и и счётный вход поступает на следующий элемент и и на него же поступает выход первого, аналогично дальше

синхросигнал со сквозным переносом проходит через весь счетчик

используя так же предыдущий Т триггер поставили инвертор и получили суммирующий счетчик (можно просто показать что у триггеров другой фронт работы по спау и нарисовать просто кружок на входе С с треугольником)

это счётчик со **сквозным** переносом, поэтому время установки кода равно (n-1)Tand + Tтриггера (или ещё + Тинвертора если учитывать инвертор)

второй параметр -- время установки переноса будет равно n * Тand 

данная схема быстрее по сравнению с предыдущей

<a href="https://ibb.co/7vdzWnm"><img src="https://i.ibb.co/zsT5RXv/image.png" alt="image" border="0"></a>

каждый последующий элемент И объединяет значения предыдущих разрядов и на каждый из них приходит счётный вход ⇒ данная схема называется с параллельным переносом

время установки кода в этой схеме будет ещё меньше: Тand + Ттриггера -- синхросигнал приходит одновременно на все триггера, поэтому оно не зависит от числа элементов

но при этом размер схемы растёт

время установки переноса равно Tand

Это асинхронный суммирующий с параллельным переносом, самый быстрый счётчик

можно объединять в группы счетчиков: внутри группы можно организовать параллельный перенос а между группами может быть сквозной / последовательный перенос, а можно тоже организовать параллельный перенос

<a href="https://ibb.co/NKjzxdj"><img src="https://i.ibb.co/njcSrNc/image.png" alt="image" border="0"></a>

синхронный счетчик с произвольным кодированием

попробуем посмотреть как работает данный счетчик. что нужно чтобы построить вд

нужно знать работу каждого элемента у нас есть JK триггер, инвертор и элемент И который можно дополнительно встроить потом как кобминационную схему

остальные элементы надо строить последовательно потому что еасть обратная связь

jk триггер: 00 хранит, 10 - 1, 01 - 0, 11 меняет значение на противоположное. Это счётчик не просто с произвольным кодированием, а главное что синхронный, потому что у него объединены синхровходы

значит любое изменение С одновременно приходит на каждый триггер а значит можно независимо рассмратривать каждый триггер при том состоянии кторое было до этого события

но прежде всего надо посмотреть установку в начальное состояние 
когда приходит clr (установка в начальное состояния) устанавливает в 1 нулевой и первый триггер а второй в 0 ⇒   по clr счётчик устанавливается в 0 1 1 = 3


теперь приходит синхросигнал, нехависимо рассматриваем каждый триггер

нулевой триггер: j вход соединен с Q2 = 0 ⇒ на j = 0; k = Q1 = 1 ⇒ 10 ⇒ триггер переходит в 0

первый триггер: он работает как d триггер (у него один вход прямой, другой инверсный) ⇒ этот триггер с инвертором на входе можно рассматривать как d триггер, j = 1 до прихода C ⇒ k = 0 ⇒ 10 триггер остаётся в единице

второй триггер 0 остаётся без изменений

можно представить граф переходов, он произвольный

модуль счётчика равен 8: видно 8 разных состояний
начальное состояние 3, последнее 5 -- на нём вырабатывается перенос CR (carry)

в заключительном тесте будет стоять что-то подобное, надо ответить, какие наборы проходит счётчик. Можно строить диаграмму, а можно таблицу состояний

исходное состояние 3. куда переходим можно писать рядом, а можно принципиально считать что следующее состояние будет на следующей строчке (можно строить только один столбик)

мы находимся в состоянии 3, на триггере 01 ⇒ он перешёл в 0; на первом триггере 10 ⇒ 1 и так далее

триггера мы рассматриваем в любом порядке независимо

так мы вычисляем совокупность состояний на каждом наборе


чему равно время установки кода в данной схеме: в данном случае только Ттриггера, так как синхровход приходит одновременно на все и каждый триггер переключается одновременно в соответствии с таблицей перехода.

важно бывает посчитать быстродействие -- через какое время мы можем подать следующий синхросигнал или период Тсинхроимпульса. надо проанализировать все переходные процессы. Код устанавливается за Ттриггера. Что ещё может переключаться -- инверторы за триггерами, а в общем случае там мб не инверторы, а какие-то схемы ⇒ надо будет учитывать ещё время переключения данных КС на информационных входах триггеров; потом после переключения КС + время предварительной установки вхдов триггеров.

Т = Ттриггера + ТКС + Тпред. уст. триггера

только после этого можно подать следующий фронт, а частота = 1/Т

в лабе надо будет определить частоту счётчика или делителя при параллельном режиме.

для построения временных диаграмм можно строить таблицу состояний, это позволит ускорить анализ схемы: рассматриваем текущее состояние и для каждого из триггеров рассматриваем таблицу и определяем, какое состояние будет следующим.

в 4 лабе в задании мы должны реализовать делитель частоты либо на двоичном

<img src="https://i.ibb.co/fCTwyJ9/image.png" alt="image" border="0">

Порядок срабатывания или приоритет соответсвует порядку указывания букв в обозначении: C > L > E > D.

Из обозначения букв можно построить УГО в системе Xilinx. 
- C -- это просто счётчик, но учитывая, что они все синхронные в Xilinx, то мы можем уже построить синхровход. Если бы вход был инверсный, в конце обозначения было бы _1, и тогда
- B -- двоичный счётчик
- 2 -- в обозначении уже можем отметить два выхода
- C -- можем построить CLR
- E -- вход CE
- L -- вход Load

<img src="https://i.ibb.co/MRZYZ1n/image.png" alt="image" border="0">

Количество входов D равно количеству выходов: в счётчик можно сразу загрузить некоторое состояние по сигналу L.

Высшим приоритетом обладает вход CLR, затем L (работает по фронту, синхронный сигнал), затем CE.

Можно отметить, что в Xilinx есть счётчики суммирующие или реверсивные, чисто вычитающих счётчиков нет.

В состав счётчика включается 2 триггера. CLR объединён у двух триггеров. Для загрузки работают входы D0 D1, которые подаются на триггеры. L загружает на оба триггера.

Счётчик должен считать: младший разряд всегда в счётном режиме, поэтому на Т подаём VCC. 

единичка сверху поступает на нижний триггер, чтобы разрешить счёт в старшем разряде

У триггеров есть вход CE, но в таблице отмечено, что и при L, и CE должны работать по фронту 01 ⇒ включается дополнительный элемент ИЛИ, который объединяет CE и L, выход которого подключается к CE триггеров.

У всех счётчиков всегда принято, что на последнем состоянии надо собирать выход TC. Раз счётчик суммирующий, то последнее состояние -- 3 (11), поэтому на выходе стоит 2И для выработки этого сигнала.

Выход CEO формируется как TC * CE. 

<img src="https://i.ibb.co/p3D0SFY/image.png" alt="image" border="0"><

Появилось обозначение D (direction) ⇒ появился новый вход UP.

У синхронных счетчиков в Xilinx можно воспринимать как вход разрешения счёта.

Вход UP имеет низший приоритет, поэтому в таблице он показан справа.

У элементов хранения (регистры, счётчики) можно выделить три группы сигналов
- задающие микрооперацию (up, l , ce)
- исполняющие микрооперацию (c, clr)
- информационные входы (do, d1)

тут как в предыдущем случае + дополнился мультиплексор: при UP = 1 единица с верхнего триггера приходит на нижний и разрешает ему считать, а при UP = 0 при 0 на Q инверсное значение передаётся вниз (переход 0 -> 3).

ТС формируется в этом случае, когда придут два нуля при UP = 0 или две единицы при UP = 1.

Последнее состояние умножается на СЕ и получается СЕО.

**ДЗ с 163 №1**

 <a href="https://ibb.co/W2ydgkK"><img src="https://i.ibb.co/d523GPK/image.png" alt="image" border="0"></a>

на примере 3 двухразрядных счётчиков строится шестиразрядный счётчик CB6CE

младший счётчик считает быстрее всего (Q0), но в лабе лучше показывать все что относится к одной секции показывать принадлежащими к нему, здесь они показаны ниже (TC0, CEO0). На 3 состоянии эти сигналы равны 1, но они заведены на вход следующего счётчика. Как только этими сигналами ему разрешается счёт, срабатывает один счёт среднего счётчика. Дальше стоят нули и состояние среднего счётчика сохраняется. Когда средний счётчик достигнет 3, сформируются сигналы ТС1 и СЕ01 (однако на выходе СЕО1 сигнал будет сформирован только после 15 импульса, потому что только в этот момент на средний счётчик придёт СЕО0). Этот сигнал разрешает работать старшему счётчику, и он переключается только после 15 импульса.

Таким образом, на выходе последнего счётчика ТС2 стоит уже 16 наборов, и только на последнем 63 импульсе будет сформирован сигнал СЕО2.

Все выходы ТС можно было бы собрать в одном месте и получить точно такой же сигнал СЕО2, отличие было бы в том, что таким образом собранный ТС был бы быстрее, так как СЕО проходит через все элементы последовательно, и там задерживается.

на выходах как ТС, так и СЕО, мб состязания потому что сначала может переключиться первый триггер, а только потом переключится второй, и эти состязания за счёт разных связей

<a href="https://ibb.co/pjVw2ZQ"><img src="https://i.ibb.co/Wv85nF0/image.png" alt="image" border="0"></a><br />

в первую очередь это можно сделать за счёт реализации межразрядных связей (тут не указано), а указано про управление модулем за счёт использования входов управления на готовых счётчиках

можно загрузкой загрузить в счётчик значение К по load, дойти до конца (М-1 можно считать последним набором с одними 1111111) и тогда выходов ТС можно обнулить

<img src="https://i.ibb.co/9gRc8Zs/image.png" alt="image" border="0">

это двоично-десятичный счётчик (CD)

по синхронному входу R устанавливается счётчик в 0, далее он начинает считать до 3 и на данном элементе И (сверху справа) выбрано третье состояние, и формируется значение L ⇒ по следующему синхросигналу L имеет высший приоритет и поэтому значение, которое стоит на входах D (7: 0111) загружается в счётчик и по следующему синхроимпульсу счётчик переходит в состояние 7, а L стал равен 0. Далее счётчик опять переходит в режим счёта, считает до 9 и на 9 формируется сигнал TC (9, потому что это двоично-**десятичный** счётчик).

В данном случае связь TC-OR2 можно было бы не заводить, потому что после состояния 9 у счётчика и так идёт состояние 0, поэтому можно было бы просто подавать R, но так, чтобы он включал в себя синхросигнал (потому что R синхронный).

Так образом реализован счётчик 0 1 2 3 7 8 9. **В тестах когда указываем последовательность состояний надо начинать с наименьшего набора и не повторять его в конце**.

Могли бы быть любые другие наборы, например, можно было бы пропустить другие наборы. для этого можно поставить на выходе счётчика какую-нибудь минимизированную КС и тогда уже обязательно понадобился бы элемент OR2 на входе R.

R -- это вход управления, а не исполнитель. Исполнитель это CLR.

Если была бы заведена связь TC - OR2 и вход CLR, то модуль счётчика будет равен 6 (на 9 будет неустойчивое состояние и TC придёт сразу на CLR и счётчик асинхронно сбросится в 0), а могло бы быть и ещё меньше, если бы мы переходили из 7 состояния в 8 через 9. Поэтому в этот момент времени принципиально возможна иголка.

В unit это может не получиться, потому что по паспортным всё может быть ок и состязаний не будет, а в реале всё сложнее.

<a href="https://ibb.co/12hwM50"><img src="https://i.ibb.co/Lpb2rW0/image.png" alt="image" border="0"></a>

<a href="https://ibb.co/7tzg5Kz"><img src="https://i.ibb.co/jk5V2D5/image.png" alt="image" border="0"></a>


В Xilinx в option -> preference можно задавать частоту. за счёт задания b0 b1 b2 частота будет делиться каждый раз в два раза.

счётчик повторяет что-то, поэтому у него есть частота. Как правило частоту делят на значение модуля М счётчика. Если частот счётчика повторяется, то он мб делителем.

скважность у синхросигнала на ФД это меандр (скважность = 2), и на ФД каждый следующий выход счётчика делит частоту вдвое.

<img src="https://i.ibb.co/5ncF9rM/image.png" alt="image" border="0">

данный счётчик работает по спаду (на входах кружочки)

QA -- триггер, он делит частоту на 2
QB-QD -- счётчик по модулю 5, считает от 0 до 4.

здесь мы сделали не синхронный счётчик, с выхода триггера QA подаётся сигнал на вход счётчика CKB.

по спаду сигнала QA счётчик переключается, CKB для него это счётный вход

таким образом если суммарно все выходы рассмотреть как один счётчик, то он считает наборы 0 1 2 3 4 5 6 7 8 9 и работает как обычный двоичный счётчик

второй вариант: на CKB зададим счётный вход с внешних импульсов, а старший выход счётчика подадим на вход триггера. Счётчик будет считать от 0 до 4 и после перехода из последнего состояния (по спаду сигнала QD) на выходе триггера появится 1. В следующий раз триггер обнулится.

Таким образом, мы проходим наборы 0 2 4 6 8 1 3 5 7 и т.д.

на верхнем делителе: исходная частота tau, а у QA частота 0.5 tau, S (скважность) равна 2, QB не равномерный ⇒ скважность посчитать нельзя
QC: 6 нулей, 4 единицы ⇒ S = 10/4 = 2.5
QD: 8 нулей и 2 единицы ⇒ S = 10 / 2 = 5


при втором подключении
QA: 5 нулей, 5 единиц S = 10 / 5 = 2
QB: 01 01 00 10 10⇒ он неравномерно периодический, можно считать модуль 10 или модуль 5, но скважности нет. если этот сигнал мы будем пускать на вход Х осциллографа, то на экране будет фигня, потому что задержки между сигналами разные
QC: 00110 T = 5, S = 2/5 = 5/2
QD: 00001 M=5, S = 5/1 = 5

в лабе надо спроектировать на заданном счётчике счётчик с заданным модулем и скважностью, наборы можно выбирать любые; в первой части они заданы

можно расписать таблицу состояний 
<img src="https://i.ibb.co/zFPYXFG/image.png" alt="image" border="0">

тут повторение через 8 ⇒ как минимум на 8 поделить можно

но другие сигналы (Q2, Q1, Q0) не периодические

во 2-4 частях лабы можно задать произвольные наборы, но важно помнить, что один из выходов счётчика должен быть выходом делителя. Никакой комбинации на входе быть не должно, потому что могут быть состязания. **Выход делителя -- один выходов счётчика**.


надо собрать
- десятичный счётчик
- делитель на триггерах
- делитель на заданном счётчике
- делитель на vhdl

наборы определяем сами, для этого можно посмотреть на таблицу состояний.

<img src="https://i.ibb.co/BsRjjCt/image.png" alt="image" border="0">

Первое, для чего предназначен регистр, -- это хранение чисел.

Цепи переноса можно назвать цепями передачи между разрядами, то есть межразрядные связи. В счётчиках они тоже бывают, потому что счётчик это набор триггеров, так же как и регистр. Последовательные регистры могут принимать сигналы, прежде чем его сдвинуть.

Сдвиг может происходить не обязательно на один разряд. При этом времена задержки могут быть разные, если используются разные по скорости элементы. Также время задержки в схемах содержит не только от задержки элементов, но и от цепи передачи информации. Поэтому приходится выдерживать время прохождения информации до триггеров, время предустановки, и только потом подавать синхросигналы. Поэтому в сдвиговых регистрах должны использоваться либо триггеры с динамическим управлением записью, либо двухступенчатые.

<img src="https://i.ibb.co/t8fkmj4/image.png" alt="image" border="0">

В системе Xilinx есть и те, и другие типы регистров, но больше параллельные.

Триггеры с третьим состоянием на выходе или открытым коллектором можно соединить "монтажным" выходом. Там всего один контакт, и он может работать как на выход, так и на вход. Обычно это используются в сетях - шинные формирователи. Это случай, когда один контакт вида I/O, куда можно и писать, и откуда можно читать. То есть здесь надо соединять выход со входом. Для этого выход триггера должен быть с третьим состоянием или открытым коллектором (высокое сопротивление). В этом случае выход -- разрыв между замлёй и питанием. Это третье состояние: 0, 1 и открытый коллектор. Это закрытый коллектор, у которого сопротивление порядка кОм между землёй и транзистором, и такое же между транзистором и питанием. При этом можно даже напрямую соединять выходы с разных триггеров в регистре, такое соединение называется монтажным ИЛИ. В ПЛИС такое есть: 84 контакта, где все контакты, кроме генератора I/O и питания, можно программировать как вход, так и как выход, а можно и как I/O (в один момент он работает на приём, а в другой на выход, например, по управляющему сигналу Y)

Мы рассматриваем триггеры и с прямым и с инверсным выходами, в Xilinx сейчас как правило прямые входы, потому что любую инверсию можно реализовать на входе следующих схем за счёт задания инверсии на входе. Как правило, выходы регистров поступают на какие-то КС, где сигнал уже можно проинвертировать. Но в общем случае, например, в ТТ в лабах, можно передавать и прямой, и инверсный выход, что позволит не делать инверсию отдельно.

<a href="https://ibb.co/VNtgr6t"><img src="https://i.ibb.co/GJ0WBm0/image.png" alt="image" border="0"></a>

Какую микрооперацию забывают чаще всего? **Хранение данных**. Но чтобы что-то хранить, надо сначала выполнить ввод (приём, запись, загрузка) данных.

Последовательно данные вводятся при сдвиге. При этом мы можем получить преобразование последовательного кода в параллельный (на вводе) и наоборот при выводе.

В Xilinx нет регистров со сдвигом чисто вправо. В этом случае можно поступить так: выполнять сдвиг на регистре со сдвигом влево и переставить разряды в другом порядке на входной шине: вместо младших старшие, вместо старших младшие и таким образом сдвиг на выходе будет работать правильно.

Сдвиг влево -- это сдвиг в сторону **старших** разрядов.

Сдвиг на заданное число разрядов важен при работе с числами с плавающей запятой, где надо проводить нормализацию и денормализацию мантисс, поэтому идут на затраты схем, но зато нормализацию и денормализацию можно выполнить за один такт.

Важно, что в 5 лабе регистр должен обеспечивать хранение, даже если этого в варианте не указано.

Данные в принципе можно не выдавать, если выходы будут находиться с третьем состоянии.

Можно написать сброс как отдельную микрооперацию, потому что начальное состояние не обязательно может быть нулевое.

<img src="https://i.ibb.co/GFWyCQN/image.png" alt="image" border="0">

**Сдвиг** -- это одновременное перемещение двоичного слова в разрядной сетке с сохранением порядка следования единиц и нулей.

Операции сдвига позволяют реализовать различные преобразования данных, например, из одного кода в другой: ПК, ОК, ДК, работать с отдельными битами (выдвигать его и проверять).

Сдвиг влево выполняет арифметическую операцию умножения на 2 в степени. Сдвиг вправо -- деление на 2 в степени, которое может быть со знаком (арифметический сдвиг).

Также операции сдвига применяются для нормализации и денормализации чисел.

**Логический сдвиг вправо**: внутри все разряды сдвигаются вправо. Но при этом младший разряд выдвигается и теряется. При этом в старший разряд вдвигается либо 0, либо 1 в зависимости того, что будет подано на вход SRI - **shift right input** -- вход последовательного ввода.

Аналогично при сдвиге влево теряется выдвигаемый старший разряд; все разряды внутри передаются соседним, а в младший разряд вдвигается информация внешнего входа SLI (**shift left input**).

Поэтому в системе Xilinx всегда есть вход SLI; SRI есть только в реверсивных.

На входы **последовательного** ввода SLI или SRI подаётся 0 или 1.

Это можно применять для беззнакового умножения или деления чисел.

**Циклический сдвиг**: информация, которая до этого выдвигалась, теперь загружается внутри цепи (не на вход SRI) и вдвигается. При этом мы уже не можем управлять вдвигаемым разрядом, потому что сдвигается только то, что находится внутри. Между старшим и младшим разрядом установлена кольцевая связь.

**Арифметический сдвиг**: в числе знак -- старший левый разряд при сдвиге **вправо** так же, как и при логическом сдвиге младший разряд выдвигается и теряется, а знаковый разряд **остаётся на месте**. Однако если младший разряд теряется, старший разряд при сдвиге вправо заполняется знаком или нулём, в зависимости то знака.

В Xilinx в явном виде арифметических сдвигов нет.

При сдвиге влево в младший разряд мы вдвигаем 0 в ПК и ДК и знак в ОК. При этом старший разряд после знака теряется, а не переходит в знаковый. При этом знаковый разряд остаётся на месте.

В арифметическом сдвиге нет дополнительных кодов SRI или SLI, потому что заполнение идёт изнутри.

Нужно проверять переполнение: например, если число не помещается в разрядную сетку, при сдвиге надо анализировать знаковый и старший разряды до сдвига, и если будет превышение максимально возможного, должно фиксироваться переполнение. При этом конкретный результат не играет роли, потому что он всё равно неправильный.

Например, если взять число 0.100 = 4 и сдвинуть его вправо (что равносильно его умножению на два), то после сдвига оно должно будет равно 8, а 8 в трёх числовых разрядах записать нельзя.

<a href="https://ibb.co/3zyRVSs"><img src="https://i.ibb.co/FVbHc8W/image.png" alt="image" border="0"></a>
Параллельный регистр. Буква F в УГО обозначает триггер: регистры хранения реализуются только на триггерах.

У этих 4 триггеров объединены входы управления C, CE, CLR, есть 4 входа параллельной загрузки (параллельного приёма, параллельной записи) и 4 выхода. Он никак не преобразует информацию, у него у каждого триггера свой независимый вход и его же одноимённый выход. Задавать порядок разрядов в него можно в любом порядке, на D0 X3, на D1 X0 и так далее.

Здесь использованы **динамические** триггеры (треугольник), а могли бы использоваться и статические (так как они не передают информацию никуда дальше, это бы ничему не помешало)


<a href="https://ibb.co/pPXTH2L"><img src="https://i.ibb.co/n0kyXrL/image.png" alt="image" border="0"></a>

Асинхронный сбром ⇒ есть вход CLR, Раз регистр, то у него обязательно будет вход C.

Вход разрешения тактового сигнала ⇒ CE

параллельные выходы ⇒ 4 выхода
параллельные входы ⇒ 4 входа

Последовательный вход ⇒ SLI


В сдви

SR4CLE
- SR: shift register. Shift ⇒ должен быть вход C, так как все синхровходы дб объединены, а также вход SLI последовательной загрузки. В Xilinx SLI всегда присутствует, а SRI может быть только вместе с SLI в реверсивных регистрах.
- 4 ⇒ только 4 выхода
- C ⇒ есть вход CLR; если бы стояло R, это бы означали **синхронную загрузку**
- L ⇒ у регистра есть входы параллельной загрузки. Но этой параллельной загрузкой нужно управлять входом L (load)
- E ⇒ есть вход CE. Регистр выполняет не только операции сдвига и загрузки, но ещё и хранения. А раз имеется три микрооперации, нужно иметь два управляющих входа.

Этот регистр сдвигает сверху вниз, от Q0 к Q3.

Из обозначений следует, что высший приоритет у входа CLR. Если CLR = 1, то все остальные операции не работают. Если регистр не работает, надо проверять, что приходит на его вход CLR.

По умолчанию в Xilinx загружается 0, даже если не подать CLR, потому что в начале работы при загрузке на кристалл проходит сигнал GSR (Global Set Reset), который поступает на все входы CLR, S, Reset. Потому что если бы этого не происходило, то при записи конфигурации элементов выходы могут быть подключены к внешним устройствам, поэтому предусматривается автоматическое установление в 0. Поэтому все элементы не имеют двух входов, а только один, чтобы подать сигнал GSR, который виден при временном моделировании в лабе. Но CLR всё равно рекомендуется подавать.

Далее высший приоритет у входа L. Если L = 1, то независимо от входов CE, SLI, но по фронту C загружается состояние со входов параллельной загрузки.

Если CE = 1, выполняется сдвиг (внутри это логический сдвиг, хотя это можно отдельно не говорить, потому что внешние связи могут быть такие, что логический сдвиг превратится в арифметический сдвиг в каком-то коде). Происходит сдвиг слева направо 0 -> 1, 1->2, 2-> 3, 3 теряется; в 0 загружается SLI.

Если на входах L и CЕ поданы 0, то регистр хранит информацию.

Тогда в соответствии с таблицей регистр выполняет следующие операции
- обнуление
- загрузка
- сдвиг влево на 1 разряд
- сдвиг влево на 1 разряд
- хранение

На входе перед триггерами стоит многовыходная КС: однотипные схемы перед 1-3 тирггерами, а в нулевом разряде стоит мультиплексор, в который можно загрузить SLI или D0; а на следующих загружается либо Di, либо значение предыдущего разряда.

На МQ0 при L = 1 происходит загрузка D, при L = 0 поступают сигналы с предыдущих триггеров при i = 1, 2, 3 и для нулевого -- сигнал с SLI.

Информационные входы (входы данных) -- SLI, Di
входы управления -- L, CE 
исполнительные входы -- C, CLR. По ним исполняется установка в 0, загрузка или сдвиг.

Наконец, объединяются все входы управления CE триггеров. Мы должны загружать параллельный или последовательный код по входу CE, который зависит от внешних входов CE или L.

C, CLR также объединены у всех триггеров. 

КС, которые информационные (MUX) и КС управления входом CE (OR2 вверху).

Если задать CE = 1, и L = 1, то будет выполняться загрузка, потому что она имеет высший приоритет.

На этом же регистре можно было бы сформировать последовательный вывод. Его можно было бы считать на Q3.

Если сдвиг идёт на 2 разряда, то входов загрузки SLI надо было бы сделать два для заполнения обоих пустых разрядов.

Хранение можно обеспечить за счёт передачи сигнала с выхода триггеров на входы триггеров. Для этого можно сделать дополнительный вход. Это тратит больше энергии, потому что идёт переключение.

Условно можно считать, что внутри триггера стоит элемент И, на который приходят CE и C, Таким образом, хранение можно обеспечить за счёт подачи 0 на CE.

<a href="https://ibb.co/9tXmF9x"><img src="https://i.ibb.co/m8srLCn/image.png" alt="image" border="0"></a>

В обозначение добавилась буква D -- Direction ⇒ это реверсивный регистр, и надо управлять направлением ⇒ появился вход LEFT ⇒ появился вход SRI

Сдвиг влево -- сверху вниз; вправо -- снизу вверх.

L = 1 ⇒ загрузка.

CE = 1 ⇒ может быть сдвиг либо вправо, либо влево. CE фактически управляет сдвигом: если LEFT = 0, то сдвиг выполняется вправо с входа SRI передаётся на Q3, все остальные сдвигаются вверх, Q0 теряется.; при LEFT = 1 -- наоборот.

В связи с этим появился второй набор мультиплексоров. Для сдвига влево MDL; для сдвига вправо MDR.  Теперь при сдвиге вверх появляется мультиплескор MDR3, на который приходит SRI, аналогично нулевому мультиплексору в MDL.

Вход L управляет первой группой, LEFT -- второй группой.

<a href="https://ibb.co/34vS6Q3"><img src="https://i.ibb.co/9chyKSD/image.png" alt="image" border="0"></a>

Здесь приведён пример увеличения разрядности реверсивного счётчика. Все входы управления в каждом регистре объединены. Входы C, CLR также объединены, но это исполнительные входы.

Входы SLI, SRI и D -- информационные входы.

Если D0-D3 -- младшие разряды, то на выходе регистра третий разряд не теряется, а переходит в следующий разряд следующего счётчика. При сдвиге в другую сторону 8 разряд переходит на SRI предыдущего, 4 на SRI нулевого, а Q0 теряется.

В своих регистрах в БО можно будет использовать, например, один триггер для сдвига. На 4 работе, если не удаётся реализовать на одном счётчике (например, нужен счётчик на 5 разрядов), то можно дополнить счётчик дополнительными триггером, а не соединять два счётчика.

На регистрах сдвига можно реализовать счётчик. За счёт управления входом SRI или SLI можно реализовать счётчик. В счётчке мы ставили КС на входах D, которая зависела от выходов и для текущего состояния мы готовили, в какое состояние должен переключиться счётчик и ставили соответствующую КС.

При сдвиге входы D отключены и при CE равном единицу сходы SLI. Из нулевого состояния регистр может перейти в состояние, равное тому, чему равно SLI, то есть либо в 0, либо в 1.

Из первого состояния можно перейти либо во второе, либо в третье.

Можно подготовить КС на входе SLI, на вход которой подаём выход.

<a href="https://ibb.co/Br4mLns"><img src="https://i.ibb.co/xfmyhF5/image.png" alt="image" border="0"></a>

Строим граф переходов. Например, в 5 состоянии (101) если приходит 0, но мы переходим во второе состояние (010), а если 1, то в третье состояние (011).

На вход SLI ставится КС, на входы которой поступают выходы схемы.

Предложен счётчик 0 1 3 6 4. Если провести минимизацию (это пропущено), то в результате минимизации будет получен элемент NOR2. За счёт этой комбинационной схемы (NOR2), синтезированной на основании графа переходов, синтезирован счётчик по модулю 5.

Но так можно сделать не с любыми наборами. С какими-то наборами, не входящими в граф переходов, пришлось бы пользоваться входами установки.

Это же можно реализовать и на триггерах. Данный регистр: вход только последовательной загрузки и 4 параллельных выхода, внутри из себя представляет 3 последовательно соединённых между собой триггера ⇒ вариант а) это внутренняя схема данного регистра за исключением отсутствия CLR (поэтому обозначение у триггера только FD) и отсутствия входа CE (то есть он всегда работает, но по фронту). Такой триггер не рекомендуется использовать, лучше использовать триггера с СЕ, потому что такие триггеры без СЕ могут не срабатывать. 

Вход T0 можно считать в данном случае входом SLI для регистры.

Тот же самый счётчик можно реализовать не на регистре сдвига, а на регистре хранения (в). На таком регистре очень просто реализовать сдвиг, ведь на регистре хранения можно входы D исключить и завести связи между триггерами. На данном регистре хранения Q0 -- вход SLI, на который подаётся NOR2, с 0 разряда передаётся 1, а 3 разряд выдвигается.

На регистре хранения можно реализовать сдвиг, но у него тогда будут отсутствовать напрямую входы загрузки (они будут заняты связями между разрядами для сдвига).

В данном случае в графе мы не используем состояния 2, 3 и 7. Если мы случайно в результате сбоя попадём в один из этих наборов, что будет? Например, если попали во 2 набор (010), на NOR 2 будет 0 ⇒ перейдём в 100 (4) и вернёмся в граф.

Из 5 (101) получаем на входе SLI 0 ⇒ 010 ⇒ 100
7 (111) ⇒ 0 ⇒ 6 (110)

В схемах всегда нужно рассматривать возврат в требуемый режим. Либо надо принудительно задавать сброс и начальную загрузку. Часто стоит вопрос, как быстро нужно вернуться в начальное состояние -- за один такт или за несколько.

В системе Xilinx есть регистры сдвига только влево или реверсивные. Можно задать разряды в другом порядке и получать сдвиг в другую сторону. Но сдвиг в Xilinx только логический, если нужен циклический, нужно заводить отдельные связи, для арифметического надо смотреть отдельно, в некоторых кодах надо добавлять отдельные триггера.

В готовых регистрах 4 разряд Q3 не используется, и в Implementation будет выдаваться предупреждение, что выход Q3 не задействован. при размещении на кристалле этот выход удаляется и нигде не используется. Q0 не удаляется, потому что он используется внутри схемы.

Принципиально можно на 8-разрядном регистре создавать 6-разрядные, потому что лишние неиспользуемые элементы будут удаляться.

<a href="https://ibb.co/z58Jn8k"><img src="https://i.ibb.co/N31SV14/image.png" alt="image" border="0"></a>


Таким образом можно получить счётчик по модулю до 8.

Особая группа -- кольцевые счётчики, на вход SLI у них подаётся выход последнего разряда, то есть образуется кольцевая связь. Таким образом, будет N состояний и в каждом из состояний будет одна единичка (если мы записали одну единицу в начале). Дешифрирование состояний счётчика очень простое.

Если подать выход не со старшего состояния, а с какого-то другого, то он будет использовать просто меньше разрядов и меньше состояний. Но при этом надо не забыть загрузить начальное состояние, иначе счётчик будет гонять нули по кругу.

На основании такого кольцевого счётчика строится распределитель тактов. Унитарный код можно получить , поставив на выход счётчика дешифратор. Минус у такой схемы -- могут быть иголки, когда счётчик переключается 01 -> 00 -> 10, когда триггеры переключаются не одновременно.

Распределители тактов
- распределители уровней (импульсы друг за другом без пауз)
- распределители импульсов (импульсы стробируются входным генератором)

Распределители импульсов реализуются за счёт конъюнкторов (элементов И).

<a href="https://ibb.co/tm50KxD"><img src="https://i.ibb.co/smrTR6q/image.png" alt="image" border="0"></a>

С выходы U3 заводим связь на SLI ⇒ счётчик по модулю 4. На выходах будут уровни -- сигналы идут подряд без промежутков. Из уровней можно получить импульсы, добавив конъюнкторы: один вход у них соединён с распределителем уровней, а вторые подключены к синхровходу. Регистр срабатывает **по спаду** за счёт инвертора после С, чтобы исключить иголки.

Как в этом счётчике задать начальное состояние? Для этого надо задать входы D и выполнять начальную загрузку. Но можно дополнить регистр-счётчик сбросить в 0, и когда у нас все нули, на вход надо подать единицу один раз, а потом одни нули. Предложено поставить элементы NOR4, которые будут формировать 1, как только на него придут все нули. На диаграмме показано, что по входу CLR можно сбросить счётчик в нулевое состояние, в нуле на выходе NOR4 формируется единица, которая будет загружена на выход U0 по спаду С. Счётчик переходит из U4 в U0 и дальше идут сдвиги. Как только счётчик опять получает значение 4 нуля, опять формируется единица. Таки образом, за счёт этого элемента мы получили не только начальную загрузку счётчика, но, если посмотреть на диаграмму, то счётчик можно считать пятиразрядным, у которого есть пятый выход уровня U4.

Регистр если имеет N триггеров, то будет иметь N состояний в нитарном коде, но, дополнив его одним элементом NOR, можно получить ещё одно состояние.

Все выходы U поступают на 5 конъюнкторов и стробируются (вырезаются) с помощью сигнала С.

Когда в тексте пишутся латинские буквы, обычно они пишутся курсивом.

NOR4 -- самовосстановление, то есть данный регистр-счётчик при сбое, например, из состояния 2 перешли в 3 (1, 01 и вдруг 0011). Поскольку 2 единицы дают 0, то перейдём 3 - 6 - 12 - 8 - 0 и сформируется единичка на выходе. За счёт этого элемента мы возвращаемся в наш граф переходов после сбоев за несколько шагов. 

Если мы загрузили в регистр какое-то число и сдвигаем его связями, надо ответить на вопрос, что мы будем наблюдать в той или иной точке. Аналогично объяснить на экране осциллографа, почему тот или иной триггер перешёл в то или иное состояние.

На с. 99 86 рисунок показан с ошибкой. Что будет на выходах элементов, если мы инвертор удалим?  Если U будут переключаться по фронту, то если мы посмотрим на выходы U,  U1 и U2 могут завершиться и начаться соответственно не одновременно, так как счётчик может переходить как 01 -> 11 -> 10. Здесь иголок нет, потому что мы переключаемся по спаду и подачу C мы уже прекратили, а в противном случае на одном из выходов могут быть иголки. Так как если при переходе через два состояния появляются некоторые промежуточноые **и в то же время подан синхросигнал**, то на выходах C будут иголки, потому что они будут срабатывать сразу.

Если мы загрузим тройку за счёт входов D, то мы перейдём 3 -6 - 12 - будет 4 состояния, но не в унитарном коде. Состояний может оказаться меньше, например, 5 - 10 - 5 (0101) - (1010)

<a href="https://ibb.co/bRS74TL"><img src="https://i.ibb.co/mFLSnkt/image.png" alt="image" border="0"></a>


Если в обычном кольцевом счётчике мы заводили связь  со старшего разряда на SLI напрямую, то в счётчике Джонсона мы подаём **инверсный** сигнал.

Плюс: каждый раз переключается один разряд. Особенность: в счётчике распространяется волна единиц и волна нулей на каждом разряде (это видно на временной диаграмме).

При этом выход не представлен в коде 1 из N, поэтому, чтобы сказать, в каком состоянии находится счётчик, надо его декодировать. Нужно выделить определённую комбинацию

<a href="https://ibb.co/Bnv2nz0"><img src="https://i.ibb.co/y4KF4fH/image.png" alt="image" border="0"></a>

Если мы завели обратную связь и счётчик в начальный момент установили в 0, то после нуля на ход SLI будет приходить единица, пока они не дойдут до последнего разряда. Поэтому будут наборы 0 - 1 - 3 - 7 - 15. При 15 единичка пришла на выход Q3, инвертируется и начиная с этого момент на вход SLI начинают приходить единицы: 14 - 12 - 8 - 0. Получается, всего 8 наборов.

В коде Грея при n триггеров будет 2^n^ наборов, а тут только 8 (2n) наборов. На каждом переходе изменяется только один разряд. Как видноЮ наборы не подряд идущие. У счётчика можно определить по выходам, сколько импульсов уже прошло. Например, если состояние 8, надо уметь посчитать, сколько состояний уже прошло. Для этого можно было бы поставить более сложную КС, которая могла бы данный код счётчика Джонсона (Мёбиуса) переводить в двоичный код. А можно перевести в унитарный код, в котором удобно смотреть, какое состояние прошло, а самое главное -- эти выходы очень удобно использовать для построения распределителей уровней или импульсов. В данном случае показано распределение уровней (между ними нет промежутка, а импульсы **стробируются** или вырезаются синхросигналом). При этом, конечно, могут быть задержки, но переключается всегда один из выходов, поэтому иголок не будет. Тогда, например, из таблицы переходов можно было бы увидеть, что можно определить, что такое первый уровень, первый выход D1. Для этого нужно смотреть набор хх01 -- он больше нигде не встречается. Аналогично для остальный наборов это можно получить. Можно было бы также провести минимизацию для каждого выхода, расписать минимизацию и показать, что данный выход нужен при данной комбинации выходов счётчика, при этом остальные комбинации равны 0, а 8 отсутствующих комбинаций равны х. Таким же образом можно сказать, что нулевой набор -- это код хх00, потому что ни у кого больше не встречается комбинация двух нулей в младших разрядах. При этом на выходе получается распределитель уровней. Если дальше из него нужно стробировать, нужно поставить элемент И на выходе и инвертор для предотвращения иголок.

Если рассматривать граф переходов для счётчика, то он проходит уже показанный состояния (1 - 3 - 5 - 7 - 15 - 14...), но нету восьми других состояни.

<a href="https://ibb.co/hCJ2T0G"><img src="https://i.ibb.co/pnB4kqH/image.png" alt="image" border="0"></a>

Если  мы попадём в неправильное состояние (например, 2), то счётчик будет циркулировать по графу б) и не будет самовосстановления.

Поэтому если мы в них попадаем, то надо провести минимизацию и дополнить схему. В таком случае мы будем возвращаться в исходный граф, но не с первого перехода. То есть для самовосстановления надо доопределить состояния.


В лабе надо продумать, как организовывать циклическийй сдвиг.

Кольцевой счётчик это как циклический сдвиг. В лабе надо ориентироваться, что будем наблюдать при загрузке и сдвиге информации. Этот счётчик будет использоваться потом для распределителей тактов и распределителей импульсов.

Чтобы на осциллографе наблюдать всю временную диаграмму счётчика Джонсона, надо на вход Х осциллографа подать спад Q3 или фронт Q0. Начиная со спада Q3 мы запускаемся и видим все ступеньки. А если запускаемся по фронту Q0, то мы начнём наблюдать с D1.


Когда мы будем смотреть Q0, Q1 или выходы D в режиме внутренней синхронизации (запуску от наблюдаемого сигнала, когда вход X отключается, в запускается внутренний генератор от самого исследуемого сигнала, осциллограф работает по наблюдаемому сигналу), то если мы будем наблюдать один из $D_i$, то вид для любого из сигналов будет как Do (если это фронт), или как D1 (если это спад),

Поэтому если на осциллографе что-то не совпадает, в первую очередь надо проверить, какая синхронизация.

Для сигналов Qi мы также будем наблюдать одинаковую картинку (если наблюдает по фронту, то будем видеть 11110000, если по спаду -- 00001111). 

Вид картинки при внутренней и внешней синхронизации зависит от того, что приходит на вход синхронизации. 

В кольцевом счётчике как правило свдигается одна единица ⇒ n состояний

в счётчике джонсона будет 2n состояний

здесь чтобы определить какое состояние стоит например на 15 наборе, он по счёту будет только четвёртым. Для этого для каждого выхода построить распределитель уровней -- КС для каждого выхода, построить диаграмму вейча и определить что будет за элемент для d0

по вд можно заметить, что можно построить 8 диаграмм вейча ⇒ 8 состояний ⇒ 8 иксов ⇒ после минимизации мы бы получили nq0 nq3.  

заметим что для счётчика джонсона если мы попадаем в неправильное состония, попадаем в другой граф, неправилньый, из которого уже не вытйи

чтобы сема восстанавливалась, хоть и не за один шаг, можно провести другую минимизацию, чтобы мы возвращались в состояние из правильного графа и получить схему счетчика с самовосстановление

<a href="https://ibb.co/R0kS8Ww"><img src="https://i.ibb.co/gTL7YCK/image.png" alt="image" border="0"></a>

<a href="https://ibb.co/cFNGJMc"><img src="https://i.ibb.co/swF0jkv/image.png" alt="image" border="0"></a>

каждое последующее состояние почти не зависит от предыдущего. Но через какое-то время мы всё равно начнём повторяться, но хорошие генераторы имеют большой модуль

в хороших генераторах типа генераторов случайных, а не псевдослучайных последовательностей, вероятность появления следующего значения равновероятна

на основе этих генераторов строятся ключи защиты: подаём на вход в канал нужную информацию совместно с генератором ПСП, передаём их вместе через xor в шину, а у приёмника на первом входе стоит xor, а на втором сам ключ ⇒ на выходе получим

для этого в сборнике задач предложено использовать регистр сдвига 4 разрядный. У него объединяем по ксору два выхода -- один из них последний, второй может быть каким-то из предыдущих. Когда неизвестно, что это будут за разряды, а если их ещё и много, то можно будет генерировать последовательности. При n счётчиках получается модуль счёта 2^n^- 1, при этом нулевая комбинация исключается.

С каждого выхода генератора Х идёт какая-то конкретная последовательность нулей и единиц, которая является псевдослучайной, но на некоторых выходах эта последовательность может совпадать с точностью до сдвига.

Вход старт нужен для запуска регистра. 

НО в нашем случае из нуля регистр ни в какое состояние не перейдёт (на SLI из-за XOR3 будет подан ноль), а одноразовый короткий сигнал старт даёт единичку, которая переходит в SLI.

Мы видим сдвиговый регистр с входом только последовательного приёма, а входов D нет, поэтому нет и входа L.

Справа предложена самозапускающаяся схема. Здесь нет нулевого состояния. Когда схема вдруг сбилась и перешла в нулевое состояние, её нужно восстановить -- для этого ставится элемент 4или-не, который в данном случае будет аналогом входа START.

На этот элемент XORR мы объединяем старший разряд и какой-нибудь из младших (например, Q0). ПРи этом на этот же элемент прихолит выход элемента 4или-не, который равен 1 только окгда схема сбилась, а всё остальное время он равен 0 и не мешает xor.

Таким образом, получается какая-то другая случайная последовательность. Чем больше n, тем больше длина последовательности. Если разрядов будет 20, то модуль этого счётчика равен примерно миллиону. (1 048 575)

При этом если период генератора известен, то например есть 15 тестов для проверки генератора. ПРоверяется количество 0 или 1, вероятность появления пары или тройки, количество групп подряд идущих единиц и нулей, есть визуальные методы проверки качества этих генераторов.


 <a href="https://ibb.co/XXMw5c1"><img src="https://i.ibb.co/TcdC096/image.png" alt="image" border="0"></a>


в лр было приведено на рис 5.4 как можно реализовать внутренний регистр сдвига на который на вход d можно поставить мультиплексор, на которых реализуется либо параллельная загрузка (L = 1) или сдвиг (L = 0). При последовательной загрузке работает вход SLI, который дальше назвали DP0.



# Сумматоры
<a href="https://ibb.co/YLSGTwG"><img src="https://i.ibb.co/TgG5qd5/image.png" alt="image" border="0"></a><br />

Арифметическое сложение: в нём присутствуют цепи межразрядного сложения, в отличие от логического сложения (ИЛИ) и сложения по модулю (XOR, но мб по любому модулю, например, по модулю 3 -- это будет остаток от деления на 3.

<a href="https://ibb.co/9yc9rmh"><img src="https://i.ibb.co/2cW7k0S/image.png" alt="image" border="0"></a><br />


Полусумматор --  у него нет входного переноса, а у одноразрядного полного сумматора он есть. Полусумматор всё равно может использоваться в многоразрядных сумматорах в младшем разряде.

Сумматор для последовательных операндов: мы сдвигаем всегда операнды, для них используется одноразрядный полный сумматор и быстродействие там не нужно, обработка происходит редко.

Накопительный сумматор -- это сумматор, у которого на выходе стоит регистр, накапливающий результат: его мы применяем при умножении

<a href="https://ibb.co/X4BChKB"><img src="https://i.ibb.co/W392bM9/image.png" alt="image" border="0"></a>

Переполнение разрядной сетки в дальнейшем мы будем называть переносом.

Суммируются два разряда, и в отличие от логического сложения и сложения по модулю 2, перенос не пропадает и формируется на выходе Carry Output.

Тут кстати есть ошибка: $HS = \overline A B \vee A \overline B = A \oplus B$

В отличие от полусумматора, у полного сумматора появляется вход CI.

<a href="https://ibb.co/rs5RScd"><img src="https://i.ibb.co/hf2JjZY/image.png" alt="image" border="0"></a>

Здесь есть три входа ⇒ 8 строк в таблице истинности. Из этой таблицы можно извлечь правило: если нечётное количество единиц на входе, то выход S будет равен 1.

Если единицы на двух или более входах (в данном случае на двух или трёх), то CO будет равен 1.

Если не проводить минимизацию, то можно выписать СДНФ, выписывая единицы -- элементарные конъюнкции или термы, для S и для переноса CO. Если их реализовывать без всякой минимизации, можно получить приведённую на рисунке схему (её называют классической схемой сумматора) в базисе И ИЛИ НЕ.

На экзамене также нужно будет писать ТИ, писать минимизацию и реализовывать схему.

Если посмотреть только на таблицу, то видно, что CO и S с 1 по 6 наборы отличаются инверсией. Если бы мы написали $S = \overline {CO}$, то надо было бы это дополнить 7 набором: $S = \overline{CO} \vee A B CI$ и запретить нулевой набор, дописав ещё $\overline {CO} (A \vee B \vee CI)$

По аналогии с вычтателем, функцию S нельзя минимизировать. Если посмотреть на $CO$ из диаграммы Вейча, можно любой набор склеить с 7, получив B CI + A CI + A B, то есть перенос можно было бы реализовать как три двухвходовых элемента И без инверсии, то есть это было бы ещё быстрее. Если посмотреть на исходную схему, то время появления сигнала на выходе CO с инверсией будет равно 3, а без неё -- 2.

<img src="https://i.ibb.co/D8n8kq7/image.png" alt="image" border="0">

Свойство самодвойственности видно на 0 и 7 строках. Чтобы выиграть время переноса между разрядами, можно использовать и те, и другие выходы в каждом разряде: и инверсные, и прямые поочерёдно.

Чем отличаются схемы друг от друга: мы увидели два варианта аппаратной реализации: без минимизации (на элементах) и с минимизацией. Рассмотрим, как меняется быстродействие: если меняется информация на каком-то входе, через какое время это изменения поступит на выходы S и CO.

Рассмотрим это на схеме выше. От А, B и CI сигналы проходят на СO сразу, но на сумму оно будет приходить медленнее, так там есть связь с CO, но от A, B и CI связи к двум выходам идут одинаковые, и в общем случае у них задержки одинаковые. Считаем, что задержки от А до S и от A до CO такие же, как и у B.

Задержка до CO будет равная 2, а от входа до S будет равна 4, то есть задержка на СО меньше, чем на сумме.

Если вернуться на классическую схему, то на любом выходе задержка будет равна 3 элементам: инвертор, И и ИЛИ.

Задача -- сделать так, чтобы СО сформировался быстрее, пусть даже выход S будет медленнее.

Если бы мы не заметили свойство в ТИ, можно было бы попробовать провести минимизацию CO и получить её. Считая, что есть А, В, CI и реализовав уже CO, можно было бы сделать S как функцию от 4 переменных.

<a href="https://ibb.co/3rfWSnf"><img src="https://i.ibb.co/FxsJ8Fs/image.png" alt="image" border="0"></a>


В ТИ стоит на 1 наборе X на S, потому что при трёх нулях не может быть CO, то есть данная комбинация входов невозможна.

Чтобы легче заполнять табличку, воспользуемся не диаграммой Вейча, а картой Карно. В карте Карно, в отличие от диаграммы Вейча, наборы переменных строго фиксированы: это код Грея по каждой стороне: каждая соседняя пара переменных отличается только в одном разряде. 

Эту же схему можно было бы реализовать так:

<a href="https://imgbb.com/"><img src="https://i.ibb.co/d65twQh/image.png" alt="image" border="0"></a>

В левом случае задержка от каждого входа до каждого выхода равна 2.

Количество единиц для выхода S можно посчитать с помощью двух последовательных XOR. Задержку в XOR и AND сравнивать, если та схема реализована не на ПЛИС, нельзя, потому что это элементы их разных базисов. Понятно, что в XOR задержка будет намного больше, так как внутри него также содержатся элементы.

Также можно построить сумматор на основе полусумматоров и схемы ИЛИ. Это надо будет пояснить на экзамене: как работают оба полусумматора и как они формируют выходы. Есть две пары переменных, каждый из полусумматоров фактически определяет количество единиц в каждой паре.

Если у готового сумматора переставить местами А, В и CI (внешние входы), результат от этого не изменится. С точки зрения быстродействия: желательно при объединении разрядов это не путать, потому что связь CI-CO может быть реализована быстрее.

### Сумматор для последовательных операндов

Схема взята из Угрюмова.

<a href="https://ibb.co/kq9MSMC"><img src="https://i.ibb.co/44YJVJr/image.png" alt="image" border="0"></a>

при подготовке в лабах лучше не менять входы местами: если CI идёт сверху, то надо его делать сверху, чтобы не делать лишних ошибок.

Есть два операнда А и В, многоразрядные (n разрядов). Если мы суммируем, то на выходе у нас получается число из n+1 разряда (учитывается перенос из старшего разряда, который превращается в n разряд). А можно было бы не менять разрядность выхода, и просто снимать перенос с отдельного триггера.

Сумматор -- одноразрядный полный комбинационный. Не рассматриваем вариант, как мы записали в эти регистры А и В значения (могли бы записывать и параллельно, и последовательно за n тактов). У регистра суммы показан вход последовательного приёма SLI.

На выходах в соответствии с ТИ появляется и сумма, и CO. CO приходит на триггер, чтобы запомнить его и вывести на следующем такте (если завести это напрямую, то может быть генерация в случае обратного кода).

Запись в регистр результата и на сумматор происходит с помощью сдвига.

Надо отметить, что тут младшие разряды нулевые, поэтому тут сложение с младших разрядов "младшими разрядами вперёд".


У триггера обязательно должнен быть вход CLR, чтобы преенос от предыдущих операндов не влиял на суммирование новых.

<a href="https://ibb.co/7N0sdwN"><img src="https://i.ibb.co/Kz8TpMz/image.png" alt="image" border="0"></a>


Время СО для данной схемы: tA-CO + (n-1) tCI-CO

В числах со знаками может быть перенос в знаковый разряд (перенос из S2 в S3). Это будет переполнение: перенос из цифровых разрядов в знаковые, выход OFL.

<a href="https://ibb.co/HN18KV8"><img src="https://i.ibb.co/GsBSd0S/image.png" alt="image" border="0"></a><br />

Часто в процессорах внутри могут быть отдельные флаги для CO и OFL.

Самое главное -- как можно быстрее организовать перенос от младших разрядов к старшим.

При это S0, S1, S2, S3 будут в паспортных данных иметь разные времена формирования, причём S3 имел бы самое большое время.

S формируется, если количество единиц на входе нечётное, CO -- когда две или более единицы на входе (в нашем случае 2 или 3).

<a href="https://ibb.co/94dMLB9"><img src="https://i.ibb.co/DMjqymD/image.png" alt="image" border="0"></a>

В счётчике входной счёт бежал сквозным переносом дальше. БП -- это блок переноса. Сумма равна 1, когда есть нечётное количество единиц. предложено онтосительно переноса рассмотреть две функции: функцию генерации и функцию прозрачности. При этом функция генерации формируется при 2 или 3 единицах, функция транзита формируется при наличии входного переноса

Эти две функции внутри сумматора можно записать в виде:
g = 2 единицы внутри (исключаем CI)
h = A or B (CI учитывается уже вне сумматора)

Внутри сумматора реализуются две функции.

На выходах h и g поступает перенос одновременно на всех разрядах, так как CI не участвует в формировании h и g. Каждый из блоков работает практически одновременно.

В начальный момент h и g формируются сразу через время задержки сумматора и дальше независимо от того, как суммируется S, можно передавать их дальше. Можно посчитать, что у разряда S2 можем одновременно рассматривать блок 1 и 2 как од

<a href="https://ibb.co/8MPnFwL"><img src="https://i.ibb.co/MnPyqHx/image.png" alt="image" border="0"></a>

Функии генерации и транзита мы генерируем уже в блоках, а не в сумматорах. На каждом разряде в каждом блоке учитывается всё больше предыдущих сигналов.

Например, C0 (carry ноль) учитывает генерацию 0, CI и транзакцию 0.

C1 учитвает генерацию первого разряда + перенос входной первого разряда и транзакцию первого разряда. Если это расписать, то получится g1 + g0 h1 + CI h1 h0

Получается, что на каждом блоке элементов только два: один И и один ИЛИ, у них только растёт разрядность. Задержка получается всего на 2 элемента.

Видно, что на каждом следующем разряде увеличивается аппаратура. Чтобы с этим бороться, используют такой сумматор:

n-разрядные входные числа разбиваются на группы по m разрядов и между группами стоят блоки переноса. 

Здесь предложено использовать последовательный межгрупповой перенос. На первый блок приходит перенос, если от m разрядов уже присутствует функция, на неё домножается и сигнал идёт дальше на второй БП и так далее.

<a href="https://ibb.co/HhqQjxy"><img src="https://i.ibb.co/2ZdBTsr/image.png" alt="image" border="0"></a>

Внутри сумматоров может быть как параллельный, так и последовательный сумматор, а значит, на его выходе может быть как параллельный, так и последовательный перенос. Для случая последовательного переноса будет (n-1) группа БП * время БП + время суммирования, чтобы получить S.

Часто под сквозным и последовательным переносами понимают одно и то же.

Цель этого сумматора -- уменьшить количество оборудования, но это идёт в ущерб времени.

Также можно сделать и параллельный перенос между группами, но это опять будет увеличивать объём оборудования. Например, вместо 4и на 3 разряде будет стоять 2и 2и 2и.

Внутри многовходовых элементов увеличивается размер самого элемента и усложняется многоэмиттерный транзистор внутри, поэтому задержка растёт.

<a href="https://ibb.co/7VqH2JN"><img src="https://i.ibb.co/nfFTzs8/image.png" alt="image" border="0"></a>

Сумматор с условным переносом

Сумматор разбили на дву группы: есть сумматор младшей группы и сумматор старшей группы.  Для этого нужно было бы перенос из младшего разряда завести на старший. Получили бы n-разрядный сумматор с выходами младших разрядов, старших и переноса.

Дублируем старшую группу: ставим третий сумматор и на него тоже заводим старшие разряды. Тем саммым количество оборудование увеличивается на 50%. Цепочка переноса разрывается и подаём на один сумматор CI=1 а на второй Ci=0. Через время, равное суммированию n/2 разрядов на выходах трёх сумматоров будет результат. Получили три суммы, а дальше предлагается поставить мультиплексор, на который приходит из старших двух групп два результата и в зависимости от реального переноса из младшего сумматора выбираем настоящий результат из двух.

Это позволяет в 2 раза, если не считать мультиплексор, повысить быстродействие. 

Аналогично, если считать, что это какой-то промежуточный сумматор, на выход также ставим мультиплексор, который выбирает один из переносов старшего сумматора в зависимости от переноса из младшего.

## Накапливающий сумматор

Если выход комбинационной схемы сумматора дополнить регистром, то получится накапливающий сумматор. Выход регистра можно завести на вход. Показано, что регистр должен быть с динамическим управлением или двухступенчатый (наклонная черта имеет два смысла: количество разрядов в шине и динамическое срабатывание), а также сброс (но если перед сумматором поставить КС, которая на него посылает 2 нуля, то тогда сброс регистра будет не обязателен).

Накапливающий сумматор может быть полезен при вычислении суммы частичных произведений, а также на нём можно суммировать все элементы массива (получать контрольную сумму).

## Сумматор-вычитатель

<a href="https://ibb.co/wrwjC2M"><img src="https://i.ibb.co/Pz904Vw/image.png" alt="image" border="0"></a>

Вход CI можно понимать как BO (borrow). Если рядом представить таблицу истинности, то если посмореть на значение суммы и разности, видно, что они одни и те же. Поэтому выход S вычитателя такой же, как и у сумматора. 

CO должен выбирать либо CO от сложения, либо BO от вычитания. Надо это минимизировать и посмотреть, чему они равны. На CO стоит мультиплексор, который в зависимости от сигнала ADD выбирает CO или BO.

На экзамене надо показать, что мы владеем минимизации, надо рассказать, как можно реализовать классический сумматор декомпозицией -- разделением на части.

Всегда важно смотреть, что является вычитаемым и уменьшаемым для вычитателя. В Xilinx А -- это уменьшаемое, а B -- вычитаемое.

Элемента лучше рисовать более жирными линиями (двойной), а где один разряд -- одной линией, а шину двойной.

ДЗ с 118 №4: разработать комбинационную схему (можно сумматоры, дешифраторы, а лучше до простых элементов в базисе И ИЛИ)

Когда мы будем раскрывать внутреннюю структуру сумматора в иерархии, можно увидеть, что нарисован прямоугольник и стрелка: внизу старший, а вверху младший разряд. Если идёт сквозной ускоренный перенос, он нарисован сверху вниз. Где-то структура раскрыта как последовательный перенос: несколько сумматоров, между которыми бежит перенос.


# Состязания

<a href="https://ibb.co/zFYdT1p"><img src="https://i.ibb.co/QkR03ZL/image.png" alt="image" border="0"></a>


Если рассмотреть элемент И-НЕ, подать на него два сигнала A и В, считая, как при синтезе, что они поступают одновременно, то мы будем наблюдать на выходе единицу, что правомерно было бы, если выполняется функциональное моделирование, которое демонстрирует результат после переходных процессов

Попробуем промоделировать эту же схему в Unit или с учётом задержек. 

С учётом задержек мы увидим провал -- иголку на выходе F (две единицы с задержкой дадут 0)
<a href="https://ibb.co/2PjcGbc"><img src="https://i.ibb.co/92qyQMy/image.png" alt="image" border="0"></a>

На диаграмма переходной процесс можно представлять так: с третьим состоянием (1, 0 и неопределённость)

<a href="https://imgbb.com/"><img src="https://i.ibb.co/mDQyxDJ/image.png" alt="image" border="0"></a>

Раз элемент находится в неопределённом состоянии, непонятно, к чему это могло бы привести: и к состязаниям, и к иголкам, причём довольно сложной формы. Если у нас есть неопределённость и умножаем её на 0, получим 0, а если умножаем на 1, то получаем неопределённость.

<a href="https://ibb.co/58z4Qz4"><img src="https://i.ibb.co/T8n2Qn2/image.png" alt="image" border="0"></a>

В ПЛИС отрезки связи коммутируются, а в каждом узле коммутации стоит ключ -- пин транзистор, который тоже имеет задержку. Если мы передаём сигнал из одного угла в другой угол в КЛБ (матрица 14х14 узлов), можно было бы получить задержку до 3 нс, просто перемещаясь из одного угла в другой.

Рассмотрим такую комбинационную схему. Видно, что у сигналов есть различные пути прохождения.

Пусть мы рассматриваем ФМ, когда задержки равны нулю. 


У каждого элемента может быть своя задержка: здесь показана часть схемы, а у элементов может быть другое количество входов. А чем больше входов у элементов, то, как правило, задержка от этого меняется.

Также может построить и для D3, для этого надо учитывать A и D2.

<a href="https://ibb.co/gyPBknk"><img src="https://i.ibb.co/TcbF9C9/image.png" alt="image" border="0"></a>


Если бы мы наблюдали ФМ, мы бы не увидели никаких иголок. А здесь мы видим иголку на D2 (1-> 0), а на D3 мы видим, что после ухода в 0, как и должен был быть, он ещё и возвращается в единицу и потом опять уходит в ноль.

На D2 должна была быть всё время единица, но она уходит в ноль из-за задержек. Видно два вида состязаний: уход в ноль или уход в единицу. 

<a href="https://ibb.co/H2ng6T0"><img src="https://i.ibb.co/Jd5kVjN/image.png" alt="image" border="0"></a>

<a href="https://ibb.co/rwDstMf"><img src="https://i.ibb.co/gRkV7wF/image.png" alt="image" border="0"></a>

Это особенно важно, если мы говорим о больших частотах. Сигнал распространяется со скоростью света: около 30 см в одну наносекунду. Если считается разброс (уход в 0 и возврат) будет больше времени задержки узлового элемента, то есть элемента, на котором мы смотрим, то состязание будет. Если мы строим моделирование, то мы говорим о паспортной задержке.

Статическое состязание -- "риск в 1" ли "риск в 0": однократный уход в другое состояние. Иголка вверх или вниз, кратковременное появление на выходе КС другого состояния.

А динамическое состязание -- состязание при переходе из одного состояния в другое.

<a href="https://ibb.co/4FpHPZy"><img src="https://i.ibb.co/grJxzM1/image.png" alt="image" border="0"></a>

Под задержками в цепях подразумевается как сама цепь (задержка прохождения сигнала), так и задержки на элементах этой цепи.

Далее рассматриваем статические состязания.

Рассматрим прохождение сигналов в цепочке элементов на примере двух элементов. Схема из двух элементов НЕ, показан какой-то кусочек схемы, где, возможно, есть другие входы, воздействующие на А и В.

Если рассматривать в "троичной системе", то можно было бы простоить диаграмму так:

<a href="https://ibb.co/WkxfbWN"><img src="https://i.ibb.co/y6fqwnm/image.png" alt="image" border="0"></a>

Это могут быть и блоки, где мы просто рассматриваем влияние изменения значения одного из входов на его выход.

<a href="https://ibb.co/tm5pv8x"><img src="https://i.ibb.co/Vj8Yz2Q/image.png" alt="image" border="0"></a>

Что бы мы увидели на функциональном моделировании, где задержки равны нулю, или , точнее итоговый езультат выдаётся уже после переходных процессов:

<a href="https://ibb.co/SrQHy9t"><img src="https://i.ibb.co/L5QBR2x/image.png" alt="image" border="0"></a>

Посмотрим, к чему приведёт разброс задержек. Будем счтать что у каждого из элементов максимальная задержка. Тогда получим сдвиг:

<a href="https://ibb.co/S6dnRjr"><img src="https://i.ibb.co/Gdt2c6T/image.png" alt="image" border="0"></a> Выходной сигнал сдвинут относителльно входного на $t_1 + t_2$.

<a href="https://ibb.co/C2t2rGN"><img src="https://i.ibb.co/SrxrLCW/image.png" alt="image" border="0"></a>

Теперь будем считать, что включение (прееход в 1) будет максимальной заджеркой, а переход 1 -> 0 -- минимальный (выключение).

<a href="https://ibb.co/0GyNBGg"><img src="https://i.ibb.co/CHKdJHk/image.png" alt="image" border="0"></a>

Тогда длительность импульса при проходждении по цепочке может уменьшиться на $t_1 + t_2$. Когда сигнал проходит по цепочкам, он может свою длительность уменьшить, а если рассмотреть ситуацию наорбот, то увеличиться:

<a href="https://ibb.co/CMGyMmC"><img src="https://i.ibb.co/k9CT95b/image.png" alt="image" border="0"></a>

Вывод: при прохождении сигналов по цепочке элементов может меняться или увеличиваться на $\pm k\tau$ (где \tau -- задержка элемента) и сдвигаться на $k\tau$. 

Сигнал, когда проходит по цепочке элементов, может менять свою длительность или сдвигаться.


## Прохождение сигналов в длинных цепях

Рассмотри это же для длинной цепи. Рассмотрим две цепочки элементов: в одной цепи сигнал равен 1 и мы говорим, чтом меняетс только сигна А. Считая, что в одной чётное количество элементов, а в другой -- нечётное количество элементов, и проходя по сложной схеме, черз большое количество блоков, они встретились на одном элементе.

Для ФМ мы бы получили такую диаграмму:

<a href="https://ibb.co/9q7xNZ6"><img src="https://i.ibb.co/FBFQKH2/image.png" alt="image" border="0"></a>


<a href="https://ibb.co/c8Lcw8x"><img src="https://i.ibb.co/dpg0tp7/image.png" alt="image" border="0"></a>

Проходя по разным цепочкам (чт и нч -- для того, чтобы полярность сигналаб была разныя) сигнал может прийти в разное время

## Синтез комбинационных схем, свободных от состязаний

Рассмотрим такую функцию: $$F = X3 \overline {X1} \vee  X1 X0$$ Будет такая схема:

<a href="https://imgbb.com/"><img src="https://i.ibb.co/M6vW8gn/image.png" alt="image" border="0"></a>

Построим диаграмму для данной схемы, но не для всех наборов, а будем рассматривать переходы 15 -> 13 -> 15.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/r5pWgY5/image.png" alt="image" border="0"></a>
Кстати, можно заметить, что X2  в результате минимизации пропал.

Сначала строим элемент D1, он зависит только от X1. Вообще сложностей в построении тут быть не должно, потому что по сути меняется только Х1, а все остальные сигналы нравны единице.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/nsBwz8T/image.png" alt="image" border="0"></a>

Получили иголку на выходе.

Эта схема построена в базисе И-НЕ. Вообще говоря, каждый элемент тут это как блок, он может быть довольно сложнымЮ, просто мы рассматриваем случай, когда меняется только один сигнал, и он задержкивается в каждом блоке.

Как можно бороться с этими состязаниями с помощью диаграммы Вейча (визуальнвый или графический метод, карты Карно). Тут приведенена не диаграмм ВЕйча, а карта Карно. Оосбеноость карты Карно -- как правило, принято, что каждый соседний наобор отличается друго от друга только в оной переменной. Это же способствует код Грея

<a href="https://imgbb.com/"><img src="https://i.ibb.co/hC8TXdv/image.png" alt="image" border="0"></a>

<a href="https://imgbb.com/"><img src="https://i.ibb.co/RcD8y11/image.png" alt="image" border="0"></a>

Минимизация была бы такая. Но в зависимости от того, какой порядок наборов хадать, некоторые импликанты могут меняться, объединения могут выглядеть по разному (квадрат, вертикаль, 4 угла и так далее).

Попробуем понять, почему у нас было состязание при переходе 15 -> 13. Если мы посмотрим на эталонную диаграмму, 13 и 15 наборы принадлежат разным импликантам. При переходе из 15 -> 13 или обратно может быть состязание. Из-за перехода между разными импликантами, то есть между разными элементами по одному сигналу,  который, в свою очередь, может быть задержан и приходить на эти элементы не одновременно, возникает состязание. Предложено бороться с этим, вводя дополнительную импликанту, которая покрывает 15 и 13 одновременно:

<a href="https://ibb.co/6vRbzF2"><img src="https://i.ibb.co/gvMwNJG/image.png" alt="image" border="0"></a>

На выходе дополнительного элемента D5 у нас всегд будет 0.

<a href="https://ibb.co/MV6Rgq8"><img src="https://i.ibb.co/PhQ5rBT/image.png" alt="image" border="0"></a> 

Изменений не будет, так как туда входят X0 и X3, а они не меняются. А раз сигнал не меняется, то никакого состязания на F не будет.

<a href="https://ibb.co/K74v7mH"><img src="https://i.ibb.co/gwqKw6C/image.png" alt="image" border="0"></a>

Мы рассматриваем не все возможные состяния, а состояния А и В (пары состояний), где А = В.

Мы рассматриваем только стстические состязания. Среди них выделяются ри вида состязанй
- стсатические: когда два входных состояния отличаются только одной переменной (13 и 15 отличаются только Х1). Кадждая клеточка по горизонтали или вертикали в карте Карно дии диагфмме Вейча отличается тольок одно переменной
- логические: отличается не одна, а несколько переменных
- функциональноые

все они в целом тоже статические, то есть динамических тут нет

Логические - это подкуб (4, 8, но как правило, 4)

Статичесике: мы можем рассмотреть переход из 5 в 7 и из 7 в 5. Меняется одна переменная, то есть по горизонатли или вертикали.

В отчёте мы показываем не на одной ДВ, а на нескольких: на одной статтическеи, на твторой логические, на третьей фнукциональные.

Логические: когда переход из 13 в 11 или наоборот. Подкуб -- когда меняется две переменных: 9 - 15: меняется две переменных. Поэтому можно лишний раз повторить диаграмму Вейча в отчётах, чтобы это было видно.

На второй диаграмме Вейча будут только логические, статические не надо (они тут просто показаны). логические можно убрать, также покрыв их одной импликантой.

Функциональные -- в подкубе (например, 15 - 12) можно перейти напрямую, а можно перейти через ноль: 15 -> 14 -> 12.

<a href="https://ibb.co/KxtfHTf"><img src="https://i.ibb.co/RTXsWRs/image.png" alt="image" border="0"></a>

Рядом второй пример функционального из 11 в 8.

Но также если мы хотим перейти из 12 в 7, это можно сделать разными путями: как через единицы, так и через нули, поэтому подкуб этого перехода будет через нули. Это тоже будет функионцльное.

Подкуб перехода 8 - 3 будет вообще состоять из 16 элементов.

В ЛР отмечаем, предложено одно функциональное состязание, надо строить все функциональные состязания, которые проходят через 1- 0 по вертикали или горизонтали. Например, для данной карты Карно надо было отметить только 14 и 10 (два крайних правых перехода), а вообще их может быть много.

Для левой диаграммы надо было бы отметить в ЛР надо было бы отметить 7 - 4: из 7 вышли, перешли через ноль в четвёрку.

Функциональные состязания убрать не удаётся. Минимизировать их не можем, а статические и логические -- можно за счёт введения дополнительных импликант.

<a href="https://ibb.co/Fb6PXR7"><img src="https://i.ibb.co/tMBdzVC/image.png" alt="image" border="0"></a>

Можно поставить и три инвертора на схеме, если состязания получаться не будут.

Моделировать: задавать абор 15-13-15 через BUS, следующий 11-9-11

дальше просто отделяем

в подготвке так и строим: сначала одни статические, потом логические


потом добавляем схему без состязания. Можно строить не отедлньо схему без состязаний а просто добавить элеме5нты, а те же входы повтортиь

в логических 15-13 мы тоже попали на статическое состязание

потом получаем фунцкиональные состязанияЮ которые не удаляются. Их мы покрыть не модем, хотя его в принципе можно вдруг удалить (тут FG --- функция с гонками, F -- функция без гонок).

рядом в картах карно расписываем наборы для состязаний

рядом дугим цветом выдялем покрытия которые мы покрыли (анпример исходное значение, а потом как мы покрыли его чтобы убрать задержку)

Подкуб -- там где меняется 2 в степени количества изменяющихся переменных.

<a href="https://ibb.co/Gn7BcVm"><img src="https://i.ibb.co/LYSbnCK/image.png" alt="image" border="0"></a>

функциональное мы пишем не одно случайное состязание а все переходы через один ноль (15 - 12) или 4 -7 в левом нижнем примере, там можно перейти через ноль.

## Анализ комбинационных схем с целью выявления состязаний

Надо установить условия, при которых возможны состязания: нет ли каких-то иголок, которые могут помещать работе схемы.

## Методы устранения состязаний в комбинационных схемах

<a href="https://ibb.co/pRbKjnd"><img src="https://i.ibb.co/D8zMfLQ/image.png" alt="image" border="0"></a>

Схемы, свободные от состязаний, можно построить с помощью дополнительных импликант.

# ПЛИС
<a href="https://ibb.co/MkmzJvc"><img src="https://i.ibb.co/Zz0QbjB/image.png" alt="image" border="0"></a>


Многие рисунки взяты из книжки Угрюмова, номера оставлены.

GA (Базовые матричные кристаллы, вентильные матрицы). 

Одна из особенностей -- CPLD -- ПЛИС с внутренней энергонезависимой памятью, а в FPGA нужно после включения питания реконфигурировать кристалл, это  как в лабе.

Была ещё одна классификация. CPLD имеют много комбинационных схем, а в FPGA много элементов памяти -- триггеров.

Сейчас часто говорят от системах на кристалле. Современные ПЛИС это серьёзные устройства, в которых внутри самого ПЛИС можно реализовать ядра. В один из кристаллов, например, в спартан 6 , которые стоят на столе в лабе, можно записать два ядра со своим ассемблером. Поэтому если первоначально ПЛИС разрабатывались для того чтобы разрабатывать схемотехнические решения, то сегодня это реально существующие устройства. Но отличие ПЛИС от заказных БИС в том, что в ПЛИС все связи коммутируются, а значит, получаются дополнительные задержки на связях. Поэтому на ПЛИС будут другие временные параметры, а это может приводить и к неправильной работе, к тем же состязаниям. Внутри кристалла приходится учитывать отражение сигнала от конца длинной линии, и ставятся специальные согласующие схемы, чтобы сигнал не отаражался и не было наводок.

Минус ПЛИС в том, что всегда есть избыточность.

## Программируемые логические матрицы (ПЛМ)
Состоят из матрицы элементов И и матрицы элементов ИЛИ. Входной буфер образует однофазные сигналы в двухфазные. На входе X, на выходе X и $\overline X$, потому что буферы формируют необходимые сигналы по уровню и по мощности для матрицы элементов И. Внутри нужно обеспечить работу матрицы, поэтому буфер, кроме преобразования в парафазный сигнал, задаёт необходимую мощность.

Также есть выходной буфер, которые обеспечивать необходимую нагрузочную способность выхода (на сколько входов может работать выход схемы, это определяется входными и выходным током), разрешают или запрещают работу выхода сигналом ОЕ (Output Enable)
<a href="https://ibb.co/dk4xpKz"><img src="https://i.ibb.co/JrjgpkM/image.png" alt="image" border="0"></a>

Чтобы получить единицу в схеме, питание подключать напрямую нельзя. Для этого надо землю подключить на инвертор или сопротивление (примерно 1 кОм) от питания.

Схемы ввода-вывода обеспечивают согласование с внешними схемами и требуемый интерфейс.

Основные параметры ПЛМ:
- количество входов $M$
- число термов $L$ или импликант. 
- число выходов $N$

Каждому терму доступны все входы M. Каждая функция может содержать L термов.

Это может выглядеть примерно так
<a href="https://ibb.co/jRGhjj6"><img src="https://i.ibb.co/dg6BHHW/image.png" alt="image" border="0"></a>

<a href="https://ibb.co/S0Ph8gD"><img src="https://i.ibb.co/Nps8Pqg/image.png" alt="image" border="0"></a>
Вначале программирование заключалось в том, что те связи, которые не нужны (а изначально были все), надо было пережечь, но при этом она уже не восстанавливалась. Для этого на них надо было подать большой ток. 

Вертикаль -- элементы И (термы), кгоризонталь -- функции. Если какие-то функции не нужны, а нужны только три контакта, то три пемеычки в эмиттере осатвляем,  а остальные темры не участвуют.

Плюс у ПЛМ в том, что каждому терму доступны все входы и каждой функции все термы. Но это же и является минусом, если есть несколько термов и импликант, которые не используются.

<a href="https://ibb.co/mX8zJVF"><img src="https://i.ibb.co/nnCkrN8/image.png" alt="image" border="0"></a>

<a href="https://ibb.co/0fckvbF"><img src="https://i.ibb.co/khxpvC9/image.png" alt="image" border="0"></a>

ПЛМ способна реализовать N логических функций от M аргументов, содержащих не более L термов.


Рассмотрим реализацию скобочной функции на ПЛМ.
 $x_1x_2 \vee \overline{x_1}\overline{x_2}$ -- функция равнозначности& которая домножается на $x_3$. Мы её подаём на входы и уже этот выход домножается на $x_3$ и к нему же добавляется ещё эта функций. Таким образом, выход заводится на вход.
<a href="https://ibb.co/0fckvbF"><img src="https://i.ibb.co/khxpvC9/image.png" alt="image" border="0"></a>

<a href="https://ibb.co/bRPT6rL"><img src="https://i.ibb.co/840qmj2/image.png" alt="image" border="0"></a> Мы можем соединять выходе между собой, если на выходе есть монтажное ИЛИ -- третье состояние или отрктыый кооллектор. Элемент, показанный треуглоничком, имеет три состояния. Он может работать на выход. Есл запретить его работу, то с выхода другого элемента сигнал будет передан на вход. Этим элементом можно управлять ключом, который тоже является термом, чтобы можно было разрешить работу выхода в зависимости от каких-то условий.

## Программируемая маричная логика
<a href="https://ibb.co/GnWM3s0"><img src="https://i.ibb.co/k54D63x/image.png" alt="image" border="0"></a>
Было предложено ввести ПМЛ, чтобы побороть избыточность ПЛМ. Навряд ли найдётся много схем, чтоы в каждой функции были нужны все терым. Каждой функции, а их также N, доступны, например, только 4 терма.

Число входов M
Число выходом N
Число элементов И -- 4N. (в ПЛМ было L)

Rf;lfz aeyrwbz -- njkmrj 4 nthvf/

Менше гибкость и проще изготовление (меньше связей внутри проходит)

<a href="https://imgbb.com/"><img src="https://i.ibb.co/kDDC0Pd/image.png" alt="image" border="0"></a>

Если посмотреть на эти функции, эти термы являются инверсными. Мы можем рассмотреть не по единицам, а по нулям и тогда ввести только t9 и использовать t1, t3, t4

<a href="https://ibb.co/g6hVDWc"><img src="https://i.ibb.co/V35mvCk/image.png" alt="image" border="0"></a>

Так что можно строить минимизацию по нулям в таком случае. На выходе ставится ключ, который даёт при открытии 0 и на выходе будет F1, если его закрыть, то передастся единичка и элемент М2 (XOR) как управляемый инвертор подаст $\overline{F1}$. Там же видны и сопротивления выходного буфера для согласования мощностей и сил токов.

<a href="https://ibb.co/zmfhF5H"><img src="https://i.ibb.co/BfsVGPK/image.png" alt="image" border="0"></a>

На выходах удобно поставить xor, который позволяет выдать выход либо в прямом, либо в инверсном выходе. Так же можно делать на выходах регистра флагов в процессоре. Чтобы сократить связи, на выходе мультиплексора поставить xor. Это же можно использовать в блоке операций, когда надо заданные разряды проинвертировать.

Если 4 термов не хватает, то можно использовать разделение термов, но лучше называть это объединение термов. 

<a href="https://ibb.co/68Tq3hh"><img src="https://i.ibb.co/kJwPRnn/image.png" alt="image" border="0"></a>

Для этого предлагается добавить элемент И, который разрешает объединить две функции, и их передать на выход, управляя ключом. То есть термы от соседней функции можно занять. Аналогично можно скором сложить эти две функции и опять же передать на выход.

<a href="https://ibb.co/N9nhrDN"><img src="https://i.ibb.co/7nNcQMp/image.png" alt="image" border="0"></a>

Есть две функции, и их можно передать вверх или вниз, а от соседей верху или снизу тоже можно передавать термы. Получается, что каждая функция может содержать уже не 4 терма, как было изначально, а от 16 (4*4) термов. Условно показаны кружочки под мультиплексорами -- входу управления, но их нужно программировать. Эти мультиплексоры можно было бы заменить элементами И. Иногда идут даже на чуть большую площадь ради однотипности всех элементов, видимо, тут будет использоваться много мультиплексоров, хотя по сути это элементы И.

Опять, на выходе можно поставить ксор, который будет передавать прямой или инверсный выход

<a href="https://ibb.co/410jDNs"><img src="https://i.ibb.co/y4x8Msh/image.png" alt="image" border="0"></a>

Каждый терм, а терм -- это горизонталь, может быть запрограммирован от входов (вертикали). У каждого элемента И (терма) на данной схеме будет 68 (32 внешних + два для запоминания от предыдущей функции + контактная площадка ввода-вывода от третьего состояния) = 34 переменных + прямой и инверсный (входной буфер), который преобразует однофазный сигнал и парафазный. 

На правой части: стоит ксор, передающий прямой или инверсный выход, дальше функцию могли бы запомнить на D-триггере и выдать на выход через верхний контакт на мультиплексор.

Ксор перед мультиплексором перед триггером позволяет обеспечить работу D триггера, чтобы он выход передавал с инверсией на вход, то есть инвертировать вход триггера. Синхровход показан за счёт нижнего мультиплексора. он может быть общим (Синхр), который общий для всего кристалла (хотя на самом деле их может быть несколько), либо он может быть асинхронным, где мы с какой-то другой схемы можем сюда подать сигнал.

Это матричная ячейка. Таких матричных ячеек много.


<a href="https://ibb.co/vkrY2Ln"><img src="https://i.ibb.co/3c8ztSZ/image.png" alt="image" border="0"></a>


Логический блок (ЛБ) сожержит 16 таких макроячеек.

Буферы ввода-вывода БВВ

Локальные программируемые матрицы -- внутри логического блока. Есть ещё и программируемая матрица соединений. У них смысл один и тот же.

## FPGA (БМК) - базовые матричные кристаллы

<a href="https://ibb.co/Dkgp9nk"><img src="https://i.ibb.co/824crV2/image.png" alt="image" border="0"></a>



дз 

разработать устройство для перестановок:
4 входы двухразрядные
0А задаём нулевое значение 
1А задаём 01
2А задаём 10
3А задаём 11

4 двухразрядных шины

на выходе получить Y или F: 4 шины
0F ... 3F

последовательно с каждым тактом
на выходе после первого такта будет 3 2 1 0
потом 2 3 1 0 (1 0 не меняется)

пусть перестановки могут повторяться

тогда это будет 4! = 24 варианта

надо не просто схему, а подумать, как должна выглядеть схема, когда таких входов не 4, а больше

сначала нарисовать функциональную схему, а затем реализовать

и когда разрядов не 2, а любое количество (то есть каждый IA может содержать по k разрядов)

мы загрузили

можем считать что все 4 приходят последовтальеон (есть одна входная шина и мы  с неё загружаем сначала) а можно как будто они все сразу параллельно

по одной шине сначала в регистр записать 0А с помощью сдвигов потом 0В

сначала мы загрузили в какие-то регистры

можно ставить 4 разрядные для облегчения чтобы меньше связей проводить вместо двух отдельных триггеров

можно счётчики

мультиплексоры не подходят

простое решение: счётчик на мультиплексор. На 24 входа мультиплексора поставить счётчик, который будет им управлять, за это бан

схема работает 24 шага но мы останавливаться не будем и пусть она идёт бесконечно

вторая задача -- 8 разрядный вход А и задан трёхразрядный Y 
на выходе получить циклический сдвиг в КС, где Y указывает, на сколько разрядов надо сдвинуть

513 сдвиг вправо

<a href="https://ibb.co/SKsHC9p"><img src="https://i.ibb.co/sFmcYMr/image.png" alt="image" border="0"></a>

Впервые FPRGA как базовые мтаричные кристаллы появились в 1975 году как реализация нестандартных схем высокопроизводнтельных ЭВМ.

БМК -- совокупность базовых ячеек, при этом базовые ячейки могут быть разного размера: как квадрат, как прямоугольник и так далее. Между этими ячейками были так называемые каналы соединения. На периферии располагаются буферы ввода-вывода, которые можно было программировать.

Здесь приведён пример современных ПЛИС. Сегодня кристалл состоит из КЛБ, между которыми находится область соединений. По периферии кристалла располагаются БВВ с той же функцией.

У Virtex показано, что где были области соединений, между ними находятся на пересечениям матрицы переключений МП, между которыми отрезки. Матрицы соединяют горизонтали или перенаправляют сигналы на все 4 направления. Также есть длинные линии (условно показаны вверху и внизу, но они  идут по всему кристаллу между КЛБ), они проходят, минуся матрицы переключения.

Также показано, что, в отличие от того, что мы рассмативаем, есть ещё отдельные блоки памяти (RAM). Например, в спартане 6 из 20 штук ёмкостью 4К. Они устанавливаются на углам, поэтому память делится на три вида. Это 
- распределённая память --- память внутри КЛБ на LUTах
- отдельные блоки памяти ёмкостью 1-4К
- "Теневое ЗУ", которое выполняет всю настройку и конфигурацию. В нём задаётся настройка матрицы переключений и какое-то управление.

<a href="https://ibb.co/9p52yxt"><img src="https://i.ibb.co/qDQ9mH5/image.png" alt="image" border="0"></a>

Внутри КЛБ находятся регистр и функциональный преобразователь ФП (или по другому логический преобраователь) и мультиплексоры, которые настриваются на работу тех или иных регистров и функций.

Также показаны области межсоединений.

Из вводной работы

<a href="https://ibb.co/M91KmXX"><img src="https://i.ibb.co/GFMGqhh/image.png" alt="image" border="0"></a>

Загрузка при конфигурировании идёт именно битовая, то есть через всего одну ножку. Поэтому есть вероятность, что может произойти сбой.

В рабочих версиях FPGA может находиться ПЗУ, которое загружает нужную готовую конфигурацию не из ЭВМ.

### Реализация логических блоков

<a href="https://ibb.co/StD8mN4"><img src="https://i.ibb.co/Mcy41nx/image.png" alt="image" border="0"></a>

Функциональность: можно ли реализовать оперативную память с такими-то характеристиками, можно ли реализовать функцию от 60 переменных или только от 20 и так далее.

На мультиплексорах также можно реализовывать любые функции, задавая на информационных входах нули или единицы, или задавать функции на основе LUT.

<a href="https://ibb.co/ykdHygd"><img src="https://i.ibb.co/M1ZFVPZ/image.png" alt="image" border="0"></a>

Это пример реализации функции на транзисторных парах. Здесь показано, что каждая пара отвечает за реализацию какой-то части логических элементов. Мелкими элементами получаем крупное устройство. Это зернистая структура с точностью до транзисторов.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/pyqVtqS/image.png" alt="image" border="0"></a>

Это вариант реализации на регистре. Если записать на него разную информацию (например, 0110), то в этом случае при 0 на выходе А будут закрыты 1 и 3 транзистор, а 1 на инверсном откроет 2 и 4. Аналогично 0 на В закрывает 5, 1 открывает 6. 

При двух нулях передаём 0 (пунктиром), также можно перебрать и другие комбинации. Если порассуждать, то при записи такого кода мы получим A xor B. То есть в теневое ЗУ для управления этими транзисторами можно получить такое число. На экзамене надо подумать, что записать в регистр, чтобы получить другую функцию, например, ИЛИ или И-НЕ.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/ykqGR3F/image.png" alt="image" border="0"></a>

На мультиплексорах, задавая значение на входах (это записывается в конфигурации, мы за счёт подачи переменных на входы мультиплексора, можно получить функцию. Утверждается, что так можно получить любую функцию от трёх переменных.

<a href="https://ibb.co/nCyTQmb"><img src="https://i.ibb.co/vYWbLqH/image.png" alt="image" border="0"></a>

В КЛБ входят три LUT F, G и H. LUTы или ПЗУ F и G имеют ёмкость 16 в 1, H -- 8 в 1. Таким орбазом, на каждом из LUT можно сгенерировать логическую функцию.

Также  показаны два триггера. За счёт мультиплексоров можно выводить на выход разные значения. 4 выходы: два выхода с триггеров и два выхода комбинационных. Таким орбазом, мы можем вывести G или H  с Y. На X мы можем вывести H или F. С входа информация также может быть передана на любой из триггеров.

Информационные входы : 4F, 4G b 1H. Выходы с G и F можно передать, программируя связи, на входы H, поэтому на H будет функция от трёх входов.
 
На каждом F-LUT или G-LUT можно реализовать функцию от 

<a href="https://ibb.co/hWGj7C4"><img src="https://i.ibb.co/Xsng2VK/image.png" alt="image" border="0"></a>

На КЛБ можно реализовать две функции от 4 переменных. 

Некоторые функции от 9 переменных: если взять все входы 4F, 4G и 1H.

Как можно было бы реализовать функцию XOR5 на F, G и H: разбить на две части: на F реализауем одну часть таблицы, на G -- другю части таблицы и за счёт управления пропускаем либо одну часть либо другую

<a href="https://ibb.co/zhBNr2b"><img src="https://i.ibb.co/hR4CydH/image.png" alt="image" border="0"></a>

Сколько входовой мультиплексор можно было бы реализовать?

Понятно, что 8 входов нельзя (много). Например, можно ли реализовать 7 входов -- а МУХ это тоже функция, на одном КЛБ? Его можно разбить на две части: кадждый четырёхвходовой, а S0 выбирает либо верхний либо нижний мух

<a href="https://ibb.co/SRzFBTy"><img src="https://i.ibb.co/t89VDfK/image.png" alt="image" border="0"></a>
В сборнике задач приведена другая таблица загрузки.

На экзамене будет вопрос: сколько нужно клб/как будут использоваться луты чтобы реализовать например мультиплексор 8 в 1, дешифратор 4, ксор16 и так далее.

На КЛБ реализуются любые функции за счёт записи таблицы истинности в эти три памяти.

<a href="https://ibb.co/C7pPwFc"><img src="https://i.ibb.co/cFKYydB/image.png" alt="image" border="0"></a>

Сейчас внутри находятся уже 6-входовые луты, то есть каждый из них реализует 2^6^ . Три лута, набор мультиплексоров, управление триггерами и что передавать на выход. Показано, что можно устанавливать триггеры в 1/0; в помощью мух 7 и 8 можно реализовать работу триггеров либо по фронту, либо по спаду синхроимпульса. Но раз стоит мух с инвертором, то это сигнал задержится. Синхро буте приходить по разветвлённой цепи напрямую, минуя коммутации, но тут уже задержится.

9 и 10 позволяют выключить вход СЕ, подав на него всегда 1. И синхровходов может быть не один (С1..С4 вверху).

<a href="https://ibb.co/sbX9SY0"><img src="https://i.ibb.co/zQtVcvy/image.png" alt="image" border="0"></a>

16х1 память: 16 -- количество адресов, 1 -- количество разрядов.
<a href="https://ibb.co/jfFsHWJ"><img src="https://i.ibb.co/bmnD72b/image.png" alt="image" border="0"></a>


### Программируемые соединения

<a href="https://ibb.co/YywmxS0"><img src="https://i.ibb.co/Tbd6sGW/image.png" alt="image" border="0"></a>

Линии двойной длины идут через одну матрицу, чтобы вдвое повысить быстродействие.

Длинные линии либо подключаются к данному КЛБ или нет, к матрицам они не подключаются.

Тактируемые линии для того, чтобы сигнал дошёл одновременно к ближним и дальним КЛБ, минуя матрицы переключения, должны двигаться так, чтобы путь был одинаковый, поэтому путь может быть достаточно запутанным.

<a href="https://ibb.co/pnsC5rL"><img src="https://i.ibb.co/HXMm3pH/image.png" alt="image" border="0"></a>

<a href="https://ibb.co/wRVNnbT"><img src="https://i.ibb.co/G0yvZ1X/image.png" alt="image" border="0"></a>

Около КЛБ находятся буферы типа BUFG для подключения к длинным линиям, они не входят в состав кристалла.

<a href="https://ibb.co/HCV9Q2p"><img src="https://i.ibb.co/8b0QVB4/image.png" alt="image" border="0"></a>

6 ключей: он разрешает работу и тогда работает как замыкание, иначе между контактами большое сопротивление типа кОм -- размыкание.


Соединение контактов внутри матрицы: открытие/закрытие ключей

<a href="https://ibb.co/0GnnC52"><img src="https://i.ibb.co/4VFF8kt/image.png" alt="image" border="0"></a>

Чтобы записать информацию в триггер, надо в режиме конфигурации выбрать этот триггер, а потом записать. Этот процесс итеративный. Можно по одной линии сразу выбрать несколько транзисторов, если будет много линий записи/чтения, но в общем случае запись идёт по одной линии.

<a href="https://ibb.co/7C3n42p"><img src="https://i.ibb.co/XLn78S5/image.png" alt="image" border="0"></a>

Снижение напряжения питания до 1В уменьшает задержки

500 пользовательских выводов. Кристалл под стеклом на макете имеет 84 ножки. Кристалл остался того же размера, может, даже меньше, чем в макете, ножки будут находиться под кристаллом, и для припайки в плате контактные площадки имеют углубление со специальным вещество, ПЛИС нагревается и как будто приваривается.

удалить из таблицы назначения функциональных элементов $\varphi$

игреки рисуем для одного примера умножения и одного примера второй операции

все шины внутренние надо будет выводить


# Запоминающие устройства

<img src="https://i.ibb.co/vhhwcm3/image.png" alt="image" border="0">

Не забывать, что у памяти, как у регистров, основной режим работы -- режим хранения, а также чтение и запись, а также в динамической памяти, так как она на конденсаторах, нужен режим восстановления информации (внутренний, пользователь его не использует), так как конденсаторы всё время разряжаются.

Память, как правило, многоступенчатая, и имеет иерархическую структуру
- РОН (регистры общего назначения). Они находятся на кристалле вместе с процессором, их, как правило, порядка 32. Количество разрядов адреса зависит от количества адресов как $\log n$. Поэтому 32 разрядная память требует 5 разрядов шины адреса.
- Кэш память (могут быть 4 уровня). L1 -- самый верхний, и, как правило, вместе с процессором находится на кристалле. В зависимости от архитектуры -- Неймана или гарвардской, L1 делятся на две памяти -- памяти инструкций и памяти данных, а у Неймана память одна. Остальные уровни кэш памяти, как правило, единые. L4 может реализовывать обмен уже не только с ОП, но и с внешней памятью. Отличие кэша от ОП заключается в том, что 
- Основная память -- под ней всегда понимается ОП, но может быть и ПЗУ, выделенная отдельно, в которой могут храниться постоянные части программ, которые не меняются. ПЗУ может быть и полупостоянной, или ППЗУ (перепрограммируемое ЗУ, которое можно перезаписывать), или могут быть масочные ЗУ, которые изменить нельзя.
- Специализированные блоки памяти
- Внешняя память -- внешнее запоминающее устройство.

По быстродействию: чем ниже в иерархии, тем быстродействие ниже -- как правило, говорят, где-то на порядок (больше 5 раз). По ёмкости, наоборот, чем ниже, тем выше.

Процессор работает только с кэш-памятью. Он обращается просто к памяти. По определению программа и данные хранятся в основной памяти, но для того, чтобы поысить быстродействие процессора, часть ячеек основной памяти переписывается в кэш-память по уровням, но обращается процессор всегда к первому уровню L1, если первого уровня нет, то ко второму L2 и так далее. Минимальная величина обращения -- байт или слова, а обмен идёт не байтами или словами, а блоками -- 64, 128 байт и так далее. Из ОП постоянно перемещается информация в кэш-память по уровням, и обратно, та информация, которая не нужна, возвращается обратно. Они могут не совпадать, если мы в кэше изменили информацию со стороны процессора, и не успели её переписать в ОП, так что за этим нужно следить.

<a href="https://ibb.co/vHk0tsD"><img src="https://i.ibb.co/QfMy58X/image.png" alt="image" border="0"></a>

К любой памяти мы обращаемся по адресу в работе обычного процессора, кроме третьего --  там адрес выступает в качестве признака. 

В адресных ЗУ задаётся адрес, они могут быть с произвольной выборкой, так как адрес произвольный.

В динамической памяти у любого конденсатора есть токи утечки: есть паразитные сопротивления, по которым заряд стекает с конденсатора. Нужно периодически (через несколько мс) восстанавливать (регенерировать) информацию. Сейчас это 16 мс -- через 16 мс каждый элемент памяти нужно восстанавливать. Поэтому регенерация, восстановление идёт построчно, иначе если бы у нас был Гб памяти, мы бы не успевали обновлять всё. Восстановление идёт так: мы считываем память и потом её перезаписываем. При обращении к динамической памяти, так же как и в ферритовых сердечниках, информация разрушается и её надо перезаписывать и восстанавливать. Но зато основное достоинство ферритовых сердечников по сравнению с интегральными микросхемами -- устойчивость к радиации. При помехах, а они всегда будут при переключении, если переключаются много элементов в кристалле. могут быть большие скачки, которые могут приводить к случайному переключению триггеров.


ЗУ с последовательным доступом -- это некоторая очередь. Примеры -- магнитная лента, диск. В диске или в магнитной ленте мы всё равно задаём нужный нам адрес, но чтобы дождаться этого адреса нужно ждать, пока мы пройдём по этой ленте. Поэтом время обращения будет содержать время поиска информации и время считывания информации. В случае диска головку ещё нужно переместить на нужную окружность и в среднем прокрутить пол-диска.

К FIFO и LIFO мы обращаемся уже не по адресу, а по порядку записи и порядку обращения. Поэтому говорят, что это безадресные ЗУ. Если в качестве ЗУ будет диск, то там обращение по адресу.

Ассоциативные доступ: поиск информации осущеслвяется по признаку. Пример -- кэш-память. Если в адресном ЗУ мы знаем, где находитя нулевой адрес, где первый, k-тый, k+1-ый, 2^n^ и так далее, то если нам нужно обратиться по адресу, мы указывем номер строки и столбца. С точки рения процессора в кэш памяти тоже обращаются по адресу, но он вытсупает как признак -- то есть сравнение адреса идёт по рпризнаку который хранятся в кэш памяти. Поэтому данные с одним и тем же адресом могут располгаться в ранх местах кэш-памяти.

Ассоциативное ЗУ: снимать информацию можно с датсиков и записываться информацию может в виде номер датчика: значение ва при считывании можно считать всю минформацию по первому датчику, при этом из памяти можноет быть не однозначное считывание а нсколько но зная весь алгортмм считывания можно выдать только по однмому датчику. То есть в качестве признака может выступать номер датчика.

С точки зрения пользователя ППЗУ переписываются в служебном режиме, не когда обрабатывается его программы, поэтому они называются ROM. Раз у них нет режиме запаиси, они будут к тому же и быстрее.

Циклы записи значительно медленне, чем чтение. Они могут быть примерно на пол порядка (условно в 5 раз) медленне. поэтому если даже и записываем,, то записываем в каком-то другом слежубном режме.

Была память с УФ считыванием. Сбоку микросхемы могла быть прозрачная лупа, через кторую можно было стироать информацию, влопоть до того, чтобы могло солнце стирать информаци. и приходилосб 
ту стеклянную лупу заклеивать изолентой, а при переписывании информацию эту микросхему можно было подержать на солнышке, стереть её и записывать её не на работающей плате, а ставить её в отдельный программатор и боращение было 25 мкс (а обычно порядка сотни нан). То есть стараются ППЗУ делать так чтобы она слуайно записалась не на платах, потому что любое ППЗУ имеет ограниченное количество циклов перезаписи. Если бы оно было не огр, это было бу обычным ЗУ.

ПЗУ при отклюючении сохраняют информацию. Это порядка 100 тысяч перезаписей, но при включении режиме записи вся память исчезает, поэтому нужно программиорвать в других условиях.

Флеш память тоже имеет ограниченное количество циклов поэтому её надо заменять, а ещё она может перегреваться. Чем больше объём памяти, тем больше она нагревается.

<a href="https://ibb.co/mNf4zLv"><img src="https://i.ibb.co/cY4QTGb/image.png" alt="image" border="0"></a>

Как правило, это аппаратные затраты и быстроедйствие. 

- инф ёмкость: важно обращать внимание, в чём она может храниться. Может храниться в битах, байтах, словах, ячейках -- то, что считывается из физической памяти за одно обращение. Минимальный адрес сейчас везде в процессорах доступен до байта. Но в задании написано, что память 16х8 (прозвдение числа ячеек на разрядность памяти). То есть у нас 16 восьмиразрядных ячеек. Обычно это количество байт. Например, 4Гх8 -- это 4 гигабайта, но она же хранит не 4 Гигабайта. а 2 гигаслова. Также можно было сказать не 4ГБ, а хранит 32 гигабита. А можно сказать и в ячейках -- ячейка это сколько считывается за одно обращение. У всех будет 16 слов на 8 разрядов, а регистрова память 8х4, то есть минимальной единицей будет не байт, а полубайт, а 4 бита, чтобы уменьшить шину для наблюдения. Чтобы обратиться к гигабайтам, нужно, чтобы шины имела 30 разряда. Для 4 ГБ адресная шина должна иметь 32 разряда. 
- Быстродействие оценивают временами на чтение (её надо выдерживать на выходе, потому что её надо куда передать), плюс цикл включает время восстановления шин -- внутри какие-то усилители, поэтому цикл это время между двумя последователными обращения, это не одно и то же что время чтения и записи по отдельности. Поэтому говроят быстроедйствие , но под производительностью часто понимают количество байт в секунду, сколько байт в секунду можно передать, но это чаще о канале передачи.
- Время считывания -- интервал между моменто обращения или когда выставляется адрес и моментов выдачи данных на выход
- Время записи -- задали чигналл для записи и установили данные и когда она будет записана
- Цикл -- интервал между двумя обращениями на запись или на чтение. Нужную информацию при считывании надо выдерживать + на восстановление, активацию и деактивацию шины + на димемической памяти регенерация.
- Время за первым обращением: в странчичной памяти, когда певе обращение долглое, а следующим значительно быстрее.
- Bandwisth -- акогда мы выдаём пакетом или страницей данные, это время передачи уже последующей информации в последнующие обращения


<a href="https://ibb.co/bQXw0r1"><img src="https://i.ibb.co/vVkyFJ1/image.png" alt="image" border="0"></a>

<a href="https://ibb.co/QrLH9K8"><img src="https://i.ibb.co/XS15XCy/image.png" alt="image" border="0"></a>

память хранит данные ⇒ должны быть входы для записи данных, которые с точки зрения постоянной памяти могут быть отсутствовть , если бы был ROMю

далее адресные -- логарифм от количества аресов. Если у нас известно количество разрядов адреса то количество ячеек (первая цифра в организации памяти, скольок мы считываем за одно оращение -- мгут быть однобитные или многобитные).

один адрес указывает на количество адресов ячеек

потом количество разрядов данных

и далее как минимум если есть два режима памяти -- запись и чтения то как правило указывется режим write (запись). В данном случае запись будет выполняться. Раз вход прямой, то надо задать единицу на этом входе для записи.

Есть также инверсный вход CS (chip select), он идёт по уровню, потому что нет фронта. Запись и обращение к памяти идёт статически то есть запись идёт при нуле -- когда CS равен 0, то мы записываем.

Тут есть ошибка в обозначении слева: у DO (data output) тоже должно быть m разрядов, потому что записывается в DI (data input) m разрядов

<a href="https://ibb.co/qdtLkgM"><img src="https://i.ibb.co/0cgph9j/image.png" alt="image" border="0"></a>

Здесь показа цикл чтения. CS показан инверсный, так что если он равен 0, то мы будем обращаться к памяти. Входы CS -- это входы выборки разрешения или дешифрирования, разрешают объединять между собой несколько кристаллов.
 R/W -- вход read/write выбора операции
В данном случае показан цикл чтения, в отличие от предыдущего варианта. Раз написан цикл чтения, то R/W устанавливается в единицу. Но всегда лучше иметь чтение в виде единицы, как здесь.

CS разрешает обращаться к памяти, по нему начинает выполняться операция. Адрес нужно установить заранее до начала уровня chip select, поэтому есть время предустановки адреса относительно CS. Если он придёт позже, значит позже выйдет информация.


Задаём сигнал R/W (лучше считать его ввсегда равным единице), но если будетс тоять 0 мы можем начать запись в неправильнымй режтм, поэтмоу лучше чтобы он находился в режме чтения и только иногда  взсписи.

DO  -- данные могут быть получены через время одступа или вемя выборки отноистльено А $t_A$, но они могут быть получкены также относительно CS. Кажется, задаём одни и те же данные. но если адрес мы подали намного раньше, чем CS, то данные то мы раньше не получим, мы их получим по CS. потому можно считать данныве выборки имено отноитсльеон CS. Но надо Надо знать эту характеристику tA, потому что мы адрес можем подать и позже в сулчае чтения, поэтому данные будут получены через время выборки относительно адреса. Для записи это неудачно, потму что если мы подали паавильный адрес позже, мы можем сначала записать данные в неправильный адрес,  а потом уже тлькло в правильный.

Надо понять, что есть время доступа относително адреса, время оступа относительно чип селект. Данные появились на выходе --  а до этого показано что они в промеуточном состоянии, а упамяти, как правило, выход с третьим состояниям или тоткрытым коллектором, то осначлаа данные нахоодятся в ретьем состоянии перелюкчаются, и зная когда эти данные пбудут получены мы выдержимваем эти данные чтобы они передались куда-т дальше, и через какое-то врем данные снимаются и пропадают. Цикл обращения: первое обращение когда мы можем податьа следующий адрес или следующее обращение. Когда снимается CS, с шины исчезает информация.

В паспортных данных:
- время предустаонвки должно быть больше паспортных данных
- время удержания должно быть больше паспортных
- время доступа гарантируетс, что будет не более паспортных
- время считывания -- не более (то есть там показана максимальная задержка) (<=), если они буудут выдержаны требуемое время

Запуск часто идёт по CS, потому что адрес мы снимаем с счётчика, а его выходы в свою чоередь могут меняться не одновременно, поэтому после последнего переключения выходов счётчика мы мовыдержимвем время на паямти и уже включаем CS. При считывании это не страшно, можно считать потом уже по парвильному адресу.

Могут быть несокльок разрядов адреса и несокльок разрядов данных.

Здесь считывание идёт **по уровню**: пока стоит уровень на чтение, информация стоит на выходе. Сняли чип селект -- информация пропадает.

Псколько память для больших количества разрядов, то у кристалла должно быть, например, 30 ножек на адрес. Поэтому ввели такое понятие и не толко адля адреса -- мультиплексирование -- последовательная передача чего-то. В даном случае это последовательная ередача адреса. Он развбваивается на две части и сначлаа предаётся первая часть, ва потом вторая. При этом вводятся два строба -- строб строки и строб стшолбца. То есть оподаётся половина разрядов адреса, которые принимаем по стробу. потом по тем же адресным шиным передаётся вторая половина адреса и она стробируется по CAS. (правая схема)

<a href="https://ibb.co/16zYdMR"><img src="https://i.ibb.co/vYXCQhL/image.png" alt="image" border="0"></a>

В общем случае мультиплексоировние может быть и в процессорах: по одной многоразрядной шине могут передаваться и адреса, и данные последовательно. Может быть всего дона шина данных, по которой передаются и данные, и шина, котонечно, в быстродействующих процессорах это не проводистя, но лишние шины это лишняя площадь. В том улсчае падает быстродействие, потому что мы передаём адрес и данные не паралельно, а за два сигнала.Тут нарисовано что WR, RAS и CAS работают по нулвому уровню


Здесь уже три сигнала -- два строба адреса и один сгнал обращения. Стробы адреса могут использоватся для дешифрации: если мы подадим только RAs, а CAS не передадим, то информация передаваться не будет

Вкертикальный ромбик с подчёркиванием снизу--- это выход с третьим состоянием

<a href="https://ibb.co/PmrKC41"><img src="https://i.ibb.co/bW6TdLN/image.png" alt="image" border="0"></a>

Здес связи нейдачно: от адреса вверх пошли потом вниз точне адрес ужобнее было бы показать егде-то по середнине


по адресу устанавливается адрес строки (AR) который должен опережать фронт

установили адрес-- это  адрес как правило всегда должен принматься во внутрениий регистр памяти регистр адреса сроки

потом мы выдерживаем это чтобы в регистр приняли

потому адрес начинвает менятья пожтому между этими состояниями показана неопределённость

далее утсанавлвисят адрес стошбца по тем же адресным шинам который относительно каса должен быть предварительно выержан и удержан

по касу начинается считыывваание и через время стрелочки к DO на выходе появляются данные

эти данные могут зраниься определённое врем -- пока не снимем либо кас, либо рас.

установили по расу адрес строки, по кссу адрес стобца и считывание начианестя от каса польскоу он позже

если же мы подали запись, то здесб показано шина D это и вход и выход то есть это как DIO ( D input output то есть там есть третье состояние

на шине данных устанавливются данные инпут поторкые будту записываться по касу

н для этого заранее устанавлиаестя режим записи (подкаскзка что запись идёт пи инверсном сигнале по нулю)

w опережает кас но часто он должен поступать послже кас. могут работать по последнему что позже придёт -- кас или r/w

если r/w прихоит раньше то не будте записи пока не придёт кас

если позже -- то сначала пойдт режим чтения и только потому будут записываться

но важно что данные должны прийти ранше w но их можно и даржеть пока не закончится цикл записи то есть даные можно держать пока кас или рас не снимется.

может быть что они наоорбот могут не опрежеать а поскльку запись выплонятесч по уровню как в статических ЗУ то данне должны быть выдержаны не раньше а до снятия кас или рас то есть время предустановки надо мерить односительно снятия сигнала записи поэтому время должно не опре

если подать позже то сначлаа запишем неправильные даныне но раз мы их выдержимваем то в итоге запишутся правильные

эти данные могут не приниматься на регистр а держаться на входвх памяти до снятия кас/рас

в режиме регенерации показан один из подходов здесь но там есть три похода -- задаётся троска мы как бы полувыбрали данные -- мы выбрали данные но на выход не передели потому что нет столбца. Этот режм ерегенерирует всю стоку. то есть когда подан кас но не подат рас

в режиме запис  и чтения тоже происходит регенерация всей строки: когда мы обращаемся к первой строке при любобм обращении вся строка считывания

дальше в оддном стоббце только записываются новые данные а в томтот момент всео остальые данные восатсстанавливаются

при счтиывании мы считали всю строку, из одного с тлбца передали данные на  выход но вся строка при этом восстаналивается

поэтлому регенерация осуществлятся при любом обращении к памяти либо принудмитьеьно но в этом момент может апрещаться обращение к памяти

можно обращаться за первым анными а дальше а=даавать дадрес следующего сотолбца то есть выдерживать только адрес подават нескольок касов и буде страничное отображение

на схемах показано однопоротоваяпамять, но меожет быть многопортовая. Порт -- это адрес и данные, которые мож=гутбыть на боращения не запись. Каждый порт может обращаться на запис и чтнеие, а может быть оидин только зна запись, а другой только на чтение.


<a href="https://ibb.co/ZBf3ZDZ"><img src="https://i.ibb.co/c6yPmnm/image.png" alt="image" border="0"></a> Регистровый файл или двухпоротвая память

<a href="https://ibb.co/m6Ks9Bv"><img src="https://i.ibb.co/bzVhs3H/image.png" alt="image" border="0"></a>

у неё два порта -- один адрес на чтение, другой адрес на запись, есть RD  WR то есть два порта у одного а чтениеу другого на зспи



и данные которые записываются 

на схеме регистрового файла показана ёмкость памяти как её можно определить определить можно по разрядом показано что етсть два адреса на запись WA и WB, два адреса на чтение RA и RA=B на чтение и внутри есть 4 регистра

мы можем считать из этих регистров информацию. Кадвй из регистовв хранит иформцию разрядностью 4 (разрядаонтсь вхондных данных 4 выходных тоже 4)

справа стоит мультиплексор 4 в 1 с третьим стосоянием

передаём на выход когда есть стигнал RE -- разрещешение выхода

4 ргеистра поэтмоу в организации памяти это памятьт 4х4 (4 первых это количество ячеек или 4 адреса) умножить на 4 -- 4 разряда.

Один порт на чтение, а другой портт на запись то есть как записать входные данные в один их жтих регистров

Внутри регистров стои тэтелемнт И который разрешает записывать

адрес регистра задают WA WB и также есть вхд WE инверсный вход разрешения записи

это пример двухпортовой записи ёмоктьсю 4х4 где ук каждой из них есть порты на чтение и на запись и соотвтетсвюущие входы разренеия.




усолвно можно говорить что WA WB это на входе стоит дешифратор со входом рещерешения WE который разрешает аработу одному из регистров

у него могут быть режимы

мы можем писсать по удресу WA 

можем считывать одновременно из другого адреса потому что есть свои разряды адреса -- по одному пишем, по другому считываем

если мы зададим один и то  же адрес, мы сможем одновременно и писать, и считывать ти тоогда на выходе через некотороя время появятся новые данные


треуголник в МХ это выход с открытым коллектором


если бы каждый порт бы и на запись, и на чтение, то внутри этого пблока должны быть должен был быть ещё один элемент в составе памяти -- арбитр,  который разрегшает работать одному из портов или нет. Например ,  если мы начали рзапись по первоум порту и пытвемся азапись по второму, то должен стоять арбитру, который будет выдержитвать время записи по первому порту, а ворой ждёт. В примере на схеме арбитр не нужен, потому что порты ненезависимые

однаоко устроств

также надо смотреть на приоритеты: если пришло приоритетное оращение (как в прерываниях), ото нужено дождаться, пока закночится цикл обращения или цикл выполнения команды, а если это цикл в конвейере, то нужно очистить конвейер, а это не просто сброс, потому что мы могли ещ1ё и в бфер записать информацию.

Буфер FIFO -- устанавливаюстся межжду двумя устройствами, которые обладают различным быстродейтсвием. Если бы бы отдельный буфер, на вход поступает ниформация с одной скоростью и одним временем, а на выходе данные с другой сткоростьюю.

WR работает : устаналивается адрес для записи на счётчике (сначала мы их обнулили), записываем при обращении в нулевой адрес при этом после этого адрес изменился на единичку. Пришёл следующий сигнал на запись, мы записали в перво вторую чячейку, арес увеличился и такдалее.

Если мы обращаемся на считываени, первым мы считаем, что пришло на нулевой арес, потму адерс считывания опять увеличивается.

То есть адрес записи идёт, а за ним "гонится" адерс для считывания.

Дальше адрес считывания может догнать адрес записи Он может его начать опережать, и как тольео они совпадут и если работает режим на чтение то монжно сказать, чт буфер пуст и выдатся флаг буфер пуст.

ЕИЛи наоборот, если мы не успеваем считывать информацию из буфера и опять у нас адеса сопвали при записи, то сообщеается, что буфер полон и запись остааналивается.

<a href="https://ibb.co/R2Y0znw"><img src="https://i.ibb.co/y0dyWTj/image.png" alt="image" border="0"></a>

адрес из кторого мы считыванием называется вершиной стека,вторая характеристика -- глубина стека это скольЗаписыываем данные WR пришёл, даные записали в стек и при этом мы не меняем адресю Если мы считываем мы из этого же адреса данные считыве.

Пришли новые данные, мы увеличивли счётчик и происходит запись наовых даных.

А перед этим можно было вычесть единичку

то есть вершиныа всегда достна

если идт несоклько записей, то

то еть работает реверсивный счетчик

инкрсменет INC что мы пишем на один адрес меньше



к эказмену подумать как можно было бы на регистре сдвига реализовать АШАЩко данных мжно записатю. здесь достаточно уже не два счётчика, а оин.

# Типы выходов элементов

<a href="https://ibb.co/C0z2g6t"><img src="https://i.ibb.co/DKtphYb/image.png" alt="image" border="0"></a>


В лабах мы привыкли использовать логические выходы. Но на лекциях было упомянуто, что могут быть ещё два выхода: с третьим состоянием и с открытым коллектором, которые иногда называют монтажным ИЛИ, то есть когда выходы между собой можно объединять. По этой причине хилинх не проверяет объединение выходов.

### Логические выходы

<a href="https://ibb.co/5xBtsmN"><img src="https://i.ibb.co/k6QkqjR/image.png" alt="image" border="0"></a>

Есть несколько входов, предварительные каскады. Важно, что на выходе находятся два транзистора А и Б и диод, чтобы между ними не проходили помехи. Всегда в обычных стандартных логических выходах управление работающими в режиме ключа транзисторами (могут быть открыты или закрыты), всегда  логическом режиме один из этих ключей открыт. При этом если открыт верхний, то ток идёт от питания на входы других элементов. Если отркты нижний, то, наоборот, приходит ток от другого элемента. 

<a href="https://ibb.co/Bf033GZ"><img src="https://i.ibb.co/wd5gg7W/image.png" alt="image" border="0"></a>

Аналогично показаны два транзистора и ёмкость. Далее показано, что один из транзисторов Т1 и Т2 всегда открыт, а другой закрыт.

Когда управляем выходами, один из транзисторов надо закрывать, а другой открывать. Но, как следует из состязаний, одновременно это не происходит, поэтому всегда может происходить ситуация, когда они оба закрыты или открыты. В момент переключения из 1 в 0 ток может проходить напрямую через оба атранзистора, при этом могут быть токи заряда или разряда ёмкости ==> могут быть большие всплески тока. Этого в осциллографе мы почти не наблюдали. Если бы мы подключались к этим транзисторам напрямую, мы бы увидели, что выбросы напряжения могут быть даже больше напряения питания, которые могут приводить к выходу из строя.

Чтобы не было этих состязаний и токов, предусматривают определённые переключения, чтобы снизить сквозной ток.

### Выходы с третьим состоянием
<a href="https://ibb.co/vxLz2D7"><img src="https://i.ibb.co/nsQkhRH/image.png" alt="image" border="0"></a>

Вводится дополнительный вход, который закрывает оба транзистора. В третьем состоянии по сигналу ОЕ оба этих транзистора закрыты. Часто выход обозначают буквой Z и говорят, что он находится в высоком сопротивлении. Если транзистор закрыт, то между И и С большое сопротивление, то есть между питанием и землёй большое сопротивление, а,  следовательно, малые токи. Поэтому выходы таких элементов можно соединять между собой.

<a href="https://ibb.co/3S5zLPP"><img src="https://i.ibb.co/P1sQfVV/image.png" alt="image" border="0"></a>

Выходы в третьем состоянии можно соединять между собой, но всегда должен быть открыт только один выход. То есть должны быть отключены все выходы (подан соответствующий ОЕ), и разрешение подано только на 1.

Если откроется случайно более одного выхода, то выходной ток будет практически ничем не ограничен, так как не будет ограничительных сопротивлений -- если их поставить, то будут меньшие токи, а значит, меньшее быстродействие, а также эти сопротивления будут занимать лишнюю площадь.

<a href="https://ibb.co/7jH4Dxz"><img src="https://i.ibb.co/Cmq2ypt/image.png" alt="image" border="0"></a>

Из-за того, что должен быть включён только один выход, иногда уже не говорят, что это монтажное ИЛИ, так как ИЛИ подразумевает возможность работы нескольких выходов.

Если посмотреть на два элемента ОЕ с выходом в третьем состоянии (рис. 1. 8 б) (вообще открытый коллектор обозначают ромбиком с чертой посередине или треугольничком, а также буквой Z). Если мы соединили два выхода между собой. но у него прямое или инверсное управление, то на таком элементе ОЕ можно реализовать мультиплексор. Еесли нужен всего двухвходовой мультиплексор, а элементов не хватает (потому что даже двухвходовй МУХ это КЛБ), то можно задействовать элементы ОЕ, которые не входят в КЛБ -- их 4 или 8 штук на кристалле. И дополнительно поставить всего один инвертор, который бы посылал на один ОЕ прямой вход, а на другой -- инверсный.

Главное -- выходы можно объединять между собой, так как выходные ключи могут быть закрыты за счёт входа ОЕ.

<a href="https://ibb.co/2ZvtGzv"><img src="https://i.ibb.co/9ZbTQxb/image.png" alt="image" border="0"></a>

R1 и R2 могут быть тоже выполнены на транзисторах, но они будут находиться уже не в режиме ключа. Они нужны, чтобы ограничивать токи.

Можно считать, что эта цепь -- первоначальный классический вариант. Видно, что на входе стоит многоэмиттерный транзистор и диоды, чтобы исключить выбросы и состязания, чтобы большие токи не пошли сверху вниз, и, самое главное --выход не подключён ни к какой схеме. Если в предыдущих слайдех
 































<!--stackedit_data:
eyJoaXN0b3J5IjpbNjkxNjAyMzE4LC0xNzMxMjQ4MDE4LC04Mz
IzMzE4NTMsLTM0MjQ2OTcyMSwyMDcwMjQ1NjA4LC01MDg2Mjgw
NzIsMTcyMjIzOTMxLC0xNzY4NzkwNjYzLDEzNzM1NDg4LC00Nz
gxMDkzNzMsLTEzNzI0Mzc4NzAsLTE3OTg3Mjg4NjgsMTA3NjA0
MjMwLC04MTE3Mzc5NzMsLTIwNzM1ODUxMjQsLTEzOTczNzMyOT
UsMTc5OTg4MTg5NCwxMzAzMzg3MzcwLC01NDQ3MzQ3NjUsNTQw
MTM0MTg2XX0=
-->