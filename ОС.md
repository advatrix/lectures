# Элементы теории операционных систем
### Классификация ОС
Существует много критериев для классификации ОС:
- по виду и составу вычислительной системы
	- ОС универсальных ЭВМ третьего поколения
	- ОС персональных компьютеров
	- ОС СЦВМ
	- ОС рабочих многотерминальных станций
	- ОС сетевых и распределенных вычислительных систем
	- ОС супер-ЭВМ (векторно-конвейерных, кластерных систем и пр.)
	- ОС мобильных устройств
- по отношению к пользователям
	- многопользовательские
	- однопользовательские
- по режиму вычислительного процесса
	- системы пакетной обработки (задания выполняются последовательно друг за другом)
	- системы разделения времени 
	- системы реального времени
- по технологии разработки и способу распространения
	- ПО с открытым кодом
	- свободно распространяемое ПО
	- ПО с закрытым кодом, распространяемое на основе платных лицензий.

### Типичный состав современной ОС
1. Обработчики прерываний и супервизоры
2. Планировщики
3. Система управления процессами и ресурсами
4. Программы управления основной памятью
5. Программы управления виртуальной памятью
6. Программы файловой системы
7. Оболочки
8. Система генерации

Современные ОС обладают слоистой структурой: приложения -> утилиты -> оболочки  -> ядро -> аппаратура

Слоистая структура операционной системы впервые была предложена и реализована Дейкстрой в 1960 году.

### Ядро операционной системы
**Ядро** -- комплекс небольших программ, постоянно присутствующих (резидентных) в оперативной памяти и выполняющих следующие основные функции:
1. Обработка прерываний
2. Создание и уничтожение процессов
3. Переключение процессов из состояния в состояние
4. Диспетчирование процессов
5. Приостановка и активизация процессов
6. Синхронизация процессов
7. Поддержка операций ввода и вывода
8. Поддержка распределения и перераспределения основной памяти
9. Поддержка работы файловой системы
10. Обслуживание аппараратного контроля вычислительной системы

В ядро вклю чают те программы, которые наиболее часто используются, не требуют частой динамической настройки и обеспечивают быструю реакцию системы на различные события в аппаратуре ВС. Как правило, это различные супервизорные программы и обработчики прерываний.

Супервизорные программы и обработчики прырываний бывают нескольких типов:
- первого рода: полностью резидентные
- второго рода -- частично резидентные
- третьего рода -- резидентные по условию


Различают два режима работы вычислительной системы:
- режим супервизора: обеспечивает возможность выполнения любых команд -- привилегированных и непривилегированных
- режим задачи -- возможность выполнять только непривилегированные команды

Переход из режима в режим осуществляется специальными командами посредством внутренних супервизорных прерываний. Тем самым обеспечивается первый уровень защиты ОС.

## Планировщики
**Планировщики** -- программы, отвечающие за распределение времени процессора конкретным процессам. Они различаются по уровню планирования:
- диспетчеры
- планировщики первого уровня (оперативные)
- планировщики второго уровня (долговременные)

Основная функция всех планировщиков -- обеспечить предоставление процессора по очереди всем существующим в системе активным процессам с учетом их приоритетов и текущего состояния системы. Для этого используются различные алгоритмы планирования.

Наиболее распространённым алгоритмом оперативного планирования в настоящее время является круговой циклический алгоритм (**RR-алгоритм**). В этом алгоритме каждому процессу по очереди выделяется определённый квант процессорного времени, по истечении которого происходит передача управления следующему активному процессу.

Для долговременного планирования чаще используются такие приоритетные алгоритмы, как
- **SJF** -- кратчайшее задание выполняется первым
- **SRT** -- наибольшим приоритетом обладает задание, до окончания выполнения которого остаётся наименьшее время
и так далее.

Приоритеты планирования бывают
- динамические
- абсолютные
- относительные

Классическим примером динамического приоритетного планирования является алгоритм КОРБАТО. В этом алгоритме поддерживается несколько приоритетных уровней. На каждом уровне реализуется дисциплина обслуживания типа FIFO (очередь). После выделения процессу очередного кванта времени процесс переводится на уровень с более низким приоритетом. Тем самым обеспечивается равномерное продвижение в системе всех активных задач. Количество уровней планирования может быть различным в зависимости от режима вычислительного процесса и типа ВС

## Управление процессами и ресурсами системы
Обычно под **процессом** в ОС понимают совокупность программы и данных, которые обрабатываются на некотором процессоре. В некоторых системах используется термин "задача", что является синонимом процесса. 

Понятие процесса неотделимо от понятия "ресурс".

Под **ресурсом** понимается любой объект, который может быть распределён процессу для его выполнения. Это устройства вычислительной системы, оперативная память, линии связи и т.д.

Реаличают ресурсы потребляемые (CR) и повторно используемые (SR).

**CR-ресурсы** после использования в систему не возвращаются (в неизменном виде). К числу этих ресурсов относятся изменяемые структуры данных и процедуры, а также информационные ресурсы (различные сигналы и сообщения)

**SR-ресурсы** после использования процессом возвращаются в систему в неизменном видеи могут повторно использоваться.К числу таких ресурсов относятся все аппаратные ресурсы, а также неизменяемые структуры данных и процедуры.

Под **управлением** процессами и ресурсами понимается решение следующих задач:
1. Изменение статуса процесса (выполняется, готов, блокированЮ приостановлен). 
2. Синхронизация двух и более процессов. 
3. Решение проблемы взаимных блокировок


Изменение статуса процесса выполняется при наступлении некоторых событий, которые отслеживаются программами ядра. Эти изменения соответствуют графу состояний процесса.

Синхронизация процессов необходима, если эти процессы используют общие ресурсы. Синхронизация выполняется с помощью так называемых двоичных семафоров Дейкстры или мониторов Хоара.

**Двоичный семафор** -- переменная, принимающая только значения 0 или 1 и над которой определены две неделимые операции. С каждым семафором связана **критическая секция** в программе процесса. Семафор позволяет только одному процессу войти в критическую секцию. Только в своей критической секции процессу разрешается выполнять действия над **критическим ресурсом**. Критическим считается ресурс, которым одновременно может владеть только один процесс.

**Монитор Хоара** редставляет собою комплекс процедур и структур данных, который также регулирует использование процессами критических ресурсов.


## Управление основной памятью

Необходимость управления основной памятью возникает вследствие ограниченного размера ОП в современных ВС. Эта проблема усугубляется в условиях мультипрограммирования, когда необходимо в ОП хранить одновременно коды и данные многих активных процессов.

Простейшим решением является **свопинг** (вытеснение), при котором очередной процесс загружается в то же место ОП, которое занимал предыдущий процесс. Усовершенствованный свопинг предполагает вытеснение предыдущего процесса только в том случае, если в данный момент в ОП отсутствует свободный участок необходимого размера. В любом случае операционная система должна отслеживать состояние ОП, которая в каждый момент времени представляет собою пеструю картину чередования занятых и свободных участков.

Обычно все свободные участки ОП перечисляются в списке, упорядоченном начальному адресу. При поступлении запроса менеджер ОП просматривает этот список и выбирает для выделения процессу свободный участок по одному из следующих алгоритмов:
- "первый подходящий": когда из спика выбирается первый пригодный участок
- "следующий подходящий": отличается от предыдущего алгоритма тем, что адрес выбранного участка запоминается в качестве начальной точки просмотра списка при слудеющем обращении с таким же запросом
- "наименее подходящий", когда выбирается наибольший по размеру подходящий участок
- "быстрый подходящий", в котором поддерживается несколько списков некоторых наиболее часто запрашиваемых размеров

## Управление виртуальной памятью
Размер оперативной памяти современных ВС не позволяет выполнить очень большие программы, требующие широкого диапазона используемых адресов памяти. Для решения этой проблемы в ОС вводится понятие **виртуального адресного пространства**, поддерживаемого виртуальной памятью.

Реальное выполнение программ происходит только с использованием оперативной памяти, поэтому в ОС должен существовать менеджер виртуальной памяти, отображающий виртуальные адреса на адреса ОП. 

В настоящее время наиболее широко используется страничная и сегментная организация виртуальной памяти.

### Страничная организация

Всё пространство виртуальных адресов разделено на части, называемые **страницами**. Соответствующие единицы в ОП называются **страничными блоками**.

Размер страницы в разных системах колеблется от 512 байт до 64 Кб. Все страницы хранятся во внешней памяти, но в каждый момент времени часть страниц присутствует в виде копий в страничных блоках ОП.

Отображение виртуальных страниц на страничные блоки осуществляется с помощью таблицы страниц. При ображение в программе к некоторой странице специальный диспетчер памяти определяет наличие или отсутствие этой страницы в ОП. Если страница присутствует, то формируется реальный адрес в ОП, по которому и производится необходимое действие. 

Если страница отсутствует, то с помощью таблицы страниц находится требуемая страница во внешней памяти, которая и загружается в ОП.
Перед загрузкой требуется освободить для неё место в ОП. Для этого  из одного из страничных блоков страница должна быть "вытеснена" во внешнюю память. При выталкивании используются следующие алгоритмы замещения страниц:
- NRU -- выталкивается не использовавшаяся в последнее время страница
- FIFO -- выталкивается самая старая страница
- LRU -- выталкивается не использовавшаяся дольше всего страница
- NFU -- выталкивается редко использовавшаяся страница


### Сегментная организация
В отличие от страничной организации, при сегментной организации виртуальное адресное пространства, а также пространство ОП разбивается на сегменты, которые могут иметь различный размер.

Реализация сегментной памяти наряду с преимуществами создаёт дополнительные проблемы: например, при смене сегментов в ОП возникает лишняя фрагментация, требующая уплотнения.

В некоторых системах (MULTICS) предельный размер сегмента очень большой, поэтому в пределах сегмента реализована страничная организация памяти.

## Файловые системы
Потребность долговременного хранения в ВС больших объемов информации не может быть удовлетворена просто за счет использования виртуального адресного пространства.

Для такого хранения информации в операционных системах вводится понятие **файл**. Под файлом понимается совокупность элементов информации, сгруппированных под общим именем для хранения и использования в информационно-вычислительных системах.

Совокупность определенным образом организованных файлов, а также средства управления этой совокупностью называются **файловой системой**.

Конечного пользователя интересует только удобство работы с файлами и безопасность файловой системы. Внутренняя организация, размещение файлов на внешнем носителе информации, оптимизация использования внешней памяти ВС, как правило, скрыты от пользователя.

ОС поддерживает **логическую и физическую организацию** файлов.

**Логическая** организация принимается во внимание пользователем при программировании приложений и подразумевает логическую структуру данных и способ доступа к этим данным.
Различают
- последовательную
- индексно-последовательную
- прямую
- библиотечную
организации данных.

Способы доступа к данным бывают
- **базисные** -- наиболее быстрые. Используются для обмена большими порциями информации между внешней и основной память. однако требуют от программиста дополнительной работы.
- **с очередями**: в максимальной степени освобождают программиста от рутинной работы, такой как блокирование и разблокирование, буферизация и т.д., возлагая эти обязанности на ОС.

**Физическая** организация данных отражает особенности размещения данных во внешней памяти, а также учитывает алгоритмы записи и чтения при обращении к устройству.

Единица хранения информации на внешнем устройстве называется **записью**. Различают записи фиксированной, переменной и неопределенной длины. Для выполнения операций записи и чтения записи могут быть объединены в блоки. Блоки могут занимать непрерывные участки памяти или представлять собою связные списки. В последнем случае более эффективно используется внешняя память, но усложняется алгоритм обслуживания таких записей.

### Структура файловой системы

Файловые системы большинства современных ОС имеют древовидную иерархическую структуру, которая обеспечивает уникальность имени файла для всей системы. Это свойство особенно важно для многопользовательских ОС. Для построения такого дерева вводится особый тип файлов: **файлы-каталоги**.


**Файл-каталог** содержит записи, обычно фиксированной длины, каждая из которых описывает характеристики включенного в этот каталог файла (имя, размер, адрес размещения , права доступа и др.). Поддержка структур данных, обеспечивающих функционирование древовидной структуры, является одной из важнейших задач файловой системы ОС.


## Оболочки операционных систем
В современных ОС **программы-оболочки** являются важнейшей частью и выполняют как внутренние функции, связанные с координацией работы остальных рассмотренных ранее частей ОС, так и функции создания и поддержки интерфейса пользователя.

Во всех операционных системах основным интерфейсом является **командная строка**, которая содержит запросы пользователя на выполнение определенных действий со стороны операционной системы. Ввод запроса в виде команд или группы команд выполняется через терминал пользователя в ответ на приглашение оболочки ОС.

Взаимодействие с операционной системой приложений осуществляется путем так называемых **«системных вызовов»**, размещаемыхв нужных местах программы приложения. Для реализации сложных запросов со стороны пользователя (а также и со стороны приложений) в оболочку включаются дополнительные средства программирования ветвящихся и циклических алгоритмов.

Эти средстве (внутренние команды оболочки) составляют особый язык программирования, позволяющий писать на нём процедуры (скрипты), к которым можно обращаться как из командной строки, так и из приложений.

Другим возможным интерфейсом пользователя является **графический (оконный) интерфейс**, реализуемый отдельной графической оболочкой, более удобный для пользователя, но обладающий меньшими возможностями по сравнению с командной строкой.

## Средства генерации ОС
Любая операционная система поставляется в виде **дистрибутивов** – набора модулей на сменном носителе информации. Из этих модулей собираются все части ОС, которая будет функционировать на определенной аппаратной платформе в вычислительной системе с определенной конфигурацией оборудования.

Процесс такой сборки и называется **генерацией** ОС. В процессе генерации кроме конфигурации оборудования и его характеристик устанавливаются различные параметры будущей системы, различные ограничения (например, max количество пользователей в системе, max число процессов, запущенных с одного терминала, квоты времени и памяти и т.д.), а также значения параметров по умолчанию. 

Генерация может осуществляться в несколько этапов.

Иногда часть работы по генерации совмещается сзагрузкой системы. К задачам генерации близки задачи резервного копирования и восстановления системы после сбоев или некорректных действиях пользователя.

# Введение в ОС UNIX

## Состав ОС UNIX
Собственно операционной системой является **ядро**. Оно управляет всеми доступными ресурсами и доступом к аппаратным средствам вычислительной системы. Ядро состоит из модулей, каждый из которых имеет интерфейс с одним из компонентов аппаратных средств. Эти модули обеспечивают программам доступ к процессору, оперативной памяти, дискам, терминалам, сети и т. д. В случае установки в вычислительной системе новых типов устройств в ядро включается новый программный модуль.

Типичное ядроUNIXсостоит из двух секций. Первая секция практически инвариантна по отношению к аппаратуре, чем обеспечивает переносимость системы. Вторая секция включает модули, работающие непосредственно с аппаратурой. Незначительный объем ядра (~ 10000 операторов Си и ~1000 Ассемблера) достигается тем, что в нем реализовано ограниченное число простых функций (примитивов).


### Инструментальные средства и приложеня

Наиболее ярко модульный принцип организации системы UNIXпроявляется именно на этом уровне. Каждая команда системы UNIX выполняет определенное действие, а некоторая совокупность образует своего рода"инструментальный ящик" (a tool box) или просто "инструмент." Если необходимо выполнить некоторое задание, следует просто извлечь соответствующие инструменты. Сложные задачи могут быть решены посредством объединения в единое целое подходящих инструментов.

С самого начала "инструментальный ящик" системы UNIX включал больше, чем только базовые команды для управления системой. Система UNIX имеет также утилиты для 
- электронной почты `mail`, `mailx`
- редактирования файлов `cd`, `ex`, `vi`
- обработки текстов `sort`, `grep`, `we`, `awk`, `sect`
- форматирования текста `nroff`
- разработки программ `cc`, `make`, `lint`, `lex`
- управления программами `sees`, `res`
- внутрисистемных коммуникаций `uucp`
- сбора учетной информации о процессах и пользователях `ps`, `du`, `acctcom`

Поскольку среда пользователя системы UNIX была реализована интерактивной, программируемой и модульной, то в случае необходимости в пользовательский инструментарий могут быть легко разработаны и включены новые утилиты, а ненужные инструменты исключены без какого-либо ущерба для ОС

## Вход в систему
Система UNIX идентифицирует каждого пользователя с помощью **имени пользователя** (входного идентификатора ID). Администратор может задать пользователю исходный пароль, который он в состоянии со временем изменить, или пользователь может установить себе пароль сам. Только администратор имеет право исключить пароль из строки пользователя в файле регистрации пользователей.

После входа в систему пользователь может вводить команды. Shell интерпретирует, а операционная система организует их выполнение. Любое сообщение, появляющееся при выполнении команды, выводится на экран терминала.

По окончании работы и выходе из системы термнал освобождается, и с него в систему может войти другой пользователь.

### Типичный сеанс (сессия) работы с системой
```bash
login: user1 <Return>  # вход в систему
password: 

# сведения об операционной системе
# новости

$ commands  # выполнение требуемый действий

$ exit # или <Ctrl> + <d>
login:  # выход из системы
```

Когда приглашение `login` появилось, пользователь должен ввести своё входное имя. 

Если появилось приглашение `password`, следует ввести пароль. Для обеспечения секретности набираемый на клавиатуре пароль не высвечивается на экране. При вводе идентификатора и пароля клавиша `<#>` вызывает возврат курсора на один символ назад, а клавиша `<@>` удаляет всю вводимую строку.

При первом входе в систему может оказаться так, что пользователь должен установить пароль. Пароль должен соответствовать следующим требованиям
- состояить минимум из шести символов
- по крайней мере два из шести первых символов должны быть буквами
- по крайней мере один из шестипервых символов должен быть не буквой

После первого ввода пароля система попросит пользователя повторить ввода для проверки правильности введенног пароля. Затем она снова выдает приглашение для входа, и он может войти в систему, задав новый пароль.

## Формат командной строки

### Синтаксис:
```bash
$ команда [-опции] [аргументы] <Return>
```
После появления на экране приглашения shell'а в виде символа `$`, можно вводить команду. Имя команды всегда является первым словом в командной строке. Многие команды допускают использование необязательных опций, расширующих их функциональные возможности, а также аргументов в виде строки текста, имени файла или имени каталога. Перед необязательными опциями обычно ставится дефис `-`

### Примеры
```bash
$ date  # аргументы отсутствуют
Fri Jul 1 11:10:45 EDT 1995

$ echo Hello!  # один аргумент
Hello!

$ bannerHi  # неверный синтаксис
sh: bannerHi: not found

$ ls -F  # одна опция
dira/ dirb/ f1 f2 prog1* prog2* 
```

**Пробел** используется как разделительн имён команд, необязательных опций и аргументов. Между разделяемыми компонентыми командной строки допускается задание одного или более пробелов, для ввода которых используются клавиши `<Space>` или `<Tab>`.

Ввод каждой команды завершается нажатием клавиши `<Return>`/

> **Внимание**! При вводе команд система UNIX делает различие между регистрами клавиатуры! Большинство команд и опций вводятся в нижнем регистре.


> **Внимание**! В одной командной строке можно набрать более одной команды, разделив их точкой с запятой:

```bash
$ ls;pwd
```

## Файловая система UNIX
**Файл** представляет собой некоторый связный в логическом отношении набор данных, хранящийся на устройстве массовой памяти, обычно дисковой, и имеющий имя. Поскольку рассматривается система UNIX, то файл это не более чем представление данных в виде совокупности байтов. Там нет по сути заранее определенных записей, полей, меток окончания записей или файлов. Это обеспечивает определенную гибкость для разработчиков приложений, которые сами определяют внутренние характеристики файлов.

**Обычный файл** обычно содержит текст в кодах ASCII и создаётся с помощью текстового редактора с терминала.

**Файл программы** представляет собой обычный файл, содержащий исполняемые инструкции. Он может включать объектный код, который не может быть выведен на экран дисплея терминала (`mail`, `who`, `date`) или содержит команды shell системы UNIX и называемый обычно **shell-процедурой**, которая может быть выведена на терминал (`profile`, `logout`)

**Каталог** представляет собой специфический файл, содержащий в себе имена файлов и каталогов. В каждом элементе каталога хранится также **номер описателя файла** (индексного дескриптора файла), с помощью которого идентифицируется местонахождение файла с соответствующими данными.

**Файл устройства** представляет собой специальный файл, который обеспечивает интерфейс между ядром системы и реальным внешним устройством. Поскольку такие файлы выполняют функции интерфейсов, они никогда не содержат реальных данных. Обычно эти файлы находятся в каталоге `\dev`, т.е. в нём будет находиться файл для каждого внешнего устройства, с которым взаимодействует компьютер.

### Что можно делать с файлами?
```bash
ls  	# просмотр характеристик файла
cat  	# просмотр содержимого файла
more  	# поэкранный просмотр содержимого файла
cp	# копирование файла
mv	# переименование файла или каталога
mv	# перемещение файла в другой каталог
ln	# создание ссылки на файл (файла-псевдонима)
rm	# удаление файла
```

### Задание имен файлов
Имя файла обычно не может быть больше 255 символов. Имя обычно включает буквы (a-z, A-Z), цифры от 0 до 9, точку, дефис и нижнее подчеркивание. Многие другие символы имеют специальное назначение в shell'е, такие, как, например, пробел или слэш, и поэтому не могут использоваться при задании имен файлов. Другими специальными символами являются *, <, >, $, |. Их использование в именах файлов часто может привести к неожиданным результатов.

Имена файлов. состоящие из двух слов, объединяются символом подчеркивания. Например,
```bash
$ cd a_dir
``` 
-- правильный синтаксис, в команде `cd` указан один аргумент.

В системе UNIX точка `.` представляет собой обычных символ и поэтому может использоваться внутри имени файла любое число раз, например, `a.bcdefgh`, `a.b.c.d`, `a...b`. Она имеет особое значение только тогда, когда является *первым* символом имени файла и в этом случае определяет *невидимый файл*. Имена файлов, начинающиеся с точки, могут быть выведены командой `ls -a`.

Подобно картотеке, иерархическое построение файловой системы UNIX обеспечивает простой и эффективный механизм организации файлов. Поскольку дистрибутив системы UNIX обычно включает в себя сотни файлов и программ, их организация в виде иерархической структуры позволяет каждой версии системы UNIX поддерживать единообразную организацию каталогов. Вершина иерархии определяется как корень (root) каталога и помечается знаком слэш `/`

Система UNIX имеет набор команд, позволяющих легко создавать новые каталоги, а также перемещать или копировать файлы из одного каталога в другой. 

В некоторых ОС файловая система была реорганизована в двух основных направлениях -- файлы различаются как статические и динамические.

### Статические файлы
Они являются разделяемыми. В этой части файловой системы существуют три важнейшних каталога: `/opt`, `/usr` и /sbin.

**/opt** содежит приложения и программные продукты. Разработчики приложений и администраторы системы используют этот каталог для инсталляции новых программныз продуктов или приложений.

**/usr/bin** содержит программы для всех команд, которые необъодимы для выполнения основных действий с системой UNIX и работы с файлами. Они обычно доступны для всех пользователей.

**/usr/sbin** содежит программы для команд системного администратора. Для использования большинства из них пользователь должен иметь привилегии суперпользователя.

**/usr/lib** содержит разделяемые и архивные библиотеки, используемые для приложений.

**/usr/share** содержит независимые от поставщика системы файлы (наиболее важный -- описание системы)

**/usr/share/man** содержит все файлы, связанные с оперативным справочником команд

**/usr/local/bin** -- программы и утилиты для локального применения

**/usr/contrib.bin** -- общедоступные программы и утилиты. Их список можно найти, обратившись к сервисному информационному бюллетеню или группе пользователей

**/sbin** содержит специальные команды, используемые для запуска и останова системы


### Динамические файлы
Являются личными, то есть не разделяемыми. В этой части файловой системы находятся семь важнейших каталогов: /home, /etc, /sta/id, /tmp, /dev, /mnt и /var.

**/home** -- каждый пользователь системы UNIX должен быть зарегестрирован. Наряду с идентификатором и паролем системный администратор создаст для пользователя его собственный каталог. Каталог /home обычно содержит по одногому подкаталогу для каждого зарегестрированного пользователя. После входа в системы он оказывается в своём каталоге, поэтому он называется HOME-каталогом или **входным** каталогом. 

Пользователь может изменить своё положение в файловой системе. Как минимум, у него будет возможность доступа ко всему, что находится в каталоге /home; как максимум, он сможет переходить в *любой* каталог иерархии (по умолчанию). Прерогативой администратора системы остаётся ограничение доступа пользователя к особым каталогам системы.

**/etc** содержит множество конфигурационных файлов системы.

**/stand/vmunix** хранит программу, представляющую собой ядро системы UNIX. Оно загружается в память при запуске системы и управляет всеми действиями пользователей при работе с системой.

**/tmp** используется как рабочее пространство памяти для ОС, которая нуждается в создании своих рабочих файлов. /tmp очищается при перезагрузке. Следует заметить, что файлы, находящиеся *в любом* каталоге с именем tmp, могут быть удалены *в любой момент времени*.

**/dev** содержит файлы, представляющие внешние устройства, которые могут быть подключены к системе. Поскольку эти **файлы** играют роль шлюзов по отношению к внешним устройствам, то соответствующие данные никогда напрямую не хранятся в файлах устройств. Такие файлы часто называются **специальными файлами** или **файлами устройств**.

**/mnt** используется для монтирования других устройств

**/var/main** содержит "почтовый ящик" для каждого пользователя, для которого поступают сообщения по электронной почте

**/var/news** включает все файлы, содержащие сообщения о текущих новостях системы. Их содержимое будет выведено на экран при запуске команды `news -a`

**/var/tmp** используется в качестве рабочего пространства памяти для пользователей.

### Точка .
Элемент каталога, называемый **точка**, представляет текущий каталог. Если в настоящий момент времени пользователь находится в каталоге `/home/user3`, то `./memo/f1` представляет `/home/user3/memo/f1`.

### Две точки ..
Элемент каталога с именем `..` определяет каталог, непосредственно предшествующий текущему каталогу и часто называемый **родительским каталогом**. Каждый каталог может содержать несколько файлов и подкаталогоы, но всегда имеет только один родительский каталог. Вследствие этого не возникает никакого беспорядка при перемещении вверх по ирерархии каталогов.

Корневой каталог `/` подобен любому другому и включает в качестве элементов одновременно и одну, и две точки. Однако поскольку корневой каталог не имеет родительского, двойная точка ссылается на себя.

### Основные команды файловой системы
```bash
pwd	# выводит имя текущего каталога
ls	# выводит списко файлов и каталогов, находящихся в текущем каталоге
cd	# изменяет текущих каталог пользователя
find	# поиск файлов
mkdir	# создать каталог
rmdir	# удалить каталог
```

### Команда `ls` -- вывод содержимого каталога
Команда `ls` используется для вывода списка имён файлов и каталогов. Если команды вводится без аргументов, она выводит на экран дисплея имена файлов и каталогов, содержащихся в текущем каталоге.

В команде `ls` можно задавать аргументы, задающие как относительное, так и абсолютное маршрутное имя файла или каталога. В случае задания маршрутного имени файла она выдаёт информацию, связанную с указанным файлов. Аналогично её действие по отношению к каталогу: выдаётся содержимое соответствующего каталога.

Команда `ls` допускает также задание ряда опций, которые обеспечивают вывод дополнительной информации. В командной строке могут быть заданы одновременно несокльок опций для вывода более подробной информации о файле или каталоге.

`-a` выводит имена всех файлов, включая файлы с точкой. Обычно **файлы с точкой** невидимы, если в команде не задана опция `-a`. В общем случае они содержат информацию о конфигурации в рамках сеанса работы пользователя или приложений.

`-d` вычисляет характеристики каталога вместо представления его содержимого

`-l` представляет полный перечень атрибутов, характеризующих каждый файл, включая тип, права доступа, количество ссылок, владельца, группу, размер в байтах, дату последней модификации и имя

`-F` добавляет знак `/` к имени каждого файла, являющегося каталогом и `*` к имени каждого исполняемого файла

`-R` рекурсивно перечисляет файлы в данном каталоге и во всех подкаталогах

### Команда `cd` -- изменение текущего каталога
Если команда `cd` задана без аргументов, то пользователь окажется в home-каталоге.

В POSIX Shell имеется возможность запомнить имя предыдущего каталога. Команда `cd`, как и ожидается, изменяет текущий каталог, но одновременно обладает дополнительными возможностями, позволяющими сократить длины вводимых командных строк.

>**Внимание**! При использовании команды `cd` время от времени следует выполнять команду `pwd`, чтобы определить своё местоположение в иерархии.

```bash
$ pwd
/home/user3/tree
$ cd /tmp
$ pwd
/tmp
$ cd -
/home/user3/tree
```

### `mkdir` и `rmdir` -- создание и удаление каталогов
При создании каждого каталога автоматически создаются два подкаталога с именами `.` и `..`, представляющие текущий и родительский каталоги. Создаваемые каталоги не изменяют положения пользователя в иерархии файловой системы.

По умолчанию, когда задаётся имя задаваемого каталога, все промежуточные каталоги уже должны существовать. В противном случае можно использовать следующую опцию:

`-p` создаются промежуточные каталоги, если они до этого не существовали

Команда `rmdir` позволяет удалить каталог. Для того, чтобы можно было удалить каталоги, они должны быть пустыми (то есть они не должны содержать какие-либо файлы за исключением файлов в именем `.` и `..`). Нельзя также удалить каталог, находящийся между текущим и корневым.

Обе рассматриваемые команды допускают задание множества аргументов. Аргументы команды `mkdir` представляют собой имена создаваемых каталогов. Аргументы команды `rmdir` должны соответствовать именам уже существующих каталогов. 

### Команда `grep`/`egrep` -- поиск строк в файле по шаблону

В шаблон могут входить обыкновенные символы (представляющие сами себя), а также спецсимволы:
- `.` -- любой произвольный символ
- `*` -- множитель (замыкание Клини)
- `.*` -- любая последовательность символов
- `^шаблон` -- привязывает шаблон к началу строки
- `шаблон$` -- привязывает шаблон к концу строки
- `[символы]` -- любой один символ из тех, что внутри скобок

**Пример**: вывести всех привилегированных пользователей:
```bash
egrep ':0:0:' /etc/passwd
```

Вывести всех непривилегированных пользователей:
```bash
egrep -v ':0:0:' /etc/passwd
```

Вывести всех пользователей, имена которых начинаются с букв a, b, e, d
```bash
cat /etc/passwd | grep "^[abed]"
```


### `find` -- найти файл в дереве каталогов
`find` рекурсивно обходит указанные каталоги и файлы, проверяет для низ выполнение указанных условий и может вдобавок выполнять с найденными файлами указанные действие. Например, самое простое -- распечатать имя файла.

```bash
find файл [...] ключи/условия/действие
```

#### Ключи-условия команды `find`:
- `-name "*.c"` -- простое имя подходит под шаблон *.c
- `-type f` -- брать только обыкновенные файлы
- `-type d` -- брать только каталоги
- `-size +500` -- файлы размером БОЛЬШЕ 500*512 байт
- `-mtime -3` -- дата модификации МЕНЬШЕ 3-х дней
- `-newer filename`-- дата модификации искомого файла МЕНЬШЕ, чем у заданного файла filename
- `-print` -- распечатать маршрутное имя файла
- `-exec` -- команда над файлом {} \;

> **Внимание** команда `find` использует стандартные shell'овские шаблоны, в то время как `grep` использует регулярные выражения 


#### Примеры
Напечатать имена всех обыкноченных файлов, изменившиеся за последние 4 дня в текущем каталоге и его подкаталогах
```bash
find . -type f -mtime -4 -print
```

Уничтожить все файлы с окончаниями `*.bu`, `*%`, которые не менялись больше месяца.

```bash
find / \( -name "*.bu" -o -name "*%" \) -type f \ -atime +30 -exec rm {} \;
```

Запись `rm {} \;` обозначает команду Unix `rm`, которая будет выполняться для всех таких найденных файлов. Вместо `{}` каждый раз будет подставляться имя найденного файла.

## Типы файлов
В системе UNIX поддерживается несколько типов файлов, каждый из которых определяется первым символов в выводе команды `ls -l`. Наиболее часто встречающиеся типы файлов идентифицируются следующим образом:
```
-	обычный файл
d	каталог
l	символическая ссылка
g	сетевой специальный файл
c	байтоориентированный специальный файл (терминалы, принтеры)
b	блочноориентированный специальный файл (диски)
p	именованный канал (канал внутри межпроцессного взаимодействия)
```

### Характеристики файлов
```bash
$ ls -l
-rw-r--r-- I user3 class 37	Jul 24 11:06 f1
-rwxr-xr-x 1 user3 class 52	Jul 24 11:08 f2
drwxr-xr-x 2 user3 class 1024	Jul 24 12:03 memo

тип	  ссылки        размер               имя
 права доступа    группа       дата и время модификации
	    владелец
```
---
### `cat` -- вывод содержимого файла
Синтаксис:
```bash
cat [file ...]  # объединяет и выводит содержимое файла
```

Примеры:
```
$ cat remind
Your mother's birthday is November 29.
$ cat note remind
TO: Mike Smith
The meeting is scheduled for July 29.
Your mother's birthday is November 29.
$ cat
abc
1234
<Ctrl>+<d>
abc
1234
```

Команда `cat` используется для объединения и вывода содержимого файлов как единого целого. Она не форматирует вывод файлов и не отделяет окончание одного файла от начала другого.

При запуске команды `cat` без аргументов, она приостанавливается в ожидании ввода с клавиатуры. Это подобно действиям команд `mail` и `write`. Для продолжения вывода необходимо нажать клавиши `<Return>` и `<Ctrl>+<d>`.

**Внимание!** Если файл содержит управляющие символы, такие, например, как объектный код программы, и запущена команда `cat` с именем этого файла, то терминал может зависнуть. Вернуть его в работоспособное состояние можно одним из следующих способов:

**Способ 1**:
1. Выйти из системы, для чего нажать клавишу `<Return>`, а затем ввести команду `exit`.
2. Выключить, а затем снова включить терминал
3. Вновь войти в систему


**Способ 2**:

1. Нажать клавишу `<Break>`
2. Одновременно нажать клавиши `<Shift>+<Ctrl>+<Reset>`
3. Нажать `<Return>` 
4. Выполнить команду `tset -e -k`
5. Выполнить команду `tabs`
---
### `more` -- вывод содержимого файла
**Синтаксис**:
```bash
more [filename]
```

Пример:
```bash
$ more funfile
--funfile (20%) --

<Q> или <q>	выход из команды more
<Return>	вывод очередной строки
<Space>		вывод очередного экрана с информацией
```

Команда `more` предназначена для вывода содержимого файла в поэкранном режиме. Для того, чобы увидеть следующий экран с информацией, следует нажать клавишу `<Space>`.

С помощью клавиши Enter можно организовать построчный просмотр файла.

Наконец, для выхода из команды `more` следует нажать класишу q.

---
### `tail` -- вывод окончания файла
**Синтаксис**:
```bash
tail [-n] [filename]...
```
**Пример**
```bash
$ tail -n note
soon as it is available
```

Команду `tail` целесообразно использовать, когда нужно вывести на экран последние n строк файла (по умолчанию n = 10). Она особенно полезна при просмотре длинных файлов протокола, в конец которых периодически добавляется информация. С её помощью можно быстро найти последние сообщения системы вместо того, чтобы просматривать весь протокол, если применять команды `cat` или `more`.

---

### `cp` -- копирование файлов
**Синтаксис**
```bash
cp [-i] filename output_file			# копирование файла
cp [-i] filename [filename...] output_dir	# копирование файлов в каталог
cp [-i] directory [dicectory...] output_dir	# копирование каталогов
```

**Пример**
```bash
$ ls -F
f1 	f2* 	memo/ 	note 	remind
$ cp f1 f1.copy
$ ls -f
f1 	f1.copy 	f2* 	memo/	 note	 remind
$ cp note remind memo
$ ls -F memo
note	remind
```

Команда `cp` используется для создании копии одного или нескольких файлов. Применяя эту команду, следует иметь в виду:
- требуется указать *как минимум* два аргумента -- источник и приёмник
- для любого из аргументов допустимо использование относительных и/или абсолютных маршрутных имён
- при создании копии одного файла в качестве приёмника может быть указано маршрутное имя файла или каталога
- если в качестве приёмника выступает файл, который не существует, он сначала будет создан. Если файл-приёмник не существует, его содержимым станет содержимое файла-источника.
- когда в качестве приёмника указывается каталог, файл будет скопирован в него с сохранением своего имени
- опция `-i` (interactive) приводит к выводу предупреждения о том, что файл-приёмник уже существует, и потребует подтверждения, что его содержимое должно быть заменено на новое.


**Примеры**
```bash
$ cp f1 f1.copy		# создаётся файл в текущем каталоге f1.copy
$ cp f1 memo		# создаётся копия файла f1 в каталоге memo
$ cp f1 memo/f1.copy	# создаётся копия файла f1 в каталоге memo с именем f1.copy

# при копировании нескольких файлов в качестве приёмника должно быть указано имя каталога
$ cp note remind memo

# файл не может быть скопирован сам в себя
$ cp f1 f1
cp: f1 and f1 are identical
```

Для копирования каталога следует использовать опцию `-r` (recursive).

**Внимание**! По умолчанию команда `cp` вызовет перезапись существующих файлов без какого-либо предупреждения пользователя!

---
### `mv` -- перемещение или переименование файлов
**Синтаксис**:
```bash
mv [-i] filename new_filename		# переименование файла
mv [-i] filename [filename...] out_dir  # перемещение файлов в каталог
mv [-i] directory [directory...] out_dir# переименование или переещение каталогов
```

**Примеры**
```bash
$ ls -F
f1	f2*	memo/	note	remind

$ mv f1 file1
$ ls -F
file1	f2*	memo/	note	remind

$ mv f2 memo/file2
$ ls -F
file1	memo/	note	remind

$ ls -F memo
file2*

$ mv note remind memo
$ ls -F
file1	memo/

$ ls -F memo
file2*	memo	remind

$ mv memo letters
$ ls -F

file1	letters/
```

Команда `mv` используется для переименования файла или перемещения одного или группы файлов в другой каталог. Применяя эту команду, следует иметь в виду:
- требуется указать *по крайней мере* два аргумента -- источник и приёмник
- в качестве аргументов допустимо использование относительных и/или абсолютных маршрутных имён
- в случае переименования одного файла в качестве приёмника может быть указано маршрутное имя файла или каталога.
	- если приёмником является файл в текущем каталоге, то он будет просто переименован
	- если приёмником является каталог, то файл (каталог) будет просто перемещён в требуемый каталог
	- если файл не существует, он будет создан
	- если файл-приёмник уже существует, его содержимое будет заменено содержимым файла-источника
- в случае, когда в качестве приёмника указан каталог, содержимое файла не изменяется, и он под своим именем перемещается в указанный каталог.

Опция `-i` приводит к выводу предупреждения о том, что файл или каталог-приёмник уже существует и потребует подтверждения, что содержимое файла или каталога должно быть перезаписано.

**Внимание!!** По умолчанию команда `mv` приводит к перемещению или переименовыванию всех существующих файлов без какого-либо предупреждения пользователя!


### `ln` -- создание ссылки на файл
**Синтаксис**
```bash
ln filename new_file			# создание ссылки на файл
ln filename [filename...] directory	# создание ссылок на файлы в каталоге
```

**Пример**
```bash
$ ls -l f1
-rw-rw-r--	1	user3	class	37	Jul 24 11:06	f1

$ ln f1 /home/user2/f1.link
$ ls -l f1
-rw-rw-r--	2	user3	class	37	Jul 24 11:06	f1
$ ls -l /home/user2
-rw-rw-r--	2	user3	class	37	Jul 24 11:06	f1.link
$ ls -i f1 /home/user2/f1.link
$ ls -i f1 /home/user2
1789	f1	1789	/home/user2/f1.link
```

Ссылки обеспечивают механизм, позволяющий с помощью различных имён файлов ссылаться на одни и те же данные на диске. Это полезно в тех случаях, когда несколько пользователей хотят использовать одни и те же данные, но предпочитают доступ к ним из своего собственного каталога.

Если пользователь 3 изменяет файл fl, то пользователь 2 увидит произошедшие изменения в тот момент, когда обратится к файлу fl.link.

**Внимание**! Система UNIX не запрещает нескольким пользователям в одно и то же время обращаться к некоторому файлу и осуществлять в нём изменение данных. Каждый пользователь будет иметь собственное представление относительного того, какие изменения осуществлены в файле, но последний по времени записавший файл на диск пользователь по сути и будет определять его истинное содержание.

Когда осуществляется связывание нескольких файлов, выводимое с помощью команды `ls -i` на экране число, соответствующее количеству ссылок на файл, больше 1. Если какая-либо ссылка удаляется, то это приведёт только к уменьшению этого числа. Собственно содержимое файла останется неизменным до тех пор, пока число ссылок не станет равным нулю, когда дисковое пространство, занятое файлом, освобождается.

**Пример**:
```bash
$ ls -l fl
-rw-rw-r--	1	user3	class	37	Jul 24 11:06	fl
$ ln fl /home/user2/fl.link
$ ls -l fl
-rw-rw-r--	2	user3	class	37	Jul 24 11:06	fl
$ ls -l /home/user2
-rw-rw-r--	2	user3	class	37	Jul 24 11:06	fl.link
$ ls -i fl /home/user2/fl.link
1789 /home/user2/fl.link	1789 fl
```
---
### `rm` -- удаление файлов
**Синтаксис**:
```bash
rm [-if] filename [filename...]		# удаление файлов
rm -r[if] catalog [filename...]		# удаление каталогов
```

**Пример**
```bash
$ ls -F
f1	f2	fruit/	memo/
$ rm f1
$ ls -F
f2 fruit/ memo
$ rm -i f2
remove f2? [Y/n]: y
$ rm fruit
rm: fruit is a directory
$ rm -r fruit
```

Команда `rm` предназначена для удаления файлов. После удаления файлов они не могут быть восстановлены. 

Команда `rm` должна иметь по крайней мере один аргумент -- имя файла. Допускается задание в одной команде нескольких имён удаляемых файлов.

Наиболее часто в команд `rm` используются следующие необязательные параметры:
- `-f` требует безусловного удаления поименованных в команде файлов без предупреждения, даже если возникает какая-либо ошибка
- `-r` рекурсивно удаляется содержимое каталогов, указанных в командной строке
- `-i` режим интерактивного удаления, требующий, чтобы пользователь подтвердил, что удаление должно быть выполнено. На соответствующие запрос системы пользователь отвечает "да" (y) или "нет" (n). Нажатие клавиши Enter соответствует "нет".


**Внимание!** Крайне осторожно применяйте опцию `-r`. При некорректном использовании это приведёт к удалению всех файлов поддерева. Удалённый файл может быть восстановлен только с резервной копии. Если всё же требуется использовать опцию `-r`, её следует дополнить опцией `-i`.

## Генерация имён файлов

Shell предоставляет возможность экономить время при вводе с клавиатуры имён файлов. Эта возможность носит название **генерации имён файлов** или **расширением имён файлов**. Несложно увидеть, что многие имена файлов соответствуют некоторому образцу (шаблону), например, все имена файлов, оканчивающиеся на .c или все имена файлов, начинающиеся с draw. В подобных случаях можно ввести специальные символы, которые приведут подстановку одного или более символов в имя файла. Shell выполнит расширение заданного шаблона имени файла в соответствующие имена файлов перед выполнением команды. Таким образом, использование символов генерации имён файлов поможет пользователю сэкономить время при их вводе с клавиатуры.

Возможность shell'а генерировать имена файлов очень полезна, так как в большинстве приложений поддерживаются определённые соглашения по именованию их файлов. Зная такие соглашения по именованию файлов, пользователь может использовать механизм расширения имён файлов для получения доступа именно к тем файлам, чьи имена соответствуют заданному шаблону. Например, исходный текст программ на языке C по соглашению оканчивается на ".c", а текстовые процессоры в качестве расширения имён файлов, содержащих текстовые документы, могут использовать ".doc".

### Символы генерации имён файлов
```
?		Соответствует любому одному символу за исключением лидирующей точки
[ ]		Определяет группу символов
-       Определяет группу символов, принадлежащих заданному диапазону
!		Отвергает заданную группу символов
*       Соответствует произвольному числу символов, в том числе и нулевому, исключая лидирующую точку.
```

Символы генерации имён файлов *никогда* не породят имя файла, *начинающееся с точки*. В файлах, чьи имена начинаются с точки, она должна быть всегда указана явно.

**Примеры**
```bash
$ ls -a
.	..	.zz	abcabed	abcz	bbabb	cyz	zzayy
$ echo ???		# результат: echo cyz
$ echo abc?		# результат: echo abcz
$ echo ??a??	# результат: echo bbabb zzayy
$ echo .??		# результат: echo .zz
$ echo ?		# результат: echo ?
```

```bash
$ ls -a
.	..	.22	1G	2G	7G	15G	Ant	Cat	Dog	abc	abcdef	ba	cyz
$ echo [abc]??	# результат: echo abc cyz
$ echo [1-9][A-Z]	# результат: echo 1G 2G 7G
$ echo [!A-Z]??		# результат: echo 15G abc cy2
```

```bash
$ ls -a
.	..	.profile	ab.dat	abcd.dat	abcde	abcde.data
$ echo *	# результат: echo ab.dat abcd.dat abcde abcde.data
$ echo .*	# результат: echo . .. profile
$ echo *.dat	# результат: echo ab.dat abcd.dat
$ echo *e	# результат: echo abcde
```

## Перенаправление ввода и вывода
При каждом запуске shell открываются три файла, которые доступны для использования. Они носят название **stdin**, **stdout** и **stderr**.

**stdin** -- это файл, из которого shell читает ввод, и который называется стандартным вводом. Этот файл открывается с дескриптором 0 и обычно ему соответствует клавиатура. Поэтому когда shell ожидает ввода, последний должен выполняться с клавиатуры.

Командами, получающими исходную информацию со стандартного ввода являются `mail`, `write` и `cat`. Каждая из них характеризуется тем, что после её запуска она переходит в состояние ожидания ввода, подлежащего обработке. Ввод завершается нажатием Enter Ctrl+D/

**stdout** -- это файл, в который shell-процесс записывает результаты своей работы. Такой файл открывается с дескриптором 1 и обычно связывается с терминалом. Поэтому когда shell осуществляет вывод, то он отображается на экране вашего терминала.

*Большинство* команд системы UNIX, например, `date`, `banner`, `ls`, `cat`, `who` генерируют стандартный вывод.

**stderr** -- это файл, в который shell записывает свои сообщения об ошибках. Этот файл открывается с дескриптором 2. Подобно стандартному выводу, стандартный протокол связывается с экраном терминала. Стандартный протокол может быть перенаправлен независимо от стандартного вывода.

*Большинство* команд системы UNIX выдают сообщение об ошибке в случае, если они неправильно вызываются. Для того, чтобы увидеть сообщение об ошибке, введите `cp <Enter>`

### `<` -- перенаправление ввода
Любая команда, читающая ввод со стандартного ввода, может за счёт перенаправления принимать его из другого файла.
**Пример**
```bash
$ cat remind
Your mothers birthday is November 29
$ mail user3 < remind
$ mail
From user3 Mon July 15 11:30 EDT 1993
Your mothers birthday is November 29
? d
$
```
Для команд, использующих стандартный ввод, можно перенаправлять его такие образом, что ввод будет осуществляться из файла, не являющегося клавиатурой. Перенаправление ввода часто используется для команды `mail`. 

Команды, получающие свой ввод со стандартного ввода, сначала после ввода переходят в состояние ожидания ввода от пользователя с клавиатуры, который завершается нажатием `<Enter> <Ctrl>+<D>`

Многие команды, которые принимают данные со стандартного ввода, в качестве аргументов используют имена файлов. Хорошим примером для этого служит команда `cat`. Она может вывести на экран текст, вводимый с клавиатуры, содержимое файлов, заданных, как её аргументы, или, наконец, содержимое файлов, перенаправленных через стандартный ввод.

---
### `>`, `>>`: перенаправление вывода
Любая команда, отправляющая результат на stdout, может перенаправить его в другой файл.

**Пример**:
```bash
# создание/перезапись
$ date > date.out
$ date > who.log
$ cat > cat.out
...
<Ctrl>+<D>

# создание/добавление
$ ls >> ls.out
$ who >> who.log
$ ls >> who.log
```

Ряд команд выводит свои сообщения на экран. Перенаправление вывода позволяет перехватить вывод команды и сохранить его в текстовом файле.

Если в командной строке за символов перенаправления вывода `>` идёт имя файла, то стандартный вывод команды вместо экрана будет направлен в этот файл. Если такой файл не существовал до вызова команды на выполнение, он будет создан автоматически. Если файл *существовал* перед выполнением команды, он будет *перезаписан*.

В случае, когда желательно, чтобы информация была добавлена в конец файла без его перезаписи, можно использовать команду добавления к концу файла `>>`. Как и в предыдущем случае, если файл не существовал, он будет автоматически создан. При этом между символами > не должно быть пробелов.

**Вниманий!** Shell не может один и тот же файл одновременно открыть для перенаправления ввода и вывода. Поэтому файлы ввода и вывода *должны быть разными*. В противном случае можно потерять исходное содержимое файла:
```bash
$ cat f1 f2>f1
```
Здесь будет потеряно содержимое файла f1.

---
### `2>`, `2>>` -- перенаправление протокола
Любая команда, выводящая сообщения об ошибках в стандартный протокол, может перенаправить их в другой файл.

**Пример**:
```bash
$ cp 2> cp.err  # создание/перезапись
$ cp 2>> cp.err  # создание/добавление
```

Если команда вводится с ошибкой и shell не в состоянии её интерпретировать, будет сгенерировано соответствующее сообщение. Несмотря на то, что сообщения об ошибках отображаются на экране, они в действительности передаются через файл, отличный от файла для обычных сообщений. Стандартный протокол -- файл с дескриптором 2.

Поэтому когда используется перенаправление стандартного протокола, следует указать, что необходимо перехватить сообщения, передаваемые в потоке с номером 2. Для обозначения перенаправления stderr используется конструкция `2>`, причём между этими символами не должно быть пробелов. Аналогично перенаправлению стандартного вывода перенаправление протокола приведёт к созданию файла, если это необходимо, либо к перезаписи существующего файла.

С помощью конструкции `2>>` (пробелов между символами не должно быть) можно к существующем файлу добавить дополнительное сообщение.

Рассматриваемый механизм весьма полезен с точки зрения администрирования системы. Поскольку сообщения об ошибках отделены от обычных выходных сообщения, можно легко перехватить и создать специальный файл протокола, в который будут записываться сообщения, связанные с проблемами, возникшими при выполнении команды.

## Фильтры

Некоторые команды читают свой ввод со стандартного ввода и направляют свой вывод на стандартный вывод. Такие команды называются **фильтрами**. Фильтры никогда не изменяют содержимое обрабатываемого файла. Результаты выполнения таких команд обычно направляются на экран.

Фильтры исключительно полезны для обработки содержимого файла: такой, например, как подсчёт количества строк `wc`, упорядочение строк по алфавиту `sort`, поиск строк, содержащих некоторую модель `grep`.

Кроме этого, фильтры могут быть использованы для последующей обработки вывода *любой* команды.

Поскольку фильтры могут обрабатывать файлы, а стандартный вывод команд может быть перенаправлен к некоторый файл, то объединение двух действий позволяет осуществить мощную и гибкую обработку вывода любой команды. Так как большинство фильтров направляют результаты своего выполнения в стандартный вывод, то "отфильтрованные" результаты могут быть в дальнейшем обработаны посредством направления отфильтрованного вывода в некоторый файл и исполнения другого фильтра над отфильтрованный файлом (вложенность фильтров).

### `wc`: подсчёт количества слов
**Синтаксис**
```bash
wc [-lwc] [filename ...]  # подсчитывает число строк, слов и символов в файле
```

**Примеры**
```bash
$ wc funfile
116	529	3134	funfile	.4
$ wc -l funfile
116	funfile
$ ls > ls.out
$ wc -w ls.out  # подсчёт количества файлов в каталоге
72	ls.out
```

Команда `wc` подсчитывает количество строк, слов и символов в стандартном вводе или выводе. Опциями команды являются `-l` (строки), `-w` (слова), `-c` (символы). Результаты выводятся на экран. Порядок следования опций определяет порядок вывода результатов (по умолчанию: количество строк, слов и символов). Поскольку команда `wc` считает свой ввод со стандартного ввода и направляет свой вывод на стандартный вывод, то эта команда -- *фильтр*.

### `sort`: алфавитная и числовая сортировка
**Синтаксис**:
```bash
sort [-ndutX] [-k номер_поля] [файл ...]  # сортирует строки
```
**Примеры**
```bash
$ sort funfile  # funfile рассматривается как аргумент команды
$ tail -1 /etc/passwd
user3:xyzbkd:303:30:student:user3:/home/user3:/usr/bin/sh
1       2     3  4     5      6       7         8
$ sort -nt: -k 3 /etc/passwd
$ who > whoson
$ sort whoson  # упорядочение пользователей в системе по алфавиту
$ sort -u whoson  # упорядочение с исключением
```

| Опция сортировки|Тип сортировки |
|--|--|
| none | лексикографическая (по кодам ASCII) |
| `-d` | по принципу словаря (игнорируя любые символы, не являющиеся буквами, цифрами или пробелами) |
| `-n` | числовая |
| `-u` | уникальное (исключаются повторяющиеся строки)|


### `grep`: поиск по модели
**Синтаксис**
```bash
grep [-cinv] [-e] модель [-e модель] [файл ...]
grep [-cinv] -f файл_с_моделями [файл ...]
```

**Примеры**
```bash
$ grep user /etc/passwd
$ grep -v user /etc/passwd
$ grep -in -e like -e love funfile
$ who > whoson
$ grep -f whoson /etc/passwd
```

Команда `grep` очень полезна. В качестве первого аргумента в неё задаётся модель поиска (обычно заключаемая в кавычки), другими аргументами служат произвольное число файлов. Можно сделать так, что команда `grep` будет осуществлять поиск по нескольким моделям, если перед каждой из них указать опцию `-e`, или использовать опцию `-f`, за которой следует имя файла, содержащего список моделей. Результатом поиска в указанных файлах-аргументах являются все строки, которые содержат в себе указанную модель. Они выводятся на экран.

Наиболее часто в команде `grep` используются следующие записи:
| ||
|--|--|
|`-c` |подсчитывать только число строк, содержащих заданную модель |
| `-i` | игнорировать регистр букв модели |
| `-n` | сопровождать выводимые строки номерами |
| `-v` | выводить строки, не содержащие заданную модель поиска |


Как и другие фильтры, команда `grep`, если не указан файл, читает свой ввод со стандартного ввода и направляет свой вывод в стандартный вывод.
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTAxMjc2OTk3OSwxNjQ3MTgwNTc2XX0=
-->