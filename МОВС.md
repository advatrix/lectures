# Математические основы вычислительных систем (МОВС)
![](https://i.ibb.co/DLxcmxZ/image.png)

<a href="https://ibb.co/HHNNMs9"><img src="https://i.ibb.co/Jsxxb4S/image.png" alt="image" border="0"></a>

Любое число в десятичной системе счисления, например, 36.037 можно записать таким образом. Это и есть развёрнутая запись.

По определению это есть развёрнутая запись числа $x$:
$$\tag{1}X_{10}=  x_1 * 10^{m-1}+x_2*10^{m-2}+\dots + x_{m-1} * 10^1 + x_m *10^0 +\dots + x_n * 10^{m-n}$$
Запись (1) можем представить в более компактной форме, а именно в форме записи 2:
$$\tag{2}X_{10} = \sum_{i=1}^nx_i*10^{m-i} = 10^m\sum_{i=1}^nx_i*10^{-i}$$
По определению (2)  это есть сокращённая запись числа Х.


В этих записях $n$ - количество цифр в составе числа, $m$ -- количество цифр в целой части. $x_i, i=\overline{1, n}$-- цифры числа, $x_i\in \{0, 1, 2, 3...9\}$. Знак числа в этих записях опущен.

Если мы переходим к произвольной системе счисления с основанием p, переход делается автоматически: вместо 10 мы подставляем p. Например, для p = 2
$$\tag{3}X_2 = x_1*2^{m-1}+x_2*2^{m-2}+\dots+x_{n}*2^{m-n}$$
Это развёрнутая запись числа в системе счисления с основанием 2.

Сокращённая запись числа: $$\tag{4}X_2 = \sum_{i=1}^nx_i*2^{m-i}=2^m\sum_{i=1}^nx_i*2^{-i}$$

По определению это сокращённая запись числа Х в двоичной системе счисления.

Эти сокращённые записи и для десятичной системы счисления, и для двоичной, очень удобны для представления чисел в ЭВМ: можно легко перейти от фиксированной точки/запятой к плавающей.

## Способы представления чисел в ЭВМ
1. С фиксированной запятой
2. с фиксированной точкой
3. с плавающей запятой

### Представление чисел с фиксированной запятой 
$m = const = 0$ -- цифр в целой части нет, есть только дробная часть.

Когда мы работаем с фиксированной запятой, мы работаем с правильными дробями (то есть они по модулю меньше 1).

$$X_2 = \pm\sum_{i=1}^nx_i*2^{-i}=\pm(x_1*2^{-1}+x_2*2^{-2}+\dots+x_n*2^{-n})$$
При этом максимальное положительное число с фиксированной запятой имеет следующую запись:
$$x_{max} = 0.11111\dots111 = 1 - 2^{-n}$$
Минимальное положительное число: $$x_{min} = 0.000\dots001 = 2^{-n}$$
При этом диапазон чисел с фиксированной запятой будет следующий: $$0\leq |X|\leq 1 - 2^{-n}$$$$-1 + 2^{-n} \leq X\leq 1 - 2^{-n}$$

**Формат** числа отражает количество разрядов в представлении чисел, веса разрядов и положение знакового разряда.

Слева расположен знаковый разряд (1 -- отрицательное, 0 -- положительное), далее -- веса разрядов.

Таким образом числа представлены в ЭВМ: так они хранятся на регистрах и в памяти. Через всё вычислительное устройство проходит n+1 шина, к которым подключаются устройства.

Широко используется в ЭВМ, особенно в спец.технике -- бортовых ЭВМ: там нужно меньше оборудования и больше быстродействия.

Первые ЭВМ содержали 9-12 разрядов, после -- 16 разрядов, летающая машина Комета -- до 24 разрядов.

#### Преимущества
- уменьшаются аппаратные затраты для построения ЭВМ
- уменьшается время выполнения арифметических операций

**Недостаток**: все исходные данные, промежуточные результаты, и окончательные результаты должны быть по модулю меньше 1. Поэтому при постановке задачи на ЭВМ с фиксированной запятой необходим расчёт масштабов: крупная, трудоёмкая работа.

Если 1 превышается, то это переполнение и аварийная ситуация.

Зато когда мы умножаем, тут не может быть переполнения, и поэтому переполнение легко убирается

Любой алгоритм реализуется с фиксированной запятой
#### Пример масштабирования

**Задача**. Дано n = 100 положительных чисел $a_1, a_2, \dots, a_n$ Требуется найти их сумму.

**Решение**.

1. Выполняется масштабирование по данным: мы знаем $a_{max}$, и мы выбираем такую степень $k$, где к то наименьшее, при котором  $M_a = 10^k > a_{max}$ и делим все числа на этот масштаб. Получается, что все числа теперь становятся меньше 1 ⇒ исходные данные меньше 1.
2. Данные меньше 1, но их сумма может быть больше 1. Поэтому выполняется второе масштабирование: по сумме. $M_\Sigma = 10^2$. Мы делим слагаемые на 100 и у нас гарантированно сумма не будет больше 1. 

Тогда промежуточные результаты будут такими: $a_1 : (M_a * M_\Sigma)$, и именно они складываются в ЭВМ.

После этого вычисленную в ЭВМ сумму умножаем на масштабы: 
$$\left(\sum_{i=1}^{100}\frac{a_i}{M_a*M_\Sigma}\right)* M_a * M_\Sigma$$


### Фиксированная точка
Все числа являются целыми.

$m = const = n$: количество цифр в целой части равно количеству цифр в числе. Точка стоит в конце числа, в начале -- знак.

$$X_2 = \pm 2^n\sum_{i=1}^nx_i*2^{-i} = \pm\left(x_1*2^{n-1}+x_2*2^{n-2}+\dots +x_n * 2^0\right)$$

При этом максимальное положительное число $X_{max} = 111\dots 1 = 2^n - 1$.

Минимальное число: $X_{min} = 00\dots1 = 2^0 = 1$.

Диапазон, с которым работает ЭВМ: $$0 \leq |X| \leq 2^n - 1$$

$$-2^{n}+1\leq X \leq 2^n-1$$
![](https://i.ibb.co/9TGL6hT/image.png)
Формат: знак изображается слева (один разряд), далее идут веса разрядов:
Всего n+1 разряд, говорят, что это n - разрядные числа. 

#### Преимущества
- Те же, что и с фиксированной запятой: малый объём аппаратных затрат, повышенное быстродействие

**Недостаток**: при вычислениях применяются только целые числа, что ограничивает классы решаемых задач. Например, при умножении разрядная сетка быстро разрастается и надо следить за тем, чтобы не было переполнения.



### Плавающая запятая

$m\neq const$: на обработку идут числа с произвольным расположением запятой: целые, дробные, смешанные.

$$X_2 = \pm2^m\sum_{i=1}^nx_i*2^{-i}$$

При этом обозначения следующие:
- $m$ -- порядок. Он указывает расположение запятой в числе.
- $\sum_{i=1}^n x_i 2^{-i}$ -- мантисса: это все цифры из числа, начиная с первой единицы. 

При этом если $m\leq 0$, число дробное, $m \geq n$ -- целое число, а в остальных случаях число смешанное.

Если мы работаем с порядками и мантиссами и не делаем дополнительных оговорок, можно попасть в неопределённость:

![](https://i.ibb.co/3SfPBG2/image.png)

Чтобы была однозначность, вводят понятие **нормализованной мантиссы**: мантисса как дробь должна находится в диапазоне от 0.10000...0 до $|\sum x_i 2^{-i}| < 1$. То есть это мантисса вида 0, запятая, 1 и потом остальные цифры числа. Так получается полная однозначность.

Формат чисел состоит из двух частей: формата порядков (слева), на который выделяется $n_п$ разрядов, и формата мантиссы -- правая часть.

<a href="https://ibb.co/JFfKNzB"><img src="https://i.ibb.co/Nn8sXLV/image.png" alt="image" border="0"></a>

В формате разрядов один разряд выделяется на знак, а остальные разряды указывают положение запятой (например, если там написано 5, то это значит, что перед запятой идёт ещё 5 знаков).

Порядки -- целые числа со знаком. Порядками определяется диапазон представления чисел.

Формат мантиссы: всего $n_м+1$ разряд: один разряд идёт на знак числа, далее идут все цифры числа -- и целая, и дробная части, начиная с единички. 

Разрядностью мантиссы $n_м$ определяется точность представления чисел.

**Пример**
Нам дано число $A_2 = -11001,011_2$ (целая часть 11001, дробная 011). Требуется его представить в формате, где на $n_п$ отводится 4 разряда (среди них 1 знаковый), и разрядность мантиссы 8.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/YZb452T/image.png" alt="image" border="0"></a>

В данном случае запятая сдвигается вправо на $101_2 = 5$ разрядов вправо, знак мантиссы отрицательные ⇒ само число тоже отрицательное.

Если знак порядка отрицательный, значит положение запятой сдвигается влево.

**Диапазон**

При условии, что количество разрядов порядка ($n_п$) и мантиссы ($n_{м}+1$) задано, можно посчитать диапазон чисел.

$X_{max} = 2^{m_{max}}$ У нас в $n_п$ разрядах отображается некоторое число. Там может быть максимальное число  $m_{max}$. Тогда максимально возможное число получается умножением $m_max$ на максимальную мантиссу:
$$X_{max} = 2^{m_{max}}*M_{max}$$

Какое максимальное число может вместиться в $n_п$ разрядов? Это зависит от того, сколько там разрядов: $$m_{max}=  2^{n_п - 1} - 1$$
Например:
| $n_П$ | $m_{max}$ |
|--|--|
| 4 | 111 |
| 5 | 1111 |
| 6 | 11111 |

Посчитаем максимальное значение нормализованной мантиссы. Оно достигается, когда после нуля идут одни единицы: $$M_{max} = 0.1111\dots1= 1 - 2^{-n_М}\sim 1$$

Таким образом, получаем максимальное число. Вообще говоря, разрядностью мантиссы можно пренебречь и для $n_п = 8$, например, $|x_{max}| = 10^{38}$,

Аналогично для минимального числа: $X_{min} = 2^{-m_{max}} * M_{min};$ Mmin = 0.1000000
 $|x_{min}| = 2^{-128}$

Порядками определяется диапазон, а разрядной сеткой мантиссы -- точность.

Помимо числовых порядков часто используют машинные порядки или порядки со смещением
### Машинные порядки (порядки со смещением).
По определению машинный порядок -- тот же числовой порядок, к которому прибавляется константа смещения $2^{n_п-1}$.
$$m_м = m_ч + 2^{n_п-1}$$

Что дают константы смещения и машинные порядки?

Они не дают повышения точности и быстродействия, но это числа без знака.

<a href="https://ibb.co/W6MJ86k"><img src="https://i.ibb.co/QfTwSfP/image.png" alt="image" border="0"></a>


Дальше приведены примеры констант смещения и их записи в разрядной сетке.

Порядки становятся целыми положительными числами без знака. Наименьший порядок -- все нули в nп разрядах, а наибольший -- все единицы в этих же разрядов. Иногда это просто удобно, но существенных преимуществ машинные порядки не дают.

### Примеры получения машинных порядок $m_м$
Допустим, разрядная сетка для порядков равняется 4 разряда. В этой разрядной сетке находился числовой порядок +5 = 0101. Чему равен машинный порядок?

Он формируется по определению: берём числовой порядок 0101, прибавляем константу смещения 1000 и получаем 1101.

### Отображение порядков на числовой оси
<a href="https://ibb.co/zZ95SfR"><img src="https://i.ibb.co/RcrSCH0/image.png" alt="image" border="0"></a>

Верхняя часть -- числовые порядки. То есть максимальный числовой порядок в $n_п$ разрядах -- справа, минимальный -- слева.

Когда мы добавляем константу смещения, получаем, что минимальный порядок смещения равен 0 (все нули в $n_п$ разрядах). Там, где был 0, появляется сама константа смещения, а максимальный машинный порядок: во всех $n_п$ разрядах находятся единицы.

Порядки обрабатываются на отдельном устройстве. Когда обрабатываются числовые порядки, они представляются в модифицированных кодах (два знаковых бита), чтобы отлавливать переполнение. А машинные порядки обрабатываются с добавлением только одного бита: известно, что знак должен быть положительным и ответ тоже должен быть положительным. Если получается, что в знаковом разряде 1 -- это признак переполнение. И это оценивается как сумма 1 и разряда справа (1, 0) и (1, 1). То есть само переполнение определяется по цифре справа: положительное переполнение или отрицательное переполнение.

# Лекция 2. Методика выполнения операция сложения-вычитания над числами с фиксированной запятой

Это числа, по модулю меньшие 1.

Операция сложения-вычитания является главной операцией: через неё делаются умножения/деления и обрабатываются мантиссы/порядки.

Требования
1. Должна быть исключена операция прямого вычитания. Вычитание должно заменяться сложением специальных кодов (если мы так поступаем, то требуется один сумматор для этой операции, а вычитатель не требуется ⇒ аппаратная часть сокращается в два раза)
2. Обработка цифровых и знаковых разрядов при суммировании должна выполняться по единым правилам: сумматор получается более простым, так как не требуется какой-то аппаратуры для обработки знаковых разрядов
3. Должно автоматически фиксироваться переполнение. Когда работаем с фиксированной запятой, все числа по модулю меньше единицы. А если результат по модулю вдруг больше единицы, это должно автоматически фиксироваться.

Эта методика обеспечивается за счёт применения обратных и дополнительных кодов. Также ещё используется прямой код.

### Прямой код

Прямой код числа $x$ условно обозначается $[x]_п$

Прямой код числа $x$ формируется в соответствии с правилом:
$$x = \begin{cases}x, x\geq 0\\1 + x, x < 0\end{cases}$$

### Примеры
$x_1 = 0.1101 \implies [x_1 = 0.1101]_п = 0.1101$
$x_2 = -0.1101 \implies [x_2 = -0.1101]_п = 1.1101$

Применяется в кодировке знака чисел, в нём задаются исходные данные и в нём выводится результат из ЭВМ.

### Обратный код
Обозначается $[x]_o$

$$[x]_o = \begin{cases}x, x\geq 0\\2 + x - 2 ^{-n}, x\leq 0\end{cases}$$

Видна неоднозначность представления нуля: он может представляться всеми единицами или всеми нулями. Когда работают с обратными кодами, это учитывают.

### Пример
Допустим, имеем число $x = -0.1011$. Переведём его в обратный код.

Мы должны к двойке $10.0000$ прибавить это число и затем вычесть $2^{-n}$ (единичку младшего разряда).

<a href="https://imgbb.com/"><img src="https://i.ibb.co/m6n4cR7/image.png" alt="image" border="0"></a>

Хотя мы стараемся уйти от вычитания, у нас тут две таких операции. Поэтому по определению формировать обратный код не следует.

### Второй способ получения обратного кода отрицательного числа
Мы кодируем знак "минус" единицей, а все остальные биты инвертируем.
$$[0.x_1 x_2 \dots x_n]_o = 1, \overline {x_1} \overline {x_2}\dots \overline {x_n}$$

<a href="https://ibb.co/hRnyrp1"><img src="https://i.ibb.co/RpM9tL4/image.png" alt="image" border="0"></a>

Частный случай: наименьшее по модулю отрицательное число $$[-0.000\dots1]_o = 1.1\dots0$$
Наибольшее по модулю отрицательное число: $$[-0.1\dots11]_o = 1.0\dots0$$

### Обратное преобразование (нахождение числа по обратному коду)

**Правило**. Для обратного преобразования необходимо от обратного кода взять обратный код.

<a href="https://ibb.co/wS4dtJf"><img src="https://i.ibb.co/Mc7gd8m/image.png" alt="image" border="0"></a>


Пример:
$$[[x = -0.110110]_o = 1.001001]_o = 1.110110$$


## Дополнительный код

Обозначается $[x]_д$

Определение $$[x]_д = \begin{cases} x, x\geq0\\2 + x, x < 0\end{cases}$$

У нуля одно изображение.

### Получение дополнительного кода отрицательного числа

$$[-0.x_1\dots x_n] = 1.\overline{x_1}\dots\overline{x_n}+2^{-n}$$

Для получения дополнительного кода отрицательного числа необходимо взять инверсию от цифровой части и прибавить единицу в младший разряд.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/dtH8Yfq/image.png" alt="image" border="0"></a>

В семействе IBM PC используются дополнительные коды.

### Обратное преобразование (нахождение числа по доп. коду)
**Правило**: от дополнительного кода берём дополнительный код

<a href="https://imgbb.com/"><img src="https://i.ibb.co/8XSYZZD/image.png" alt="image" border="0"></a>


## Методика суммирования чисел в обратных и дополнительных кодах

1. $x > 0, y > 0, x + y < 1$
2. $x > 0, y < 0, x + y < 0$
3. $x > 0, y < 0, x + y < 0$
4. $x < 0, y < 0, |x + y| < 1$
--

1)  $x > 0, y > 0, x + y < 1$
Суммируем в обратных кодах:
$[x > 0]_o + [y > 0]_o = x + y$ -- предварительный результат.
Посмотрим, каким должен быть окончательный результат. Так как оба числа положительные, то их сумма должна быть положительная и равна $x + y$. Коррекции не требуется

2) $x > 0, y < 0, x + y > 0$

$[x > 0]_o + [y < 0]_o = x + 2 + y - 2^{-n}$ -- предварительный результат.

Так как сумма больше 0, то обратный код $x + y$ будет равняться $x + y$. Чтобы получить окончательный результат, нужно прибавить к предварительному результату поправку $-2 + 2^{-n}$

<a href="https://imgbb.com/"><img src="https://i.ibb.co/fnTGgBY/image.png" alt="image" border="0"></a>
Знаковая единица сносится и прибавляется к результату.

3) $x > 0, y < 0, x + y < 0$

$[x > 0]_o + [y < 0]_o = x + y + 2 - 2^{-n}$ -- предварительный результат в обратных кодах.

Так как по условию $x + y < 0$, то обратный код для этой суммы будет $x + y + 2 - 2^{-n}$. Сравниваем предварительный и окончательный результат: они совпадают и в этом случае поправка 0.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/PTqS8mk/image.png" alt="image" border="0"></a>


4) $x < 0, y < 0, |x + y| < 1$

$[x < 0]_o + [y < 0]_o = 2 + x - 2^{-n} + 2 + y - 2^{-n}$ (предварительный результат)

Окончательный результат меньше нуля, поэтому он будет $2 + x + y - 2^{-n}$. Чтобы получить окончательный результат, надо к предварительному прибавить поправку $-2 + 2^{-n}$.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/tQ95pbX/image.png" alt="image" border="0"></a>


Во всех рассмотренных случаях мы суммировали числовые и знаковые разряды по единым правилам. Операции прямого вычитания заменяли суммированием.

А что изменится, если суммируются не обратные, а дополнительные коды?

### Дополнительные коды
Случай 2. $x > 0, y < 0, x + y > 0$

$[x > 0]_g + [y < 0]g = x + 2 + y$ (предварительный результат в дополнительных кодах).

По условию $x + y > 0$, поэтому окончательный результат равен $x + y$, и поправка равна $-2$.

В обратных кодах поправка имела величину $-2 + 2^{-n}$.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/Tkf22n6/image.png" alt="image" border="0"></a>


**Вывод**: при суммировании ДК вместо коррекции $-2 + 2^{-n}$ выполняется коррекция $-2$.

Когда мы суммируем в обратных кодах, то перенос из знакового разряда не пропадает, а идёт на суммирование в младший разряд. В дополнительных кодах эти единицы исчезают.


## Вычитание
Операция вычитания выполняется как сложение с изменением знака вычитаемого:
$$[x]_п - [y]_п = [x]_{og} + [-[y]_п]_{og}$$

<a href="https://imgbb.com/"><img src="https://i.ibb.co/F72h2Jp/image.png" alt="image" border="0"></a>


# Лекция 3.
## Дополнительный модифицированный код
Обозначается $[x]_д^м$.
<a href="https://ibb.co/VxykqVn"><img src="https://i.ibb.co/pQDkL2V/image.png" alt="image" border="0"></a>

$$[x]_д^м = \begin{cases} x, x\geq 0\\ 4 + x, x < 0\end{cases}$$

Здесь сохраняется однозначное представление нуля. Он отличается от дополнительного кода только тем, что имеется два знаковых разряда.

### Правило получения дополнительного модифицированного года
Если число положительно, просто приписывается ещё один ноль в знаковые разряды.

Если число отрицательное: 
$$[-0,x_1x_2\dots x_n]_д^м = 11,\overline{x_1} \overline{x_2}\dots\overline{x_n}+ 2 ^{-n}$$

## Обратный модицифированный код
Условное обозначение: $[x]_o^м$

По определению $$[x]_o^м = \begin{cases} x, x\geq 0\\ 4 + x - 2^{-n}, x \leq 0\end{cases}$$

**Недостаток**: двойное представление нуля, неоднозначность. 

### Правило получения обратного модифицированного кода
$$[0.x_1x_2\dots x_n]_o^м = 00, x_1x_2\dots x_n$$$$[-0.x_1x_2\dots x_n]_o^м = 11, \overline{x_1}\overline{x_2}\dots\overline{x_n}$$

### Пример 
$$[-0.1011]_o^м = 11.0100$$

## Суммирование модифицированных кодов


<a href="https://ibb.co/db86RgP"><img src="https://i.ibb.co/N1cpMS9/image.png" alt="image" border="0"></a>
Исходные данные представляются в прямых кодах (см. пример). 

При получении суммы у нас есть перенос из знакового разряда. Эта единица исчезает и выполняется коррекция -4. В обратных кодах, если эта единица вышла из знакового разряда, она не пропадает, а идёт на суммирование младших разрядов.

<a href="https://ibb.co/h9k16Fn"><img src="https://i.ibb.co/1Q3JgGp/image.png" alt="image" border="0"></a>

Отметим, что теперь у нас происходит переполнение (ошибка в слайде: |x + y | > 1 на самом деле)

Пример для двух отрицательных чисел: $[x]_п = 1.1100$.

В дополнительных кодах эта операция выполняется автоматически, и поэтому единица из знаковых разрядов сама исчезает. Несовпадение знаковых разрядов говорит о переполнении: результат по модулю больше единицы.

При этом первый знак в знаковых разрядах $s_1$ -- это знак суммы, указывает на знак результата, а второй знак $s_2$ -- вспомогательный и необходим для фиксации переполнение.

<a href="https://ibb.co/J51K3bS"><img src="https://i.ibb.co/NZvsTkG/image.png" alt="image" border="0"></a>

Существует два подхода к выполнению операции суммирования.

1: операнды хранятся в ОП в прямом коде

Тогда порядок действий таков:

- В операционное устройство из ОП поступают аргументы.
- Далее происходит преобразование в ОК или ДК. 
- Преобразование суммы в прямой код
- Помещение результата в оперативную память

2: операнды хранятся в ОП уже в обратном или дополнительном коде.

В этом случае исключаются преобразования туда-сюда из ДК/ОК в ПК.

Принято считать, что разница несущественна, так как преобразование в обратный и дополнительный код можно сделать на этапе пересылки аппаратным способом, так же и обратно. Но тем не менее, второй подход получил более широкое применение.

При этом если выполняется операция суммирования, то операнды суммируются сразу. Если вычитывание -- то второй операнд преобразуется, но у этого преобразования есть одна особенность: если преобразуются обратные коды, то берётся инверсия и знаковых разрядов, и цифровой части. А если дополнительный, то берётся инверсия и знаков, и числа, и ещё прибавляется единичка в младший разряд.

<a href="https://ibb.co/n6LyZ7K"><img src="https://i.ibb.co/bQKVqsG/image.png" alt="image" border="0"></a>

# Умножение чисел с фиксированной запятой. Машинные методики выполнения операции

## Умножение прямых кодов
Когда умножаются прямые коды, то операция выполняется в два этапа:
1) Определение знака произведении в соответствии с формулой:
<a href="https://ibb.co/NLthSf1"><img src="https://i.ibb.co/VvJymbH/image.png" alt="image" border="0"></a>

2) Умножение цифровых частей (модулей чисел без знака).

<a href="https://ibb.co/QXkkyhy"><img src="https://i.ibb.co/52kkbCb/image.png" alt="image" border="0"></a>

### Умножение в прямых кодах со старших разрядов множителя

$$|Z| = |X|*|Y| =|X| (y_1*2^{-1} + y_2*2^{-2}+\dots +y_n*2^{-n}) = $$$$=|X|*y_1*2^{-1}+|X|*y_2*2^{-2}+\dots+|X|*y_n*2^{-n}$$

### Умножение в прямых кодах с младших разрядов множителя

Перепишем ту же формулу по схеме Горнера:
$$|Z| = |X|*|Y| = (\dots((0 + |X|*y_n)*2^{-1}+|X|*y_{n-1})*2^{-1}+\dots+|X|*y_1)*2^{_1}$$

Если в первом случае у нас было умножение со старших разрядов множителя, то здесь мы имеем дело с умножением с младших разрядов множителя по схеме Горнера. На первом этапе мы $|X|$ умножаем на младший разряд $y_n$ и умножаем на 2^-1^. И так далее.

Эту формулу удобно реализовать итерационно:
$$i = 1\quad A_1 = (0 + |X|*y_n)*2^{-1}$$$$i = 2\quad A_2 = (A_1 + |X|*y_{n-1})*2^{-1}$$$$\dots$$$$i = n\quad A_n = (0 + |X|*y_1)*2^{-1}$$

Такие формулы называют рекуррентными: результат следующей итерации опирается на результат предыдущей.

### Пример
<a href="https://ibb.co/yygGkkD"><img src="https://i.ibb.co/YkfYdd6/image.png" alt="image" border="0"></a>


Заметим, что разрядность сомножителей равна 3, а результат содержит 6 разрядов. В общем случае при перемножении n-разрядных чисел получаем 2n-разрядный результат.

Результат при перемножении не может быть по модулю больше единицы и переполнения никак возникнуть не может, так как мы работаем с числами, по модулю меньшими единицы.

<a href="https://ibb.co/jfZxpSV"><img src="https://i.ibb.co/1QJpSks/image.png" alt="image" border="0"></a>


Надо запомнить:
1. Знаки и цифровые части вычисляются отдельно
2. При перемножении $n$-разрядных чисел получается 2n-разрядный результат
<a href="https://ibb.co/zNG4Ms2"><img src="https://i.ibb.co/3kBC31F/image.png" alt="image" border="0"></a>

## Умножение в дополнительных кодах с автоматической коррекцией

Возможен вариант умножения как с младших, так и со старших разрядов.

При умножении в ДК как со старших, так и с младших разрядов, знак вырабатывается автоматически: знаковый разряд обрабатывается так же, как и числовой.

Если у нас имеются $n$-разрядные операнды, мы так же получаем $2n$-разрядный результат

### Умножение с младших разрядов

Основа метода -- рекуррентная формула: полученный результат на данном этапе является основой для получения результата на следующем.

<a href="https://ibb.co/T2zsYwY"><img src="https://i.ibb.co/pwCSb1b/image.png" alt="image" border="0"></a>

$$A_i = A_{i-1}*2^{-1}+[y_{n+2-i} - y_{n+1-i}]*[x]_g$$

В этой формуле $A_i$ -- результат текущей итерации. $A_{i-1}$ -- предыдущий результат, на который мы опираемся.

Для нас она мб не очень удобна, но для ЭВМ норм, так как вычисление идёт в цикле.

С самого начала мы имеем несуществующий нулевой разряд $y_{n+1}$ -- его на самом деле нет, но мы принимаем его равным 0.

Умножение идёт с младших разрядов к знаковому:

<a href="https://ibb.co/wh36xsV"><img src="https://i.ibb.co/d41KzgF/image.png" alt="image" border="0"></a>

<a href="https://ibb.co/k0L836N"><img src="https://i.ibb.co/ZKQ8H1q/image.png" alt="image" border="0"></a>

Отличие здесь следующее: после (n+1)-го такта сдвига нет, в отличие от умножения в прямых кодах.

<a href="https://ibb.co/fdyKyd9"><img src="https://i.ibb.co/GQ818Q9/image.png" alt="image" border="0"></a>

Если $X$ положительный, то по определению прямой, обратный и дополнительный код есть само число $X$ и мы его просто умножаем на $2^{\pm k}$.

Когда $X < 0$, то прямой, обратный и дополнительный коды так же являются числами и умножаются на $2^{\pm k}$, но случаи их умножения надо рассмотреть отдельно.

Общее условие: результат умножения должен быть по модулю меньше 1 -- общее требование к результатам выполнения операций с числами с фиксированной запятой.

Далее будут приведены примеры с правильными ответами и использованными для этого алгоритмами. Можно будет увидеть, что принцип умножения везде один и тот же, а именно -- сдвиг цифровой части влево или вправо на к разрядов. Однако образуются пустоты, и эти пустоты надо чем-то заполнять.

Случай 1а. Отрицательное число -0.1101. Умножаем прямой код на 2^-2^. Ответ такой: знак, естественно, сохраняется и происходит сдвиг вправо на два разряда, а пустоты заполняются нулями. Нули подчёркнуты -- это те нули, которые заполнили образовавшиеся пустоты.

Случай 1б. Умножаем число на 2^2^. Здесь происходит сдвиг влево на две позиции, и образовавшаяся пустота справа заполняется нулями.

Случай 2а. Работаем с обратными кодами. Умножаем на 2^-3^. Цифровая часть обратного кода сдвигается на 3 разряда вправо, а пустота заполняется единицами, то есть заполняется знаком.

Случай 2б. Умножение обратного кода на 2^2^. Обратный код смещается влево на 2 позиции, пустота справа из двух разрядов заполняется знаком.

То есть когда мы работаем с обратным кодом и умножаем его на степень двойки, он сдвигается влево или вправо на к разрядов, но пустоты всегда заполняются знаком.

Случай 3а. Число отрицательное, представлено в дополнительном коде. Умножаем его на 2^-4^. Знак сохраняется, код сдвигается на 4 позиции вправо, а пустоты заполняются знаком.

Случай 3б. Отрицательное число в дополнительном коде умножается на 2^2^. Умножение выполняется сдвигом цифровой части кода на 2 разряда влево, пустота заполняется нулями.

### Доказательство алгоритмов для обратного кода
<a href="https://ibb.co/3MPm7NX"><img src="https://i.ibb.co/ZYbzV8s/image.png" alt="image" border="0"></a>

а) у нас имеется отрицательное число. Обратный код этого числа по определению равен 1 и инверсии по разрядам. Этот обратный код мы умножаем на 2^-k^ и хотим посмотреть, что получится. Мы используем следующий приём: исходное число умножаем на 2^k^ и смотрим, какое число должно получиться.

Умножая обычное число, мы просто сдвигаем числовую часть вправо. Теперь от результата надо взять обратный код, который по определению равен 1 и инвертированным разрядам. Таким образом, действительно, при умножении на 2^-k^ после знака в обратном коде у нас появляются к единиц и инверсия по цифровой части.

б) когда умножаем на 2^k^. Имеется отрицательное число, в котором имеется s нулей после точки. Берём от него обратный код -- он по определению равен инверсии цифровой части, и умножаем его на 2^k^.

Применяем тот же приём: сперва умножаем исходное число на 2^k^, а потом уже от результата берём обратный код. Когда умножили число, мы получили s-k нулей после точки, в правой части появились к нулей, то есть сдвиг значащих цифр налево на к позиций. От этого берём обратный код и получаем, что после знакового разряда идут s-k единиц, а в конце k единиц ⇒ мы не ошиблись, и пустоты действительно заполняются единицами.

У нас было требование, чтобы мы находились в области фиксированной запятой: умножая, мы не должны вылезти за пределы единицы по модулю.

<a href="https://ibb.co/0MLQ9Fk"><img src="https://i.ibb.co/G2DFMtX/image.png" alt="image" border="0"></a>

Из более младшего разряда вычитаем более старший разряд, на который выполняем умножение. У нас появляется дополнительный фиктивный разряд $y_4 = 0$

Предварительная итерация (0000) равна нулю. 

Первая итерация: y4 = 0 (фиктивный), y3 = 1. Находим разность разрядов (-1), и [x]д умножаем на -1 ⇒ получаем [-x]д. Посмотрим, что у нас получилось: 0.111, и это мы прибавляем к 0000  ⇒ результат первой итерации 0111.

Далее согласно алгоритму мы умножаем результат на 2^-1^, это выполняется сдвигом с заполнением пустоты знаком. Получили 00111 (результат положительный, поэтому заполнили пустоту 0).

И так далее.


Для получения алгоритма умножения со старших разрядов достаточно раскрыть скобки в формуле по схеме Горнера. На семинаре это будет рассмотрено.

# Лекция 5. Деление чисел с фиксированной запятой.

При делении прямых кодов исходные данные в прямых кодах,промежуточный результат и ответ -- в прямых кодах, а сама арифметика выполняется в обратных или дополнительных кодах, по-другому выполнять её невозможно.

<a href="https://ibb.co/Y7yT08n"><img src="https://i.ibb.co/pvRrhZV/image.png" alt="image" border="0"></a>

Нам даны некоторые два числа X и Y в прямом коде с фиксированной запятой, оба по модулю меньше единицы. Нас интересует результат деления X на Y в прямом коде.

**Ограничение**: по модулю результат деления должен быть меньше 2, то есть результатЮ который мы получаем, будет иметь следующий вид: Знак (целая часть -- 0 или 1) (дробная часть $z_1z_2\dots z_n$). 

Ограничение предполагает, что оба числа имеют запись вида $$|X| = 0.1\dots$$

А также сохранение методики для сложения чисел в случае деления.

### Этапы деления
Сначала определяется знак числа:
$$Зн.Z = Зн.X \oplus Зн.Y$$

Затем делятся цифровые части X и Y.

Далее, поскольку знаки частного определяются отдельно, будем рассматривать только деление цифровых частей.
### Алгоритм деления без таблицы умножения
Деление -- это операция, обратная умножению, и в общем виде оно выполняется по таблице умножения. Но существует алгоритм деления без применения этой таблицы:
<a href="https://ibb.co/hm79R0N"><img src="https://i.ibb.co/qryjM68/image.png" alt="image" border="0"></a>

Даны два числа меньше единицы по модулю. Делим одно число на другое. Идея: последовательное вычитание делителя из делимого.

Из 0.83 вычитаем 0.36 и получаем остаток 0.47. Он положительный ⇒ в первой цифре есть 1. Аналогично на следующей итерации, а вот на третьей получается -0.25 < 0  ⇒ на этом этапе вычислена первая цифра частного: 1 + 1 = 2.

Далее восстанавливается остаток до последнего положительного: -0.25 + 0.36 = 0.11 -- восстановленный остаток (откат назад). А затем этот остаток умножается на 10, происходит его увеличение и процедура продолжается.

Такой подход используется при делении в ЭВМ.

### Алгоритм деления со сдвигом остатка и его принудительным восстановлением

<a href="https://ibb.co/s10Bgw6"><img src="https://i.ibb.co/09gwnMF/image.png" alt="image" border="0"></a>

Находится $\alpha_0$ -- нулевой остаток. Если остаток неотрицателен (то есть |x| > |Y|), то целая часть равняется единице (это очевидно), в противном случае целая часть равняется нулю.

Далее вычисляется первая цифра после запятой. Для этого находится $\alpha_1$ либо по верхней, либо по нижней строчке в зависимости от знака $\alpha_0$. По знаку $\alpha_1$ определяется первая цифра после запятой. ($z_1 = [\alpha_1 \geq 0]$).

Далее операция циклически продолжается. Вычисляется вторая цифра после запятой, для этого находится $\alpha_2$ в зависимости от знака $\alpha_1$ и т.д.

Алгоритм подходит и для деления мантисс чисел с плавающей запятой.

<a href="https://ibb.co/f8fpwvp"><img src="https://i.ibb.co/LQmt75t/image.png" alt="image" border="0"></a>

В зависимости от знака на очередной итерации формируются цифры частного.

Этот алгоритм можно упростить, а именно раскрыть скобки в нижней цепочке. Получим две цепочки алгоритма в зависимости от знака на очередной итерации.

<a href="https://ibb.co/NjSdpFy"><img src="https://i.ibb.co/pzyBZ1L/image.png" alt="image" border="0"></a>

Этот алгоритм широко применяется на практике

<a href="https://ibb.co/wyv1x5m"><img src="https://i.ibb.co/dBhyz8Y/image.png" alt="image" border="0"></a>

<a href="https://ibb.co/X8NFFHK"><img src="https://i.ibb.co/NSQWWRJ/image.png" alt="image" border="0"></a>

Отличие: вся арифметика при работе с ПК выполнялась в ДК и знак обрабатывался как отдельный этап. В случае деления чисел в ДК (исходные данные в ДК) знак вырабатывается автоматически.

При определении $\alpha_0$ X сразу сравнивается с Y. (в качестве удвоенного остатка берём [X]д).

<a href="https://ibb.co/MBYqW1c"><img src="https://i.ibb.co/8YWFTxr/image.png" alt="image" border="0"></a>

Знаки разные ⇒ на первом этапе мы Y прибавляем. Знаки одинаковые ⇒ вычитаем. $z_0$ -- это знак результата.

Как поступать, если X больше Y? Ведь в таком случае методика неприменима! В этом случае X дополнительно уменьшают в 2 раза (до тех пор, пока числитель не станет меньше знаменателя), а результат затем, наоборот, увеличивают вдвое столько раз, сколько уменьшали числитель.

<a href="https://ibb.co/92JqVHF"><img src="https://i.ibb.co/wCTKwh9/image.png" alt="image" border="0"></a>


https://ibb.co/C86fMKW

<a href="https://ibb.co/C86fMKW"><img src="https://i.ibb.co/8sbHdgX/image.png" alt="image" border="0"></a>

При умножении чисел с плавающей запятой порядки складываются, а мантиссы перемножаются.

При делении чисел с плавающей запятой порядки вычитаются, а мантиссы делятся. При этом порядки мб представлены в прямых, обратных и дополнительных кодах, а также целыми числами -- в машинных порядках или порядках смещения.

Мантиссы также могут быть представлены в прямых, обратных или дополнительных кодах. При этом умножение мантисс и деление мантисс выполняется по правилам умножения и деления чисел с фиксированной запятой.

При этом при выполнении этих операций могут возникнуть случаи, когда при исходных нормализованных мантиссах мы получаем не нормализованный результат. При этом результат мы должны нормализовать, так как все числа в ЭВМ должны быть нормализованы.

### Случай 1. Получение ненормализованной мантиссы произведения

Первая строка представляет диапазон мантисс числа Х и числа У. По модулю нормализованные мантиссы изменяются от 1/2 и меньше 1.

<a href="https://ibb.co/2v1D9mm"><img src="https://i.ibb.co/x1tpkPP/image.png" alt="image" border="0"></a>


При умножении 1/2 на 1/2 мы получаем 1/4, то есть диапазон произведения мантисс по модулю будет следующий: от 1/4 (0.**0** 1...) до 1 (вторая строчка). Таким образом, при перемножении нормализованных мантисс получается ненормализованный результат, и таких случаев достаточно большое количество (примерно половина).

Если возникает такая ситуация и при умножении появляется ненормализованная мантисса, то мантиссу нормализуют, а именно, сдвигают влево её на один разряд, что равносильно умножению на 2^1^ и одновременно корректируют порядки, чтобы результат не изменился.

Этот случай необходимо фиксировать и фиксация этого случая следующая: если произведение Mz мантисс Mx * My в прямом коде равняется 0...., то если после запятой стоит 0, то это признак ненормализованной мантиссы.

Если результат отрицательный (1,...) и после знака в прямом коде 0, то этот результат также не нормализованный.

Если произведение мантисс, полученных в обратном или дополнительным кодах, положительное, то после запятой  0, если отрицательный, то после запятой 1 -- фиксация случаев не нормализованной мантиссы, в этих случаев мантиссу необходимо нормализовать.

### Случай 2. Получение ненормализованной мантиссы частного
Найдём модуль максимального и минимального частных.

Модуль максимального частного получается как максимальный модуль мантиссы делить на минимальный модуль мантиссы.
<a href="https://ibb.co/Ld2XsGd"><img src="https://i.ibb.co/DfSHjqf/image.png" alt="image" border="0"></a>

То есть так должно быть |Mx|max / |My|min = 0.1...1 / 0.10...0

0.1111...1 можем записать как 1 - (младший разряд) = 1 - 0.0.....01

То есть в этой части может произойти денормализация: частное больше или равно единице, и эту ситуацию необходимо отрабатывать, предварительно зафиксировав.

Минимальный модуль частного, наоборот, равен |Mx|min / |My|max 

В области минимальной по модулю мантиссы нормализация **всегда** сохраняется.

Таким образом, возможное нарушение нормализации -- **появление в частном целой части**.

Эту ситуацию необходимо фиксировать и после фиксации выполнить нормализацию. Она выполняется следующим образом: ненормализованная мантисса делится на 2 сдвигом вправо на 1 разряд, и чтобы результат не изменился, корректируют порядки, прибавляя 1 к их разности.

**Фиксация** это случай при делении прямых кодах:
1. На первом шаге вычисляется разность модулей мантисс. Если она больше 0, то в частном, очевидно, появится целая часть и его надо будет нормализовать.

При делении в ДК такая ситуация не возникает. Методика деления в ДК такова, что числитель по модулю меньше знаменателя, поэтому появление целой части там исключено.

Пример деления прямых кодов
<a href="https://ibb.co/9GRHc5x"><img src="https://i.ibb.co/GFgQnSZ/image.png" alt="image" border="0"></a>

Это означает, что исходные данные и цифры результата в прямом коде, а сами вычисления по любому идут в обратном или дополнительном коде. По другому быть не может.


Поправка: [My]п = 1.1100

### Случай 3.
При умножении или делении чисел с плавающей запятой порядки складываются или вычитаются, и может возникнуть ситуация, когда получающаяся сумма порядков больше, чем максимальный порядок, который можно представить в разрядной сетке ЭВМ.

В этом случае полагают, что результат произведения или результат деления равен бесконечности и работа ЭВМ сопровождается остановом -- зависанием.

Для фиксации порядков, допустим, выделено 4 разряда (np = 4). Тот максимальный порядок, который можно изобразить в этой сетке -- это 0.111. Но работая с порядками такой разрядности, результирующий порядок может равняться и 9, и 12, и такие величины в разрядной сетке отразить невозможно. Это переполнение разрядной сетки порядков.

#### Фиксация этого случая
Выполняется с помощью применения модифицированных обратных и дополнительных кодов для изображения порядков. Порядки обрабатываются на устройстве обработки порядков. Когда порядок приходит на это устройство, его знак удваивается, и обработка идёт уже в двумя знаками. Если в результате обработки порядков на этом устройстве получается переполнение, то в старших разрядах появляется код 01 -- это знаковые разряды. Если такой код возник, результат равен бесконечности.

<a href="https://ibb.co/q5vkqK5"><img src="https://i.ibb.co/Hdjnw6d/image.png" alt="image" border="0"></a>

### Случай 4
Может возникнуть ситуация, что алгебраическая сумма порядков будет меньше минимального числа, которое можно представить в ЭВМ.

Если возникает такая ситуация, то результат произведения или результат нахождения частного полагаются равными нулю. В этом случае ЭВМ не останавливается, вычисления продолжаются.

Фиксация этого случая выполняется с помощью МОК и МДК
<a href="https://ibb.co/FgX9N7G"><img src="https://i.ibb.co/6g82Vs6/image.png" alt="image" border="0"></a>


Если окажется, что при суммировании или вычитании порядков результат меньше наименьшего возможного порядка, который можно представить в ЭВМ (максимального порядка по модулю со знаком минус), то в старших (знаковых) разрядов этого результата возникает комбинация 10.

При умножении порядки складываются (опечатка в примере 1: + [my]o^m^ ) 

<a href="https://ibb.co/R2whGzL"><img src="https://i.ibb.co/XXRyfSm/image.png" alt="image" border="0"></a>

<a href="https://ibb.co/PY3vyN8"><img src="https://i.ibb.co/KGRpgXH/image.png" alt="image" border="0"></a>

Вначале допустим, что числа Х и У записаны с использованием обычного порядка. Это исходные данные. При умножении числовые порядки складываются, а мантиссы перемножаются.

Теперь допустим, что числа Х и У заданы уже с машинными порядками. Рассмотрим результат произведения: возникает вопрос, а можем ли мы так же формировать результат умножения, складывая уже машинные порядки или нет?

В соответствии с формулой, где изображается машинный порядок как числовой порядок плюс константа смещения, мы можем расписать следующее: сумма машинных порядков чисел Х и У это по определению сумма числовых порядков Х и У и двух констант смещения. Это предварительный результат.

А окончательный результат должен иметь вид суммы машинных порядков множителей и константы смещения. Таким образом, чтобы мы получали правильный результат, при работе с машинными порядками необходимо из суммы машинных порядков вычитать константу смещения (удаление лишней константы смещения из предварительного результата).

Таким образом, при умножении чисел с машинными порядками мы так же перемножаем мантиссы и складываем порядки, однако дополнительно вычитаем константу смещения из порядков.

Но вычитание у нас всегда заменяется операцией сложения. У нас имеется np разрядов, константе смещения записывается в них как 100...0, и от этой величины мы берём отрицательную величину.

<a href="https://ibb.co/4RMvbK9"><img src="https://i.ibb.co/ZzK4QGt/image.png" alt="image" border="0"></a>

Так изображается в обратном коде минус константа смещения.

Если для фиксации порядков отводится 4 порядка, то минус константа смещения в ОК будет выглядеть как 1.0111.

Если мы работаем в ДК, то константа смещения в дополнительном коде (2 строка) будет выглядеть как инверсия + единица в младший разряд.

<a href="https://ibb.co/f4Dd96m"><img src="https://i.ibb.co/TmWM1jz/image.png" alt="image" border="0"></a>

Заметим, что в ОП машинные порядки хранятся без знака. Знак добавляется **только на операционном устройстве**.

Выполняя точно такие же выкладки, как и с операцией умножения, мы получаем, что машинный порядок частного равен разности машинных порядков делимого и делителя плюс константа смещения.

<a href="https://ibb.co/pfRLH1B"><img src="https://i.ibb.co/8rd7ymL/image.png" alt="image" border="0"></a>

## Специфика умножения и деления над числами с машинными порядками
### Случай III. 
Когда мы работаем с обычными числовыми порядками, то этот случай характеризуется тем, что сумма или разность порядков больше, чем маскимальных порядок, который можно представить в ЭВМ. ФФиксация этого случая -- код 01 в знаковых разрядов.

В случае **машинного** порядка мы находим машинный порядок произведения или частного. При умножении мы находим сумму машинных порядков операндом и вычитаем константу смещения; при делении находим разность машинных порядков операндов и прибавляем константу смещения. Получаем результат, превышающий максимальный машинный порядок.

Это тот случай, когда результат умножения или деления полагается равным бесконечности и ЭВМ зависает.

<a href="https://ibb.co/RTMCRDK"><img src="https://i.ibb.co/PGb5q6y/image.png" alt="image" border="0"></a>

Диапазон машинных порядков следующий: от всех нулей в разрядной сетке до максимального машинного порядка: в разрядной сетке все единицы.

Если их сложить, получаем перенос единицы в старший разряд: превышение максимального машинного порядка. Когда машинные порядки обрабатываются, то на операционном устройстве к ним добавляется знак. Если он станет отрицательным, то это будет означать переполнение. Таким образом, фиксация этого случая заключается в том, что знаковый разряд равняется 1 (переполнение) и за точкой идёт 0 (больше наибольшего).

<a href="https://ibb.co/nCgbwNH"><img src="https://i.ibb.co/ws0RdF9/image.png" alt="image" border="0"></a>

В первом примере складываем 13 + 14 - 8 в ДК

Во втором примере 12 - 2 + 8 в ОК



                          

<!--stackedit_data:
eyJoaXN0b3J5IjpbLTIxMTk2MjY2MTgsNTM1MDUxNDk4LC0xNT
Y1NDAyMjYyLC0xODU4NTc2NTAsMjE5MTAyNzg2LC0xMDYxMzgw
NjE2LDIwNDU1Mjc1MjQsMTUwMDMyNTYzNywxNDI3MjUwMTMxLC
01NDk2MjMyMzYsLTczOTg4Nzk3M119
-->