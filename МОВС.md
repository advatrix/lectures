# Математические основы вычислительных систем (МОВС)
![](https://i.ibb.co/DLxcmxZ/image.png)

<a href="https://ibb.co/HHNNMs9"><img src="https://i.ibb.co/Jsxxb4S/image.png" alt="image" border="0"></a>

Любое число в десятичной системе счисления, например, 36.037 можно записать таким образом. Это и есть развёрнутая запись.

По определению это есть развёрнутая запись числа $x$:
$$\tag{1}X_{10}=  x_1 * 10^{m-1}+x_2*10^{m-2}+\dots + x_{m-1} * 10^1 + x_m *10^0 +\dots + x_n * 10^{m-n}$$
Запись (1) можем представить в более компактной форме, а именно в форме записи 2:
$$\tag{2}X_{10} = \sum_{i=1}^nx_i*10^{m-i} = 10^m\sum_{i=1}^nx_i*10^{-i}$$
По определению (2)  это есть сокращённая запись числа Х.


В этих записях $n$ - количество цифр в составе числа, $m$ -- количество цифр в целой части. $x_i, i=\overline{1, n}$-- цифры числа, $x_i\in \{0, 1, 2, 3...9\}$. Знак числа в этих записях опущен.

Если мы переходим к произвольной системе счисления с основанием p, переход делается автоматически: вместо 10 мы подставляем p. Например, для p = 2
$$\tag{3}X_2 = x_1*2^{m-1}+x_2*2^{m-2}+\dots+x_{n}*2^{m-n}$$
Это развёрнутая запись числа в системе счисления с основанием 2.

Сокращённая запись числа: $$\tag{4}X_2 = \sum_{i=1}^nx_i*2^{m-i}=2^m\sum_{i=1}^nx_i*2^{-i}$$

По определению это сокращённая запись числа Х в двоичной системе счисления.

Эти сокращённые записи и для десятичной системы счисления, и для двоичной, очень удобны для представления чисел в ЭВМ: можно легко перейти от фиксированной точки/запятой к плавающей.

## Способы представления чисел в ЭВМ
1. С фиксированной запятой
2. с фиксированной точкой
3. с плавающей запятой

### Представление чисел с фиксированной запятой 
$m = const = 0$ -- цифр в целой части нет, есть только дробная часть.

Когда мы работаем с фиксированной запятой, мы работаем с правильными дробями (то есть они по модулю меньше 1).

$$X_2 = \pm\sum_{i=1}^nx_i*2^{-i}=\pm(x_1*2^{-1}+x_2*2^{-2}+\dots+x_n*2^{-n})$$
При этом максимальное положительное число с фиксированной запятой имеет следующую запись:
$$x_{max} = 0.11111\dots111 = 1 - 2^{-n}$$
Минимальное положительное число: $$x_{min} = 0.000\dots001 = 2^{-n}$$
При этом диапазон чисел с фиксированной запятой будет следующий: $$0\leq |X|\leq 1 - 2^{-n}$$$$-1 + 2^{-n} \leq X\leq 1 - 2^{-n}$$

**Формат** числа отражает количество разрядов в представлении чисел, веса разрядов и положение знакового разряда.

Слева расположен знаковый разряд (1 -- отрицательное, 0 -- положительное), далее -- веса разрядов.

Таким образом числа представлены в ЭВМ: так они хранятся на регистрах и в памяти. Через всё вычислительное устройство проходит n+1 шина, к которым подключаются устройства.

Широко используется в ЭВМ, особенно в спец.технике -- бортовых ЭВМ: там нужно меньше оборудования и больше быстродействия.

Первые ЭВМ содержали 9-12 разрядов, после -- 16 разрядов, летающая машина Комета -- до 24 разрядов.

#### Преимущества
- уменьшаются аппаратные затраты для построения ЭВМ
- уменьшается время выполнения арифметических операций

**Недостаток**: все исходные данные, промежуточные результаты, и окончательные результаты должны быть по модулю меньше 1. Поэтому при постановке задачи на ЭВМ с фиксированной запятой необходим расчёт масштабов: крупная, трудоёмкая работа.

Если 1 превышается, то это переполнение и аварийная ситуация.

Зато когда мы умножаем, тут не может быть переполнения, и поэтому переполнение легко убирается

Любой алгоритм реализуется с фиксированной запятой
#### Пример масштабирования

**Задача**. Дано n = 100 положительных чисел $a_1, a_2, \dots, a_n$ Требуется найти их сумму.

**Решение**.

1. Выполняется масштабирование по данным: мы знаем $a_{max}$, и мы выбираем такую степень $k$, где к то наименьшее, при котором  $M_a = 10^k > a_{max}$ и делим все числа на этот масштаб. Получается, что все числа теперь становятся меньше 1 ⇒ исходные данные меньше 1.
2. Данные меньше 1, но их сумма может быть больше 1. Поэтому выполняется второе масштабирование: по сумме. $M_\Sigma = 10^2$. Мы делим слагаемые на 100 и у нас гарантированно сумма не будет больше 1. 

Тогда промежуточные результаты будут такими: $a_1 : (M_a * M_\Sigma)$, и именно они складываются в ЭВМ.

После этого вычисленную в ЭВМ сумму умножаем на масштабы: 
$$\left(\sum_{i=1}^{100}\frac{a_i}{M_a*M_\Sigma}\right)* M_a * M_\Sigma$$


### Фиксированная точка
Все числа являются целыми.

$m = const = n$: количество цифр в целой части равно количеству цифр в числе. Точка стоит в конце числа, в начале -- знак.

$$X_2 = \pm 2^n\sum_{i=1}^nx_i*2^{-i} = \pm\left(x_1*2^{n-1}+x_2*2^{n-2}+\dots +x_n * 2^0\right)$$

При этом максимальное положительное число $X_{max} = 111\dots 1 = 2^n - 1$.

Минимальное число: $X_{min} = 00\dots1 = 2^0 = 1$.

Диапазон, с которым работает ЭВМ: $$0 \leq |X| \leq 2^n - 1$$

$$-2^{n}+1\leq X \leq 2^n-1$$
![](https://i.ibb.co/9TGL6hT/image.png)
Формат: знак изображается слева (один разряд), далее идут веса разрядов:
Всего n+1 разряд, говорят, что это n - разрядные числа. 

#### Преимущества
- Те же, что и с фиксированной запятой: малый объём аппаратных затрат, повышенное быстродействие

**Недостаток**: при вычислениях применяются только целые числа, что ограничивает классы решаемых задач. Например, при умножении разрядная сетка быстро разрастается и надо следить за тем, чтобы не было переполнения.



### Плавающая запятая

$m\neq const$: на обработку идут числа с произвольным расположением запятой: целые, дробные, смешанные.

$$X_2 = \pm2^m\sum_{i=1}^nx_i*2^{-i}$$

При этом обозначения следующие:
- $m$ -- порядок. Он указывает расположение запятой в числе.
- $\sum_{i=1}^n x_i 2^{-i}$ -- мантисса: это все цифры из числа, начиная с первой единицы. 

При этом если $m\leq 0$, число дробное, $m \geq n$ -- целое число, а в остальных случаях число смешанное.

Если мы работаем с порядками и мантиссами и не делаем дополнительных оговорок, можно попасть в неопределённость:

![](https://i.ibb.co/3SfPBG2/image.png)

Чтобы была однозначность, вводят понятие **нормализованной мантиссы**: мантисса как дробь должна находится в диапазоне от 0.10000...0 до $|\sum x_i 2^{-i}| < 1$. То есть это мантисса вида 0, запятая, 1 и потом остальные цифры числа. Так получается полная однозначность.

Формат чисел состоит из двух частей: формата порядков (слева), на который выделяется $n_п$ разрядов, и формата мантиссы -- правая часть.

<a href="https://ibb.co/JFfKNzB"><img src="https://i.ibb.co/Nn8sXLV/image.png" alt="image" border="0"></a>

В формате разрядов один разряд выделяется на знак, а остальные разряды указывают положение запятой (например, если там написано 5, то это значит, что перед запятой идёт ещё 5 знаков).

Порядки -- целые числа со знаком. Порядками определяется диапазон представления чисел.

Формат мантиссы: всего $n_м+1$ разряд: один разряд идёт на знак числа, далее идут все цифры числа -- и целая, и дробная части, начиная с единички. 

Разрядностью мантиссы $n_м$ определяется точность представления чисел.

**Пример**
Нам дано число $A_2 = -11001,011_2$ (целая часть 11001, дробная 011). Требуется его представить в формате, где на $n_п$ отводится 4 разряда (среди них 1 знаковый), и разрядность мантиссы 8.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/YZb452T/image.png" alt="image" border="0"></a>

В данном случае запятая сдвигается вправо на $101_2 = 5$ разрядов вправо, знак мантиссы отрицательные ⇒ само число тоже отрицательное.

Если знак порядка отрицательный, значит положение запятой сдвигается влево.

**Диапазон**

При условии, что количество разрядов порядка ($n_п$) и мантиссы ($n_{м}+1$) задано, можно посчитать диапазон чисел.

$X_{max} = 2^{m_{max}}$ У нас в $n_п$ разрядах отображается некоторое число. Там может быть максимальное число  $m_{max}$. Тогда максимально возможное число получается умножением $m_max$ на максимальную мантиссу:
$$X_{max} = 2^{m_{max}}*M_{max}$$

Какое максимальное число может вместиться в $n_п$ разрядов? Это зависит от того, сколько там разрядов: $$m_{max}=  2^{n_п - 1} - 1$$
Например:
| $n_П$ | $m_{max}$ |
|--|--|
| 4 | 111 |
| 5 | 1111 |
| 6 | 11111 |

Посчитаем максимальное значение нормализованной мантиссы. Оно достигается, когда после нуля идут одни единицы: $$M_{max} = 0.1111\dots1= 1 - 2^{-n_М}\sim 1$$

Таким образом, получаем максимальное число. Вообще говоря, разрядностью мантиссы можно пренебречь и для $n_п = 8$, например, $|x_{max}| = 10^{38}$,

Аналогично для минимального числа: $X_{min} = 2^{-m_{max}} * M_{min};$ Mmin = 0.1000000
 $|x_{min}| = 2^{-128}$

Порядками определяется диапазон, а разрядной сеткой мантиссы -- точность.

Помимо числовых порядков часто используют машинные порядки или порядки со смещением
### Машинные порядки (порядки со смещением).
По определению машинный порядок -- тот же числовой порядок, к которому прибавляется константа смещения $2^{n_п-1}$.
$$m_м = m_ч + 2^{n_п-1}$$

Что дают константы смещения и машинные порядки?

Они не дают повышения точности и быстродействия, но это числа без знака.

<a href="https://ibb.co/W6MJ86k"><img src="https://i.ibb.co/QfTwSfP/image.png" alt="image" border="0"></a>


Дальше приведены примеры констант смещения и их записи в разрядной сетке.

Порядки становятся целыми положительными числами без знака. Наименьший порядок -- все нули в nп разрядах, а наибольший -- все единицы в этих же разрядов. Иногда это просто удобно, но существенных преимуществ машинные порядки не дают.

### Примеры получения машинных порядок $m_м$
Допустим, разрядная сетка для порядков равняется 4 разряда. В этой разрядной сетке находился числовой порядок +5 = 0101. Чему равен машинный порядок?

Он формируется по определению: берём числовой порядок 0101, прибавляем константу смещения 1000 и получаем 1101.

### Отображение порядков на числовой оси
<a href="https://ibb.co/zZ95SfR"><img src="https://i.ibb.co/RcrSCH0/image.png" alt="image" border="0"></a>

Верхняя часть -- числовые порядки. То есть максимальный числовой порядок в $n_п$ разрядах -- справа, минимальный -- слева.

Когда мы добавляем константу смещения, получаем, что минимальный порядок смещения равен 0 (все нули в $n_п$ разрядах). Там, где был 0, появляется сама константа смещения, а максимальный машинный порядок: во всех $n_п$ разрядах находятся единицы.

Порядки обрабатываются на отдельном устройстве. Когда обрабатываются числовые порядки, они представляются в модифицированных кодах (два знаковых бита), чтобы отлавливать переполнение. А машинные порядки обрабатываются с добавлением только одного бита: известно, что знак должен быть положительным и ответ тоже должен быть положительным. Если получается, что в знаковом разряде 1 -- это признак переполнение. И это оценивается как сумма 1 и разряда справа (1, 0) и (1, 1). То есть само переполнение определяется по цифре справа: положительное переполнение или отрицательное переполнение.

# Лекция 2. Методика выполнения операция сложения-вычитания над числами с фиксированной запятой

Это числа, по модулю меньшие 1.

Операция сложения-вычитания является главной операцией: через неё делаются умножения/деления и обрабатываются мантиссы/порядки.

Требования
1. Должна быть исключена операция прямого вычитания. Вычитание должно заменяться сложением специальных кодов (если мы так поступаем, то требуется один сумматор для этой операции, а вычитатель не требуется ⇒ аппаратная часть сокращается в два раза)
2. Обработка цифровых и знаковых разрядов при суммировании должна выполняться по единым правилам: сумматор получается более простым, так как не требуется какой-то аппаратуры для обработки знаковых разрядов
3. Должно автоматически фиксироваться переполнение. Когда работаем с фиксированной запятой, все числа по модулю меньше единицы. А если результат по модулю вдруг больше единицы, это должно автоматически фиксироваться.

Эта методика обеспечивается за счёт применения обратных и дополнительных кодов. Также ещё используется прямой код.

### Прямой код

Прямой код числа $x$ условно обозначается $[x]_п$

Прямой код числа $x$ формируется в соответствии с правилом:
$$x = \begin{cases}x, x\geq 0\\1 + x, x < 0\end{cases}$$

### Примеры
$x_1 = 0.1101 \implies [x_1 = 0.1101]_п = 0.1101$
$x_2 = -0.1101 \implies [x_2 = -0.1101]_п = 1.1101$

Применяется в кодировке знака чисел, в нём задаются исходные данные и в нём выводится результат из ЭВМ.

### Обратный код
Обозначается $[x]_o$

$$[x]_o = \begin{cases}x, x\geq 0\\2 + x - 2 ^{-n}, x\leq 0\end{cases}$$

Видна неоднозначность представления нуля: он может представляться всеми единицами или всеми нулями. Когда работают с обратными кодами, это учитывают.

### Пример
Допустим, имеем число $x = -0.1011$. Переведём его в обратный код.

Мы должны к двойке $10.0000$ прибавить это число и затем вычесть $2^{-n}$ (единичку младшего разряда).

<a href="https://imgbb.com/"><img src="https://i.ibb.co/m6n4cR7/image.png" alt="image" border="0"></a>

Хотя мы стараемся уйти от вычитания, у нас тут две таких операции. Поэтому по определению формировать обратный код не следует.

### Второй способ получения обратного кода отрицательного числа
Мы кодируем знак "минус" единицей, а все остальные биты инвертируем.
$$[0.x_1 x_2 \dots x_n]_o = 1, \overline {x_1} \overline {x_2}\dots \overline {x_n}$$

<a href="https://ibb.co/hRnyrp1"><img src="https://i.ibb.co/RpM9tL4/image.png" alt="image" border="0"></a>

Частный случай: наименьшее по модулю отрицательное число $$[-0.000\dots1]_o = 1.1\dots0$$
Наибольшее по модулю отрицательное число: $$[-0.1\dots11]_o = 1.0\dots0$$

### Обратное преобразование (нахождение числа по обратному коду)

**Правило**. Для обратного преобразования необходимо от обратного кода взять обратный код.

<a href="https://ibb.co/wS4dtJf"><img src="https://i.ibb.co/Mc7gd8m/image.png" alt="image" border="0"></a>


Пример:
$$[[x = -0.110110]_o = 1.001001]_o = 1.110110$$


## Дополнительный код

Обозначается $[x]_д$

Определение $$[x]_д = \begin{cases} x, x\geq0\\2 + x, x < 0\end{cases}$$

У нуля одно изображение.

### Получение дополнительного кода отрицательного числа

$$[-0.x_1\dots x_n] = 1.\overline{x_1}\dots\overline{x_n}+2^{-n}$$

Для получения дополнительного кода отрицательного числа необходимо взять инверсию от цифровой части и прибавить единицу в младший разряд.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/dtH8Yfq/image.png" alt="image" border="0"></a>

В семействе IBM PC используются дополнительные коды.

### Обратное преобразование (нахождение числа по доп. коду)
**Правило**: от дополнительного кода берём дополнительный код

<a href="https://imgbb.com/"><img src="https://i.ibb.co/8XSYZZD/image.png" alt="image" border="0"></a>


## Методика суммирования чисел в обратных и дополнительных кодах

1. $x > 0, y > 0, x + y < 1$
2. $x > 0, y < 0, x + y < 0$
3. $x > 0, y < 0, x + y < 0$
4. $x < 0, y < 0, |x + y| < 1$
--

1)  $x > 0, y > 0, x + y < 1$
Суммируем в обратных кодах:
$[x > 0]_o + [y > 0]_o = x + y$ -- предварительный результат.
Посмотрим, каким должен быть окончательный результат. Так как оба числа положительные, то их сумма должна быть положительная и равна $x + y$. Коррекции не требуется

2) $x > 0, y < 0, x + y > 0$

$[x > 0]_o + [y < 0]_o = x + 2 + y - 2^{-n}$ -- предварительный результат.

Так как сумма больше 0, то обратный код $x + y$ будет равняться $x + y$. Чтобы получить окончательный результат, нужно прибавить к предварительному результату поправку $-2 + 2^{-n}$

<a href="https://imgbb.com/"><img src="https://i.ibb.co/fnTGgBY/image.png" alt="image" border="0"></a>
Знаковая единица сносится и прибавляется к результату.

3) $x > 0, y < 0, x + y < 0$

$[x > 0]_o + [y < 0]_o = x + y + 2 - 2^{-n}$ -- предварительный результат в обратных кодах.

Так как по условию $x + y < 0$, то обратный код для этой суммы будет $x + y + 2 - 2^{-n}$. Сравниваем предварительный и окончательный результат: они совпадают и в этом случае поправка 0.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/PTqS8mk/image.png" alt="image" border="0"></a>


4) $x < 0, y < 0, |x + y| < 1$

$[x < 0]_o + [y < 0]_o = 2 + x - 2^{-n} + 2 + y - 2^{-n}$ (предварительный результат)

Окончательный результат меньше нуля, поэтому он будет $2 + x + y - 2^{-n}$. Чтобы получить окончательный результат, надо к предварительному прибавить поправку $-2 + 2^{-n}$.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/tQ95pbX/image.png" alt="image" border="0"></a>


Во всех рассмотренных случаях мы суммировали числовые и знаковые разряды по единым правилам. Операции прямого вычитания заменяли суммированием.

А что изменится, если суммируются не обратные, а дополнительные коды?

### Дополнительные коды
Случай 2. $x > 0, y < 0, x + y > 0$

$[x > 0]_g + [y < 0]g = x + 2 + y$ (предварительный результат в дополнительных кодах).

По условию $x + y > 0$, поэтому окончательный результат равен $x + y$, и поправка равна $-2$.

В обратных кодах поправка имела величину $-2 + 2^{-n}$.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/Tkf22n6/image.png" alt="image" border="0"></a>


**Вывод**: при суммировании ДК вместо коррекции $-2 + 2^{-n}$ выполняется коррекция $-2$.

Когда мы суммируем в обратных кодах, то перенос из знакового разряда не пропадает, а идёт на суммирование в младший разряд. В дополнительных кодах эти единицы исчезают.


## Вычитание
Операция вычитания выполняется как сложение с изменением знака вычитаемого:
$$[x]_п - [y]_п = [x]_{og} + [-[y]_п]_{og}$$

<a href="https://imgbb.com/"><img src="https://i.ibb.co/F72h2Jp/image.png" alt="image" border="0"></a>


# Лекция 3.
## Дополнительный модифицированный код
Обозначается $[x]_д^м$.
<a href="https://ibb.co/VxykqVn"><img src="https://i.ibb.co/pQDkL2V/image.png" alt="image" border="0"></a>

$$[x]_д^м = \begin{cases} x, x\geq 0\\ 4 + x, x < 0\end{cases}$$

Здесь сохраняется однозначное представление нуля. Он отличается от дополнительного кода только тем, что имеется два знаковых разряда.

### Правило получения дополнительного модифицированного года
Если число положительно, просто приписывается ещё один ноль в знаковые разряды.

Если число отрицательное: 
$$[-0,x_1x_2\dots x_n]_д^м = 11,\overline{x_1} \overline{x_2}\dots\overline{x_n}+ 2 ^{-n}$$

## Обратный модицифированный код
Условное обозначение: $[x]_o^м$

По определению $$[x]_o^м = \begin{cases} x, x\geq 0\\ 4 + x - 2^{-n}, x \leq 0\end{cases}$$

**Недостаток**: двойное представление нуля, неоднозначность. 

### Правило получения обратного модифицированного кода
$$[0.x_1x_2\dots x_n]_o^м = 00, x_1x_2\dots x_n$$$$[-0.x_1x_2\dots x_n]_o^м = 11, \overline{x_1}\overline{x_2}\dots\overline{x_n}$$

### Пример 
$$[-0.1011]_o^м = 11.0100$$

## Суммирование модифицированных кодов


<a href="https://ibb.co/db86RgP"><img src="https://i.ibb.co/N1cpMS9/image.png" alt="image" border="0"></a>
Исходные данные представляются в прямых кодах (см. пример). 

При получении суммы у нас есть перенос из знакового разряда. Эта единица исчезает и выполняется коррекция -4. В обратных кодах, если эта единица вышла из знакового разряда, она не пропадает, а идёт на суммирование младших разрядов.

<a href="https://ibb.co/h9k16Fn"><img src="https://i.ibb.co/1Q3JgGp/image.png" alt="image" border="0"></a>

Отметим, что теперь у нас происходит переполнение (ошибка в слайде: |x + y | > 1 на самом деле)

Пример для двух отрицательных чисел: $[x]_п = 1.1100$.

В дополнительных кодах эта операция выполняется автоматически, и поэтому единица из знаковых разрядов сама исчезает. Несовпадение знаковых разрядов говорит о переполнении: результат по модулю больше единицы.

При этом первый знак в знаковых разрядах $s_1$ -- это знак суммы, указывает на знак результата, а второй знак $s_2$ -- вспомогательный и необходим для фиксации переполнение.

<a href="https://ibb.co/J51K3bS"><img src="https://i.ibb.co/NZvsTkG/image.png" alt="image" border="0"></a>

Существует два подхода к выполнению операции суммирования.

1: операнды хранятся в ОП в прямом коде

Тогда порядок действий таков:

- В операционное устройство из ОП поступают аргументы.
- Далее происходит преобразование в ОК или ДК. 
- Преобразование суммы в прямой код
- Помещение результата в оперативную память

2: операнды хранятся в ОП уже в обратном или дополнительном коде.

В этом случае исключаются преобразования туда-сюда из ДК/ОК в ПК.

Принято считать, что разница несущественна, так как преобразование в обратный и дополнительный код можно сделать на этапе пересылки аппаратным способом, так же и обратно. Но тем не менее, второй подход получил более широкое применение.

При этом если выполняется операция суммирования, то операнды суммируются сразу. Если вычитывание -- то второй операнд преобразуется, но у этого преобразования есть одна особенность: если преобразуются обратные коды, то берётся инверсия и знаковых разрядов, и цифровой части. А если дополнительный, то берётся инверсия и знаков, и числа, и ещё прибавляется единичка в младший разряд.

<a href="https://ibb.co/n6LyZ7K"><img src="https://i.ibb.co/bQKVqsG/image.png" alt="image" border="0"></a>

# Умножение чисел с фиксированной запятой. Машинные методики выполнения операции

## Умножение прямых кодов
Когда умножаются прямые коды, то операция выполняется в два этапа:
1) Определение знака произведении в соответствии с формулой:
<a href="https://ibb.co/NLthSf1"><img src="https://i.ibb.co/VvJymbH/image.png" alt="image" border="0"></a>

2) Умножение цифровых частей (модулей чисел без знака).

<a href="https://ibb.co/QXkkyhy"><img src="https://i.ibb.co/52kkbCb/image.png" alt="image" border="0"></a>

### Умножение в прямых кодах со старших разрядов множителя

$$|Z| = |X|*|Y| =|X| (y_1*2^{-1} + y_2*2^{-2}+\dots +y_n*2^{-n}) = $$$$=|X|*y_1*2^{-1}+|X|*y_2*2^{-2}+\dots+|X|*y_n*2^{-n}$$

### Умножение в прямых кодах с младших разрядов множителя

Перепишем ту же формулу по схеме Горнера:
$$|Z| = |X|*|Y| = (\dots((0 + |X|*y_n)*2^{-1}+|X|*y_{n-1})*2^{-1}+\dots+|X|*y_1)*2^{_1}$$

Если в первом случае у нас было умножение со старших разрядов множителя, то здесь мы имеем дело с умножением с младших разрядов множителя по схеме Горнера. На первом этапе мы $|X|$ умножаем на младший разряд $y_n$ и умножаем на 2^-1^. И так далее.

Эту формулу удобно реализовать итерационно:
$$i = 1\quad A_1 = (0 + |X|*y_n)*2^{-1}$$$$i = 2\quad A_2 = (A_1 + |X|*y_{n-1})*2^{-1}$$$$\dots$$$$i = n\quad A_n = (0 + |X|*y_1)*2^{-1}$$

Такие формулы называют рекуррентными: результат следующей итерации опирается на результат предыдущей.

### Пример
<a href="https://ibb.co/yygGkkD"><img src="https://i.ibb.co/YkfYdd6/image.png" alt="image" border="0"></a>


Заметим, что разрядность сомножителей равна 3, а результат содержит 6 разрядов. В общем случае при перемножении n-разрядных чисел получаем 2n-разрядный результат.

Результат при перемножении не может быть по модулю больше единицы и переполнения никак возникнуть не может, так как мы работаем с числами, по модулю меньшими единицы.

<a href="https://ibb.co/jfZxpSV"><img src="https://i.ibb.co/1QJpSks/image.png" alt="image" border="0"></a>


Надо запомнить:
1. Знаки и цифровые части вычисляются отдельно
2. При перемножении $n$-разрядных чисел получается 2n-разрядный результат
<a href="https://ibb.co/zNG4Ms2"><img src="https://i.ibb.co/3kBC31F/image.png" alt="image" border="0"></a>

## Умножение в дополнительных кодах с автоматической коррекцией

Возможен вариант умножения как с младших, так и со старших разрядов.

При умножении в ДК как со старших, так и с младших разрядов, знак вырабатывается автоматически: знаковый разряд обрабатывается так же, как и числовой.

Если у нас имеются $n$-разрядные операнды, мы так же получаем $2n$-разрядный результат

### Умножение с младших разрядов

Основа метода -- рекуррентная формула: полученный результат на данном этапе является основой для получения результата на следующем.

<a href="https://ibb.co/T2zsYwY"><img src="https://i.ibb.co/pwCSb1b/image.png" alt="image" border="0"></a>

$$A_i = A_{i-1}*2^{-1}+[y_{n+2-i} - y_{n+1-i}]*[x]_g$$

В этой формуле $A_i$ -- результат текущей итерации. $A_{i-1}$ -- предыдущий результат, на который мы опираемся.

Для нас она мб не очень удобна, но для ЭВМ норм, так как вычисление идёт в цикле.

С самого начала мы имеем несуществующий нулевой разряд $y_{n+1}$ -- его на самом деле нет, но мы принимаем его равным 0.

Умножение идёт с младших разрядов к знаковому:

<a href="https://ibb.co/wh36xsV"><img src="https://i.ibb.co/d41KzgF/image.png" alt="image" border="0"></a>

<a href="https://ibb.co/k0L836N"><img src="https://i.ibb.co/ZKQ8H1q/image.png" alt="image" border="0"></a>

Отличие здесь следующее: после (n+1)-го такта сдвига нет, в отличие от умножения в прямых кодах.

<a href="https://ibb.co/fdyKyd9"><img src="https://i.ibb.co/GQ818Q9/image.png" alt="image" border="0"></a>

Если $X$ положительный, то по определению прямой, обратный и дополнительный код есть само число $X$ и мы его просто умножаем на $2^{\pm k}$.

Когда $X < 0$, то прямой, обратный и дополнительный коды так же являются числами и умножаются на $2^{\pm k}$, но случаи их умножения надо рассмотреть отдельно.

Общее условие: результат умножения должен быть по модулю меньше 1 -- общее требование к результатам выполнения операций с числами с фиксированной запятой.

Далее будут приведены примеры с правильными ответами и использованными для этого алгоритмами. Можно будет увидеть, что принцип умножения везде один и тот же, а именно -- сдвиг цифровой части влево или вправо на к разрядов. Однако образуются пустоты, и эти пустоты надо чем-то заполнять.

Случай 1а. Отрицательное число -0.1101. Умножаем прямой код на 2^-2^. Ответ такой: знак, естественно, сохраняется и происходит сдвиг вправо на два разряда, а пустоты заполняются нулями. Нули подчёркнуты -- это те нули, которые заполнили образовавшиеся пустоты.

Случай 1б. Умножаем число на 2^2^. Здесь происходит сдвиг влево на две позиции, и образовавшаяся пустота справа заполняется нулями.

Случай 2а. Работаем с обратными кодами. Умножаем на 2^-3^. Цифровая часть обратного кода сдвигается на 3 разряда вправо, а пустота заполняется единицами, то есть заполняется знаком.

Случай 2б. Умножение обратного кода на 2^2^. Обратный код смещается влево на 2 позиции, пустота справа из двух разрядов заполняется знаком.

То есть когда мы работаем с обратным кодом и умножаем его на степень двойки, он сдвигается влево или вправо на к разрядов, но пустоты всегда заполняются знаком.

Случай 3а. Число отрицательное, представлено в дополнительном коде. Умножаем его на 2^-4^. Знак сохраняется, код сдвигается на 4 позиции вправо, а пустоты заполняются знаком.

Случай 3б. Отрицательное число в дополнительном коде умножается на 2^2^. Умножение выполняется сдвигом цифровой части кода на 2 разряда влево, пустота заполняется нулями.

### Доказательство алгоритмов для обратного кода
<a href="https://ibb.co/3MPm7NX"><img src="https://i.ibb.co/ZYbzV8s/image.png" alt="image" border="0"></a>

а) у нас имеется отрицательное число. Обратный код этого числа по определению равен 1 и инверсии по разрядам. Этот обратный код мы умножаем на 2^-k^ и хотим посмотреть, что получится. Мы используем следующий приём: исходное число умножаем на 2^k^ и смотрим, какое число должно получиться.

Умножая обычное число, мы просто сдвигаем числовую часть вправо. Теперь от результата надо взять обратный код, который по определению равен 1 и инвертированным разрядам. Таким образом, действительно, при умножении на 2^-k^ после знака в обратном коде у нас появляются к единиц и инверсия по цифровой части.

б) когда умножаем на 2^k^. Имеется отрицательное число, в котором имеется s нулей после точки. Берём от него обратный код -- он по определению равен инверсии цифровой части, и умножаем его на 2^k^.

Применяем тот же приём: сперва умножаем исходное число на 2^k^, а потом уже от результата берём обратный код. Когда умножили число, мы получили s-k нулей после точки, в правой части появились к нулей, то есть сдвиг значащих цифр налево на к позиций. От этого берём обратный код и получаем, что после знакового разряда идут s-k единиц, а в конце k единиц ⇒ мы не ошиблись, и пустоты действительно заполняются единицами.

У нас было требование, чтобы мы находились в области фиксированной запятой: умножая, мы не должны вылезти за пределы единицы по модулю.

<a href="https://ibb.co/0MLQ9Fk"><img src="https://i.ibb.co/G2DFMtX/image.png" alt="image" border="0"></a>

Из более младшего разряда вычитаем более старший разряд, на который выполняем умножение. У нас появляется дополнительный фиктивный разряд $y_4 = 0$

Предварительная итерация (0000) равна нулю. 

Первая итерация: y4 = 0 (фиктивный), y3 = 1. Находим разность разрядов (-1), и [x]д умножаем на -1 ⇒ получаем [-x]д. Посмотрим, что у нас получилось: 0.111, и это мы прибавляем к 0000  ⇒ результат первой итерации 0111.

Далее согласно алгоритму мы умножаем результат на 2^-1^, это выполняется сдвигом с заполнением пустоты знаком. Получили 00111 (результат положительный, поэтому заполнили пустоту 0).

И так далее.


Для получения алгоритма умножения со старших разрядов достаточно раскрыть скобки в формуле по схеме Горнера. На семинаре это будет рассмотрено.

# Лекция 5. Деление чисел с фиксированной запятой.

При делении прямых кодов исходные данные в прямых кодах,промежуточный результат и ответ -- в прямых кодах, а сама арифметика выполняется в обратных или дополнительных кодах, по-другому выполнять её невозможно.

<a href="https://ibb.co/Y7yT08n"><img src="https://i.ibb.co/pvRrhZV/image.png" alt="image" border="0"></a>

Нам даны некоторые два числа X и Y в прямом коде с фиксированной запятой, оба по модулю меньше единицы. Нас интересует результат деления X на Y в прямом коде.

**Ограничение**: по модулю результат деления должен быть меньше 2, то есть результатЮ который мы получаем, будет иметь следующий вид: Знак (целая часть -- 0 или 1) (дробная часть $z_1z_2\dots z_n$). 

Ограничение предполагает, что оба числа имеют запись вида $$|X| = 0.1\dots$$

А также сохранение методики для сложения чисел в случае деления.

### Этапы деления
Сначала определяется знак числа:
$$Зн.Z = Зн.X \oplus Зн.Y$$

Затем делятся цифровые части X и Y.

Далее, поскольку знаки частного определяются отдельно, будем рассматривать только деление цифровых частей.
### Алгоритм деления без таблицы умножения
Деление -- это операция, обратная умножению, и в общем виде оно выполняется по таблице умножения. Но существует алгоритм деления без применения этой таблицы:
<a href="https://ibb.co/hm79R0N"><img src="https://i.ibb.co/qryjM68/image.png" alt="image" border="0"></a>

Даны два числа меньше единицы по модулю. Делим одно число на другое. Идея: последовательное вычитание делителя из делимого.

Из 0.83 вычитаем 0.36 и получаем остаток 0.47. Он положительный ⇒ в первой цифре есть 1. Аналогично на следующей итерации, а вот на третьей получается -0.25 < 0  ⇒ на этом этапе вычислена первая цифра частного: 1 + 1 = 2.

Далее восстанавливается остаток до последнего положительного: -0.25 + 0.36 = 0.11 -- восстановленный остаток (откат назад). А затем этот остаток умножается на 10, происходит его увеличение и процедура продолжается.

Такой подход используется при делении в ЭВМ.

### Алгоритм деления со сдвигом остатка и его принудительным восстановлением

<a href="https://ibb.co/s10Bgw6"><img src="https://i.ibb.co/09gwnMF/image.png" alt="image" border="0"></a>

Находится $\alpha_0$ -- нулевой остаток. Если остаток неотрицателен (то есть |x| > |Y|), то целая часть равняется единице (это очевидно), в противном случае целая часть равняется нулю.

Далее вычисляется первая цифра после запятой. Для этого находится $\alpha_1$ либо по верхней, либо по нижней строчке в зависимости от знака $\alpha_0$. По знаку $\alpha_1$ определяется первая цифра после запятой. ($z_1 = [\alpha_1 \geq 0]$).

Далее операция циклически продолжается. Вычисляется вторая цифра после запятой, для этого находится $\alpha_2$ в зависимости от знака $\alpha_1$ и т.д.

Алгоритм подходит и для деления мантисс чисел с плавающей запятой.

<a href="https://ibb.co/f8fpwvp"><img src="https://i.ibb.co/LQmt75t/image.png" alt="image" border="0"></a>

В зависимости от знака на очередной итерации формируются цифры частного.

Этот алгоритм можно упростить, а именно раскрыть скобки в нижней цепочке. Получим две цепочки алгоритма в зависимости от знака на очередной итерации.

<a href="https://ibb.co/NjSdpFy"><img src="https://i.ibb.co/pzyBZ1L/image.png" alt="image" border="0"></a>

Этот алгоритм широко применяется на практике

<a href="https://ibb.co/wyv1x5m"><img src="https://i.ibb.co/dBhyz8Y/image.png" alt="image" border="0"></a>

<a href="https://ibb.co/X8NFFHK"><img src="https://i.ibb.co/NSQWWRJ/image.png" alt="image" border="0"></a>

Отличие: вся арифметика при работе с ПК выполнялась в ДК и знак обрабатывался как отдельный этап. В случае деления чисел в ДК (исходные данные в ДК) знак вырабатывается автоматически.

При определении $\alpha_0$ X сразу сравнивается с Y. (в качестве удвоенного остатка берём [X]д).

<a href="https://ibb.co/MBYqW1c"><img src="https://i.ibb.co/8YWFTxr/image.png" alt="image" border="0"></a>

Знаки разные ⇒ на первом этапе мы Y прибавляем. Знаки одинаковые ⇒ вычитаем. $z_0$ -- это знак результата.

Как поступать, если X больше Y? Ведь в таком случае методика неприменима! В этом случае X дополнительно уменьшают в 2 раза (до тех пор, пока числитель не станет меньше знаменателя), а результат затем, наоборот, увеличивают вдвое столько раз, сколько уменьшали числитель.

<a href="https://ibb.co/92JqVHF"><img src="https://i.ibb.co/wCTKwh9/image.png" alt="image" border="0"></a>


https://ibb.co/C86fMKW

<a href="https://ibb.co/C86fMKW"><img src="https://i.ibb.co/8sbHdgX/image.png" alt="image" border="0"></a>

При умножении чисел с плавающей запятой порядки складываются, а мантиссы перемножаются.

При делении чисел с плавающей запятой порядки вычитаются, а мантиссы делятся. При этом порядки мб представлены в прямых, обратных и дополнительных кодах, а также целыми числами -- в машинных порядках или порядках смещения.

Мантиссы также могут быть представлены в прямых, обратных или дополнительных кодах. При этом умножение мантисс и деление мантисс выполняется по правилам умножения и деления чисел с фиксированной запятой.

При этом при выполнении этих операций могут возникнуть случаи, когда при исходных нормализованных мантиссах мы получаем не нормализованный результат. При этом результат мы должны нормализовать, так как все числа в ЭВМ должны быть нормализованы.

### Случай 1. Получение ненормализованной мантиссы произведения

Первая строка представляет диапазон мантисс числа Х и числа У. По модулю нормализованные мантиссы изменяются от 1/2 и меньше 1.

<a href="https://ibb.co/2v1D9mm"><img src="https://i.ibb.co/x1tpkPP/image.png" alt="image" border="0"></a>


При умножении 1/2 на 1/2 мы получаем 1/4, то есть диапазон произведения мантисс по модулю будет следующий: от 1/4 (0.**0** 1...) до 1 (вторая строчка). Таким образом, при перемножении нормализованных мантисс получается ненормализованный результат, и таких случаев достаточно большое количество (примерно половина).

Если возникает такая ситуация и при умножении появляется ненормализованная мантисса, то мантиссу нормализуют, а именно, сдвигают влево её на один разряд, что равносильно умножению на 2^1^ и одновременно корректируют порядки, чтобы результат не изменился.

Этот случай необходимо фиксировать и фиксация этого случая следующая: если произведение Mz мантисс Mx * My в прямом коде равняется 0...., то если после запятой стоит 0, то это признак ненормализованной мантиссы.

Если результат отрицательный (1,...) и после знака в прямом коде 0, то этот результат также не нормализованный.

Если произведение мантисс, полученных в обратном или дополнительным кодах, положительное, то после запятой  0, если отрицательный, то после запятой 1 -- фиксация случаев не нормализованной мантиссы, в этих случаев мантиссу необходимо нормализовать.

### Случай 2. Получение ненормализованной мантиссы частного
Найдём модуль максимального и минимального частных.

Модуль максимального частного получается как максимальный модуль мантиссы делить на минимальный модуль мантиссы.
<a href="https://ibb.co/Ld2XsGd"><img src="https://i.ibb.co/DfSHjqf/image.png" alt="image" border="0"></a>

То есть так должно быть |Mx|max / |My|min = 0.1...1 / 0.10...0

0.1111...1 можем записать как 1 - (младший разряд) = 1 - 0.0.....01

То есть в этой части может произойти денормализация: частное больше или равно единице, и эту ситуацию необходимо отрабатывать, предварительно зафиксировав.

Минимальный модуль частного, наоборот, равен |Mx|min / |My|max 

В области минимальной по модулю мантиссы нормализация **всегда** сохраняется.

Таким образом, возможное нарушение нормализации -- **появление в частном целой части**.

Эту ситуацию необходимо фиксировать и после фиксации выполнить нормализацию. Она выполняется следующим образом: ненормализованная мантисса делится на 2 сдвигом вправо на 1 разряд, и чтобы результат не изменился, корректируют порядки, прибавляя 1 к их разности.

**Фиксация** это случай при делении прямых кодах:
1. На первом шаге вычисляется разность модулей мантисс. Если она больше 0, то в частном, очевидно, появится целая часть и его надо будет нормализовать.

При делении в ДК такая ситуация не возникает. Методика деления в ДК такова, что числитель по модулю меньше знаменателя, поэтому появление целой части там исключено.

Пример деления прямых кодов
<a href="https://ibb.co/9GRHc5x"><img src="https://i.ibb.co/GFgQnSZ/image.png" alt="image" border="0"></a>

Это означает, что исходные данные и цифры результата в прямом коде, а сами вычисления по любому идут в обратном или дополнительном коде. По другому быть не может.


Поправка: [My]п = 1.1100

### Случай 3.
При умножении или делении чисел с плавающей запятой порядки складываются или вычитаются, и может возникнуть ситуация, когда получающаяся сумма порядков больше, чем максимальный порядок, который можно представить в разрядной сетке ЭВМ.

В этом случае полагают, что результат произведения или результат деления равен бесконечности и работа ЭВМ сопровождается остановом -- зависанием.

Для фиксации порядков, допустим, выделено 4 разряда (np = 4). Тот максимальный порядок, который можно изобразить в этой сетке -- это 0.111. Но работая с порядками такой разрядности, результирующий порядок может равняться и 9, и 12, и такие величины в разрядной сетке отразить невозможно. Это переполнение разрядной сетки порядков.

#### Фиксация этого случая
Выполняется с помощью применения модифицированных обратных и дополнительных кодов для изображения порядков. Порядки обрабатываются на устройстве обработки порядков. Когда порядок приходит на это устройство, его знак удваивается, и обработка идёт уже в двумя знаками. Если в результате обработки порядков на этом устройстве получается переполнение, то в старших разрядах появляется код 01 -- это знаковые разряды. Если такой код возник, результат равен бесконечности.

<a href="https://ibb.co/q5vkqK5"><img src="https://i.ibb.co/Hdjnw6d/image.png" alt="image" border="0"></a>

### Случай 4
Может возникнуть ситуация, что алгебраическая сумма порядков будет меньше минимального числа, которое можно представить в ЭВМ.

Если возникает такая ситуация, то результат произведения или результат нахождения частного полагаются равными нулю. В этом случае ЭВМ не останавливается, вычисления продолжаются.

Фиксация этого случая выполняется с помощью МОК и МДК
<a href="https://ibb.co/FgX9N7G"><img src="https://i.ibb.co/6g82Vs6/image.png" alt="image" border="0"></a>


Если окажется, что при суммировании или вычитании порядков результат меньше наименьшего возможного порядка, который можно представить в ЭВМ (максимального порядка по модулю со знаком минус), то в старших (знаковых) разрядов этого результата возникает комбинация 10.

При умножении порядки складываются (опечатка в примере 1: + [my]o^m^ ) 

<a href="https://ibb.co/R2whGzL"><img src="https://i.ibb.co/XXRyfSm/image.png" alt="image" border="0"></a>

<a href="https://ibb.co/PY3vyN8"><img src="https://i.ibb.co/KGRpgXH/image.png" alt="image" border="0"></a>

Вначале допустим, что числа Х и У записаны с использованием обычного порядка. Это исходные данные. При умножении числовые порядки складываются, а мантиссы перемножаются.

Теперь допустим, что числа Х и У заданы уже с машинными порядками. Рассмотрим результат произведения: возникает вопрос, а можем ли мы так же формировать результат умножения, складывая уже машинные порядки или нет?

В соответствии с формулой, где изображается машинный порядок как числовой порядок плюс константа смещения, мы можем расписать следующее: сумма машинных порядков чисел Х и У это по определению сумма числовых порядков Х и У и двух констант смещения. Это предварительный результат.

А окончательный результат должен иметь вид суммы машинных порядков множителей и константы смещения. Таким образом, чтобы мы получали правильный результат, при работе с машинными порядками необходимо из суммы машинных порядков вычитать константу смещения (удаление лишней константы смещения из предварительного результата).

Таким образом, при умножении чисел с машинными порядками мы так же перемножаем мантиссы и складываем порядки, однако дополнительно вычитаем константу смещения из порядков.

Но вычитание у нас всегда заменяется операцией сложения. У нас имеется np разрядов, константе смещения записывается в них как 100...0, и от этой величины мы берём отрицательную величину.

<a href="https://ibb.co/4RMvbK9"><img src="https://i.ibb.co/ZzK4QGt/image.png" alt="image" border="0"></a>

Так изображается в обратном коде минус константа смещения.

Если для фиксации порядков отводится 4 порядка, то минус константа смещения в ОК будет выглядеть как 1.0111.

Если мы работаем в ДК, то константа смещения в дополнительном коде (2 строка) будет выглядеть как инверсия + единица в младший разряд.

<a href="https://ibb.co/f4Dd96m"><img src="https://i.ibb.co/TmWM1jz/image.png" alt="image" border="0"></a>

Заметим, что в ОП машинные порядки хранятся без знака. Знак добавляется **только на операционном устройстве**.

Выполняя точно такие же выкладки, как и с операцией умножения, мы получаем, что машинный порядок частного равен разности машинных порядков делимого и делителя плюс константа смещения.

<a href="https://ibb.co/pfRLH1B"><img src="https://i.ibb.co/8rd7ymL/image.png" alt="image" border="0"></a>

## Специфика умножения и деления над числами с машинными порядками
### Случай III. 
Когда мы работаем с обычными числовыми порядками, то этот случай характеризуется тем, что сумма или разность порядков больше, чем маскимальных порядок, который можно представить в ЭВМ. ФФиксация этого случая -- код 01 в знаковых разрядов.

В случае **машинного** порядка мы находим машинный порядок произведения или частного. При умножении мы находим сумму машинных порядков операндом и вычитаем константу смещения; при делении находим разность машинных порядков операндов и прибавляем константу смещения. Получаем результат, превышающий максимальный машинный порядок.

Это тот случай, когда результат умножения или деления полагается равным бесконечности и ЭВМ зависает.

<a href="https://ibb.co/RTMCRDK"><img src="https://i.ibb.co/PGb5q6y/image.png" alt="image" border="0"></a>

Диапазон машинных порядков следующий: от всех нулей в разрядной сетке до максимального машинного порядка: в разрядной сетке все единицы.

Если их сложить, получаем перенос единицы в старший разряд: превышение максимального машинного порядка. Когда машинные порядки обрабатываются, то на операционном устройстве к ним добавляется знак. Если он станет отрицательным, то это будет означать переполнение. Таким образом, фиксация этого случая заключается в том, что знаковый разряд равняется 1 (переполнение) и за точкой идёт 0 (больше наибольшего).

<img src="https://i.ibb.co/ws0RdF9/image.png" alt="image" border="0">

В первом примере складываем 13 + 14 - 8 в ДК

Во втором примере 12 - 2 + 8 в ОК


<a href="https://ibb.co/Pj7sQXd"><img src="https://i.ibb.co/fFhVv6s/image.png" alt="image" border="0"></a>

Это случай, когда результат умножения или деления равен 0, в обычных порядках он фиксируется с использованием модифицированных кодов. Этот случай фиксировался кодом 10 в знаковых разрядах на устройстве, которое обрабатывало числовые порядки, результат такой операции полагался равным 0 и ЭВМ продолжала работу.

В случае **машинных** порядков при делении и умножении чисел машинные порядки должны находиться в диапазоне от 0...0 до 1...1. При этом машинные порядки складываются и вычитается константса смещения в случае умножения; а при делении машинные порядки вычитаются и константа смещения прибавляется. Переполнение разрядной сетки: получающийся результат обработки машинных порядков меньше, чем минимальный машинный порядок.

Диапазон машинных порядков от 0...0 до 1...1. Что будет получаться, если мы ко всем нулям прибавим -1. 

Получаем, что в np разрядах все единицы и знак знакового разряда 1 ⇒ на операционном устройстве получается отрицательный знак.

Вычтем единицу ещё раз. Знак остался тем же, после него опять идут единицы. И так далее.

Это используется для фиксации переполнении в случае меньше наименьшего, когда на операционном устройстве обработки машинных порядков в знаковом разряде получается 1, то это уже переполнение, а если после этого идёт ещё 1, то это результат меньше наименьшего -- фиксация этого случая.

<img src="https://i.ibb.co/Y3wgjyc/image.png" alt="image" border="0">

Тут ошибка: Z = 0, а не бесконечности

<img src="https://i.ibb.co/VqgX9H2/image.png" alt="image" border="0">

# Лекция 6. Сложение-вычитание чисел с плавающей запятой
<img src="https://i.ibb.co/y44fwd7/image.png" alt="image" border="0">

Допустим, у нас имеется два числа в 10СС. Первое число в нормализованном виде выглядит как 10^2^*0.3607854. В таком виде эти числа непосредственно хранятся в памяти.

При сложении чисел с плавающей запятой нельзя непосредственно складывать мантиссы, потому что веса цифр мантиссы разные и зависят от порядков. Чтобы обеспечить корректность сложения, необходимо обеспечить равенство порядков слагаемых. В таком случае мы получаем следующую запись:
- первое число остаётся без изменений
- второе число **с таким же порядком** будет выглядеть как 0.0009532

Если мы будем складывать числа с равными порядками, результат сложения будет корректен, потому что в данном случае, например, 7 будет складываться с 9, то есть сотые будут складываться с сотыми, 8 будет складываться с 5, то есть тысячные с тысячными и так далее. Поэтому когда складываются или вычитаются числа с плавающей запятой, первым действием является обеспечение равенства порядков слагаемых.

Для этого находится разность порядков, причём неважно, в какой последовательности что вычитать: первой из второго или второй из первого. Далее по разности находится наименьший по величине порядок (если разность положительная, первый порядок больше, иначе наоборот).

Далее число с наибольшим порядком остаётся без изменений, а число с наименьшим порядком денормализуется посредством сдвига цифр после запятой на разность порядков.

Если бы разность получилась отрицательное, второе число осталось бы без изменений, а первое подвергнулось денормализации на величину разности порядков.

При этом достигается равенство порядков чисел и можно проводить операцию алгебраического суммирования.
<img src="https://i.ibb.co/MZvKsDb/image.png" alt="image" border="0">

Даны два числа: X и Y с плавающей запятой. Выполняется алгебраическое сложение (в него входят сложение и вычитание). Порядок суммы или разности равен **максимальному порядку слагаемых**. Эта величина 2^m max^ умножается на сумму или разность **модифицированных** мантисс (со штрихами).

<img src="https://i.ibb.co/YbXyQjh/image.png" alt="image" border="0">

                          
На первом шаге сразу находится разность порядков чисел X и Y. 

<a href="https://ibb.co/xSZsVds"><img src="https://i.ibb.co/6RQZ6LZ/image.png" alt="image" border="0"></a>

вычитая порядки, получаем, что разность порядков равна 11.110 Разность порядков отрицательная, поэтому мы делаем выводы
- сдвигаться будет мантисса числа X, потому что его порядок меньше
- мы будем выравнивать порядки посредство прибавления единиц, чтобы отрицательная величина стала равняться нулю

Прибавляем единицу и сдвигаем мантиссу, пока разность порядков не занулится.

Первая разность порядков равна 11.110 < 0. Прибавляем 1 к разности порядков и одновременно сдвигаем мантиссу числа X на одну позицию вправо. 

Прибавляем единицу и получаем 11.111 < 0. Опять прибавляем 1 и сдвигаем мантиссу вправо.

После второго сдвига мантисса X равна 1.1101, а порядки выравниваются (00.000). Числа подготовлены к вычитанию.

Вычитаем мантиссы, потому что равенство порядков уже достигнуто. Получаем разность мантисс 00.1011 -- это разность мантисс с равными порядками.

Записываем ответ. В ответ идёт максимальный из порядков (порядок числа Y), записанный в том же коде, и результата вычитания мантисс с равными порядками, тоже в дополнительном коде (потому что исходные числа заданы в ДК)

## Частные случаи
<a href="https://ibb.co/W05R0mZ"><img src="https://i.ibb.co/vhqMh0p/image.png" alt="image" border="0"></a>

### 1. Получение суммы с ненормализованной мантиссой

Мы сложили мантиссы и оказалось, что после знакового разряда у нас имеется $i$ нулей. Поэтому мы обязаны нормализовать результат, чтобы эти нули исчезли, без искажения величины самого результата.

Нормализованная мантисса должна находиться по модулю в диапазоне от 1/2 до 1, то есть первая цифра после знакового разряда должна быть 1.

В этом случае ненормализованную мантиссу мы умножаем на $2^{+i}$. Мантисса становится нормализованной, и одновременно, чтобы результат не изменился, из максимального порядка, который идёт в ответ, мы вычитаем $i$ единиц.

При этом следующей строчкой даётся пояснение, что происходит. У нас результат $Z = 2^{\max (m_x, m_y)} * M_{z нн}$ (ненормализованная мантисса) и это равняется $2^{\max (m_x, m_y) - i}*M_{z нн} * 2^{+i}$

#### Признак этого случая
Когда мантиссу мы сдвигаем влево на $i$ разрядов и одновременно корректируем порядок. И здесь расписаны случая для прямых, обратных и дополнительных кодов.

В мантиссе результата в прямом коде после знакового разряда идёт 0. 

В ОК или ДК если мантисса ненормализованная, то это зависит от её знака: если она больше 0, то после точки идёт 0; если она меньше 0, то после точки идёт 1.


<a href="https://ibb.co/fdTMPdf"><img src="https://i.ibb.co/gZcyBZN/image.png" alt="image" border="0"></a>

Выполняется сложение мантисс и анализируются знаки суммы. Наличие нулей после знаков говорит о том, что мантиссы ненормализованы. Поэтому начинается процесс нормализации. Сперва мантисса увеличивается в два раза сдвигом на один разряд и одновременно из максимального из порядков (с данном случае они равны) вычитается единица.

### 2. Получение целой части в сумме мантисс
<a href="https://ibb.co/Htp4Jsw"><img src="https://i.ibb.co/0CV2wS4/image.png" alt="image" border="0"></a>

В этом случае результат нормализуется, а именно, мантисса, которая по модулю больше или равна единице, делится на 2 (с помощью сдвига), становится нормализованной (попадает в нужный диапазон, что обозначено фигурной скобкой), и одновременно, чтобы результат не изменился, к максимальному из порядков прибавляется единица.

Признак: при суммировании мантисс в знаковых разрядах возникает код 10 или 01 -- признак того, что мантиссы имеют целую часть.
<a href="https://ibb.co/jZVZjSW"><img src="https://i.ibb.co/VpHpksQ/image.png" alt="image" border="0"></a>

Тут ошибка: мантисса числа Х в дополнительном коде равна 11.0011

### 3. Получение числа, большего максимально возможного

<a href="https://imgbb.com/"><img src="https://i.ibb.co/5cz9Gpm/image.png" alt="image" border="0"></a>

Код здесь 10 (01 писать не надо)

<a href="https://ibb.co/ThRSyDv"><img src="https://i.ibb.co/f0t5JV1/image.png" alt="image" border="0"></a>

### 4. Получение числа, меньшего минимально возможного

<a href="https://imgbb.com/"><img src="https://i.ibb.co/SxYNqzx/image.png" alt="image" border="0"></a>

Из максимального порядка, который идёт в ответ, вычитается $i$ единиц и оказывается, что результирующий порядок меньше наименьшего, который можно представить в ЭВМ. Этот случай получается, когда ненормализованная мантисса попадает в диапазон $$2^{-i-1}\leq |M'_x \pm M'y|<2^{-i}$$
Число **меньше минимально возможного**, тут опечатка.

При этом результат операции равняется нулю, и вычисления продолжаются.

**Фиксация**
$$[\max (m_x, m_y)]_{до}^м + [i]_{до}^м = [m_z]_{до}^м$$

Код 10 в старших разрядах.

<a href="https://ibb.co/QjdxfCr"><img src="https://i.ibb.co/n8CKbnz/image.png" alt="image" border="0"></a>
**Ошибка: результат равен нулю**.

### 5. Переполнение разрядной сетки порядков

В этом случае выполнение операции прекращается и сразу же указывается окончательный результат. Результат равен одному из слагаемых, а именно, слагаемому с наибольшим порядков. 

Максимальное значение порядка имеет величину $2^{n_п - 1}$, и эта величина для большинства ЭВМ равняется разрядности мантисс. Если мы начнём извлекать одну из мантисс, то она всё равно уйдёт за разрядную сетку с меньшим порядком, она будет денормализовываться и её учитывать не надо.

**Фиксация**
На первом этапе находится разность порядков и мы получаем код либо 01, либо 10 в старших разрядах.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/t3v9YX2/image.png" alt="image" border="0"></a>

В ответ идёт слагаемое с наибольшим порядком.

<a href="https://ibb.co/rk7jRbC"><img src="https://i.ibb.co/b1W0MHS/image.png" alt="image" border="0"></a>

В первом случае результат выполнения операции будет равен числу Х, во втором -- числу Y.


## Специфика сложения-вычитания с машинными порядками.

### 1. Ненормализованная мантисса: содержит $i$ нулей после знаквоого разряда.

Может оказаться, что результата меньше чем минимлаьный порядок, который можно персдтавить в ЭВМ. В этом случае резулттат равен нулю Этот случай фиксируется на сумматоре пордков через разные знаки ($10, \dots$).

В машинных порядках из максимального порядка, который идёт в ответ,вычитается $i$ единиц и оказывается, что результат меньше наименьшего машинного порядка. Как мы помним, машинные порядки -- это целые числа без знака от нулей в разрядной сетке порядков до единиц. И если на сумматоре порядков в нулевом и первом разрядах идёт сочетание 11, ..., то это тот случай, когда результат равен нулю.

при обратботке машинных порядков на сумматоре добавляется **тольк один** знаковый разряд для фиксации переполнения. Если в единственном знаковом разряде появляется единица то это уже переполнение. Если после него идёт единица, то это случай а.

### 2. Результтат больше наибольшего

В этом улчае результат операции полагается равным бесконечности. Фиксация происходит кодом 01 в знаковых разрядах на сумматоре порядков. Этот случай имеет место, когда сумма мантисс оказывается ненормализованной и по модулю больше единицы. В этом случае мантиссы нормализауются её сдвигом на один разряд, то есть делится пополам. Чтобы результат не изменился, короректруется оядок, оторый  \идеёт в ответ, прибавлением единцы. Если при этом произойдёт перепрлнение порядков, результат будет равен бесконечночти.

Ааналогично может быть и в ммашинных порядках: к максимальному машинному порядку прибавляется единица и оказывается, что резульата больше наибольшего числа, которое можно педставить в ЭВМ. Этот результаа фиксируется кодом 1.0 на сумматоре.

---
<a href="https://imgbb.com/"><img src="https://i.ibb.co/6sgyCtT/image.png" alt="image" border="0"></a>

Порядки у этих числе равны, и когда ЭВМ вычест из одного результата другой, разность будет равна нулю и мантиссы будут склаыдваться без денормализации. Но получится ненормализованный результат: в знаковых разрядах код 10.

В этих случаях ненормализованная мантисса уменьшается в два раза путём сдвигана один разряд вправо: она делится пополам. Мантисса получается нормализованной в МДК, но и одновременно к максимальному из порядков прибавляется единица, чтобы результат не изменился. В этом случае в знаковых разрядах в сумматоре порядков получается код 01 ⇒ результат операции является равным бесконечности, ЭВМ останавлиается.

Походий случай и с машинными порядками. Пусть требуется сложить два числа с палавающей запятой, у которых порядки представлены в машинных кодах. Мантиссы такие же, ка ки в предыдущем случае.

На первом шаге вычитаются порядки. Их разность равна нулю, мантиссы без денормализации складываются,например, в МДК. Получается переполнение разрядной сетки мантисс: в знаковых разрядах на сумматоре 10. Результат нормализуется сдвигом полученной мантиссы вправо на один разряд. Получается нормализованная мантисса. И одновременно, чтобы результат не изменился, к тому наибольшему порядку, который пойдём в ответ (в данном случае они одинаковые), прибавляется единица. И на сумматоре порядков получается, что знак равен 1 (заведомо переполнение) и первый цифровой разряд после знака -- 0. Это означает, что результат равен бесконечности.

# Лекция 7. Двоично-десятичные системы счисления. Сложение и вычитание чисел в этих системах.

**Двоично-десятичная СС** -- это есть система счисления, в которых каждая десятичная цифра заменяется четырёхразрядным двоичным эквивалентом.

Возможных эквивалентов всего 16, десятичных цифр 10. Поэтому возможно создать достаточно большое количество двоично-десятичных систем счисления.

На практике наиболее широкое применение нашли две двоично-десятичные СС, а именно 8421 и 8421+3.

Соответствие десятичных цифр и их двоичных эквивалентов представлено на слайде:
<a href="https://imgbb.com/"><img src="https://i.ibb.co/hftfsC2/image.png" alt="image" border="0"></a>

<a href="https://imgbb.com/"><img src="https://i.ibb.co/R30zNtH/image.png" alt="image" border="0"></a>

Здесь каждая из цифр заменяется двоичным эквивалентом.

**Основное преимущество** заключается в том, что перевод чисел из десятичной системы в ДД прост и обратный переход тоже прост: он табличный и не требуется выполнение операций умножения и деления.

**Основной недостаток** этих систем: требуется больший объём оборудования для представления чисел и соответственно их обработки. Нужно увеличивать разрядность регистров, памяти, операционных устройства и так далее.

Допустим, у нас есть некоторое число $A$. Пусть оно в десятичной системе счисления содержит $n$ десятичных разрядов, $n$ десятичных цифр. Тогда в ДД-системах это число будет представлено $4 n$  двоичными разрядами.

В двоичной системе счисления это число будет содержать $$k = \frac{n}{\lg 2} = \frac{n}{0.3}$$разрядов.

Если у нас $n$ десятичных разрядов, то диапазон чисел, представленных в 10 и 2 СС должен быть равен:$$2^k = 10^n \implies k * \lg 2 = n\implies k =\frac{n}{\lg 2}$$

В ДДСС это число содержит $4n$ двоичных разрядов. Получаем $$\frac{4n}{n : 0.3} = 1.2$$То есть на 20% объём оборудования в ДДСС будет больше, чем в двоичных.

## Арифметические действия на ДД числами

Основной принцип: обработка разрядов чисел выполняется по правилам двоичной арифметики, чтобы использовать стандартное оборудование. Но при этом эти вычисления организованы таким образом, чтобы воспроизводилась *десятичная* арифметика.

### 8421
Складываем числа по правилам двоичной арифметики и сразу получаем правильный результат.

Но если сложить 9 и 8 по тем же правилам, мы получим 11. А результат должен быть равен 17.
<a href="https://imgbb.com/"><img src="https://i.ibb.co/xf2p1gF/image.png" alt="image" border="0"></a>

Так получилось потому что у нас выработался перенос единицы. Этот перенос унёс с собой 16 единиц. А в десятичной системе он должен унести только 10 единиц ⇒ он забрал лишние 6 единиц. В этом случае надо вернуть 6 единиц. Если к 11 прибавить 6, мы как раз и получим 17.


### 8421+3
Складываем два числа 3 + 5. Получаем вместо восьмёрки 14. Неправильный результат получен, потому что в этой системе каждая цифра несёт на себе избыток 3. Мы получили результат с избытком 3 + 3 = 6  ⇒ одна тройка лишняя. Если мы одну тройку отнимем от результата, то он будет верным.


### Сложение чисел в системе 8421

В любом ДД разряде в тетраде $x_i$ прибавляется тетрада $y_i$ и может быть перенос из более младшей тетрады: $p_{i+1}$$$x_i+y_i+p_{i+1}$$
<a href="https://imgbb.com/"><img src="https://i.ibb.co/ZccNHN3/image.png" alt="image" border="0"></a>

Складывая цифры в этой тетраде по правилам двоичной арифметики, получаем какую-то предварительную сумму $S_{iп}$ и перенос $P_i$.

Получение *предварительной* суммы связано с переносом (коррекция на 6). В системе 8421 различают два типа переноса
- естественный, когда складываются цифры в тетраде и по правилам двоичной арифметики вырабатывается перенос. Это случай, когда сумма в тетраде $\geq 16$. Это специфика двоичной арифметики
- искусственный: когда сумма в тетраде заключена в диапазоне между 10 и 15.  Это специфика десятичной арифметики. Этот перенос надо предусмотреть.


### Естественный перенос
<a href="https://imgbb.com/"><img src="https://i.ibb.co/RYQqnd4/image.png" alt="image" border="0"></a>

Должен получиться окончательный результат $S_i=17$. Складываем два числа по правилам двоичной арифметики. Получаем предварительную сумму 11. Крайняя левая сумма в $S_{iп}$ -- единица переноса, которая уносит из этой тетрады 16 единиц вместо 10. Возвращаем 6 единиц и получаем правильный окончательный результат.

Таким образом, если возникает естественный перенос в каком-до ДД разряде, то к предварительной сумма, которая формируется в этом разряде, надо прибавить 6 и получить правильный результат в *данном ДД разряде*.

Таким образом, если в тетраде сумма $\geq 16$, то к предварительной сумме в этом четырёхразрядной двоично-десятичном разряде прибавляется 6.

### Искусственный перенос

<a href="https://imgbb.com/"><img src="https://i.ibb.co/bjh623R/image.png" alt="image" border="0"></a>

Допустим, в каком-то разряде складываются 5, 6 и перенос из младшего разряда. Правильный результат 12.

Складываем числа по правилам двоичной арифметики. В сумме получается 1100 = $S_{iп}$. По правилам десятичной арифметики мы должны выработать перенос из этого разряда, так как число попало в диапазон от 10 до 15. Поэтому искусственно вырабатывается единица переноса (подчёркнутая и жирная), которая унесёт в следующую тетраду 16 единиц. Но в этом разряде должно удалиться 10 единиц по правилам десятичной арифметики, поэтому дополнительно вычитается 10 и получается правильное число.

**Вывод**: если в тетраде результат от 10 до 15, то из предварительного результата вычитается 10 и добавляется дополнительная единица переноса.

Операция вычитания (-10) заменяется операцией сложения. Посмтрим, как можно полностью уйти от операции вычитания.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/WcVXXYg/image.png" alt="image" border="0"></a>

Здесь указаны все возможные предварительные результаты, требующие искусственного переноса и соответственно вычитания 10.

Явно к этой сумме прибавляется 6 и вычитается 16 посредством блокировки переноса (жирная единица).

<a href="https://imgbb.com/"><img src="https://i.ibb.co/RcK2nPg/image.png" alt="image" border="0"></a>

К тем разрядам, из которых возник перенос, прибавляется 6. Если перенос искусственный, то после суммирования перенос блокируется.

### 8421+3
<a href="https://imgbb.com/"><img src="https://i.ibb.co/zNtJ2vy/image.png" alt="image" border="0"></a>

Каждая тетрада в этой системе больше предыдущей на 3. Поэтому когда мы выполняем суммирование. то в любом двоично-десятичном разряде получаем предварительную сумму и опциональный перенос. При этом предварительная сумма в силу того, что каждое слагаемое имеет избыток 3, имеет общий избыток 6. Поэтому при любом сложении в этой системе из предварительной суммы надо всегда вычитать тройку, то есть 0011.


Операция вычитания так же заменяется операцией сложения. -3 заменяется на +13 - 16. При этом +13 прибавляется явно, а -16 вычитается посредством блокировки переноса.
<a href="https://imgbb.com/"><img src="https://i.ibb.co/Q6kMmsZ/image.png" alt="image" border="0"></a>

В системе 8421+3 есть только естественный перенос, потому что искусственный и естественный перенос сливаются и становятся неразличимы.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/Lr35fTX/image.png" alt="image" border="0"></a>

Например, пусть складываются две ДД цифры 7 и 5. Получается предварительная сумма и перенос. С учётом наличия переноса мы должны вернуть 6 единиц в этот разряд, но в этом разряде уже есть 3 лишних единицы. Поэтому *при наличии переноса* из этого разряда мы прибавляем только 3 единицы.

**Правило суммирования в системе 8421+3**

Если в тетраде предварительная сумма < 10, то перенос не вырабатывается, и к предварительной сумме прибавляется 13, что сопровождается блокировкой переноса.

Если же сумма в тетраде больше или равна 10, то есть перенос есть, то к предварительной сумме прибавляется 3.

В примере под первой чертой находится предварительная сумма $S'_{iп}$. Далее к тем тетрадам, в который выработался перенос, прибавляются тройки (то есть к двум младшим тетрадам). К третьей тетраде, где перенос не выработался, прибавляется 13 и при этом блокируется перенос.

## Вычитание в системах 8421 и 8421+3
1. Операция вычитания выполняется через сложение с использованием ОК или ДК так же, как и в двоичной арифметике.
2. Двоично-десятичные системы счисления делятся на две большие группы: самодополняющиеся и несамодополняющиеся. 
3. Самодополняющиеся системы -- это системы, в которых коды отрицательных чисел получаются посредством инверсии двоичных разрядов. Например, система 8421+3 является самодополняющейся. Допустим, у нас есть число -792 в десятичной системе счисления. В системе 8421+3 это число будет записываться -0.1010 1100 0101. И если мы будем формировать обратный код, то мы меняем знак на противоположный и далее выполняем инверсию двоичных цифр по всем разрядам: 1.0101 0011 1010. Чтобы сформировать ДК отрицательного числа, мы просто к ОК этого числа добавляем единицу. То есть принципы такие же, как и в двоичной арифметике: все операции вычитания заменяются сложением, но перед этим вычитаемое подготавливается его представлением в специальных кодах.
4. К несамодополняющимся системам относится система 8421. Исходные коды десятичных цифр в этой системе от 0 до 9 указаны слева. А обратный код не получится сформировать инверсией, он формируется с помощью специальных логических схем, которые преобразуют исходные коды в обратные коды. Такие схемы легко синтезировать: каждый разряд $c_i$ ($c_8$, $c_4$, $c_2$, $c_1$) по отдельности рассматриваем как не полностью определённые функции от исходных кодов: $$c_i=F(a_8, a_4, a_2, a_1)$$

<a href="https://ibb.co/BCtV4Wv"><img src="https://i.ibb.co/mcGCvZd/image.png" alt="image" border="0"></a>


### Вычитание в системе 8421
Эта система несамодополняющаяся.

<a href="https://ibb.co/YTKhfMF"><img src="https://i.ibb.co/zHLZPYT/image.png" alt="image" border="0"></a>

Вычитаем два числа в 10сс. Должно получиться 307.

Записываем уменьшаемое, то есть 586. В системе 8421 она просто так и пишется.

Далее надо вычесть 279. Мы предварительно пишет знак минус и вычитаем 2 7 9.

Записав исходное условие, приступаем к самому примеру. Переписываем 5 8 6 и прибавляем -279 в обратном коде. 

Обратный код от 2 = 7, от 7 = 2, от 9 = 0. Далее идёт сложение по правилам двоичной арифметики: в первом разряде 6 без переноса, далее в следующем разряде получили 10, выработали искусственный перенос. Далее сложили 5, 7 и искусственный перенос, получили 12 и сформировали ещё один искусственный перенос. И так как это обратный код, то единица, которая выходит в знаковый разряд, прибавляется к предварительной сумме. Таким образом получаем $S_{iп}$ -- предварительная поразрядная сумма.

Далее выполняется коррекция: ко всем разрядам, в которых возник перенос, искусственный или естественный, прибавляется 6 и выполняется суммирование. При этом все единицы переносов блокируются, потому что на данном этапе по сути происходит вычитание 16.

Получается окончательный результат 307, что и должны были получить.

<a href="https://ibb.co/925DKZs"><img src="https://i.ibb.co/6bCM9Xg/image.png" alt="image" border="0"></a>

Этот пример наоборот. Также уменьшаемое 2 7 9 записывается в двоичных кодах, а далее -586 записывается как - 5 8 6. Это запись исходного примера (первые две строки).

Далее начинается вычитание: опять переписываем 2 7 9 в двоично-десятичном виде и прибавляется минус 586 в обратном коде: [5]о=4, [8]о=1, [6]о=3.

Далее выполняется сложение по правилам двоичной арифметики на двоичных сумматорах. В первом разряде складывается 9 + 3 = 12 в предварительной сумме. Это число находится в диапазоне от 10 до 15, поэтому специальной схемой вырабатывается искусственный перенос. Затем  в следующем разряде происходит сложение 7, 1 и искусственного переноса, получается 9 -- тут никаких переносов нет. Аналогично и в старшем разряде.

В младший разряд, где возник перенос, прибавляется 6 при формировании окончательной суммы. При этом возникает единица переноса: она блокируется. Остальные разряды суммируются с нулями, и получается ответ в обратном коде.

Переводим этот результат из обратного кода в прямой и получаем -307 -- окончательный ответ.

### Вычитание в системе 8421
Это самодополняющаяся система. 

<a href="https://ibb.co/XzqNTqn"><img src="https://i.ibb.co/Bg9dR9h/image.png" alt="image" border="0"></a>

Переписываем исходный пример в системе 8421 + 3. 5 записывается как 8, 8 как 11, 6 как 9.

Далее идёт выполнение примера: переписывается уменьшаемое, и прибавляется уменьшаемое в обратном коде (хотя здесь и написано в ДК, но всё равно для формирования ДК число сперва нужно перевести в ОК). ОК формируется просто инверсией двоичных разрядов, а затем прибавляется единица, чтобы получить ДК.

Далее выполняется сложение в ДК. Получаем предварительную сумму. В системе 8421+3 бывают только естественные переносы, поэтому предварительные суммы анализировать не требуется.

Младший разряд складывается без переноса. Второй разряд складывается с переносом. Далее происходит суммирование единицы переноса со старшим разрядом, и оттуда возникает ещё одна единица переноса, которая суммируется со знаком. Предварительная сумма: 10. 0011 0000 1101.

К этой сумме прибавляется коррекция: в те разряды, где перенос не вырабатывался, прибавляется 13 с блокировкой переноса. А там, где перенос выработался, просто прибавляется 3.

Прибавляя коррекцию, получаем итоговый результат.

<a href="https://ibb.co/25g1HWS"><img src="https://i.ibb.co/vDZ6RVh/image.png" alt="image" border="0"></a>

Пример наоборот.

Сначала просто записываем операнды в системе 8421.

Далее прибавляем вычитаемое, но все цифры его инвертируем для получения обратного кода.

В первом разряде сформировалась единица переноса. В остальных разрядах переносов нет. 

Полученная предварительная сумма корректируется: к разряду, из которого выработался перенос, прибавляем 3, а к тем разрядам, у которых перенос не выработался, прибавляем 13 с блокировкой единицы переноса.

В итоге получаем ответ в обратном коде. Далее мы переводим этот ответ в прямой код: сохраняем знак и инвертируем разряды.



# Лекция 8. Высказывания

**Высказывание** -- это есть грамматически правильное повествовательное предложение, о котором можно сказать, что оно истинно или ложно.

**Простое высказывание** --  Любое утверждение, о котором можно сказать, что оно истинно или ложно.

**Составное высказывание** -- это высказывание, состоящее из простых высказываний

**Основное свойство любого высказывания** (и простого, и составного) заключается в том, что оно может быть или истинным, или ложным (оно не может быть истинным и ложным одновременно).

Для описания высказываний и для работы с высказываниями в качестве математического аппарата используют аппарат функций алгебры логики.

В этом аппарате для обозначения простых высказываний используют малые буквы латинского алфавита :$p$, $q$, $r$, $x$, $y$, ...

Составные высказывания являются функциями от простых высказываний и они обозначаются заглавными буквами латинского алфавита: $P$, $Q$, $R$, $X$, $Y$, ...

Если высказывание -- простое или составное --  является истинным, то переменные, которые обозначают это высказывание, полагают равными единице.

Если же высказывание ложно, то переменные, его обозначающие, полагают равными нулю.

При работе с высказываниями применяют следующие функции алгебры логики:

Из 20 (4 для одного аргумента и 16 для двух аргументов) ФАЛ применяют следующие:
- функция конъюнкция (И, $\land$)
- функция дизъюнкция (ИЛИ, $\vee$)
- функция отрицание (НЕ, $\overline x$)
- функция импликация ($\rightarrow$)
- функция исключающая дизъюнкция ($\veebar$)
- функция равнозначность ($\sim$)

<a href="https://ibb.co/3pGmq9Q"><img src="https://i.ibb.co/pfGj8B5/image.png" alt="image" border="0"></a>

**Конъюнкция** $F(p, q) = p \land q$ -- это составное высказывание, $F(p, q)$, которое является истинным только тогда, когда оба высказывания $p$ и $q$ являются истинными.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/bBKJgg7/image.png" alt="image" border="0"></a>

Когда мы работаем с высказываниями, можно применять таблицы истинности. Можно обозначать высказывания либо как Л/И (ложь/истина), либо через 0/1.

**Дизъюнкция** $F(p, q) = p \vee q$ -- это составное высказывание, которое является истинным, когда хотя бы одно из высказываний $p$ или $q$ является истинным.

**Отрицание** $F(p) = \overline p$ -- это высказывание, которое является истинным, когда высказывание $p$ является ложным.


<a href="https://imgbb.com/"><img src="https://i.ibb.co/ZGKntKb/image.png" alt="image" border="0"></a>

**Импликация** $F(p, q) = p \to q$ -- это составное высказывание, которое представляет собой утверждение с условием. Имеет форму "если $p$ истинно, то $q$".

**Исключающая дизъюнкция** $F(p, q) = p \veebar q$ -- это составное высказывание, которое утверждает, что является истинным одно из высказываний: $p$ или $q$, но не оба.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/yNb2NNz/image.png" alt="image" border="0"></a>

**Равнозначность $F(p, q) = p\sim q$** -- это составное высказывание, которое утверждает, что высказывания $p$ и $q$ равнозначны.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/r5G18r8/image.png" alt="image" border="0"></a>

### Пример
Пусть $A$ и $B$ -- простые высказывания. Напишем формулы и их смысл.

1. $\overline A$ = на улице нет дождя.
2. $\overline B$ =  над моей головой не раскрыт зонт
3. $\overline A \vee B$ = на улице не идёт дождь или над моей головой раскрыт зонт
4. $A \land \overline B$ =  на улице идёт дождь и над моей головой не раскрыт зонт
5. $A \to B$ = если на улице идёт дождь, то надо моей головой раскрыт зонт
6. $B \sim A$ = над моей головой раскрыт зонт тогда и только тогда, когда на улице идёт дождь.
7. $A \veebar \overline B$ = или на улице идёт дождь, или над моей головой раскрыт зонт, но не совместно.

<a href="https://ibb.co/jfTwvC9"><img src="https://i.ibb.co/B3t6VhH/image.png" alt="image" border="0"></a>

Если $P$ и $Q$ -- исходно составные высказывания, то мы  с ними можем обращаться так же, как с простыми, формируя высказывания $P \vee Q$, $P \land Q$ и так далее.

Допустим, нам дано некоторое сложное высказывание. Нам дана задача определить, истинно оно или ложно. Сразу это сделать мы не можем. Мы поэтапно строим это высказывание, то есть отдельно $P$, $Q$, и так далее.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/7XhTKHn/image.png" alt="image" border="0"></a>

Интересно, что после преобразований мы получили, что это высказывание всегда является истинным. Поэтому аппаратная реализация этого высказывания --  проводочек с высоким напряжением. А если бы высказывание было постоянно только ложным, это был бы проводочек, подключённый к земле.

Надо помнить, что если у нас есть сложное составное высказывание, надо строить ТИ обязательно пошагово.

Любое высказывание может быть исходно задано с помощью таблицы истинности.

 Так. допустим, у нас составное высказывание $F$ зависит от простых высказываний $x_1\dots x_n$. Тогда в таблице истинности которая будет давать полное исчерпывающее описания для этого составного высказывания, будет содержаться $2^n$ строк. Будет осуществляться полный перебор по всем простым высказываниям или простым переменным.

К таблице истинности можно перейти не только от формул, но и сразу от постановки задачи.

<a href="https://ibb.co/HHY2CC1"><img src="https://i.ibb.co/P64YMM3/image.png" alt="image" border="0"></a>

Допустим, требуется сформировать составное высказывание $F = F(x_1, x_2, x_3)$, которое отражает работу устройства для обработки результатов голосования комитета трёх.

Если два или больше члена комитета за принятие резолюции, то она принимается. Строим таблицу истинности по простым высказываниям за/против для каждого члена комиссии. Справа в столбике $F$ -- это принята или не принята резолюция. 

Мы описали составное высказывание с помощью ТИ, далее можно перейти к формульному описанию. Выписываем термы (элементарные конъюнкции), на которых функция принимает значение 1, то есть строим СДНФ.

После этого можно реализовать уже готовое устройство на ПЛИС.

**СДНФ** -- это ДНФ, в которой 
- элементарные конъюнкции содержат все переменные.
- нет одинаковых элементарных коньюнкций

<a href="https://ibb.co/f0QjjDm"><img src="https://i.ibb.co/kcMNNmY/image.png" alt="image" border="0"></a>

**Первичный терм** или **терм первого ранга** --  одна переменная или её отрицание.

Количество первичных термов, которые содержатся в описании функции, называют **сложностью функции** и обозначают $L(F)$. В а=данном случае L(F) = 12.

Если построенное высказывание минимизировать, то минимальная формула будет иметь следующую запись, и сложность этой минимальной записи будет равна 6. При этом сама функция не изменится, просто записи будут несколько разными.

К разделу высказываний относятся предикаты.

## Предикаты

Пусть функция $P(x_1\dots x_n)$ может принимать два значения, а именно, $P = 0$ или $P = 1$. Аргументы $x_1, x_2 \dots x_n \in M$ и могут принимать бесконечное количество значений.

Тогда функция $P$ называется **предикатом $P$ предметной области $M$**.

С предикатами мы можем обращаться как с высказываниями.
<a href="https://imgbb.com/"><img src="https://i.ibb.co/bbgnTxV/image.png" alt="image" border="0"></a>

**Пример 1**

Предикат $P$ утверждает, что $x^2 - 3x + 2 = 0$.

Здесь $U$ -- область определения предиката: $U = \R$., а $S = \{1, 2\}$ есть множество истинности этого предиката, то есть те значения $x$, при которых это высказывание является истинным.

**Пример 2**

Записаны два предиката: $P$ и $Q$. 

Область определения обоих предикатов является множество вещественных чисел ($\R$), а множество истинности первого предиката: $S_1 = \{1, 2\}$, для второго: $S_2 = \{-1. 1\}$.

С предикатами можно обращаться как с высказываниями. Формируем составное высказывание из двух предикатов -- $P\land Q$ и получаем систему: $$\begin{cases}P: x^2-3x+2=0\\Q: x^2=1\end{cases}$$и множество истинности для такого составного предиката это есть $S = \{ 1\}$ -- не что иное, как $S_1 \cap S_2$ 


**Пример 3**
<a href="https://imgbb.com/"><img src="https://i.ibb.co/VYfYZzD/image.png" alt="image" border="0"></a>

Множество определения одно и то же для двух предикатов: это $\R$.

Формируем составное высказывание из двух предикатов и получаем систему. Тогда множеством истинности для такого составного высказывания будет пересечение множеств истинности каждого из предикатов, и равно 0, так как при 0 это составное высказывание является истинным.

# Лекция 9. Классы функций. Теорема Поста. Базисы

<a href="https://imgbb.com/"><img src="https://i.ibb.co/QHqbqR9/image.png" alt="image" border="0"></a>

Таблица: здесь все функции двух аргументов и указано, к какому классу они относятся. Указано условное обозначение функции, далее будет детально рассмотрена каждая функция.

1.  $F_0$ --- функция, сохраняющая ноль. Она относится к классам линейных функций, функций сохраняющих ноль и самодвойственных функций.
2. $F_1(\land)$ -- функция И. Относится к классам, функций, сохраняющих ноль, сохраняющих ноль и монотонных функций
3. Левая коимпликация $F_2(\twoheadrightarrow)$
4. $F_3$ -- функция, эквивалентная $x$. Относится ко всем классам.
5. $F_4 (\twoheadleftarrow)$ -- правая коимпликация
6. $F_5$ -- функция, эквивалентная $y$
7. $F_6$ -- исключающее ИЛИ, сложение по модулю 2.
8. $F_7$ -- ИЛИ
9. $F_8 (\downarrow)$ -- ИЛИ-НЕ, стрелка Пирса, не относится ни к одному из классу
10. $F_9$ -- функция эквивалентности или равнозначности 
11. $F_{10} (\overline y)$ -- НЕ $y$
12. $F_{11} (\larr)$ -- правая импликация
13. $F_{12} (\overline x)$ --  НЕ $x$
14. $F_{13} (\to)$ -- левая импликация
15. $F_{14} (|)$ -- штрих Шеффера. Не относится ни к одному из классов.
16. $F_{15}$ -- функция, сохраняющая единицу. 


### Класс линейных функций 

**Определение**. Функция называется линейной $F(x_1, x_2, \dots, x_n)$, если её можно представить в виде следующего полинома первой степени: $$k_0\oplus k_1 x_1 \oplus k_2x_2 \oplus\dots\oplus k_nx_n,\quad k_i\in\{0, 1\}$$, где $x_i$ -- аргументы функции, $k_i$ -- коэффициенты, которые могут принимать значения 0 или 1.

<a href="https://ibb.co/DRs3v1c"><img src="https://i.ibb.co/KrRCf54/image.png" alt="image" border="0"></a>

Если функция зависит от $n$ аргументов $x_1\dots x_n$, то линейных функций в этом множестве будет всего 2^n+1^.

Пусть n = 2. Тогда 2^3^ = 8 линейных функций будет от 2 аргументов.

### Функции, сохраняющие ноль

Если функций на нулевом наборе равняется 0, то эта функция по определению относится к классу функций, сохраняющих ноль. 

$$F(0, 0, \dots, 0) = 0$$

Для двух переменных такими функциями являются $F_1 - F_7$.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/9Zn3T2q/image.png" alt="image" border="0"></a>

### Функции, сохраняющие единицу

**Определение**. Если функция на единичном наборе аргументов равна единице, то эта функция относится к классу функций, сохраняющих единицу.

$$F(1, 1, \dots, 1) = 1$$

Для двух переменных это функции с нечётными индексами ($F_1, F_3, \dots, F_{15})$

### Монотонные функции

**Определение**. Функция алгебры логики называется монотонной (то есть относится к классу монотонных функций), если при любом возрастании наборов аргументов значения функции не убывают.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/2tHH4Sq/image.png" alt="image" border="0"></a>


**Определение**. Набор аргументов $x_1^1, x_2^1, \dots, x_n^1$ ялвяется возрастающим по онтошению к набору $x_1^2, x_2^2, \dots, x_n^2$ если для всех аргументов в этих наборах выполняется соотоншение $$x_i^1 \geq x_i^2, \quad, i=\overline{1, n}$$
<!--stackedit_data:
eyJoaXN0b3J5IjpbODAyOTc4OTA5LDEwMjM4MzE0NTEsLTEyMj
A5MDAzMDYsODAwODU3ODM3LDgzODkzOTc3NSwtMjA2NTM5NTU3
OCwxMjAzMzc0MDg5LDM4NjY2MjIyMSwxNjkzMjcxMDgwLC0yMz
I3NTYxMDIsLTE5NjY5NzA3NzQsNDYxMDI1MzMxLDEzMDkyODIw
NDQsLTE0ODc1MjcwNjAsMTAyNjU3MzUzOCwxNDI4MDQxMjI2LC
05MTAxOTU0NjQsLTE5MTMzMzYxMCwxODY0NDk2OTIzLDUzNTA1
MTQ5OF19
-->