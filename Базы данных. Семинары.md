# Проектирование в соответствии с нотацией IDEF1x

В процессе проектирования используются некоторые нотации модели данных, и чаще всего -- нотации модели данных "сущность-связь". В частности, достаточно удобная нотация IDEF1x. 

Также можно упомянуть пакет ERwin, который предназначен для разработки моделей "сущность-связь". В нём есть возможность разрабатывать соответствующую схему, используя нотацию IDEF1x.

## Этапы проектирования

|Номер этапа |  Название | Документация
|--|--|--
1 | Определение сущностей | Пул сущностей (текстовый документ)
2 | Определение связей | Матрица связей. Диаграмма уровня сущностей (ER-диаграмма)
3 | Определение ключей | Диаграмма уровня ключей (KB-диаграмма)
4 | Определение атрибутов | Полноатрибутная диаграмма (FA-диаграмма)

### Определение сущностей

Само название модели "сущность-связь" говорит о том, что мы должны определить сущности. Результатом этого этапа является текстовый документ -- пул сущностей, в котором описывается каждая сущность, включенная в проект. 

Форма записи этого документа свободная, но удобно использовать табличку. При этом крайне желательно, чтобы все эти документы сохранялись, чтобы подтверждать, что мы сделали именно то, что просил заказчик.

### Определение связей

Сущности вступают между собой в какие-то связи, и эти связи надо определить.

При этом, как и на любом другом этапе проектирования, надо как можно больше приставать с вопросами к заказчику как к обладающему знаниями предметной области источнику, если хоть что-то непонятно.

Результатом второго этапа является матрица связей между сущностями -- в достаточно свободной форме и первая диаграмма -- ER-диаграмма уровня сущностей. 

При этом мы ограничиваемся рассмотрением лишь бинарных связей (то есть связей между двумя объектами), и эти связи бывают двух типов: один ко многим и многие ко многим. Диаграмма уровня сущностей -- единственный тип диаграммы, на которой допускается связь типа многие ко многим. В этой диаграмме отображаются те связи, которые присутствуют между сущностями в реальном мире.

В матрице связей указываются, какие сущности в принципе связаны между собой. Как они связаны, сколько этих связей, тут не решается.

Результатом этого этапа является диаграмма уровня сущностей. Её надо сохранить и прислать, потому что дальнейшие переходы к следующим этапам должны ей соответствовать.

### Определение ключей

В результате получается диаграмма Key_Based, где для каждой сущности определяется уникальная характеристика, идентифицирующая каждую сущность -- ключ.

На этом этапе в диаграмме уровня ключей не должны остаться связи типа многие ко многим -- для этого есть формальные подходы, позволяющие исключить такие ключи и не нарушить систему в целом.

Чтобы сделать ключевую диаграмму, копируем уже имеющуюся ER-диаграмму в отдельный файлик и на основе её рисуем KB-диаграмму.

### Определение атрибутов

Результат -- полная атрибутная диаграмма, которая позволяет по её виду легко перевести её на язык реляционных баз данных. Поэтому после этого уже можно писать SQL запросы на создание табличек.

При определении атрибутов может понадобиться ввести какие-то новые сущности, которые на первом этапе были не очевидны. Это нормальная ситуация.

## Пример проектирования

### Постановка задачи

Спроектировать систему для организации учебных занятий в институте. 

Система должна:
- хранить информацию о студентах, учебных группах, преподавателях и изучаемых предметах (учебный план)
- хранить информацию о проведении учебных занятий в группах конкретными преподавателями
- хранить информацию о контроле успеваемости студентов по изучаемым предметам

Для того, чтобы спроектировать модель, недостаточно знать, что в неё входит -- нужно знать, и какие ограничения накладываются на данные, хранящиеся в этой системе.

### Требования к системе

- Студенты зачисляются (переводятся) в группу перед началом учебного года; переводы в середине учебного года не допускаются. 
- Занятия организуются для групп
- Преподаватели назначаются для проведения занятий в группах в соответствии со своей специализацией.
- Преподаватель может проводить занятия по разным предметам и в разных группах
- Занятия по одному и тому же предмету в группе могут проводить несколько преподавателей

Для того, чтобы определить, какую информацию хранить в системе, нужно чётко представлять бизнес-процессы, которые предъявляют определённые требования к хранящейся информации.

### Определение сущностей

По сути, все существительные, которые встречаются в тексте задания, являются кандидатами в сущности. 

- Кафедра/Е1
- Группа/Е2
- Студент/Е3
- Предмет/Е4
- Преподаватель/Е5
- Контроль/Е6

Однако это только кандидаты в сущности. Для каждой из них надо ответить на целый ряд вопросов:

**1.  Можно ли как-то описать соответствующий объект?** Например, кафедра -- некоторое подразделение института, осуществляющее подготовку студентов по конкретным специальностям. Такие описания нужно фиксировать -- они потом войдут в пул сущностей и позволят прийти к общему видению задачи с заказчиком.

**2.  Имеет ли соответствующий кандидат в сущность какие-либо свойства?** Например, кафедра имеет название, номер специальности.

**3.  Можно ли получить информацию о свойствах объекта?**

**4.  Могут ли существовать объекты с одинаковыми свойствами?** Две кафедры с одинаковыми названиями вряд ли могут существовать, но могут существовать разные кафедры, выпускающие специалистов по одному и тому же направлению.

**5.  Можно ли отличить один объект от другого?** Каждая кафедра имеет своё уникальное название и номер


**6.  Является ли кандидат в сущность некоторой характеристикой другого объекта?** Если да, то он исключается из списка кандидатов в сущности.

Если на первые пять вопросов ответ "да", а на последний -- "нет", то кандидат в сущность является сущностью.

### Пример пула сущностей

| Номер множества сущностей | Имя множества сущностей | Определение | Описание
|--|--|--|--
Е1 | Кафедра | Подразделение института, которое выпускает специалистов по конкретной специальности | Как только в институте фиксируется решение о создании новой кафедры, формируется новый экземпляр данного множества сущностей.
E2 | Группа | Учебная единица, для которой организуются занятия в соответствии со специальностью | Как только в институте для выпуска специалистов по какой-либо кафедре создаётся учебная группа, формируется новый экземпляр данного множества сущностей
E3 | Студент | Человек, достигший совершеннолетия, успешно сдавший соответствующий экзамены и зачисленный (переведённый) в группу соответствующим приказом по институту | Студент зачисляется в соответствующую группу. В случае необходимости создаётся новая группа, и в таком случае создаётся новый экземпляр данного множества сущностей. **Ограничения**: группа может состоять минимум из 5, максимум из 25 студентов.


### Матрица связей

<a href="https://ibb.co/0MRyX7F"><img src="https://i.ibb.co/hWJFM6Z/image.png" alt="image" border="0"></a>


Модели сущность-связь используют графическое представление. Конкретные графические элементы могут отличаться в разных нотациях: мы ориентируемся на нотацию IDEF1x, в соответствии с которой сущность изображается прямоугольником, разделённым горизонтальной линией на две области (для диаграммы уровня сущностей такой разделение необязательно), а связь, поскольку IDEF1x ограничивается рассмотрением **только** бинарных связей, представляется просто линией. Однако в реляционной модели данных бинарные связи могут быть разными, поэтому преставление конкретной бинарной связи может выглядеть по-разному.

Если мы задаём сущность, в общем  случае эти две области прямоугольника имеют специфическое название. В диаграмме уровня сущности название сущности всегда -- существительное в единственном числе, хотя оно и определяет множество экземпляров. Эти две области на ER-диаграмме могут отсутствовать и не надо их сразу там заполнять, потому что это приводит к дополнительным ошибкам на дальнейших этапах проектирования.

### Связь

1. Только бинарные связи. 
2. Название связи определяется глаголом или глагольной фразой. Для каждой бинарной связи определяются два отображения, каждое из которых надо назвать.
3. Именование бинарной связи осуществляется для двух отображений: СОТРУДНИК, ОТДЕЛ (Отдел *состоит из* нуля или более сотрудников, Сотрудник *зачислен в* один отдел). Очень важно, чтобы в записи отображений были записаны и минимальные, и максимальные кардинальные числа: нельзя писать "отдел состоит из многих или нескольких сотрудников". Если написать так, это будет ошибкой. Имя связи: **"состоит из / зачислен в"**
4. Тип связи определяется кардинальными числами двух отображений

### Определённая 1:n (связь типа один ко многим)

Для одного отображения минимальное кардинальное число равно 1, максимальное -- много. 

На стороне связи "много" -- там где максимальное кардинальное число, ставится точка, а там где связь 1, никаких обозначений не ставится.

Например, для такого отображения говорится, что для отображения сотрудника на отдел минимальное кардинальное число и макс равно 1, а для отображения одела на сотрудники минимальное число равно 0, а максимальное -- бесконечность.

Такая связь характеризуется одной глагольной связью от одного ко многим. Для второго отображения связь можно не писать

### Неопределённая (n:n) связь многие ко многим

Например, связь между товаром и товарным документом. Один товар может быть указан в нуле или большем количестве товарных документов, а товарный документ может содержать

На обоих концах указываются точки. Связь указывается в обоих направлениях. Причём сначала указывается отображение слева направо сверху вниз.

Между сущностями предмет и преподаватель дву связи: по одной -- преподавать проводит занятия, а по второй --специализация преподавателя. Поэтому между сущностями предмет и преподаватель две разные связи. 

Если мин кард число не ноль, то на конце связи мб указана буква Р (Positive).

Если мин кард число 0, а макс 1, то мб указана буква Z.

Плохо, если для связей типа многие ко многим на обоих концах связи стоит буква Р -- тогда непонятно, как надо будет создавать базу данных. Поэтому для обоих концов связи лучше вообще ничего не указывать: в реляционной модели данных связи типа многие ко многим существовать не могут, но когда мы проектируем ИС, мы начинаем разработку именно с модели сущность-связь и не всегда понятна реализация бизнес-логики.

Но если на первом этапе при разработке ER-диаграммы мы не будем использовать связи многие ко многим, это может привести к тому, что мы некорректно опишем предметную область, и потом придётся много всего исправлять. Поэтому в ER диаграмме связи типа многие ко многим приветствуются, если они отображают семантику предметной области.

Первый этап проектирования предполагает следующие документы
- пул сущностей
- прислать обязательно ER диаграмму

Для каждой связи в ER диаграмме надо написать два отображения -- это обязательное условие. 


# Семинар 2

## Фаза 3. Определение ключей


### Определение ключей

- Выделение первичных и альтернативных ключей
- определение доменов
- разрешение неопределённых связей (типа n:n)
- определение внешних ключей

Надо иметь средства, позволяющие идентифицировать каждый экземпляр сущности. Для этой цели используются ключевые атрибуты: если мы в сущности определяем ключ, то это означает, что в данном множестве не  могут оказаться два разных экземпляра сущности с одинаковыми значениями ключевых атрибутов. Причём таких ключей может быть много, один из них  выдвигается на роль **первичного** ключа (Primary Key),  а остальные, если они есть, -- альтернативные (AK). Поскольку ключи -- это атрибуты, а они определены на домене, то на этой фазе надо определить домены для ключей.

На этом же этапе неопределённые связи типа многие ко многим надо заменить определёнными связями.

Для определения связей между сущностями в РМД используются внешние ключи -- FK.

Когда мы выделяем ключевые атрибуты, надо решить, есть у сущностей в этом множестве какие-то собственные уникальные атрибуты: например, серия и номер паспорта у сотрудника или номер зачётной книжки студента. Если такая ситуация оказывается невозможной: например, нет таких уникальных атрибутов или они неудобны (например, к неудобным атрибутам относят дату и время, которые везде представляются по-разному; текстовые строки), поэтому на роль ключевых атрибутов лучше выбирать целые числа; то если нет таких атрибутов, то вводят искусственный атрибут, который не является собственным атрибутом сущности, но используется как первичный ключ -- *суррогатный ключ*.

Однако такие суррогатные ключи определяются в рамках конкретной организации, поэтому иногда поиск по ним затруднителен. Поэтому сначала надо искать собственные ключевые атрибуты.

При этом ключи могут быть простыми (представлены одним атрибутом) или составными (представлены комбинацией нескольких атрибутов). Если среди собственных ключевых атрибутов есть целые, то мы выделяем его на роль первичного ключа, иначе выдвигается суррогатный целочисленный ключ, а все собственные уникальные ключи становятся альтернативными.

Первое, что мы делаем на этом этапе, -- для каждого типа сущности пытаемся выделить ключевые атрибуты. 

Результатом этой фазы будет диаграмма уровня ключей -- KB-диаграмма со всеми именами ключей.

На ER-диаграмме определённая связь отображается просто линией с точкой, а на KB-диаграмме это может быть либо идентифицирующей, либо неидентифицирующая; обязательная или обязателньая.

Тип связи оказывает влияние на вид сущности. Они определяются как зависимые по идентификации (скруглённые углы) и независимые (с прямыми углами). 

Если для идентификации сущности мы можем ограничиться только собственными атрибутами сущности без учета связи, то эта сущность **независимая по идентификации**.

Если для идентификации сущности надо учитывать связь, в которую вовлечена эта сущность, то она **зависимая по идентификации**.

Разновидность сущности определяется связью.

### Определённая идентифицирующая обязательная связь

Поскольку эта связь **определённая**, то для одного конца минимальное кардинальное число любое, а максимальное кардинальное число -- бесконечность ( об этом говорит точка). Со стороны прямой линии минимальное и максимальное кардинальные числа равны 1.

Это определённая **обязательная** связь, так что экземпляры из второго множества сущностей (то есть со стороны "много") не могут существовать дез связанных с ними экземпляров их первого множества сущностей.

Кроме того, связь характеризуется внешним ключом. Внешний ключ -- это атрибут сущности, который не является её собственным атрибутом, но определяет связь.

Например, у нас есть сотрудники, и для выполнения каких-то работ сотрудник назначается в конкретную бригаду - он становится членом этой бригады. Чтобы идентифицировать члена бригады, мы не можем ограничиваться только табельным номером сотрудника, потому что один сотрудник мб членов нескольких бригад ⇒ используется собственный атрибут "номер бригады" и атрибут сотрудника - номер сотрудника, который является внешним ключом по отношению к сущности "член бригады".
 
 Если внешний ключ становится частью первичного ключа, то такая связь называется **идентифицирующей**, а сущность -- **зависимой по идентификации**.

Поэтому сущность на конце 1 определяется как **родительская** сущность, а сущность на конце много -- дочерняя. Экземпляры дочерней сущности идентифицируются с учётом связи. Частью первичного ключа является внешний ключ ⇒ связь идентифицирующая и сущность зависима по идентификации.

Поскольку этот внешний ключ становится частью первичного ключа, а атрибуты первичного ключа не могут отсутствовать -- они обязательные, то эта связь ещё и является **обязательной** ==> минимальные и максимальные кардинальные числа слева равны 1: член бригады это обязательно сотрудник.


### Определённая неидентифицирующая обязательная связь

Определённая -- связь типа "один ко многим". Обязательность означает, что на стороне 1 минимальное и максимальное кардинальные числа равны 1, а свойство "не идентифицирующая" говорит о том, что атрибут внешнего ключа **не является** частью первичного ключа.

Если сотрудник однозначно идентифицируется собственным табельным номером без учёта отдела, в который он зачислен, а внешний ключ попадает в область прочих атрибутов, то это **не идентифицирующая связь**.

Должность имеет составной первичный ключ, и весь он мигрирует в область FK2 сущности сотрудника. При этом очень важно, чтобы атрибуты перечислялись в том же порядке, в которому они перечисляются в записи первичного ключа сущности. Если используем ERWin, то там всё будет автоматически, а если вручную -- надо следить за этим самим.

### Определённая неидентифицирующая необязательная связь

Определённая -- значит, связь 1 ко многим
Неидентифицирующая - внешний ключ в области внешних атрибутов
Необязательное -- минимальное кардинальное число мб равно нулю

Ромбик говорит  что минимальное кард число 0, макс -- 1.

Внешний ключ не мб включен в область первичного ключа, тк он может отсутствовать, а для первичного ключа все атрибуты обязательные.

Обычно така связь используется для определения иерархической структуры: разные экземпляры одного и того же множества сущностей вступают в одну связь. Такая связь означает, что отображается древовидная структура, а для корня нет родительской категории, и значение внешнего ключа будет пустым.

### Связь типа категория

Часто раньше упоминалась связь 1 к 1, но от неё отказались. Если надо представить связь 1 к 1, то это частный случай типа один ко многим.

Но есть и частные случаи, когда множество сущностей рассматривается как подмножество другого множества сущностей. 

Обозначается кружком, который подчёркнут либо одной (это означает неполную категорию: может существовать элемент множества, не относящийся ни к одной категории) или двумя линиями (полная категория).

Например, юридическое и частное лицо -- подмножества множества покупателей, а её полнота определяется из анализа предметной области.

### Разрешение связей типа n:n

Реляционная модель данных не позволяет представлять связи типа "многие ко многим". Когда мы от ER-диаграммы переходим к KB-диаграмме, происходит разрешение таких связей. Она приводит к тому, что появляется дополнительная сущность и две связи типа 1 ко многим, причём "много" стоит на стороне дополнительной сущности.

При этом часто эта дополнительная сущность становится зависимой по идентификации: первичные ключи исходных сущности мигрируют в область первичного ключа дополнительной сущности.

В некоторых случаях такое разрешение мб неприемлемым. Например, если есть две связи многие ко многим, то для каждой такой связи появляются дополнительные сущности


Однако составные первичные ключи в дополнительных ключах часто бывают неудобными, поэтому иногда вводятся суррогатные ключи (типа "номер записи").

### KB-диаграмма

После разрешения таких связей получается диаграмма уровня ключей. Надо обязательно прислать ER-диаграммы, и при проверке диаграммы уровня ключей надо видеть ER-диаграмму, потому что при переходе между ними часто допускаются ошибки, которые дальше могут сказаться на этапе создания базы данных или на более поздних этапах.

## 4. Разработка полноатрибутной схемы

### Определение атрибутов

- выделение атрибутов и доменов
- представление "неудобных" атрибутов в виде отдельных сущностей. Неудобные атрибуты -- это длинные строки, значения которых могут повторяться (например, должность сотрудника). Надо гарантировать, что такой текст для всех сотрудников будет представлен правильно: поэтому если появляются такие неудобные атрибуты, целесообразно ввести новую сущность "должность" и ввести суррогатный ключ "код" и альтернативный "название должности".

В результате получается FA-диаграмма с атрибутами всех сущностей. Эту схему можно не присылать, но она используется уже для этапа создания базы данных.

# Семинар 4

Следующим этапом после создания полноатрибутной схемы является создание базы данных.

Для этого выполняется предложение

```sql
create database имя_базы;
```

И потом в созданной базе данных создаются все необходимые объекты. Для нас такими объектами являются, прежде всего, таблицы: каждому отношению из FA ставится в соответствие таблица реляционной БД. Для этого используется подмножество SQL для описания данных:

```sql
CREATE TABLE имя_таблицы (
	имя_колонки тип_данных
	ограничения_на_колонку,
	...,
	табличное_ограничение,
	...
)
```

После того, как мы напишем sql скрипт создания БД надо прислать его на проверку. Кроме того, после этого надо проверить, что мы правильно создали базу данных (реинжиниринг).

В разных СУБД используются свои диалекты sql, которые могут отличаться как в формате представления предложения `create table`, так и типах данных.

В состав ЯОД входят всего два предложения -- `create` и `drop`, где после этих слов указывается, что именно мы описываем -- например, `table`, `database`, `index` и так далее.

При этом если в РМД порядок перечисления доменов в отношении не важен, то в sql это свойство нарушается, и колонки будут включаться в таблицу именно в таком порядке, в котором они описываются.

Несмотря на то, что РМД определяет атрибуты на доменах, в реляционных СУБД обычно вместо доменов используются типы данных, и принадлежность атрибута к домену устанавливается как тип данных.

Табличные ограничения -- это те, которые охватывают сразу несколько колонок таблицы. Они описываются отдельно, но все колонки, которые в этом ограничении упоминаются, должны быть описаны до табличного ограничения.

### Типы данных

**Числовые** -- используются для представления целых, вещественных и десятичных чисел

```sql
smallint - полуслово (2 байта)
tinyint - 1 байт
integer
real
decimal - обычно используется для представления вещественны чисел
```

**Строковые** -- используются для представления строк

```sql
char - строки фиксированной длины, после него опционально может идти указание длины, например, char[5], но если длина не указана, то по умолчанию она принимается равной 1
varchar - строковые данные переменной длины
```

При этом если мы объявили пятисимвольный `char(5)`, а использовали только два символа, то они будут расширены до 5 символов, то есть во всех строках этот атрибут будет именно указанной длины, а незанятое место будет заполнено пробелами.

Для `varchar` надо указывать предполагаемое максимальное значение; по умолчанию равно 1, что для `varchar` бессмысленно, так что это грубейшая ошибка. 

Если мы задаём `varchar(5)`, а используем только два символа, то только эти два символа и будут храниться, и до 5 ничего дополняться не будет. Однако в памяти каждая строка типа `varchar` также содержит дополнительное поле, указывающее её длину. 

Если попытаться сравнить `char(5) 'ab'` и `varchar(5) 'ab'`, то результат сравнения будет отрицательным, так как для `char(5)` будет представление `'ab'` и три пробела.

**Дата-время** используются для представления даты и времени

```sql
date
time
datetime
smalldatetime
```

Обычно всё, что касается даты-времени, в СУБД реализуется с помощью библиотечных функций.

### Выражения

В sql нет никакого неявного преобразования типов операндов. Если оно нужно, надо явно выполнять его с помощью функции `cast`.

**Операция конкатенации (+)** выполняет сцепление двух строковых операндов и образует строковое выражение


**Арифметические операции** можно использовать с операндами числовых типов

**Бинарные операции / + -** определяют сложение, вычитание, умножение и деление

**Операции над датой и временем** реализуются с помощью библиотечных функций

### Ограничения целостности

Тип ограничения целостности | Представление в SQL
--|--
Уникальность значений | `PRIMARY KEY` ИЛИ `UNIQUE`
Обязательность значений | `NULL` или `NOT NULL`
Допустимость значений | `CHECK` логическое условие
Ссылочные ограничения | `FOREIGN KEY`

#### Допустимость значений

```sql
CHECK (условие)

Условие:

[NOT] предикат [ бинарная_операция [NOT] предикат]

Предикат:
операции отношения = <> != < <= > >=
expr1 [NOT] between expr2 and expr3
expr [not] in (expr_list)
expr [not] like template 
```

#### Ссылочное ограничение

```sql
Ссылочное ограничение на колонку:

... references parent_table (pk_name_in_parent_table) -- если FK и PK названы одинаково, можно не указывать имя ПК в род таблице
	on delete reaction
	on update reaction

reaction:
- no action (restrict в других диалектах)
- cascade
- set null


Табличное ссылочное ограничение (когда в родительской таблице ПК составной, тогда и FK составной)

foreign key (columns_list) -- важно чтобы атрибуты перечислялись том же порядке что и у родительской таблицы
	references parent_table (pk_from_parent_table)
	on delete reaction
```

### Удаление таблицы

```sql
drop table table_name
```

Нельзя удалить родительскую таблицу, если существует хотя бы одна связанная с ней дочерняя таблица

## Предложения SQL

```sql
insert into имя_таблицы (колонка1, ...)
	values (значение1, ...), ( ... ) ...
	запрос
-- явные ограничения разработываются с помощью триггеров и процедур
-- неявные с помощью create table
-- для каждого диалекта sql стандарт бизнес логики свой
-- перед заполнением БД имело бы смысл сделать триггеры
-- иначе для тех строк которые уже были включены в таблицы триггеры вызваны не будут
-- имена колонок перечисляются в любом удобном порядке
-- значения можно задать самому (values)
-- или вместо values можно написать запрос select

delete from имя_таблицы
	where условие_отбора_строк

update имя_таблицы
	set колонка1 = выражение, ...
	where условие_отбора_строк

-- имя колонки может повторяться:

update sp set qty = qty + 10 // это будет выполнено для всех строк в таблице
```

### Формирование запросов

```sql
select [distinct] список_вывода -- имена колонок, выражения, встроенные функции СУБД
from источники -- имена таблиц, из которых выбираются данные
where условие_отбора_строк
group by список_для_группирования
	having условие_отбора_групп
order by список_для_упорядочивания
```

Для заполнения таблиц нужно разрабатывать триггеры

### Триггеры

На них стандарта нет и в каждом диалекте используется свой язык, в Postgres -- PL/SQL.

```sql
create trigger checkSal1 -- имя триггера уникально в пределах БД
on employee -- триггер всегда привязывается к какой-то таблице
after insert -- и какому-то действию с этой таблицей: after/before insert/delete/update 
-- здесь триггер срабатывает уже после вставки данных в таблицу: 
-- еслик какие-то неявные ограничения нарушены, вставка не произойдёт и триггер не сработает
-- обычно пишутся триггеры after, потому что в этом случае гарантируется, что будут выполняться все внутренние ограничения, чтобы не делать лишние проверки
[for each row] / [for each statement]
-- for each row: триггер будет срабатывать после вставки каждой строки
-- for each statement: сначала будут вставлены все строчки, и только после этого вызван триггер
as
	set nocount on // специфика ms sql; в postgres такой необходимости нет
	declare // объявляем переменные
		@sal decimal(10, 2), // имена локальных переменных начинаются с @
		@minSal decimal(10, 2),
		@maxSal decimal(10, 2),
		@jobId int;
// поскольку триггер срабатывает после insert, то в нём есть временная таблица с именем inserted
// вставляется только одна строка (for each row), значит, в inserted есть только одна строка данных
// раз одна строка, то можно считать значения из этой строки и записать в переменные
	select @sal = sal, @jobId = jobId
		from inserted;
	select @minSal = minsal, @maxSal = maxsal
		from job 
		where jobid = @jobId;  // считали вилку должностных окладов для данной должности
// проверяем корректность
	if @sal < @minSal or @sal > @maxSal
	begin
		raiserror('Incorrect salary for jobId = %d', 11, 1, @jobId); // вывести сообщение об ошибке, raiserror
		// 11 - код серьёзности ошибки
		// 1 - уровень разделения серьёзности ошибки внутри кода
		rollback // все действия которые были выполнены (вставка записи) откатывается
	end;

// аналогичный вариант
	select @sal=sal from inserted;
	select @minSal = minsal, @maxSal=maxsal
		from job
		join inserted i on i.jobId = job.jobId;
	if @sal < @minSal or @sal > @maxSal
	begin
		raiserror('Incorrect salary', 11, 1);
		rollback
	end;
```

В Postgres нет таблички `inserted`, но можно указать такую конструкцию

```sql
create trigger trigger_name
on table_name
after insert
old as T1
new as T2
...
```
 тогда таблица `T2` определяет новое имя таблицы после вставки

Предложения SQL являются атомарными: не может быть такого, что часть предложения выполнилась, а часть -- нет. Поэтому если мы вставляем в таблицу несколько строчек и если хотя бы в одной строке будут нарушены ограничения целостности, то ни одна строчка из запроса вставлена в итоге не будет.

Триггер представляет собой некоторую специальную процедуру, которая пишется на расширенных диалектах SQL для бизнес-логики. Для SQL определён стандарт, касающийся только работы непосредственно с таблицами -- вставка, удаление, изменение, запросы, при этом на диалект SQL, касающийся бизнес-логики и процедур, стандарта нет. Следовательно, форматы предложений `create trigger` в MSSQL и Postgres будут разные.

Перед тем, как мы начнём заполнять базу, надо разработать и отладить свои триггеры.

```sql
create or replace trigger имя -- если триггер с такими именем есть, то он просто пересоздастся (or replace)
условие_срабатывания 
on имя_таблицы // триггер обязательно привязывается к таблице
[for each row] // триггер будет вызываться для каждой строчки отдельно - это понизить производительность
// по умолчанию for each statement
// если мы пишем after insert for each statement, то сначала в таблицу будут вставлены все строки, но только после этого вызовется триггер
// это мб быстрее, но сложнее - мы не будем получать доступ к каждой вставленной строке отдельно
[when (условие)] // перед срабатыванием триггера проверяется условие - если оно не выполнено, триггер срабатывать не будет
declare // объявление локальных переменных как в create table
	...
	// тип данных для переменных можно указать так
	a таблица.колонка type // тип переменной совпадает с типом колонки - так триггер сам будет "подхватывать" обновления таблиц
begin // что нужно сделать
...
end

// обычно условие срабатывания задаётся так:
{before, after, instead of}  // время выполнения триггера относительно операции
insert / delete / update // какой операции
/*
более предпочиттельным является создание триггера after
он будет срабатывать только если строчка прошла проверку целостности, так повысится производительность

триггер instead of используется обычно не для таблиц, а для представлений (view)
view - это представление, которое хранится в виде select-запросов, и в отличие от таблиц, реально в базе не существует
поэтому с view можно выполнять только select
но если хочется с ними выполнять insert/delete/update, то можно перехватить эти операции с помощью триггера
*/
```

Пример триггера, проверяющего корректность оклада

```sql
// postgres
create or replace trigger checkSal1
after insert or update
on employee
[referencing new as t1 old as t2] // переименование предопределённых имен старых и новых значений 
for each row
declare
	minSal number,
	maxSal number;
	// к старым и новым значениям можно обращаться через :old._ и :new._
	// если мы не уверены в типах данных переменных, можно указать:
	minSal job.minSal%TYPE
// из таблицы job для указанного значения jId считывается minsal и maxsal
begin
	select j.min_sal, j.max_sal into minSal, maxSal
	// selectы с into мб только в скалярных запросах - то есть тех, которые возвращаяют максимум одну строку результата
	from job j
	where j.job_id = :new.job_id
	-- проверяется корректность
	if :new.sal < minSal or :new.sal > maxSal
		then raise_application_error(-200001, 'incorrect salary'); // первый аргумент - код ошибки: отрицательное значение - пользовательская ошибка
	end if;
end;
```
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE3NzU4ODE0OCwtMTQxMzA5NTUyOCw3OT
M3MzUwNzIsMTQ4Nzc2NDY0LDk3NzA5MTczMCwtMTAyNzQ5Nzky
OF19
-->