## Содержание курса

| Этапы жизненного цикла | Используемые средства
|--|--|
Проектирование | Модели данных, модель "сущность-связь"
Разработка | Реляционная модель данных
Реализация | Язык SQL конкретной СУБД; внутренние структуры хранения



В этом семестре мы будем проектировать базу данных как часть некоторой информационной системы. Обычно информационные системы создаются для решения задач, специфических для предметной области; они используются для поддержки текущей деятельности предприятия, а поскольку для этого требуется хранить большие объёмы информации, то если раньше она хранилась в бумажном виде, сейчас это, конечно же, неудобно, и она сохраняется в электронном виде на машинах.

Если посмотреть на историю вычислительной техники, то первые вычислительные машины были построены в конце 40-ых - начале 50-ых годов прошлого века, и получили название **вычислительные**, потому что они изначально разрабатывались для организации и автоматизации вычислительных работ: необходимо было обрабатывать большие объёмы данных, получаемых в результате физических экспериментов.

Но поскольку в состав вычислительной системы входят в том числе и средства, позволяющие надёжное и долговременное хранение данных, то такие вычислительные системы почти сразу же стали активно использоваться для разработки **информационных систем**, целью которых является накопление, обработка и долговременное хранение больших объёмов информации. Естественно, центральной частью таких ИС стали системы хранения данных. Первые варианты таких СХД получили название **базы данных**.

ИС, которые были разработаны для поддержки текущей деятельности предприятия, получили название **транзакционных систем** *(OLTP -- OnLine Transaction Processing  --  системы обработки транзакций)*. Это связано с тем, что текущая деятельность предприятия предполагает выполнение большого количества однотипных операций, которые получили название **транзакции**. Соответственно, в этом курсе мы рассматриваем проектирование баз данных, используемых в транзакционных системах.

Применительно к базам данных можно выделить некоторые этапы жизненного цикла -- проектирование, разработка и реализация.

Для описания данных, которые хранятся в БД, используется **информационная модель**, которую на разных этапах жизненного цикла можно описывать разными средствами.

На этапе **проектирования**, когда мы разрабатываем саму информационную модель, ориентируясь на предметную область, обычно используются **модели данных**, которые явились развитием модели "сущность-связь" (ER), которая удобна тем, что она имеет свой диаграммный язык, с помощью которого эту модель легко представить, и она понятна. 

Здесь стоит отметить, что разработчик ИС, как правило, не является конечным её пользователем. Если он является специалистом в области IT, то конечный пользователь таковым специалистом не является, зато он хорошо погружён в предметную область, в отличие от разработчика. Поэтому на этапе проектирования разработчик должен представить информационную модель в виде, который может понять пользователь, и учесть все их пожелания.

Сегодня на этапе проектирования мы используем не саму модель данных, а её модификацию -- модель **IDF1X**. Такую диаграмму уже легко перевести на язык реляционной модели данных.

Так как БД предполагают хранение больших объёмов данных на внешней памяти, а для её обработки нужно выгружать данные в ОП, то возникает вопрос производительности таких систем: объёмы данных в ОП очень большие, и как найти то, что нас интересует с тем, чтобы пользователь, формирующий какой-то запрос, не просиживал перед чёрным экраном недопустимо долгое время? Поэтому очень важно понимать, как организуется хранение данные во внешней памяти так, чтобы время отклика системы было приемлемым. Для таких ИС главными требованиями являются два (и они очень часто вступают друг с другом в противоречия):
- обеспечить целостность и достоверность информации
- обеспечить приемлемое время отклика

# 1. Модели данных. Общая характеристика

На разных этапах проектирования и разработки ИС используются разные модели данных, которые, в сущности, описывают одно и то же. Поэтому очень часто в разных моделях данных для обозначения каких-то схожих понятий используются одни и те же термины, но семантика в них может отличаться.

Что такое информация и как она используется? Конкретные ИС предназначены для поддержки текущей деятельности предприятия, которое опирается на какие-то внешние явления. Эти внешние явления, которые представляют интерес для предприятия, должны быть каким-то образом описаны. Для этого обычно используется понятие **данных**, с которыми связаны две характеристики:
- конкретные значения данных, то есть **факты**: 127, 7 февраля, ...
- **семантика** -- интерпретация, смысл значений: вес груза в кг, начало весеннего семестра, ...

При этом важно, что семантика определяет ещё и возможные операции над данными: например, если 12 -- это номер сотрудника, то его нельзя складывать, а можно только сравнивать, и т.д.

Обычно в памяти вычислительных машин мы храним только факты, при этом семантика отрывается от них. Этот отрыв в целом ряде случаев весьма усложняет обработку фактических значений.

Когда используется термин **информация**, то обычно он предполагает соединение фактов и их семантики. Если мы описываем их на естественном языке, это позволяет объединить их, получив "вес перевозимого груза 167 кг". Но для хранения на машине такое использование естественного языка считается невозможным.

Очень часто для удобного представления информации используется табличный способ -- например, расписание занятий, где названия строк  и столбцов задают семантику, а значения на их пересечениях -- факты.

### Файловые системы

Первые разновидности ИС организовывали хранение фактов именно в файлах, а семантику -- в прикладных программах, с помощью которых можно было вытащить конкретные факты из файлов и соответствующим образом обработать. Поэтому доступ к данным в таких системах осуществлялся только через прикладные программы.

**Файловые системы** -- набор программ, выполняющих операции, связанные с обработкой данных. При этом каждая программа, которая включается в такую файловую систему, по сути определяет свои собственные данные и управляется своими собственными данными.

#### Недостатки

Файловые системы обладают существенным рядом недостатков, которые привели к необходимости разработки каких-то других типов ИС.

- разделение и изоляция данных: интерпретация данных осуществляется прикладной программой ⇒
- дублирование данных: одни и те же данные могут дублироваться в разных программах, работающих с одними данными но решающих разные задачи
- зависимость от файлов: прикладные программы обрабатывают файлы с жёстко заданной структурой, и мы не можем перевести программу на обработку файлов другого типа
- несовместимость данных: обычно дата-время представляется либо в виде структуры, либо в виде строки
- фиксированные запросы к данным: в программу жёстко закладываются те запросы, которая она может выполнять

Причина этих недостатков в том, что факты и семантика разделены. 

На смену файловым системам пришли системы баз данных.

### Системы баз данных

**База данных** -- совместно используемый набор логически связанных данных и их описаний, предназначенных для удовлетворения информационных потребностей организации. В таких системах описание данных часто называется **метаданными**.

**СУБД** -- ПО, осуществляющее управление данными

**Система баз данных** - компьютеризованная система хранения записей: база данных, СУБД, аппаратура и люди, которые используют эту информацию


<a href="https://ibb.co/Bw4PtJK"><img src="https://i.ibb.co/CWJtzys/image.png" alt="image" border="0"></a>

**Сервер** владеет каким-то ресурсам и предоставляет соответствующие услуги, а **клиент** ими пользуется.

В **двухзвенной архитектуре** прикладные программы, которые обрабатывают данные, реализованы на стороне клиента. Она обращается к серверу за данными и обрабатывает их в соответствии со своей логикой.

В последнее время чаще всего вместо двухзвенной архитектуры используется **трёхзвенная**:


<a href="https://ibb.co/GWhD6ph"><img src="https://i.ibb.co/9bM0DgM/image.png" alt="image" border="0"></a>

В этом случае есть чистый сервер -- сервер, на котором установлена БД и СУБД, есть чистый клиент, на котором установлены средства для формирования необходимых запросов и отображения результатов их выполнения -- чистый интерфейс пользователя, а для реализации прикладной логики выделяется особый компонент -- **сервер приложений**, который по отношению к серверу БД выполняет роль клиента, а по по отношению к клиенту -- роль сервера.

Такая архитектура удобна, если разные прикладные программы используют более или менее одинаковые прикладные модули обработки данных, то это модули могут бтыь реализованы в виде одной копии на стороне сервера приложений.

Кроме того, на сервере приложений для реализации прикладной логики можно использовать языки высокого уровня, что облегчает их разработку.

Сама СУБД также реализует двухзвенную логику: есть серверная часть, которая отвечает за управление доступа к данным, и есть клиентская часть, которая реализует интерфейс пользователя.


## Категории пользователей

### Администраторы данных и баз данных

**Задачи:**
- обеспечение бесперебойной работы ИС
- поддержание необходимого качества данных

**Требования к СУБД:**
- обеспечение контроля доступа
- надёжность
- высокая производительность
- поддержка больших объёмов хранимой информации
- масштабируемость системы

### Разработчики баз данных

**Задачи**
- проектирование структуры БД
- реализация БД в рамках заданной СУБД

**Требования к СУБД**

- стандартизованные средства создания БД и манипулирования данными

## История развития СУБД

### СУБД первого поколения

- середина 60-х иерархическая СУБД IMS
- сетевая модель IDS (Interpreted Data Store)

Сетевая модель позволяла представлять более сложные связи, чем иерархическая модель.


СУБД, где используется сетевая или иерархическая модели данных, называются **унаследованными**.

Однако в иерархической модели для создания сложных связей будут дублироваться данные.

<a href="https://ibb.co/QJd94zV"><img src="https://i.ibb.co/PrQxd3y/image.png" alt="image" border="0"></a>



## Архитектура ANSI-SPARC

**Внешний уровень (view)** ориентирован на представление БД для конечного пользователя в зависимости от его нужд -- для каждой категории пользователей оно мб разным. Но эти представления могут в чём-то пересекаться, поэтому во избежание дублирования информации они все воедино собираются в **концептуальный** уровень (логическое описание), а **внутренняя схема** уже организует физическое хранение данных в БД.

<a href="https://ibb.co/Hh9L54v"><img src="https://i.ibb.co/SfZDFyT/image.png" alt="image" border="0"></a>

Внутренняя схема объединяет в себе все характеристики каждого из представлений. Поэтому чтобы пользователи получали доступ только к той информации, которая им нужна, эта внутренняя схеме *отображается* во view для каждого конкретного пользователя/группы. Это гарантирует, что каждый пользователь будет иметь доступ только к той информации, которая нужна ему.


Чтобы с этими данными работать, надо концептуальный уровень отобразить на физический -- на организацию хранения данных. Если мы ориентируемся на какой-нибудь ЯП, например, С, то для описания сотрудника создаётся соответствующая структура. Это позволяет, с одной стороны, исключить дублирование информации, а с другой, представлять её удобной для обработки.

Термин **информация** заключается в том, что мы не только храним конкретные *значения* данных, но и их *семантику*.

СХД начинались с создания файловых систем (где факты хранятся отдельно от семантики), им на смену пришли системы БД, которые объединяют факты и семантику.

СУБД строились на основании модели, которая позволяла описывать эти данные. СУБД используют три модели: сетевая и иерархическая (это уже в пролом), и реляционная -- основная на сегодняшний день.

Проектирование таких баз данных осуществляется в соответствии с положениями, принятыми при разработке архитектуры СУБД, определёнными в рамках комитета ANSI/SPARC.



# 2. Модели данных

Поскольку при разработке СУБД и при разработке информационных систем, в основе которых лежат СХД, используются какие-то модели данных -- и мы будем проектировать свою БД в соответствии с реляционной моделью данных, рассмотрим общие положения, касающиеся определения, а что же такое модель данных.

**Модель данных** -- это интегрированный набор понятий для описания **данных**, **связей** между данными и **ограничений**, накладываемых на данные в некоторой организации.

В какой-то степени в качестве аналогии можно привести алгоритмы -- это тоже набор понятий для описания обработки данных. Модель данных позволяет описать данные, которые существуют в реальном мире -- а они обязательно взаимодействуют между собой, поэтому надо описывать и связи.

При этом в разных предметных областях на одни и те же данные могут накладываться разные ограничения, поэтому описание данных, связей и ограничений рассматривается применительно к конкретной предметной области.

<a href="https://ibb.co/B3GzqG1"><img src="https://i.ibb.co/vqhwZht/image.png" alt="image" border="0"></a>

Модели данных принято делить на две категории: **сильно типизированные** и **слабо типизированные**.

В **сильно типизированных** МД все данные, описывающиеся в рамках данной модели, относятся к каким-то конкретным категориям: поскольку мы реально описываем всё, что происходит во внешнем мире, то, наблюдая за этим внешним миром и выявляя общие характеристики объектов и явлений, можно всё, что мы наблюдаем, разделить на какие-то категории. Например, можно использовать типы данных в ЯП -- это по сути такое категории, по отношению к которым мы выбираем объекты, обрабатывающиеся в программах.

В **слабо типизированных** МД распределить данные между какими-то категориями не представляется возможным. Но для того, чтобы можно было рассматривать связи и ограничения, то реальные объекты, явления и элементы из реального мира просто относятся либо к одной категории, либо к другой категории.

## Сильно типизированные модели данных

Большинство моделей данных, используемых в ИС, относятся к сильно типизированным. Это позволяет нам рассматривать все свойства данных, связи между данными, оперируя понятием **категории** -- не рассматривая каждый конкретный экземпляр данных, а рассматривая их общие характеристики.

Поэтому сильно типизированные модели данных делятся на две категории в зависимости от того, как эти категории определяются -

В моделях данных **на основе объектов** данные распределяются между разными объектами. Все элементы, размещаемые в одном объекте (в данном случае объект означает множество), характеризуются общим набором свойств. К таким моделям относятся объектно-ориентированная модель данных, а также семантические модели --в частности, сущность-связь. Однако модель сущность-связь не лежит в основе никакой реальной СУБД, хотя она очень активно используется на этапе проектирования.

Втора группа сильно типизированных МД -- **на основе записей**. Это реляционная модель, сетевая и иерархическая.

В сильно типизированных МД выделяются следующие основные компоненты: **категория** -- обобщённое понятие, с каждой категорией связывается некоторый набор **свойств** категории -- и тогда все экземпляры, которые включаются в ту или иную категорию, обладают одинаковым набором свойств -- но значения свойств, конечно же, могут быть разными. И поскольку модель данных должна отражать **связи** между категориями, они тоже входят в компоненты сильно типизированных моделей данных.

Например, транспортное предприятие в своём составе имеет средства передвижения (автомобиль - первая категория), и водители -- вторая категория. Для категории ВОДИТЕЛЬ определяются свойства имя, возраст, стаж работы, а для категории АВТОМОБИЛЬ -- модель, госномер, дата ТО и так далее. Между этими двумя категориями устанавливаем определённую связь, которую можно сформулировать в виде предложения: "водитель управляет автомобилем". Связь в данном случае -- "управляет" -- глагол.

В конкретном применении модели данных совокупность именованных категорий, их свойств и связей между ними, называется **схемой**. Таким образом, всё, что выделено синим на слайде, -- это схема, позволяющая описать работу транспортного предприятия.

Например:

ВОДИТЕЛЬ (Имя, Возраст, Стаж работы, ...)
АВТОМОБИЛЬ (Модель, ГОсномер, Дата,...)
УПРАВЛЯЕТ (ВОДИТЕЛЬ, АВТОМОБИЛЬ)


**Реализация БД** -- совокупность данных, структура которых соответствует некоторой схеме.

**База данных** -- совокупность реализаций, полученных в результате некоторых преобразований и удовлетворяющих одной и той же схеме.

<a href="https://ibb.co/RgzpMBr"><img src="https://i.ibb.co/Fhgbf0Z/image.png" alt="image" border="0"></a>

Определение БД содержит в себе некоторую связь со временем: конкретная реализация БД соответствует конкретному моменту времени -- это то, что есть сейчас. Но в нашей БД были какие-то реализации в прошлом и будут какие-то реализации в будущем, и все такие реализации -- те, которые были, и те, которые будут -- и называются базой данных.

Поэтому термин БД не означает моментальный снимок данных, хранящихся на машине -- это то, что изменяется во времени.

В зависимости от конкретной предметной области, если для них используется одна и та же МД, мы можем описать и разные схемы: например, можно попытаться описать схему учебного процесса (тогда будут категории группа, предмет, преподаватель и связи между ними).

Каждой конкретной схеме соответствует реализация. Эти реализации могут изменяться за счёт использования каких-то преобразований и операций, и вся эта совокупность реализаций и называется БД, причём она не ограничена: потому что могло быть что-то и до первой реализации, и будет что-то после последней реализации.

Так как мы имем дело с сильно типизированным МИ, мы можем определить схему, и все наши данные будут ей удовлетворять.

Поскольку БД меняется в времени, то когда мы описываем конкретную предметную область, мы сталкиваемся с необходимостью представления **статических** неизменяемых свойств и **динамических** изменяющихся свойств. Например, схема базы данных -- это статическая информация, а реализация отражает динамику.

Поэтому для реализации статических и динамических свойств в сильно типизированных моделях данных используются какие-то языки: для описания статических свойств рассматриваются **правила порождения**, которые позволяют описать схему базы данных и какие-то ограничения. Обычно правила порождения не различают, порождается ли структура или ограничения, и задаются средствами языка описания данных. Хотя в последнее время всё чаще язык описания данных как бы разбивается на два подмножества: дя описания структуры рассматривается DDL, а для описания ограничений рассматривается подмножество этого языка -- язык описания ограничений.

Для описания операций преобразования динамических свойств рассматривается подмножества языка манипулирования данными.

Таким образом, языки БД делятся на DDL (ЯОД) и ЯМД (DML, Data Manipulation Language)

<a href="https://ibb.co/84tqCLp"><img src="https://i.ibb.co/jZsmNP2/image.png" alt="image" border="0"></a>

Например, в реляционных БД существует один общий язык SQL, в который включены подмножества и DDL и DML.

При описании структуры мы тут же определяем какие-то ограничения, если они очевидны и мы можем их сразу сформулировать. Например, на должность водителя можно принимать только совершеннолетних (возраст > 17), а стаж работы < возраст - 17: только человек, достигший совершеннолетия, может получить права по управлению автомобилем: поэтому это гарантирует, что на предприятии не появится 18-летний водитель с 10-летним стажем. Конечно, все эти ограничения разрабатываются применительно к предметной области, и заказчик, который хорошо знает специфику работы своего предприятия, может чётко определить эти ограничения, поэтому с ним надо работать активно.

Поскольку мы должны описать **структуру** -- совокупность категорий, свойств и связей между категориями, рассмотрим, какие компоненты мы используем для её описания.

### Структурные компоненты

**Множество** -- собрание правильно идентифицированных объектов, удовлетворяющих правилу принадлежности.

<a href="https://ibb.co/H2FTXG8"><img src="https://i.ibb.co/3srmkSZ/image.png" alt="image" border="0"></a>

Для множества мы должны определить какое-то условие: правило принадлежности, которому должны удовлетворять все элементы этого множества.

В зависимости от того, как задаются множества, они делятся на две группы -- множества-домены и множества-отношения.

**Отношения **-- это некоторый агрегат построенный на других множествах. В зависимости от того, на каких множествах отношение построено, рассматривают **отношения сущности** -- построены на доменах, и **отношения связи** -- построены на отношениях сущности.

При определении множества мы должны задать две важные характеристики -- **интенсионал** (характеристика типа, определяющая допустимые множества значений). По сути интенсионал -- это тип переменной `int`

Кроме того, **экстенсионал** -- определяет конкретное значение множества. По аналогии с ЯП -- это конкретное значение переменной типа `int`, например, 27

### Домены и атрибуты

**Домены** -- множества, элементы которых более или менее однородны. Обычно в МД роль доменов выполняют типы данных: например, целое число.

Значения, входящие в домен, могут использоваться для задания свойств категории.

**Атрибуты** -- именованные домены, представляющие семантически значимые объекты. Они позволяют называть свойства категорий.

В этом примере все атрибуты приведены на одном и том же домене -- целые числа. Атрибуты позволяют связать факты и их семантику -- способы их обработки: например, возраст с целыми числами. 

<a href="https://ibb.co/t4XczXw"><img src="https://i.ibb.co/Cz2v62p/image.png" alt="image" border="0"></a>

### Отношение сущности

**Отношение сущности** -- агрегат, построенный на множествах-*доменах*.

В соответствии с определением этого отношения (это определение берётся из математической теории отношений с уточнениями, специфическими для МД):

Пусть дана некоторая совокупность доменов $D_1, D_2, \dots, D_n$, не обязательно различных. Тогда отношение -- это множество упорядоченных кортежей вида $\lang d_1, d_2, \dots, d_n\rang$, в которых каждый $d_i$ принадлежит соответствующем домену $D_i$: $$R = \{\lang d_1, d_2, \dots, d_n\rang|d_i\in D_i, i=\overline{1, n}\}$$

Само отношение -- неупорядоченное множество, но кортежи, в него входящие, упорядочены в соответствии с порядком следования доменов.

**Степень** отношения (**арность** кортежа) -- количество множеств, на которых построено это отношения (в данном случае равно $n$)

**Мощность** отношения -- количество кортежей в конкретной реализации отношения.

Если арность -- характеристика *интенсионала*, то мощность -- характеристика *экстенсионала*, то есть конкретной реализации отношения.

Если в качестве доменов рассматриваются, например, $$D_1 = \mathtt{int} \{1, 4, 8\}\\D_2=\mathtt{char}\{a, c, x\},$$то отношение, построенное на этих двух доменах, может включать в себя следующее множество кортежей: $$\{\lang 1, a\rang, \lang 1, x\rang,  \lang 8, c\rang, \dots\}$$


Степень кортежей -- 2 (потому что 2 домена), а мощность конкретно этого отношения равна 3 (потому что 3 кортежа).

**Схема отношения** -- именованный список пар <имя атрибута: имя домена >.

$$имя\_схемы(имя\_атрибута : имя\_домена, \dots)$$

Атрибут в отношении -- это семанически значимый объект, определяющий способ использования домена в отношений. Атрибуты как раз и позволяют внести семантику в описание данных.

D1 предсталвяет собой интенсионал : строчная английская буква, а эстенционал -- {a, b, c, d, e}

На основе этих двух доменов создаётся отношение. В данном случае -- это множество бинарных кортежей (по два элемента в каждом кортеже), причём первый элемент каждого кортежа принадлежит D1, а второй -- D2.

Схема отношения: R(Категория: D~1~, Индекс:D~2~). Так как интекс принадлежит десятичным цифрам (D2), то мы теперь знаем, что индексы мы можем не только сравнивать на равенство, но ещё и определять < и >

В таком отношении арность равна 2, а мощность -- 3. Если арность -- характеристика типа и не зависит от конкретной реализазции отношения, то мощность зависит от конкретнкнернтой реализации и будет меняться.

### Отношение связи

**Отношение связи** -- агрегат, построенный на множествах-*сущностях*

Определяются точно так же: если у нас есть некоторая совокупность множеств сущностей, то отношение связи -- неупорядоченное множество упорядоченных кортежей вида $\lang s_1, s_2, \dots, s_n\rang$, где $s_i\in S_i$: $$R = \{\lang s_1, s_2, \dots, s_n\rang|s_i\in S_i, i=\overline{1, n}\}$$


#### Характеристики связи

**Арность** характеризует, на каком количестве множеств сущностей рассматривается связь. Мы ограничиваемся бинарными связями -- связями между двумя множествами сущностей. Это ограничение определяется тем, что реляционная модель данных поддерживает только бинарные связи, но используя только их, можно реализовать сколь угодно сложные ИС.

Для бинарной связи определяются два **отображения**: $$R: S_1\to S_2; R^{-1}: S_2\to S_1,$$Какое из отображений определить как прямое, а какое -- как обратное, значения не имеет

А вот уже отображение обладает своими характеристиками.

**Кардинальное число отображения** -- количество элементов одного множества, связанных с одним элементом другого множества $$R(S_1(\min_1, \max_1):S_2(\min_2, \max_2)$$

То есть количество экземпляров из множества сущностей $S_2$, связанное с одним экземпляром из множества сущностей $S_1$, определяет **кардинальность** отображения $S_1\to S_2$.



У каждого отображения своя кардинальность. Поскольку каждый экземпляр $S_1$ может быть связан с разным количеством $S_2$, то обычно рассматриваются минимальное и максимальное значение.

Каждый экземпляр из $S_1$ связан с минимум $\min_2$, максимум с $\max_2$ экземплярами $S_2$. Именно эти характеристики -- $\min_1, \dots, \max_2$ -- определяют тип связи.

Например, курсы по выбору: ВЫБИРАЕТ(СТУДЕНТ(5, 100): КУРС(1, 3))

Каждый студент должен выбрать какие-то курсы по выбору. Каждый студент должен выбрать по крайней мере один из трёх курсов, но курс состоится в том случае, если его выберут минимум 5 студентов из 100.

### Типы отображений

В зависимости от того, каким условиям удовлетворяют эти кардинальные числа, рассматриваются различные конкретные типы отображений.

**1. $R(S_1(0,\infty):S_2(1, \infty)), S_1\to S_2$ -- полностью определённое на $S_1$**

<a href="https://imgbb.com/"><img src="https://i.ibb.co/KsNGqwV/image.png" alt="image" border="0"></a>

Каждый экземпляр множества S1 связан минимум с одним экземпляром множества S2.

Для существования экземпляра множества сущностей S1 необходимо, чтобы он был связан с каким-то одним экземпляром множества сущностей S2 (по крайней мере, одним, но можно и больше)

Такое отображение называется **полностью определённым на S1**: экземпляр S1 не может существовать вне связи с экземплярами S2

#### Неполное функциональное отображение

<a href="https://ibb.co/2y6PvDG"><img src="https://i.ibb.co/yXR56wH/image.png" alt="image" border="0"></a>

Минимальное кардинальное число отображения равно 0, то есть экземпляр из S1 мб не связан ни с каким экземпляром из S2, а максимальное число равно 1 -- то есть максимум можно связаться с одним экземпляром S2. А это значит, что если мы можем берём соответствующий экземпляр из S1, мы всегда можем по нему найти соответствующий экземпляр S2 -- такое отображение называется **неполным функциональным**.


#### Полное функциональное отображение

<a href="https://ibb.co/2vNWsMh"><img src="https://i.ibb.co/6HBr1tw/image.png" alt="image" border="0"></a>

Когда минимальное и максимальное кардинальные числа равны 1, то есть каждый экземпляр из S1 обязательно связан с одним и только одним экземпляром из S2 -- получаем **полное функциональное отображение**: получив некоторый экземпляр S1, мы всегда найдём один единственный экземпляр S2, ему соответствующий -- то есть получаем функцию, которая по значению $x\in S_1$ находит значение $y\in S_2$. 


Эти типы функциональных отображений влияют на типы связи.



## Ограничения целостности

В общем случае модели данных включают в себя представление трёх компонентов:
- **структурные** компоненты, позволяющие описать информационную модель. В них входят отношения сущности и отношения связи.
- **ограничения целостности**, накладываемые на данные
- **манипуляционные характеристики**: база данных представляет собой совокупность реализаций, получаемых путём преобразования, и этот компонент как раз определяет, какие преобразования можно выполнять с данными.

Для описания этих трёх компонент -- структурной, целостной и манипуляционной, в языках, которые предназначены для описания информационной модели, обычно выделяют два подмножества языка:
- язык описания данных, который определяет структуру данных и **статические** ограничения, накладываемые на данные
- язык манипулирования данными, который определяет правила преобразования реализаций, на которые также оказывают влияние ограничения, накладываемые на данные.

**Ограничения целостности** -- логические ограничения, накладываемые на данные (**constraints**) в условиях соответствующей предметной области. Разрабатывая схему БД, на этапе определения связей сущностей и построения диаграмм бывает очень полезно также определять какие-то ограничения, которые накладываются на данные.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/JtR1Wj9/image.png" alt="image" border="0" height="200" align="left"></a>

Рассмотрим, где на каком этапе используются ограничения целостности. У нас есть модель данных МД, средствами которой мы можем представить некоторую совокупность схем баз данных S. Схем в рамках одной модели может быть много: всё определяется той предметной областью, которую мы реализуем; а сама база данных представляет собой совокупность реализаций DBS~i~, удовлетворяющих данной одной и той же схеме, получаемых в результате каких-то преобразований.

На уровне описания данных используется подмножество языка описания данных, а для преобразования реализаций используется подмножество языка манипулирования данными.


На этих этапах и при описании схемы, и при реализации преобразований между отдельными реализациями базы данных действуют какие-то правила, которые определяют допустимые (или достоверные) состояния БД. В силу того, что мы описываем как статические свойства, так и динамические свойства преобразований, ограничения, которые накладываются на данные, тоже делятся на две категории:
- **статические спецификации** выражают правила, которые определяют допустимые (достоверные) состояния БД. Эти правила накладываются на каждую конкретную реализацию БД
- **динамические спецификации** определяют возможные допустимые переходы из одного состояния БД в другое -- преобразования из одной реализации БД в другую: не все такие преобразования могут быть разрешены, учитывая ограничения, накладываемые на данные.

Обычно все логические ограничения, которые накладываются на данные, связаны с состоянием базы данных и включают в себя и статические, и динамические спецификации. 

Допустим мы разработали соответствующую информационную модель, для которой мы определили некоторую совокупность ограничений, накладываемых на данные. Поскольку ограничения связаны со схемой БД, а схеме БД удовлетворяют отдельные реализации, состояния БД, то между ограничением, схемой и состоянием БД существуют определённые зависимости, выраженные следующими определениями:

#### Правила, накладываемые на ограничения целостности C~i~

Ограничение C~i~:
- **правильно построено**, если оно соответствует синтаксическим правилам спецификации ограничений. Для спецификации ограничений в SQL есть средства, которые позволяют эти спецификации указать
- **удовлетворено состоянием DBS~i~** (состоянием БД -- конкретной её реализации), если оно истинно для данного состояния. Поскольку ограничения целостности -- это обычно логические условия, они могут принимать значения истина или ложь, то ограничение удовлетворено состоянием, если для данного состояния ограничение принимает значение истина.
- **удовлетворяемо**, если есть хотя бы одна реализация состояния БД DBS~i~, которая удовлетворяет этому ограничению, то есть на этом состоянии ограничение принимает значение истина.
- **недостоверно**, если никакое состояние базы данных ему не удовлетворяет.

При определении ограничений целостности надо использовать синтаксически правильные конструкции и нужно выбирать такие ограничения целостности, которые соответствуют предметной области, чтобы не оказалось так, что выбранное ограничение будет недостоверным.

#### Правила, накладываемые на конкретную реализацию состояния БД DBS~i~

DBS~i~ -- это конкретный набор данных, удовлетворяющих схеме.
- **удовлетворяет схеме S**, если он удовлетворяет всем ограничениям, определённым для этой схемы. То есть данные не просто структурно удовлетворяют схеме, но ещё должны выполняться и все ограничения целостности, которые для этой схемы сформулированы
- **непротиворечиво**, если оно удовлетворяет всем ограничениям, накладываемым на схему БЖ

#### Правила, накладываемые на схему S

Схема S:
- **удовлетворяема**, если существует некоторое состояние БД, которое удовлетворяет данной схеме
- **противоречива**, если никакое состояние базы данных этой схеме не удовлетворяет.

При проектировании схемы для неё надо определить и какие-то ограничения целостности, и гарантировать, что данная схема не окажется противоречивой, то есть могут существовать реализации, которые удовлетворяют всем ограничениям, накладываемым на данные.

### Манипуляционный компонент

Это правила переходов состояния БД. Они обычно не определяются, а разрабатываются для тех моделей данных, которые лежат в основе некоторой конкретной СУБД, а поскольку для моделей *вообще* никакой реальной СУБД существовать не может, то эту часть мы пока оставим в стороне.

Здесь можно только отметить, что языки манипулирования данными применительно к любой МД делятся на две категории:
- **навигационные** языки, которые учитывают конкретную организацию структуры информационной модели. К ним относятся языки манипулирования данными в иерархической и сетевой МД
- **ненавигационные** языки: чтобы найти нужные данные, достаточно указать, каким свойствам эти данные должны удовлетворять, не указывая конкретного маршрута движения по схеме.



В общем случае применительно к МД ограничения целостности могут быть разделены, в свою очередь, на **внутренние** и **явные**.

**Внутренние** ограничения поддерживаются самой моделью данных. Например, атрибут всегда определён на каком-то домене, а значит, значение атрибута может только принадлежать этому домену. Модель данных сама определяет понятия домена, атрибута, и поэтому своими средствами гарантирует, что атрибут не сможет принимать недопустимые значения. От разработчика БД выявление таких внутренних ограничений не накладывает никаких доп требований на реализацию таких ограничений: контроль за правильным значением того или иного атрибута берёт на себя СУБД, работающая в соответствии с конкретной моделью данных

**Явные** ограничения не мб реализованы МД. Для их реализации разработчику надо создавать какие-то дополнительные конструкции, чтобы проверить соответствующее условие. Например, в предприятии сумма окладов должна быть меньше зарплаты. Так что если предметная область предъявляет какие-то явные ограничения, их надо определить функционально или процедурно, а может быть, с помощью триггера. 


Обязательное условие: на этапе проектирования информационная модель будет представлена в виде FA диаграммы и помимо всего прочего, надо продумать и ограничения целостности: помимо описания отдельных отношений и связей между отношениями, надо сформулировать возможные условия связи: например, водителем автобуса не мб несовершеннолетний и так далее.

## Операции над данными

По своему смыслу эти операции делятся на выборку (чтение, поиск) и модификацию данных -- в основном добавление (хотя можно и удалять, но удаление на практике применяется нечасто, потому что если вдруг надо будет что-то восстановить, а копии нет, то этого сделать уже не получится). Поэтому, как правило, если данные больше уже не нужны и не используются в текущий момент времени, сохраняются в каких-то архивах и исключаются из текущей реализации БД, а при необходимости всегда можно будет обратиться к этим архивным записям.

Организация доступа к данным реализуется языками, которые делятся на две группы: ненавигационные, которые не учитывают конкретную организацию хранения данных на физическом уровне с точки зрения формирования запросов к данным (например, в СУБД на основе реляционной модели данных), и навигационные, которые это учитывают.

# 3. Модель данных "сущность-связь"

## Введение

Это семантическая высокоуровневая модель. Нет ни одной реальной СУБД, в основе которой лежит модель сущность-связь. Есть объектно-ориентированные СУБД, у которых многие характеристики похожи на модель сущность-связь.

Модель была предложена Питером Ченом (P. Chen) в 1976 году. В этом время уже велись интенсивные работы по изучению реляционной модели, поэтому в этой статье используются те же термины, что и в общем описании МД, но их семантика может отличаться: в каждой модели данных подчёркиваются какие-то особенности, которые она накладывает на то или иное понятие.

Прежде всего, он выделил разные уровни представления информации:

#### Уровень 1: информация о сущностях и связях

Этот уровень ориентирован на человека и пытается описать то, что пользователь хочет получить от будущей информационной системы, так что тут информация представлена так, как она существует в представлении людей. 

На этом уровне обычно используется описание на естественном языке, а естественный язык обладает большими степенями свободы, поэтому здесь описание может быть довольно расплывчатым и не очень строгим, а главное -- может иметь разные способы реализации. 

#### Уровень 2: структура информации

Это организация информации, в которой сущности и связи представлены данными -- по сути, выбор способов идентификации конкретных экземпляров сущностей и конкретных экземпляров связей.

#### Уровень 3: структура данных - способ доступа

Это структура данных, независимая от способа доступа к этим данным: чисто на логическом уровне. 

#### Уровень 4: структура данных + способ доступа

Здесь уже учитывается способ доступа к данным.

Чен показал, что для представления информации о сущности и связях, как она существует в нашем представлении (1 уровень) и описания структуры информации на 2 уровне подходит модель данных "сущность-связь". На 3 уровне используется реляционная модель, а 4 уровень соответствует иерархической и сетевой моделям данных.

## Уровень 1

**Сущность** -- нечто, принадлежащее объективной реальности, облаченное в материальную форму или форму идеи; любой объект, который может быть идентифицирован некоторым способом, отличающим его от других объектов, и информацию о котором надо хранить в базе данных.

Сущность -- это нечто, что может существовать реально (например, автомобиль) или в форме идеи (например, банковский счёт -- идея, в которой отражается, кто какие операции с деньгами определяет, или факт продажи -- это идея, которая говорит, что данный материальный товар был когда-то продан за какую-то стоимость).

Важно, что экземпляры сущности всегда могут быть идентифицированы и отличимы друг от друга по каким-то характеристикам.

**Связь** -- некоторая ассоциация, устанавливаемая между двумя или более сущностями.

Модель данных сущность-связь не ограничиваются только бинарным связями: здесь рассматриваются n-арные связи в общем случае.

### Сущность -- Entity

Поскольку сущности -- это нечто, принадлежащее объективной реальности, в результате наблюдения каких-то явлений, выделяется некоторое *множество* сущностей $E = \{e_i\}$. Когда рассматривается это множество, с этим множеством обязательно связывается **предикат** -- правило, на основании которого мы можем определить, принадлежит ли конкретный наблюдаемый объект в реальном мире данному множеству сущностей или нет. Предикат определяет, что может являться экземпляром сущности, а что нет.

Например, если у нас есть множество сущностей-городов, то предикатом для неё может быть какое-то ограничение на численность населения и на площадь.

С учётом свойств множества и предиката определяется **тип** сущности -- некоторое обобщённое представление однородных сущностей. Например, в нашем примере это город. Тогда **экземпляр** сущности  $e_i$ -- это конкретный элемент  множества сущностей $E$.

Если рассматривается термин *сущность* (entity), часто подразумевают конкретный экземпляр множества сущностей. Однако часто с ним связывают и понятие типа сущностей (само множество), поэтому лучше использовать чёткую трактовку. В нашем случае *сущность*  будет интерпретироваться как тип сущностей, то есть название множества сущностей. А если надо обратиться к элементу этого множества, то будем называть это *экземпляром*.

Для каждого множества сущностей определяется некоторый набор свойств, общих для всех сущностей из этого множества. В этот набор в том числе входит и предикат -- правило принадлежности.

### Связь -- Relationship

Поскольку связь -- это ассоциация, устанавливаемая между двумя или более сущностями как множествами сущностей, то каждая конкретная связь -- это связь между конкретными экземплярами сущностей. С другой стороны, этих связей много, и они тоже образуют множество. Поэтому тут, как и в случае с сущностями, есть двоякая трактовка термина связь. 

**Множество связей** -- математическое отношение между сущностями: $$R = \{\lang e_1, e_2, \dots, e_n\rang|e_1\in E_1, e_2\in E_2, \dots, e_n\in E_n\}$$Множество связей представляет собой множество упорядоченных по порядку перечисления сущностей кортежей $\lang e_1, e_2, \dots, e_n\rang$, в которых каждый элемент кортежа $e_i$ принадлежит соответствующему множеству сущностей $E_i$. 

Множество связей -- это характеристика знака, экстенсионал. Есть ещё и внутренняя характеристика -- интенсионал: тип связи. **Тип связи** определяет соответствующую ассоциацию типов сущностей.

Поскольку связь -- это также и множество, то мы можем рассматривать и **экземпляр** связи как отдельный элемент этого множества.

Кроме того, есть ещё одна важная характеристика связей -- **роль сущности в связи $r$** -- функция, которую сущность выполняет в данной связи: $$\lang r_1/e_1, r_2/e_2, \dots, r_n/e_n\rang$$Роль сущности в связи очевидна исходя из того, какие множества сущностей вовлекаются в эту связь. Например, если у нас есть два множества сущностей -- проект и сотрудник организации, то если мы рассматриваем связь -- какой исполнитель над каким проектом работает, то эта связь представляет множество бинарных кортежей вида <проект/e~1~, исполнитель/e~2~>. Поскольку элементы e~1~ и e~2~ извлекаются из разных множеств сущностей, то они уже чётко определяют, какую роль данный экземпляр сущности играет в данной связи: e~1~ -- проект, над которым работает исполнитель, а e~2~ -- исполнитель, который работает над проектом.

В целом ряде случаев при определении связи необходимость в указании роли сущностей в ней отпадает. Хотя есть ситуации, при которых эта роль должна быть очень чётко задана. Например, сущность "денежная единица" и сущность "курс", где имя роли денежной единице в связи с курсом надо обязательно указывать -- из неё переводим или в неё.

Другой пример -- сущность "личность". Если рассматривать связь между личностями  <e~1~, e~2~>, которая выражает отношения между ними, то надо чётко определять, какая сущность какую роль играет: например, e~1~ -- отец, а e~2~ -- ребёнок.

### Значения -- values

Информация о сущностях и связях представляется в виде множества пар "атрибут-значение".

Для этого используется **множество значений - values**, в которые входят
- сами значения
- предикат

Чен переопределил термин "атрибут" по сравнению с общей теорией моделей данных: **атрибут** -- функция, отображающая множество сущностей или множество связей в множество значений $$f:S_i\xrightarrow{f}V_i$$ или декартово произведение множества значений: $$f: S_i\xrightarrow{f}V_{i1}\times V_{i2}\times\dots\times V_{in}$$

### Информация о сущностях

Допустим, мы определили множество сущностей СОТРУДНИК. Далее мы определили некоторую совокупность множеств значений: здесь 5 множеств значений: НОМЕР СОТРУДНИКА, ФАМИЛИЯ, ИМЯ, ОТЧЕСТВО и КОЛИЧЕСТВО ЛЕТ. 

<div align="center"><a href="https://ibb.co/d0qvxnG"><img src="https://i.ibb.co/BVxJF8q/image.png" alt="image" border="0" height="300"></a></div>

Тогда атрибут -- это *функция*, которая отображает множество сущностей на множество значений. Эта функция с каждым экземпляром сущности связывает одно значение из множества значений: например, первый атрибут F~1~ -- это номер сотрудника, который отображает экземпляр сущности СОТРУДНИК на значение НОМЕР СОТРУДНИКА. С каждым экземпляром сущности связано в точности *одно* значение из множества значений -- это полное функциональное отображение.

Множество сущностей СОТРУДНИК отображается на множество значений КОЛИЧЕСТВО ЛЕТ с помощью двух функций, то есть двух атрибутов: возраст сотрудника и стаж его работы.

Также множество сущностей e~1~ отображается на декартово произведение множеств значений, если мы рассматриваем атрибут "полное имя сотрудника", который содержит в себе ФИО.

### Информация о связях

Чен не ограничивается бинарными связями, а рассматривает в общем случае n-арные связи. Например, у нас есть множества сущностей СОТРУДНИК, ПРОЕКТ и множество значений ПРОЦЕНТ. 

<div align="center"><img src="https://i.ibb.co/6mGQVYm/image.png" alt="image" border="0" height="300"></div>

Мы рассматриваем связь -- ассоциацию между сущностями СОТРУДНИК и ПРОЕКТ. Эту ассоциацию мы определяем как "исполнитель проекта" -- мы определяем, какой сотрудник над каким проектом работает. Сотрудников много, проектов тоже много, и множество связей тоже может включать в себя большое количество кортежей.

У каждой связи, помимо всего прочего, могут быть ещё и собственные атрибуты: например, доля времени, которую данный сотрудник затрачивает на работу над данным проектом. Этот атрибут не является атрибутом множества сущностей СОТРУДНИК, ни свойством проекта -- он характеризует именно связь.

## Уровень 2

Поскольку здесь речь идёт уже о возможности идентифицировать каждый экземпляр сущности и каждый экземпляр связи, то эта идентификация означает, как мы можем представить конкретный экземпляр сущности и конкретный экземпляр связи для того, чтобы отличить его от других.

### Представление сущности

Чтобы идентифицировать каждый экземпляр сущности, нужно использовать понятие **первичного ключа** сущности -- совокупность одного или несколько атрибутов, уникальных для каждого экземпляра сущности.

<div align="center"><img src="https://i.ibb.co/x6yQbrv/image.png" alt="image" border="0" height="250"></div>

Если у нас есть множество сущностей СОТРУДНИК и для идентификации сотрудников мы используем множество значений НОМЕР СОТРУДНИКА, в котором каждому экземпляру сотрудника соответствует в точности одно значение, но для ключа важно, что это соответствие является **взаимно однозначным**: то есть с каждым экземпляром сотрудника связано своё уникальное значение из множества значений НОМЕР СОТРУДНИКА, но и наоборот, каждому значению номера сотрудника соответствует только один экземпляр сущности СОТРУДНИК. Поэтому для того, чтобы представить сотрудника, достаточно указать его первичный ключ -- номер сотрудника. 

Для такого представления множества сущностей это самое множество уже не используется. Чен ограничивается просто множеством значений НОМЕР СОТРУДНИКА, потому что зная его, мы чётко определим и сам экземпляр сущности СОТРУДНИК.

Для удобства Чен предложил все эти множества сущностей и связей иллюстрировать с помощью таблиц:

<div align="center"><img src="https://i.ibb.co/Q6r5dCX/image.png" alt="image" border="0"></div>

Раз у нас выделяется колонка первичного ключа, то это гарантирует, что у каждого сотрудника будет свой уникальный номер.

### Представление связи

Для представления связи Чен предложил использовать **первичный ключ связи**. Поскольку связь -- это ассоциация между экземплярами сущностей, то первичный ключ связи здесь создаётся на основе первичных ключей сущностей, вовлечённых в эту связь.

<div align="center"><img src="https://i.ibb.co/FVNZdWf/image.png" alt="image" border="0"></div>

Однако такое представление информационной модели в виде таблицы неудобно: оно громоздкое и не наглядное. Поэтому Чен предложил свой диаграммный язык для представления этой информационной модели.

### Диаграмма сущность-связь

Для представление отношения сущности используется прямоугольник, внутри которого записывается имя множества сущностей.

Для представления связи используется ромбик. Имя множества связей записывается внутри этого ромбика.

Для задания атрибутов используется овал, внутри которого записывается имя атрибута. Атрибуты связываются с соответствующими сущностями или связями. Атрибуты, выполняющие функцию первичного ключа, подчёркиваются.

Рассматриваются два типа сущностей: **регулярное** отношение сущности и **слабое** отношение сущности.

**Регулярное** отношение сущности: для однозначной уникальной идентификации каждого экземпляра сущности в данном множестве достаточно использовать только собственные атрибуты сущности.

**Слабое** отношение сущности -- отношение, в котором для уникальной идентификации каждого экземпляра во множестве сущностей нужно учитывать связь: то, что в IDEF1x определяется как сущность, зависимая по идентификации. Такие сущности обозначаются прямоугольник с двойными границами.

Аналогично связь может быть представлена простым ромбиком или ромбиком со сдвоенными границами, если связь устанавливается со слабым отношением сущности, или, с точки зрения IDEF1x -- идентифицирующая или неидентифицирующая связи.

#### Представление n-арных связей

n-арные связи могут быть представлены так:

<div align="center"><a href="https://ibb.co/Thf16gp"><img src="https://i.ibb.co/HgSC6H1/image.png" alt="image" border="0" height="200"></a></div>

В нотации IDEF1x, которая ограничивается *только* бинарными связями, связь ПОСТАВКА была бы представлена отдельной сущностью ПОСТАВКА.

Наличие таких n-арных связей позволяет в какой-то степени описать предметную область более точно. 

#### Определение связей на одном множестве сущностей

<div align="center"><a href="https://ibb.co/hm74tL4"><img src="https://i.ibb.co/HHFbkBb/image.png" alt="image" border="0" height="150"></a></div>

#### Указание типов связей -- 1:n и n:n

<div align="center"><a href="https://ibb.co/jMmkxjt"><img src="https://i.ibb.co/wWVhb2t/image.png" alt="image" border="0" height="150"></a></div>

#### Слабое отношение сущности

<div align="center"><a href="https://imgbb.com/"><img src="https://i.ibb.co/gjNskHy/image.png" alt="image" border="0" height="150"></a></div>

Каждый сотрудник как член бригады зачисляется в бригаду к какому-то руководителю. Каждый сотрудник предприятия имеет свои уникальные характеристики -- первичный ключ, но для того, чтобы идентифицировать члена бригады, собственная идентификация сотрудника оказывается неприемлемой, потому что один и тот же сотрудник для выполнения разных работ может быть зачислен в разные бригады. Поэтому для идентификации члена бригады приходится использовать собственный атрибут сотрудника плюс атрибут руководителя.

Итоговая диаграмма может выглядеть так:

<div align="center"><a href="https://ibb.co/W3qMx9s"><img src="https://i.ibb.co/N3QJVh7/image.png" alt="image" border="0" height="300"></a></div>

Как видно, диаграммный язык не очень удобный, и сами диаграммы получаются громоздкие, поэтому и самим Ченом, и впоследствии в других организациях были предложены другие языки диаграмм (при этом важно, что изменения касались только самих диаграмм, не затрагивая саму суть модели сущность-связь). Например, мы используем нотацию IDEF1x, которая имеет, пожалуй, только одно принципиальное отличие от ER-модели: в IDEF1x рассматриваются только бинарные связи, тогда как в оригинальной модели допускалось использование в общем случае N-арных связей.


### Ограничения целостности

В общем случае, как уже было сказано, модель данных состоит из трёх компонент.

Первая -- это структурные компоненты, средства, которые позволяют описать структуру -- информационную модуль

Далее, поскольку информационная модель предназначена для отображения процессов и явлений, которые меняются во времени, то модель данных должна предоставлять какие-то средства, позволяющие изменять необходимые данные. Поэтому второй компонент модели данных -- *манипуляционный*, который предназначен для определения допустимых данных, которые хранятся в БД.

Наконец, третий компонент. На данные накладываются некоторые ограничения, поэтому МД должна в том числе и представлять какие-то средства для описания ограничений.

В модели "сущность-связь" манипуляционная часть отсутствует полностью, представлена структурная часть и в достаточно ограниченном виде представлены какие-то средства, позволяющие задавать ограничения целостности. Причём эти ограничения целостности определяются главным образом именно структурными компонентами.

Выделено три вида ограничений, которые задаёт сама модель данных. Если модель данных определяет какие-то ограничения, то это означает, что разработчик не должен предусматривать и прилагать какие-то дополнительные усилия для того, чтобы соответствующие ограничения реализовать.

#### 1. На допустимые значения в множестве значений

Поскольку основной структурный компонент -- отношение -- представляет собой агрегат, построенный на доменах, и включает в себя некоторый перечень атрибутов, каждый из которых определён на доменах -- множествах значений, то значения атрибутов ограничены.

Например, у нас есть множество сущностей СОТРУДНИК, и у каждого экземпляра этой сущности определены два атрибута -- стаж работы, который определён на домене КОЛИЧЕСТВО ЛЕТ, и атрибут "Возраст" сотрудника, который определён на том же самом домене.

<div align="center"><img src="https://i.ibb.co/r7SvNH7/image.png" alt="image" border="0"></div>

Поскольку любое множество задаётся в том числе с указанием правила принадлежности, которое позволяет определить, какие значения могут присутствовать в этом множестве, а какие нет, то если домен КОЛИЧЕСТВО ЛЕТ определён как множество целых неотрицательных значений, то допустимые значения этого домена могут быть такими, как представлено на рисунке. Значит, допустимое значение атрибута -- это любое значение из заданного множества.

Следовательно, могут существовать экземпляры сущности СОТРУДНИК, у которых стаж работы, допустим, равен 12 годам, а возраст равен 29 годам, или возраст 29 лет и стаж работы 33 года. Все эти значения допускаются, поскольку они принадлежат соответствующему домену, но с точки зрения предметной области это бессмысленно.

#### 2. На разрешённые значения некоторых атрибутов

Поэтому вторая категория ограничений целостности -- ограничения на разрешённые значения некоторых атрибутов. Они обычно задаются какими-то другими средствами, очень часто для этого используется язык исчисления предикатов. В данном случае ограничение записывается на естественном языке, и дополнительные разрешённые значения атрибутов могут устанавливать некоторые соотношения между значениями атрибутов.

Например $$(Возраст(e)\geq17) \land (Возраст(e)\leq 70) | \forall e\inСОТРУДНИК$$

#### 3. На существующие значения в базе данных

То есть когда каждое из этих значений могут существовать в базе данных по отдельности, а в совокупности уже не могут.

<div align="center"><img src="https://i.ibb.co/30TxP55/image.png" alt="image" border="0"></div>

Здесь сумма бюджетов всех отделов предприятия не должна превышать бюджет самого предприятия.


Специфика модели ER заключается в том, что раз она ориентирована на человека, то все определяемые в ней ограничения записываются в виде, понятном человеку, и обычно записываются на каких-то языках, которые не являются языками описания модели. 

# 4. Реляционная модель данных

## Общая характеристика


Разработана сотрудником IBM Коддом в 1969-70 гг. Она появилась раньше, чем модель данных сущность-связь, поэтому Чен, естественно, использовал какие-то термины и понятия из реляционной модели данных. Тут мы будем использовать те же понятия атрибута, отношения, ключей и так далее, но для каждой МД эти понятия чем-то чуть-чуть отличаются.

Реляционная модель обладает рядом неоспоримых достоинств, благодаря которым до сих пор современные самые популярные СУБД построены на реляционной модели данных, хотя, например, СУБД Oracle использует объектную модель данных.

Достоинствами этой модели являются:

-   Относительно небольшой набор абстракция для описания предметной области
- Модель базируется на мощном математическом аппарате, что позволяет обосновать все возможности использования модели данных
-   К моменту, когда была опубликована статья Кодда о реляционной модели, ИС уже создавались, но классификация модели данных Чена появилась примерно в середине 70-ых: до того, как модели данных были названы сетевой или иерархической, эти термины по сути не использовались. Когда появились разные модели данных для описания структуры, они и получили свои названия: в частности, реляционная модель данных получила название реляционной
-   Для манипулирования данными (реляционная МД разрабатывалась уже с целью её использования в реальных системах управления данными) эта модель данных должна обязательно включать в себя все три компонента: и структуру, о ограничения целостности, и манипуляционный компонент. Поэтому в РМД были описаны соответствующие операции манипулирования данными, которые были определены как ненавигационные: чтобы получить доступ к элементам данных, пользователю или разработчику совсем не обязательно знать, как эти данные реально хранятся во внешней памяти -- а это то, что необходимо для иерархической и сетевой МД. Чтобы найти нужные данные, достаточно просто задать те свойства, которым они должны удовлетворять, а как они будут найдены -- это дело конкретной СУБД.

РМД, несмотря на такие очень важные достоинства, обладает и рядом недостатков, в результате чего позднее, когда появилась необходимость решать дополнительные задачи, которые РМД решает не очень хорошо, появились другие системы управления данными NoSQL -- системы, в основе которых лежит не язык SQL. (Язык SQL -- ярчайшая характеристика РМД, поэтому в основе NoSQL систем лежит не РМД) 

Недостатки РМД

-   Возможности РМД не безграничны, и при использовании таких систем в некоторых областях применения, которые требуют очень сложных структур данных -- например, а САПР, РМД никакого выигрыша не даёт, а может быть, даже даёт и проигрыш, увеличивая время отклика таких систем. В таких системах используются какие-то другие МД и способы организации хранения данных
-   РМД не даёт возможности адекватного отображения семантики предметной области. Хотя с одной стороны появление таких СУБД ставило перед собой соединение значений данных с их семантикой, в полном объёме точно отобразить семантику предметной области при использовании РМД, увы, не удаётся.

Все современные СУБД, даже MySQL (которые уже не реляционные), используют некоторые элементы реляционной модели данных. Поэтому, кстати, MySQL не приветствуется в этом курсе, там многие вещи реализуются на уровне приложения. Так как мы рассматриваем БД как способ организации и хранения данных в транзакционных (OLTP) системах, в таких системах главное внимание уделяется проблеме **целостности** данных, так чтобы целостность и достоверность данных обеспечивалась самими СУБД, а на уровне прикладных программ разработчики не занимались проблемами обеспечения целостности. Если эти проблемы выносятся на приложение, то с течением времени может потребоваться разработка новой прикладной программы, а ограничения все могут забыть, в результате чего в БД могут появляться данные, которые по-хорошему не должны появляться в них. Поэтому в OLTP-системах, которые в своей основе используют РМД, реляционные СУБД гарантируют целостное состояние базы.

В общем случае структурная и целостная части в МД описываются как бы одной частью модели, для которых используется подмножества языка описания данных (DDL): DDL позволяет не только описать данные, но и описать те ограничения, которые на них накладываются.

Второе подмножество языков - это язык манипулирования данными (DML). Манипулирование данными, в свою очередь, тоже учитывает те ограничения, которые накладываются на данные.

Особенностью РМД является то, что в ней уже определена манипуляционная часть. Она содержит конкретный набор операций, которые можно применять для манипулирования данными, какую-то функциональность, и в SQL есть средства, которые позволяют описать все три компоненты модели данных.

Ещё одним несомненным достоинством РМД является то, что все СУБД, построенные на этой модели, используют единый язык SQL, в котором объединены и средства описания данных, и средства манипулирования данными, и даже какие-то средства описания ограничений.

## Структурные компоненты

<div align="center"><img src="https://i.ibb.co/JHL073D/image.png" alt="image" border="0"></div>

Здесь все домены разделены на две категории -- простые и составные. **Простой** домен -- домен, элементы которого атомарны и не имеют внутренней структуры.

**Составной** домен -- это отношение, построенное на простых доменах. Но домены, использующиеся в этом отношении, никаким специальным образом не обозначаются.

### Отношение

Даны $D_1, \dots, D_n$.

Отношение -- это $$\{\lang d_1, d_2, \dots, d_n\rang|d_i\in D_i, i=\overline{1, n}\}$$

В РМД семантика отношения сужается - это не любое отношение, которое мб определено в математической теории отношений. Это агрегат, построенный на доменах. Здесь рассматривается некоторая совокупность доменов, и отношение - это неупорядоченное множество упорядоченных кортежей вида d1 … dn в котором каждый элемент кортежа принадлежит соответствующему домену: соответствие устанавливается по порядку перечисления.

В РМД отношение определяется точно так же, как и в теории множеств. 

Но далее Кодд уже чуть-чуть меняет окраску понятий. Домен -- это множество элементов. Отношение -- агрегат, построенный на доменах. А далее он уточняет понятие атрибута:

**Атрибут** -- способ использования домена в отношении. 

Тем самым с атрибутом связывается некоторая семантика, что как раз и позволяет в таких системах соединить значения, факты и их семантику -- способ обработки этих значений.

**Схема отношения** -- именованная совокупность пар <имя атрибута : имя домена>

Например, если у нас определены домены ЧИСЛО и СТРОКА, то мы можем ввести схему отношения ОТДЕЛ, которая может включать себя бинарные кортежи. Первый элемент кортежа задаёт способ использования домена ЧИСЛО в отношении ОТДЕЛ (задаётся номер отдела), а второй элемент кортежа Название задаёт способ использования домена СТРОКА в отношении ОТДЕЛ:

> ОТДЕЛ (Номер отдела: ЧИСЛО, Название: СТРОКА)

#### Свойства отношения

Поскольку само понятие отношения активно используется в математической теории множеств и в РМД, с ним связан целый набор свойств. Какие-то из них определяются как свойства из математической теории множеств: 
- Кортежи внутри отношения не упорядочены. Это обычное правило теории множеств: элементы множества не упорядочены
- Домены внутри кортежей упорядочены, потому что соответствие между элементами кортежей и доменами устанавливается именно по порядку следования.

#### Свойства отношения РМД

Кроме того, отношения, которые уже определяются в РМД, имеют целый ряд дополнительный свойств, которые отсутствуют в математической теории отношений.

-   Атрибут отношения обязательно уникален: в отношении не могут появиться два атрибута с одним названием
-   Атрибут должен быть определён на каком-то одном домене
-   На одном и том же домене могут быть определены несколько атрибутов
-   Имя атрибута может совпадать с именем домена, если в этом есть надобность
-   Порядок следования атрибутов определяется порядком следования доменов, когда определяется отношение
-   Каждый кортеж отношения РМД уникален (этого нет в математической теории), то есть в множестве отношения не могут появиться два одинаковых кортежа
-   Порядок следования кортежей не устанавливается
-   При определении схемы БД, которая определяется совокупностью схем отношений, а схема отношения -- это именованная совокупность пар, то есть у каждого отношения есть своё имя. В конкретной схеме БД имя отношения должно быть уникально: мы не можем в БД создать два отношения с одинаковыми именами.

### Нормализация отношения

Далее введено очень важное понятие, с которым явно мы не сталкивались, но которое обязательно учитывается при проектировании РБД -- это **нормализация**.

#### Ненормализованное отношение

Отношение **нормализовано**, если каждый атрибут отношения определён только на простом домене.

Рассмотрим ненормализованное отношение:

> СОТРУДНИК(Номер сотрудника: ЧИСЛО, Имя: СТРОКА, Зарплата: ИСТОРИЯ ЗАРПЛАТЫ)

В этом отношении определено три атрибута
- Номер сотрудника определён на простом домене ЧИСЛО
- Имя сотрудника определено на просто домене СТРОКА
- А вот Зарплата сотрудника определена на *составном* домене ИСТОРИЯ ЗАРПЛАТЫ

Тогда конкретная реализация такого отношения может выглядеть в виде такой таблицы:

| Номер сотрудника | Имя | Зарплата
|--|--|--
1 | Иванов | $\begin{array}{c}1985,&500\\2000,&1000\end{array}$
2 | Петров | $\begin{array}{c}1985, &850\\2000, &500\\2003, &1000\end{array}$

Видно, что значения атрибута ЗАРПЛАТА не атомарные: мало того, что они могут включать в себя несколько значений (несколько строчек), но ещё и каждая строчка имеет свою сложную структуру. Таким образом, этот атрибут ЗАРПЛАТА определён на составном домене, и такое отношение является *ненормализованным*.

В реляционной базе данных все отношения должны быть нормализованными, поэтому такое отношение в  таком виде в ней существовать не может. 

#### Нормализованное отношение

Но такое ненормализованное отношение очень легко нормализовать, если атрибут Зарплата, который был определён на составном домене, заменить атрибутами, которые использовались для формирования этого составного домена, -- год и выплаты, и для каждого элемента составного домена значения всех других атрибутов повторить:

| Номер сотрудника | Имя | Год | Выплаты
|--|--|--|--|
1 | Иванов | 1985 | 500
1 | Иванов | 2000 | 1000
2 | Петров | 1985 | 850
2 | Петров | 2000 | 500
2 | Петров | 2003 | 1000

И в результате нормализации отношение из всего двух строк преобразовалось в отношение из 5 строк.

Есть два эквивалентный определения нормализованного отношения:
- **Нормализованное** отношение -- отношение, в котором не используются составные домены
- **Нормализованное** отношение -- отношение, в котором каждое значение атрибута является атомарным, или все атрибуты определены только на простых доменах.

Как видно, ненормализованные отношения очень легко можно преобразовать в нормализованные: да, памяти может потребоваться больше, но, тем не менее, СУБД Oracle -- первая СУБД на основе РМД,
с течением времени от этой теории нормализованных отношений чуть чуть отошла в сторону: там можно определять атрибуты на составных доменах, создавая собственные составные домены. В некоторых случаях для некоторых предметных областей такое решение может быть эффективным.

### Представление сущности


**Ключ**  - совокупность атрибутов, однозначно идентифицирующих каждый кортеж отношения. Другими словами, в отношении не могут появиться разные кортежи, у которых значения ключевых атрибутов совпадают.

Поскольку для каждого отношения может быть определено несколько наборов ключевых атрибутов, то они могу быть разделены на два подмножества:
- **Первичный ключ** PK -- это подмножество включает в себя единственный набор уникальных атрибутов, для которого характерна **не избыточность** (то есть это уникальный набор атрибутов) и **неприводимость** (то есть мы не можем из атрибутов ПК удалить какой-то атрибут так, чтобы уникальность оставшегося ключа при этом не изменилась)
-   Если в отношении есть несколько наборов ключевых атрибутов, какой-то набор мы определяем в виде ПК, а все остальные в виде **альтернативного ключа** АК. Например, для кафедры есть ПК - номер кафедры и АК название кафедры.

> КАФЕДРА (<u>Номер кафедры</u>, Название (АК))

Первичный ключ в теле отношения подчёркивается.

На основе ПК строятся индексы, которые представлены в виде В - дерева. Чем больше ключей мы можем разместить в одном узле В-дерева, тем более низким оно будет. А поскольку все узлы дерева размещаются во внешней памяти, для реализации поиска по дереву СУБД приходится каждый раз обращаться к внешней памяти за очередным узлом. Поэтому чем ниже дерево (чем большее количество ключей может разместиться в одном узле дерева), тем эффективнее будет БД.

Если ключ числовой, то в одном узле можно разместить много таких ключей. А если ключ представляет собой строку, да ещё и если длина её может быть разной, то в одном узле дерева будет размещаться меньшее количество индексов. Поэтому в реальности, если у отношения есть собственный ключевой атрибут, но он не удобен для представления в системе: длинная текстовая строка, или что-то ещё, то часто для таких сущностей вводят суррогатный ключ (в данном случае номер кафедры), который, как правило, числовой, что позволяет повысить эффективность работы с системой.

Представление сущности означает возможность уникальной идентификации каждого кортежа отношения по его атрибутам. Вообще говоря, так как отношения обладают таким свойством, что дубликатов кортежей у них нет, то в принципе вся схема отношений целиком является уникальной, и значит, может рассматриваться как ключ. Но чаще всего такое представление избыточно, так как всегда можно выделить какое-то подмножество атрибутов, которое позволяет уникально идентифицировать каждый кортеж в отношении. Значит, вся схема отношения, по сути, -- это альтернативный ключ.

### Представление связи

В РМД для представления связи рассматривается особы итп ключа -- внешний ключ.

**Внешний ключ** -- FK -- это атрибут или некоторое множество атрибутов отношения R~1~, которые не являются собственными атрибутами отношения R~1~ (они используются лишь для того, чтобы установить связь этого отношения с каким-то другим отношением), но их значение совпадает со значениями первичного ключа некоторого отношения R~2~ (при этом возможность идентичности R~1~ и R~2~ не исключается, например, в иерархических связях).

#### Представление связи 1 : n

<div align="center"><img src="https://i.ibb.co/GnFPL7V/image.png" alt="image" border="0"></div>

Например, здесь сотрудник работает в каком-то конкретном отделе. Номер отдела,  в котором работает сотрудник, не является собственным его атрибутом. Он просто отражает связь с отделом. Значение атрибута номер отдела будет совпадать со значением ПК в отношении отдел.

Рассматривается ситуация, когда в одном отделе мб 0 или больше сотрудников, но сотрудник в конкретный момент времени работает только в одном отделе (тут не рассматривается временной фактор).

Эта связь не очень удобна, поэтому появились другие разновидности модели ER, которые отличаются только диаграммным языком, например IDEF1x.

<div align="center"><img src="https://i.ibb.co/yy1gBR4/image.png" alt="image" border="0"></div>

Это представление связи на уровне данных. Чтобы определить, в каком отделе работает сотрудник, для отношения сотрудник вводится атрибут внешнего ключа номер отдела: самого сотрудника этот атрибут никак не характеризует, он характеризует именно его связь с отделом, в котором в данный момент времени работает данный сотрудник.

<div align="center"><img src="https://i.ibb.co/f0TTvCf/image.png" alt="image" border="0"></div>




Если мы хотим использовать ФК для идентификации сотрудника, то он мигрирует в ПК сотрудника и связь будет сплошной, а не пунктирной.

#### Представление связи n : n

<div align="center"><img src="https://i.ibb.co/TK9ZvLQ/image.png" alt="image" border="0"></div>

Между поставщиком и деталью устанавливаем связь ПОСТАВКА типа многие ко многим. При этом связь у Чена представляется отдельной фигурой - ромбиком и у неё мб свои атрибуты.

В РМД мы сталкиваемся со следующим: у нас есть отношения ПОСТАВЩИК и ДЕТАЛЬ, и мы должны каким-то образом представить связь многие ко многим. Мы не можем включить внешний ключ ни в отношение ПОСТАВЩИК, ни в отношение ДЕТАЛЬ, потому что значения атрибутов должны быть атомарными. В этом случае эта связь типа многие ко многим представляется собственным отдельным отношением, которые включает в себя два атрибута внешнего ключа. 

<div align="center"><img src="https://i.ibb.co/pJkMvWR/image.png" alt="image" border="0"></div>

Первичным ключом отношения связи будет составной ключ, включающие номер поставщика и номер детали. Этот ПК составляется из двух ФК, каждый из которых устанавливает связь с конкретным отношением.

<div align="center"><img src="https://i.ibb.co/bbnjDsG/image.png" alt="image" border="0"></div>

Поскольку связь типа многие ко многим представляется собственным отношением, эта особенность как раз и реализована в нотации IDEF1x: если мы на диаграмме ER определили где-то связь многие ко многим, то на след этапе проектирования мы на этом этапе избавляемся от такой связи

<div align="center"><img src="https://i.ibb.co/yf947rK/image.png" alt="image" border="0"></div>

Такую схему легко преобразовать к представлению в РМД. Поэтому эти разные языки диаграмм ориентированы на то, чтобы в рамках реляционной СУБД все необходимые объекты информационной модели можно было представить достаточно легко.

### Ограничения целостности

РМД используется уже в конкретных информационных системах, поэтому она содержит средства, позволяющие задать ограничения, накладываемые на данные.

<div align="center"><img src="https://i.ibb.co/GtzCcMH/image.png" alt="image" border="0"></div>

Манипуляционная часть, поскольку она изменяет состояние значения отношения, она какой-то частью может нарушить те ограничения, которые накладываются на данные. Поэтому когда рассматриваются ограничения целостности в РМД, их принято делить на дву группы: **целостность сущностей**, которая определяет, какие значения могут быть занесены в отношения сущности, и **ссылочная целостность** -- ограничения, которые накладываются на манипуляцию, на изменение данных: может ли быть выполнено такое изменение или нет.


Этти две группы целостностей могут быть заданы следующим образом:

#### Целостность сущностей
- Если мы какой-то атрибут или группу атрибутов определили как ПК, тем самым мы гарантируем, что в нашем отношении не могут появиться кортежи с одинаковыми значениями атрибутов этого первичного ключа -- **ограничение первичного ключа**
- Аналогично, если мы в сущности определили какие-то альтернативные ключи, они тоже являются уникальными -- **уникальность других атрибутов**
- **Обязательность значений атрибутов `NOT NULL`**: мы можем подчеркнуть, что значения каких-то атрибутов обязательно должны присутствовать в каждом кортеже отношения. И наоборот, если мы допускаем отсутствие значения атрибута, можно указать ключевое слово `NULL`
- **Допустимость значений атрибутов `CHECK`**: при всех операциях проверяется соответствующее ограничение, и если данные этому ограничению не удовлетворяют, они не появятся в отношении.

#### Ссылочная целостность

<div align="center"><img src="https://i.ibb.co/xDqGrpb/image.png" alt="image" border="0"></div>

Внешний ключ -- это **ссылка** на какую-то запись родительского отношения. Поэтому те правила, которые накладываются на связи разных сущностей, определяются как *ссылочная целостность*.

Например, между отношениями ОТДЕЛ и СОТРУДНИК определена связь: ОТДЕЛ состоит из нуля или большего количества сотрудников. Отношение, которое стоит на конце связи "один", получило название **родительского** отношения; отношение на конце связи "много" --  **дочернего**.


Нарушение ограничений может возникнуть, когда с родительским или дочернем отношением выполняются какие-то действия -- *манипуляции*. Манипуляции в реляционных БД предполагают выполнение одной из трёх операций -- **вставки** нового кортежа, **удаления** существующего кортеже или **модификации** -- изменения значений атрибутов существующего кортежа.

При этом на ссылочную целостность может повлиять только модификация ключевых атрибутов: внешний ключ дочернего отношения должен совпадать с первичным ключом родительского отношения. Поэтому если мы в родительском отношении изменяем значение ключа в каком-то кортеже, то такая модификация оказывает влияние на ссылочную целостность.

Вообще говоря, именно поэтому менять первичный ключ сущности не очень хорошо. Но если такая ситуация возникает, но надо обеспечить ссылочную целостность, или просто запретить модификацию первичного ключа.

При создании БД надо определить все такие ограничения, чтобы гарантировать, что никакое изменение в базе не приведёт к нарушению целостности.

##### Операции с дочерним отношением

- **Вставка**: значение FK должно быть корректно и ссылаться на какое-то конкретное значение первичного ключа в родительском отношении. Если при вставке неправильно задаётся значение внешнего ключа (то есть в родительском отношении нет кортежа с соответствующим значением первичного ключа), такая запись не должна вставляться
- **Удаление** без каких-либо ограничений (хотя тут надо думать о сохранении истории, поэтому вместо тупого безвозвратного удаления можно просто перенести кортеж в другую табличку)
- **Модификация FK**: новое значение FK также должно быть корректно

##### Операции с родительским отношением

- **Вставка** -- без ограничений
- **Удаление** -- надо указать реакцию на связанные записи: что делать с теми записями, которые ссылаются на кортеж
	- не удалять -- самый частый вариант, вообще это вариант по умолчанию. Если тем не менее запись надо удалить, надо сначала что-то сделать с теми записями, которые ссылаются на удаляемую (удалить их самих или изменить им ПК), и только после этого удалять родительскую сущность
	- удалить все -- как правило это делается на уровне процедуры, потому что если менять состояние БД с помощью некорректной операции, то восстановить исходное состояние бывает сложно. Так что такие рисковые операции выполняются на уровне процедур, которые могут проверить правильность предполагаемых действий
	- установить пустое значение (отсутствие связи), если в атрибуте FK дочерних сущностей указано ограничение 	`NULL`, то есть ему разрешено быть пустым. 
- **Модификация ПК** -- реакция аналогична
	- не модифицировать
	- модифицировать все значения внешнего ключа, ассоциированные с этой записью
	- установить пустое значение


Неслучайно реакция по умолчанию -- не делать ничего. Если нужно что-то другое, то это достигается с помощью процедур, основанных на бизнес-логике, чтобы предотвратить возможные проблемы. В БД накапливается информация, которая отражает длительность предприятия за длительный срок, и если эта информация будет искажена, то БД будет хранить информацию, не соответствующую реальным условиям функционирования предприятия, посему дальнейшее использование такой испорченной базы будет только во вред.

### Язык описания данных

Существуют СУБД, в основе которых лежит РМД. Для таких МД был разработан язык, включающий в себя подмножества ЯОД и ЯМД. 

Поскольку отношение -- агрегат, построенный на доменах, то ЯОД должен каким-то образом позволить создавать или определять домены, позволять создавать и отношения, и, поскольку при создании отношения мы можем указать какие-то ограниения, ЯОД должен позволять нам определять ограничения целонстности.

Все современные диалекты SQL позволяют создать отношения и ограничения целостности. Где-то можно определить домены, но, как правило, вместо доменов в них используются типы данных.

4.22

Структурный компонент РМД |Элемент РБД
--|--
Домен | Тип данных
Отношение | Таблица
Атрибут | Колонка таблицы
Кортеж отношения | Строка таблицы

Тип ограничения целостности | Представление в SQL
--|--
Первичный ключ | `PRIMARY KEY`
Уникальность значения (альтернативные ключи)| `UNIQUE` 
Обязательность значения | `NULL` / `NOT NULL`
Допустимость значения | `CHECK`
Ссылочные ограничения | 	`FOREIGN KEY`


Ограничение `NULL` в языке SQL не эквивалентно использованию слова `NULL` в С. Если мы говорим, что значение какого-то атрибута может быть опущено, это значит, что значение этого атрибута отсутствует **физически** и не заменяется никаким специальным значением -- его просто нет.

```sql
create тип_объекта
drop тип_объекта
alter тип_объекта

типы объектов:
database	index
table		trigger
view		procedure
...
```

Если мы определяем какие-то атрибуты как `UNIQUE`, то СУБД сама создаёт индексы для облегчения поиска по этим ключам.

Триггеры используются для поддержания тех ограничений целостности, которые не мб представлены средствами SQL -- например, проверка значений строк в других таблицах.

Для обеспечения бизнес-логики используют процедуры, чтобы было удобнее выполнять соответствующие операции бизнес логики.

Триггеры и процедуры разрабатываются разработчиками системы, которые имеют неограниченный доступ к базе. Поэтому надо следить за тем, чтобы это всё было корректно -- так, чтобы процедуры было легко использовать тем, кто не шарит в БД.

В первых версиях РСУБД разработчики создавали для каждой конкретной СУБД свой язык. Но со временем возникла необходимость в определении стандарта. Этот стандарт был принят, но к тому времени уже были РСУБД, которые использовали какие-то свои языки, так что по отношению к каждой СУБД используется термин **диалект SQL**: в каждой конкретной СУБД реализация языка SQL немного отличаются -- как правило, типами данных и некоторыми особенностями синтаксиса. Но основные  операции у всех диалектов одинаковые.


#### Создание таблицы

```sql
CREATE TABLE имя_таблицы (
	имя_колонки тип_данных
	ограничения_на_колонку,
	...
	табличное ограничение,
	...
)
```

В соответствии со стилем кода рекомендуется писать все зарезервированные слова SQL капсом, а все собственные имена -- буквами нижнего регистра.

Несмотря на то, что в РМД порядок атрибутов не важен, в РБД в таблице колонки упорядочены и размещаются в порядке их перечисления в предложении `CREATE TABLE`.

Запятая ставится после ограничения на колонку: сначала мы полностью описываем колонку, и только после этого ставим запятую.

Некоторые ограничения не удаётся представить в виде колоночных ограничений -- обычно это те, которые связаны с несколькими колонками, например, составные ключи. Такие ограничения оформляются как табличные, и это отдельная фраза в предложении `CREATE TABLE`, которая тоже заканчивается запятой.

После предложения `CREATE TABLE` можно указывать `;`, но это зависит от диалекта.

#### Ограничение на колонку

Ссылочное ограничение (FK)
```sql
... REFERENCES родительская_таблица (имя_PK_в_родительской_таблице)
	ON DELETE реакция

Реакция:
RESTRICT	(NO ACTION) -- не выполнять операцию
CASCADE -- удалить все записи из дочерней таблицы
SET NULL -- разрешается только если FK может быть пустым
```

Имя PK в родительской таблице можно не писать, если имена ПК и FK совпадают.


#### Табличные ограничения

```sql
имя_ограничения (PRIMARY KEY, UNIQUE, CHECK, FOREIGN KEY, etc) (список_колонок_таблицы) -- порядок должен строго соответствовать порядку перечисления колонок при создании таблицы
	REFERENCES родительская_таблица (PK_из_родительской_таблицы) -- если имена атрибутов совпадают, то РК можно не указывать. Если нет, то их надо перечислять и порядок перечисления должен быть одним и тем же
	ON DELETE реакция
```

Другие ограничения:
```sql
UNIQUE / CHECK / PRIMARY KEY (список_колонок_таблицы)
```

### Объект последовательность

Когда мы работаем с БД и в таблице определяем атрибуты ПК при вставке новых строк в эту таблицу надо гарантировать, что ПК будет каждый раз принимать новое значение. Для этого чень часто используются какие-то средства, позволяющие определять автоинкрементный тип данных.

```sql
CREATE SEQUENCE имя_последовательности
	AS целочисленный_тип
	START WITH константа
	INCREMENT BY константа -- шаг изменения последовательности
	MINVALUE КОНСТАНТА | NO MINVALUE
	MAXVALUE константа | NO MAXVALUE
	CYCLE | NO CYCLE
	CACHE константа | NO CACHE 
	-- если указываем CACHE константа, это значит, что при первом обращении к последовательности указывается не одно значение последовательности, а несколько
	-- после этого эти значения сохраняются в кеш-буфере
	-- и в следующий раз не происходит вычисления следующего элемента последовательности
	-- но когда кеш буфер опустеет, снова будут вычислены несколько очередных значений последовательности
	-- это может повысить производительность
```

### Уникальные значения

```sql
-- использование последовательности
NEXT VALUE FOR имя_последовательности

-- автоинкрементный тип (MSSQL, IBM db2)
IDENTITY (начальное_значение, шаг)
-- по умолчанию (1, 1)
```

Если в таблице используется автоинкрементный тип, он мб использован только один раз -- как правило, только для задания первичного ключа. В таблице не мб два разных атрибута с автоинкрементным типом. 

### Удаление таблицы

```sql
DROP TABLE имя_таблицы
```

При этом нельзя удалить родительскую таблицу, если существует хотя бы одна связанная с ней дочерняя таблица. 

Либо сначала надо удалить все дочерние таблицы, но если в БД уже записана какая-то информация, то при удалении таблицы мы теряем всю информацию, которая была в этих таблицах.

Второй подход -- для всех дочерних таблиц отменяются атрибуты внешнего ключа и эти дочерние таблицы перестают быть связанными с родительской таблицей. Чтобы отменить атрибуты внешнего ключа и изменить структуру таблицы используется предложение `ALTER TABLE`

### Изменение таблицы

```sql
ALTER TABLE имя_таблицы действие
```

Это самое сложное предложение, для которого очень тяжело определить стандарт. В каждом диалекте синтаксис свой, более того, он зависит ещё и от действия:

Для колонки
- добавить колонку
- удалить колонку
- изменить колонку


Для ограничений
- добавить табличное ограничение
- удалить ограничение

```sql
-- добавить колонку
ALTER TABLE имя_таблицы
	ADD определение_колонки
	-- определение колонки в том же формате, что и определение таблицы
	-- только тут нельзя указывать ограничение NOT NULL
	-- но если надо, чтобы она была обязательна, сначала добавляют колонку без ограничения
	-- потом с помощью UPDATE добавляют в эту колонку значения во все строки
	-- и только после этого можно изменить колонку ALTER COLUMN и после этого добавить NOT NULL

-- изменить колонку
ALTER TABLE имя_таблицы
	ALTER COLUMN имя_колонки тип_данных изменения

-- добавить табличное органичение
ALTER TABLE имя_таблицы
	ADD табличное_ограничение

-- удалить ограничение
ALTER TABLE имя_таблицы
	DROP CONSTRAINT имя_ограничения
	-- лучше при определении ограничений не забывать использовать CONSTRAINT имя_ограничения
```


### Примеры

```sql
CREATE TABLE p(
	p_Id INT NOT NULL PRIMARY KEY IDENTITY, 
	-- правило по умолчанию: поскольку в РМД атрибцты первичного ключа не могут иметь пустые значения, то они NOT NULL ⇒ это ограничение можно явно не писать
	-- но во избежание ошибок такими правилами по умолчанию лучше не пользоваться, мало ли что
	pName VARCHAR(20) NOT NULL UNIQUE
	-- для UNIQUE лучше явно указывать ограничение обязательности
	price DECIMAL(6, 0) NOT NULL CHECK(price > 0)
)


create table sp(
	s_Id int not null references s
		on delete no action,
	p_Id int not null,
	qty int not null check(qty > 0),
	primary key(s_Id, p_Id),
	foreign key (p_Id) references p
		on delete no action
)
```

# 5. Реляционная алгебра

Мы рассмотрели структурный компонент РМД, основными элементами которого являются домен, атрибут и отношение. Если отношение строится на доменах, то мы получаем отношение сущности. Если отношение строится на отношениях сущности, то мы получаем отношение связи.

Сила РМД в том, что в её основе лежит мощнейший математический аппарат теории множеств и теории отношений, который позволил в РМД описать не только структурные компоненты и компоненты целостности, но описать ещё и средства манипулирования данными.

Для того, чтобы обрабатывать данные, прежде всего, необходимо эти данные получить. Поэтом один из важнейших компонентов манипуляционной части ЯМД представляет подмножество языка формирования запросов -- то есть каким образом получить в  таблицах БД нужные для манипулирования данные. Эти языки запросов строятся на основе двух подходов - компонентов математической теории отношений, которые определяют правила построения языков.

Языки запросов:
- Алгебраические (реляционная алгебра)
- Исчисление предикатов (реляционное исчисление)
	- с переменными-кортежами
	- с переменными на доменах

С одной стороны, один подход предполагает запись выражения на языке **реляционной алгебры** (РА). Понятие выражения здесь достаточно традиционное -- это совокупность операндов, разделяемых знаками операций. Выражения реляционной алгебры и язык запросов, построенный на основе реляционной алгебры, используют чёткий порядок действия, как в математике. Поэтому, записывая выражение на языке реляционной алгебры, мы чётко показываем, в каком порядке надо обрабатывать данные, чтобы получить результат.

Второй подход к формированию языка запросов основывается на математической теории исчисления предикатов первого порядка. Этот подход в теории баз данных называется **реляционным исчислением** (исчислением предикатов -- ИП). Поскольку предикат -- это логическая функция, в состав которой входят какие-то переменные, то в зависимости от того, как определены переменные, в теории баз данных реляционное исчисление, в свою очередь, делится на два подмножества.
- Если переменные задают кортежи отношения (строки таблицы), то говорят о **реляционном исчислении с переменными-кортежами**
- Если переменные определены на доменах, и значениями переменных являются простые атомарные значения из какого-то домена, то такой подход определяется как **реляционное исчисление с переменными на доменах**.


В отличие от выражений реляционной алгебры, запросы на языке с использованием исчисления предикатов, то с помощью мы описываем те свойства, которые мы хотим увидеть, то есть не **как** получить результат, а **что** мы хотим получить, не определяя конкретный порядок обработки и вычисления этого выражения.

SQL не является ни чистым языком РА, ни чистым языков ИП, и позволяет формировать запросы, которые будут записаны или на языке РА или на языке РИ.

## Выражение реляционной алгебры

Они строятся так:

```
операнд1 операция операнд2 -> результат
```

В качестве операндов и результатов в выражениях реляционной алгебры выступают отношения.  Поскольку отношения характеризуются двумя свойствами -- характеристика типа -- интенсионал или схема отношения и характеристика знака -- экстенсионал, конкретная реализация отношения, то при рассмотрении правил вычисления выражений и различных операций, которые используются в записи выражений реляционной алгебры, учитывается и что является схемой отношения -- то есть интенсионал, и как формируется реализация результата, то есть экстенсионал. Поскольку интенсионал отношения -- это схема отношения, а схема отношения включает в свой состав список имён атрибутов, то при вычислениях выражений РА используется **принцип наследования имён атрибутов**:

Исходные операнды $R_1(A_1, A_2, \dots )$ и $R_2(B_1, B_2, \dots)$  имеют конкретные схемы отношений, то есть совокупности атрибутов, и когда вычисляется выражение $$R = R_1 \text{ operation }R_2,$$то интенсионалом результата отношения $R$ также является схема отношения, в которой используются имена атрибутов: $$R(C_1, C_2, \dots)$$и в качестве атрибутов результата используются атрибуты из первого или второго отношения: $C_i$  -- атрибут, совпадающий с $A_j$ или $B_k$.

При необходимости атрибуты можно переименовать.

## Операции реляционной алгебры

Все операции реляционной алгебры можно разделить на три категории:
1. **Теоретико-множественные**. Поскольку в основе РМД лежит математическая теория множеств, то в операциях РА могут быть использованы традиционные операции из теории множеств (оба операнда в них -- отношения):
	- объединение
	- вычитание
	- пересечение
	- прямое (декартово) произведение
2. **Специальные**. В качестве одного из операндов, в отличие от теоретико-множественных операций, зачастую используются атрибуты отношения. То есть один операнд -- отношение со своей схемой и со своей реализацией, а второй -- задан с помощью атрибута.
	- выбор (селекция)
	- проекция
	- соединение (join) (не путать с объединением -- union)
	- деление
3. **Переименование**. Поскольку при вычислении результата операции мы получаем отношение, то с помощью операции переименования мы можем повлиять на то, как будет формироваться схема этого отношения.

### Операция переименования

Изменяет только схему отношения, сохраняя реализацию. 

**Пример**: дано $S(A, B, C)$
Переименовать атрибут $C$ в $SC$.


Для этой операции нет специального обозначения, но для упрощения можно писать $C_{\text {AS}}\space  CS$

<a href="https://ibb.co/5WRvFJz"><img src="https://i.ibb.co/1fmK64p/image.png" alt="image" border="0"></a>

Отношение поменялось, потому что схема стала другой, однако реализация не поменялась.

## Теоретико-множественные операции

Включают в себя
- Объединение `UNION`
- Вычитание (`EXCEPT` / `MINUS`)
- Пересечение `INTERSECT`
- Прямое (декартово) произведение

В РМД выполнение этих операций реализуется несколько иначе по сравнению с тем, как они определены в теории множеств. РМД здесь накладывает ещё и свои специфические ограничения на их выполнение.

### Объединение множеств 

$$S=S_1\cup S_2 = \{s_i\space |\space s_i\in S_1 \vee s_i\in S_2\}$$


Рассмотрим специфику выполнения этой операции в РМД. Пусть даны три домена (ниже перечислены **реализации** этих доменов): $$D_1 = \{1, 2, 5, 7, 9\}\\D_2=\{a, b, c\}\\D_3 = \{2, 4, 6, 8\}$$Каждый домен -- это множество **однотипных** элементов, для которого определено правило принадлежности. Например, домен $D_1$ -- множество десятичных нечётных цифр, $D_2$ -- множество латинских строчных букв (а конкретная реализация -- {'a', 'b', 'c'}), а $D_3$ -- множество десятичных цифр.


Если мы выполним объединение двух множеств $D_1$ и $D_2$, в теории множеств мы получим множество
 $$S = D_1\cup D_2 =\{1, 3, 5, 7, 9, a, b, c\}$$С точки зрения теории множеств -- это множество. Но с точки зрения РМД полученное множество **не является доменом**, потому что у домена все элементы одного типа, а у нас здесь есть и цифры, и буквы. Поэтому в РМД такие два домена объединены быть не могут, и такая операция не может быть выполнена.

С другой стороны, если мы рассмотрим объединение доменов $D_1$ и $D_3$, то получившееся множество $$D=D_1\cup D_3=\{1, 3, 5, 7, 9, 2, 4, 6, 8\}$$уже будет являться доменом -- как множество десятичных цифр. Поэтому домены $D_1$ и $D_3$ могут участвовать в операции объединения в РМД.


Если рассмотреть объединение отношения, то поскольку каждое отношение определяется как агрегат на доменах и для каждого отношения можно сформировать схему отношения, а реализация отношения -- это множество кортежей, удовлетворяющих одной и той же схеме, то пусть у нас будут отношения $R_1, R_2, R_3$ и их реализации $r_1, r_2, r_3$: $$R_1(A_1:D_1, A_2:D_1), r_1=\{\lang1, 3\rang, \lang1, 1\rang\}\\R_2(A_1:D_1, A_2:D_2), r_2=\{\lang1, a\rang, \lang2, b\rang\}\\R_3(A_1: D_1, A_2: D_3), r_3=\{\lang1, 2\rang, \lang7, 2\rang\}$$Каждое отношение является множеством, значит, с точки зрения теории множеств мы можем объединить отношения $r_1$ и $r_2$ и получить такой результат: $$r=r_1\cup r_2=\{\lang1, 3\rang, \lang1, 1\rang, \lang1, a\rang, \lang2, b\rang\}$$В этом множестве кортежи удовлетворяют **разным** схемам отношений, поэтому с точки зрения РМД это множество **не является отношением**.

С другой стороны, если мы объединим отношения $r_1$ и $r_3$: $$r=r_1\cup r_3=\{\lang1, 3\rang, \lang1, 1\rang, \lang1, 2\rang, \lang7, 2\rang\}$$Если для второго атрибута $A_2$ мы определим домен "десятичная цифра", то в полученном множестве все кортежи будут удовлетворять одной и той же схеме, следовательно, это множество будет отношением.

#### Совместимость по объединению

Поэтому существует понятие **совместимости по объединению**, которое работает и по отношению к доменам, и применительно к отношению.

Простые домены считаются **совместимыми по объединению**, если они состоят из элементов одного типа.

Два отношения считаются **совместимыми по объединению**, если 
- оба отношения имеют одно и то же множество атрибутов (схему отношения). Если два отношения имеют разные имена атрибутов, то с помощью операции переименования мы можем соответствующее условие всегда реализовать
- одноимённые атрибуты двух отношений определены на совместимых по объединению доменах. Другими словами, одноимённые атрибуты всегда должны быть одного типа

### Объединение отношений

Дано:
- $r_1(R_1)$ (отношение $r_1$ со схемой $R_1$), 
- $r_2(R_2)$
- $r_1=\{t_{1i}\}$ -- реализация $r_1$ -- множество кортежей, удовлетворяющих своей схеме
- $r_2 = \{t_{2i}\}$
- два отношения совместимы по объединению: это означает, что схемы должны иметь одинаковые имена атрибутов $R_1\equiv R, R_2\equiv R$


**Объединением** двух отношений $r_1$ и $r_2$ называется отношение $s$, схема которого совпадает со схемами операндов, а реализация представляет собой все **разные** кортежи из реализаций исходных кортежей: $$s=r_1\cup r_2=s(R), s=\{t_i\space |\space t_i\in r_1 \vee t_i\in r_2\}$$

<a href="https://ibb.co/zsBfxgf"><img src="https://i.ibb.co/6YTswSs/image.png" alt="image" border="0"></a>

Эта операция обладает свойствами коммутативности: $$r_1\cup r_2=r_2\cup r_1$$и ассоциативности $$r_1\cup(r_2\cup r_3)=(r_1\cup r_2)\cup r_3=r_1\cup r_2\cup r_3$$


### Вычитание отношений

**Разностью** двух отношений $r_1$ и $r_2$ является отношение $s$, схема которого совпадает со схемами исходных отношений, а реализация отношения представляется теми кортежами из $r_1$, которые отсутствуют в $r_2$:$$s=r_1-r_2=s(R); s=\{t_i\space | \space  t_i\in r_1\land t_i\not\in t_2\}$$

<a href="https://ibb.co/TPX2V6K"><img src="https://i.ibb.co/p4DwtcW/image.png" alt="image" border="0"></a>

Операция вычитания не коммутативна и не ассоциативна: $$r_1-r_2\neq r_2-r_1\\r_1-r_2-r_3=(r_1-r_2)-r_3\neq r_1-(r_2-r_3)$$

### Пересечение отношений

**Пересечением** отношений $r_1$ и $r_2$ является отношение $s$, схема которого совпадает со схемами операндов, а реализация представлена кортежами из $r_1$, которые встречаются в $r_2$

$$s=r_1\cap r_2=s(R), s=\{t_i\space |\space t_i\in r_1 \land t_i\in r_2\}$$

Эта операция коммутативна и ассоциативна.

<a href="https://ibb.co/wg8wpbq"><img src="https://i.ibb.co/nm4nQVy/image.png" alt="image" border="0"></a>

Эквивалентность: $$r_1\cap r_2=r_1-(r_1-r_2)$$

### Декартово произведение

Нам даны два отношения $r_1$ и $r_2$, по отношению к которым уже не ставится требование совместимости по объединению -- здесь могут быть любые отношения с любыми схемами. Более того, требуется, чтобы схемы двух отношений не имели одноимённых атрибутов (если это так, то можно выполнить операцию переименования).

Тогда результатом декартового произведения является отношение, схема которого получается сцеплением схемы первого отношения со схемой второго отношения (для этого и нужно, чтобы схемы были из разноимённых атрибутов), а реализация отношения получается путём сцепления каждого кортежа из $r_1$ с каждым кортежем из $r_2$. $$R_1(A_2, A_2, \dots, A_m)\\R_2(B_1, B_2, \dots, B_m)\\R_1\cap R_2=0$$$$s=r_1\times r_2=s(R), R(A_1, A_2, \dots, A_m, B_1, B_2, \dots, B_n)\\s = \{u_iv_j \space| \space u_i\in r_1, v_j\in r_2\}$$

Поскольку для отношений характеристика экстенсионала -- это мощность, то есть количество кортежей, которые включены в реализацию этого отношения, то в результате мы получим реализацию отношения из $n_1n_2$ кортежей

<a href="https://ibb.co/4NngJHn"><img src="https://i.ibb.co/YjFTbxF/image.png" alt="image" border="0"></a>

Эта операция и коммутативна, и ассоциативна.


## Специальные операции
В них входят
- проекция
- выбор (селекция)
- соединение `JOIN`
- деление 

В этих операциях где-то, помимо того, что используются отношения, ещё используются и атрибуты отношений.

### Проекция

Эту операцию можно отнести к категории унарных операций, потому что в ней используется только один операнд отношения. Второй задаётся через список атрибутов.

Дано отношение $r(R)$ со схемой $R(A_1, A_2, \dots, A_m)$ и реализацией $r = \{\lang t_1: A_1, r_2: A_2, \dots, t_m: A_m\rang\}$.

Кроме того, определён некоторый список атрибутов, все элементы которого входят в схему операнда $$L (B_1, B_2, \dots, B_k), B_i\subseteq R$$Тогда проекцией реализации отношения $r$ на совокупность атрибутов $L$ называется отношение $s$, схема которого определяется этим списком $L$, а реализация получается путём вычёркивания из исходного отношения $r$ тех атрибутов, которые отсутствуют в $L$ и устранения дубликатов в оставшихся кортежах. $$s(L)=\pi_L(r)=\{\lang u_1:B_1, u_2: B_2, \dots, u_k: B_k\rang|u_i=t_j, \text{ если } B_i\equiv A_j\}$$

<a href="https://ibb.co/0BcrLFm"><img src="https://i.ibb.co/vsHkWQV/image.png" alt="image" border="0"></a>

Для неё можно выделить следующие свойства:

<a href="https://ibb.co/CvYWVcz"><img src="https://i.ibb.co/d6V7kTr/image.png" alt="image" border="0"></a>

### Выбор

Её тоже можно рассматривать как унарную операцию в том смысле, что в ней участвует только одно отношение.

Выбором из данного отношения $r$ по некоторому условию $F$ называется отношение, схема которого совпадает со схемой исходного отношения, а реализация представляет собой те кортежи из $r$, для которых $F$ истинно.  $$s(R)=\sigma_F(r)=\{u_i|u_i\in R \land F(u_i)\}$$

$F$ -- это предикат, где в качестве операндов выступают атрибуты отношения и/или константы, а операции -- арифметические операции сравнения ($=, \neq, <, >, \dots$) и логические операции И ИЛИ НЕ, которые позволяют объединять подвыражения с арифметическими операциями.

Эта операция коммутативна: $$\sigma_{F1}(\sigma_{F2}(r))=\sigma_{F2}(\sigma_{F1}(r))=\sigma_{F1\land F2}(r)$$и дистрибутивна относительно операций $\gamma=(\cup, \cap, -)$:$$\sigma_F(r\space\gamma \space s)=[\sigma_F(r)]\space\gamma\space[\sigma_F(s)]$$

Из-за того, что порядок действий в операции выбора не важен, в SQL существует оптимизатор запросов, чтобы уменьшить количество обращений к внешней памяти.

<a href="https://ibb.co/FK0kNJB"><img src="https://i.ibb.co/JKyW02z/image.png" alt="image" border="0"></a>

### Соединение

<a href="https://ibb.co/wKCq4cY"><img src="https://i.ibb.co/qR98pJx/image.png" alt="image" border="0"></a>


С точки зрения правил реализации операция соединения делится на несколько разновидностей.

#### Естественное соединение `INNER JOIN`

Даны $r_1(R_1), R_1=XY; r_2(R_2), R_2=YZ$. При этом  для естественного соединения очень важно, что эти подмножества имеют общее подмножество атрибутов.

Тогда естественным соединением называется операция, в результате которой получается отношение, схема которого является объединением схем исходных отношений, а реализация отношения -- совокупность кортежей таких, что проекция кортежа результата по схеме первого отношения принадлежит реализации первого отношения, а проекция этого же кортежа по схеме второго отношения принадлежит реализации второго отношения.

$$s(R)=r_1\Join r_2, R=R_1\cup R_2=XYZ\\s=\{t:\pi_{XY}(t)\in r_1\land \pi_{YZ}(t)\in r_2\}$$То есть все кортежи из $r_1$ сцепляются со всеми кортежами из $r_2$, которые имеют такое же значение одноимённого атрибута.

<a href="https://ibb.co/82Cr3w3"><img src="https://i.ibb.co/Npv9hqh/image.png" alt="image" border="0"></a>

Эта операция `INNER JOIN`

#### Левое внешнее соединение `LEFT OUTER JOIN`

Результат определяется как результат INNER JOIN, но если в первом отношении встречаются кортежи, для которых во втором кортеже не нашлось соответствия, они всё равно включаются в результат, а значение атрибутов из второго отношения становится пустым.

<a href="https://ibb.co/XD7D0w4"><img src="https://i.ibb.co/qCNCqZn/image.png" alt="image" border="0"></a>

#### Правое внешнее соединение `RIGHT OUTER JOIN`

Выполняется точно так же, но в результат входят все кортежи из второго отношения

<a href="https://ibb.co/r4PxmV9"><img src="https://i.ibb.co/18VrLkc/image.png" alt="image" border="0"></a>

#### Полное внешнее соединение `FULL OUTER JOIN`
Включает в себя кортежи из обоих отношений

<a href="https://ibb.co/4FXhqKK"><img src="https://i.ibb.co/L0cVFYY/image.png" alt="image" border="0"></a>

#### Соединение по условию

Схемы отношений могут иметь абсолютно разные атрибуты. Более того, требуется, чтобы там не было одноимённых атрибутов. 

$$s(R)=r_1\underset{A\theta B}{\Join}r_2=\{uv:u\in r_1, u\in r_2, u \space\theta\space v\}\\R=R_1\cup R_2$$

Эта операция отличается от операции выбора тем, что у нас два отношения, а не одно. В операции выбора мы указываем условие, в котором используются атрибуты данного отношения. В соединении по условию тоже записывается условие -- предикат, но обязательным требованием к нему является то, что первый атрибут из первого отношения, а второй -- из второго отношения: в соединении по условию сравниваются значения атрибутов из двух разных реализаций отношений.

В результате получается отношение, схема которого является объединением схем исходных отношений, а реализация будет представлять собой сцепление двух кортежей таких, что для них выполняется условие $\theta$.

<a href="https://ibb.co/dW6Bp1C"><img src="https://i.ibb.co/WxFnzq8/image.png" alt="image" border="0"></a>

### Деление

Корректно эту операцию было бы назвать "целая часть частного деления". 

Даны два отношения со своими схемами. При этом схема второго отношения является непустой (делить на ноль нельзя) подсхемой первого отношения -- то есть все атрибуты, которые используются в $R_2$ -- это какое-то подмножество атрибутов из схемы $R_1$: $$\emptyset\neq R_2\subseteq R_1$$Тогда частным от деления $r_1$ на $r_2$ называется отношение $s$, схема которого определяется как разность схем двух операндов (те атрибуты из $R_1$, которые не встречаются в $R_2$), а реализация представляет собой совокупность таких кортежей, что для всех кортежей из $r_2$ сцепление с кортежами из результата даёт кортежи, принадлежащие $r_1$. $$s(R)=r_1\div r_2=\{t_j|\forall u\in r_2 (t_ju\in r_1)\}\\R=R_1-R_2$$Другими словами, $s\times r_2\in r_1$

В SQL нет средств, которые непосредственно отображают операцию деления. Для этого используются эквивалентности

<a href="https://ibb.co/CwHjgK6"><img src="https://i.ibb.co/fXx3fd9/image.png" alt="image" border="0"></a>

Пример

<a href="https://ibb.co/Jyg3qSk"><img src="https://i.ibb.co/P90DMVC/image.png" alt="image" border="0"></a>

Однако результат декартового произведения $r_2\times s$ может не совпадать с точности с $r_1$


### Примеры запросов на языке реляционной алгебры

<a href="https://ibb.co/fYXxwfH"><img src="https://i.ibb.co/TBwg36t/image.png" alt="image" border="0"></a>

**Получить имена поставщиков S, поставляющих только деталь P с номером P1**

Из отношения SP можно получить коды поставщиков, которые поставляют нужные детали. Чтобы получить имена поставщиков, надо результат соединить с таблицей S и из неё вытащить атрибут имя поставщика.

$$\pi_{SN}(\sigma_{Pid="P1"}(S\Join SP))-\pi_{SN}(\sigma_{Pid\neq 'P1'}(S\Join SP))$$

Мы используем отношение SP, но поскольку надо использовать имя поставщика, мы сразу выполняем соединение таблиц S и SP. Результат этого соединения будет содержать в себе все атрибуты из таблицы S, а значит, и имя поставщика. При этом, когда мы получаем соединение $S\Join SP$, в таблице S будет информация обо всех поставках, а нам нужно получить тех поставщиков, которые поставляют только деталь с номером P1. Поэтому в первом случае производится соединение $S\Join SP$, и из всех полученных кортежей результата выбираются строки, в которых код детали равен P1 $\sigma_{Pid="P1"}$. Но нам нужны поставщики, которые поставляют **только** эту деталь, нас не интересуют поставщики, которые кроме P1 поставляют что-то ещё. Поэтому вторым действием мы находим поставщиков, которые находят и другие детали, кроме P1 $\sigma_{Pid\neq"P1"}$. Из каждого полученного результата с помощью проекции $\pi_{SN}$ получаем имена поставщиков. Первая проекция вернёт имена поставщиков, которые в том числе поставляют деталь P1, а вторая -- имена поставщиков, которые доставляют что-то кроме P1. Если из первого результата вычесть второй, то мы исключим тех поставщиков, которые поставляют что-то кроме P1.

**Получить имена поставщиков, которые поставляют все детали**

Это значит, что если у нас есть три детали, например, P1, P2 и P3, то если поставщик поставляет все детали, то в таблице SP с его номером должны быть строки и с P1, и с P2, и с P3. Это как раз и обеспечивает операция деления.

$$\pi_{SN}((\pi_{\text{Sid, Pid}}(SP)\div\pi_{Pid}(P))\Join S)$$С помощью $\pi_{\text{Sid, Pid}}(SP)$ мы получаем проекцию, которая включает в себя только код поставщика и номер детали, и эту проекцию мы делим на проекцию таблицы P по атрибуту номер детали. В результате мы найдём коды поставщиков, которые поставляют все детали, а нам нужно найти их имена. Их имена находятся в таблице S, поэтому мы результат деления соединяем с таблицей S и выполняем операцию проекции, получая имена поставщиков.

**Получить номера поставщиков, поставляющих максимальное количество деталей**

В языке реляционной алгебры нет возможности получать максимум и минимум. Поскольку мы ограничиваемся только номерами поставщиков, нам хватит только таблицы SP. В таблице SP указаны номера поставщиков, коды деталей и количество.

$$\rm \pi_{\rm Sid}((\pi_{\rm QTY}(SP)-\pi_{QTY}(\pi_{QTY}(SP)\underset{QTY<Q}{\Join}\pi_{QTY\space as\space Q}(SP)))\Join SP)$$

Мы берём проекцию таблицы SP по атрибуту количество товаров $\rm \pi_{QTY}(SP)$, второй атрибут -- тоже проекция таблицы SP по атрибуту количества товаров, но поскольку в операции соединения по условию два операнда должны иметь разные схемы отношений, то здесь используется переименование атрибута QTY в Q. В соединении по условию выбираются те строки, в которых количество товара из первого операнда меньше, чем количество товаров из второго операнда. В результате останутся две колонки с именами QTY и Q, при этом значение колонки QTY в каждом кортеже будет меньше значения Q. Теперь, если мы возьмём проекцию от результата по атрибуту QTY, мы получим значения количеств поставки товаров, для которых в таблице SP обязательно есть большее значение -- то есть это все те значения, которые не являются максимальными. Если потом из проекции $\pi_{\rm QTY}(SP)$ (все количества товаров) вычесть те количества товаров, для которых есть большее значение, то в результате операции вычитания останется только одноколоночный результат, в котором в качестве QTY будет указано то значение в таблице поставок, для которого нет значения большего его -- то есть по сути максимальное количество поставленного товара. Этот результат соединяем с SP, получая все остальные значения атрибутов, и берём проекцию по коду поставщика.

### Заключение

1. Выражение реляционной алгебра позволяет указать, **как** получить результат
2. Операнды и результат -- отношения (схема + реализация)
3. Теоретико-множественные операции
4. Совместимость по объединению
5. Специальные операции
6. Операция переименования

# 6. Реляционное исчисление

Это второй подход к разработке языков манипулирования данными в РМД.

## Общая характеристика

Поскольку и реляционная алгебра, и реляционное исчисление используются для того, чтобы организовать запрос к базе данных, ответом на которые должны быть какие-то данные, извлечённые и прочитанные из текущей реализации БД, в реляционном исчислении в качестве такого **запроса** используется формула некоторой формально-логической теории. В реляционной алгебре тоже использовалась формула; но если в реляционной алгебре формула показывает, *как* надо проводить вычисления, чтобы получить желаемый результат, то запрос на языке реляционного исчисления описывает *свойства* желаемого результата -- то есть что мы должны получить, но не показывает, *как* это сделать.

В качестве **ответа** на этот запрос выступает множество объектов из области интерпретации, на котором истинна формула, соответствующая запросу.

В качестве *формально-логической теории* используется **теория исчисления предикатов первого порядка**, в которой формула задаётся в виде **предиката**. В качестве *области интерпретации* рассматривается соответствующее состояние базы данных -- её текущая реализация.

### Понятие предиката

Пусть нам дана некоторая совокупность множеств $$S_1, S_2, \dots, S_n: S_i\cap S_j=\emptyset,$$и определена некоторая совокупность переменных, где каждая переменная принадлежит соответствующему множеству $$x_1, x_2, \dots, x_n: x_i\in S_i, i=\overline{1, n}$$Тогда **предикатом** называется формула $P(x_1, x_2, \dots, x_n)$, которая в результате вычисления возвращает либо значение 0, что определяется как ложь, либо значение 1, что определяется как истина: $$P(x_1, x_2, \dots, x_n)\to\begin{cases}0 \\1\end{cases}$$Эти переменные $x_1, \dots, x_n$ называются **предикатными переменными**, а совокупность множеств $S_1, \dots, S_n$, на которых определены предикатные переменные, называется **областью интерпретации предиката**.

Поскольку предикат -- по сути логическая формула, в его записи используются логические операции. 
- $\land, \vee, \neg$, которые вычисляются с учётом их обычных приоритетов
- кванторы $\forall (\forall x :f(x)), \exists(\exists x: f(x))$

Эти два квантора имеют одинаковые приоритеты и для них имеет место эквивалентность: $$\forall x (f(x))\equiv\neg\exists x(\neg f(x))$$Как правило, стандарт SQL поддерживает только квантор существования. Поэтому если нужно записать выражение, использующее квантор всеобщности, надо пользоваться вышеприведенной эквивалентностью.

#### Пример

- $S$ -- множество студентов "учебная группа"
- $f_1(t)$ = "$t$ получает стипендию", $t\in S$
- $f_2(t)$ = "$t$ не имеет задолженностей в сессию", $t\in S$

Если у нас есть два утверждения $f_1$ и $f_2$,  то мы можем записать следующие предикаты:
1. $\exists x(x\in S\land f_1(x))$: в группе есть хотя бы один студент, который получает стипендию
2. $\forall x(x\in S \land f_2(x))$: все студенты группы не имеют задолженностей в сессию

В случае с базами данных предикатные переменные будут определены на отношениях, и каждой такой переменной будет соответствовать схема отношения. 

Поскольку здесь в записи предиката используются кванторы, то они влияют на характеристику **вхождения переменных**:  

### Вхождение переменных

Если у нас есть предикат $\psi(t)$, то в этом предикате вхождение или способ использования переменной $t$ в формуле $\psi$ будет
- **связанным**, если этой переменной предшествует какой-то квантор: $\forall t (\psi(t)), \exists t(\psi(t))$
- **свободным**, если перед использованием переменной никакой квантор не указан

Эти два способа вхождения переменных очень важны с точки зрения формирования результата запроса на реляционном исчислении.

#### Пример 1

$$\forall x(R(x, y) \vee \exists y(U(x, y, z)\land Q(x, y)))$$В этом предикате есть кванторы, а значит, они связывают вхождения переменных. Первый квантор $\forall$ связывает вхождение переменной $x$: следовательно, все упоминания переменной $x$ внутри предиката связаны с этим квантором всеобщности, а раз они связаны, то они за пределами данного предиката *не видны*, то есть они *локализованы* и используются только внутри данного предиката.

Первое вхождение переменной $y$ является свободным, потому что ему не предшествует никакой квантор. Зато последующие -- второе и третье вхождения этой переменной, связаны квантором существования $\exists$.

Наконец, переменная $z$ не упоминается ни в каком кванторе, а значит, она имеет свободное вхождение. Эти переменные существуют и видны за пределами данного предиката.

Этот способ определения вхождения переменных в какой-то степени аналогичен определению функций в ЯП: например, если внутри тела функции мы объявляем какие-то локальные переменные, то они существуют только внутри этой функции и за пределами функции они не видны -- это как раз аналогично связанному вхождению переменных в предикате. Если же у нас есть внешние переменные, которые определены за пределами функции, то они сопоставимы со свободным вхождением переменных в предикатную функцию.

#### Пример 2

Пусть нам надо множество десятичных цифр $$D=\{0, 1, 2, 3, 4, 5, 6, 7, 8, 9\}$$

Мы хотим из этого множества десятичных цифр выбрать подмножество, состоящее из чётных цифр. Для этой цели надо написать предикат $\psi$ , который зависит от переменной $y$, которая должна существовать за пределами предиката ⇒ она не должна быть связана никаким квантором. Но для выбора соответствующих значений мы используем квантор существования: $$\psi(y)=\exists x(x\in D\land x \div 2 = 0\land y = x)$$Результатом будет множество $S=\{y\}$ таких, для которых $\psi(y)$ истинно.

Когда мы используем квантор существования, мы так или иначе определяем переменную, которая определена на каком-то множестве. Поэтому часто пользуются таким сокращением, указывая в скобках после объявления переменной то множество, на котором эта переменная определена: $$\psi(y)=\exists x(D)(x\div 2 = 0 \land y=x)$$

Этот квантор предполагает, что для каждого конкретного значения $y$ вычисляется предикатная формула, в которой переменная $x$ пробегает все значения. Фактически, любой квантор предполагает циклическое вычисление предикатной формулы для каждого значения переменной из области её интерпретации. Это как раз и позволяет использовать предикаты для формирования запросов: если предикатная переменная определена на каком-то отношении, то есть  на таблице, то при вычислении запросов будут просмотрены все кортежи данной таблицы, и если для каких-то кортежей предикат возвращает значение истина, значит, соответствующие кортежи войдут в результат запроса.

### Области значений и видимости переменных

1. В предикате используются и свободные, и связанные переменные
2. Если для какого-то определенного набора **свободных** переменных при вычислении предикатной формулы получено значение "истина", значит, этот <u>набор значений свободных переменных войдёт в результат</u>, определяемый предикатом
3. Если вхождение переменной в формулу **связано** квантором, такая переменная *не видна* за пределами формулы, связавшей эту переменную. При вычислении значения данной формулы используются <u>все</u> значения из области определения данной переменной.

### Связь предиката с базой данных

Область интерпретации предиката -- **база данных**.

Предикат $P(x_1, x_2, \dots, x_n)$ использует $n$ предикатных переменных. 

Если нам дано какое-то отношение $r(R)$ (отношение $r$ со своей схемой $R$) и схема отношения $R(A_1: D_1, \dots, A_n: D_n)$ включает использование $n$ атрибутов, каждый из которых определен на каком-то домене, то если мы рассматриваем в реализации такого отношения совокупность кортежей $\lang a_1: A_1, a_2: A_2, \dots, a_n: A_n\rang$, то

1. Если $P(a_1, a_2, \dots, a_n) = 1$, то $\lang a_1, a_2, \dots, a_n\rang\in r$: если предикат для данного набора значений переменных принимает значение 1, то кортеж из этого набора значений принадлежит соответствующей реализации отношения, то есть он действительно существует в какой-то таблице
2. Если $P(a_1, a_2, \dots, a_n) = 0$, то $\lang a_1, a_2, \dots, a_n\rang\not\in r$: если предикат возвращает ложь, то это означает, что кортеж не принадлежит данному отношению.

## Реляционное исчисление с переменными-кортежами

1. Область определения предикатных переменных -- отношения
2. Переменные кортежи должны удовлетворять определённой схеме отношения $R$, коль скоро эти переменные принадлежат какому-то отношению. Таким образом, рассматривать переменные-кортежи вне схемы отношения невозможно.
3. Предикат -- это *правильно построенная формула (wff -- well formulated formula)* $\psi(t)$. Выбираются те кортежи $t$, для которых $\psi(t)$ даёт значение 1

### Атомы wff

**Правильно построенная формула** -- некоторая формула, в которой используются операнды, объединённые знаками операций. В реляционном исчислении при построении wff в качестве операндов рассматриваются **атомы**.

Пусть нам даны:
- $R$ -- схема отношения
- $r(R)$ -- реализация отношения, удовлетворяющая схеме $R$
- $t(R)$, $u(R)$, $v(R)$ -- переменные-кортежи (используются строчные буквы)
- $A\sub R, B\sub R$ -- атрибуты (используются заглавные буквы)
- $\theta\in\{<, =, >, \geq, \neq, \leq\}$ -- операция отношения

Используя вышеприведённые обозначения, рассмотрим, как строится атом
1. $r(t)$ -- первый атом. Он утверждает, что кортежная переменная $t$ принадлежит данной реализации отношения $r$. Атомы, раз они используются в записи предиката, возвращают значение 0 или 1
2. $u[A]\space\theta\space v[B]$. Здесь используются две кортежные переменные $u$ и $v$, которые могут удовлетворять разным схемам отношения; но в схеме отношения, на которой определена переменная $u$, есть атрибут $A$; а в схеме отношения, на которой определена переменная $v$, есть атрибут $B$. Тогда запись вида $u[A]$ означает, что в данной кортежной переменной $u$ рассматривается атрибут с именем $A$. Если атрибуты $A$ и $B$ определены на доменах, **совместимых по операции $\theta$**, то мы можем сравнивать значения кортежных переменных по этим атрибутам. 
3. $u[A]\space\theta\space c\space(c\space\theta'\space u[A])$: в качестве одного из операндов может быть использовано не значение переменной по атрибуту, а некоторая константа, причём где она записана -- в качестве первого или второго операнда -- роли не играет. Важно только то, что атрибут $A$ должен быть определен на домене, **совместимым по операции $\theta$** с тем доменом, из которого берутся значения константы $c$.

### Правила построения wff

1. Каждый атом является правильно построенной формулой. При этом если в атоме есть кортежные переменные, то эти кортежные переменные имеют свободное вхождение.
2. Если у нас есть предикат $\psi(x)$, который представляет собой wff, в которой вхождение $x$ свободно, то конструкция вида $$\exists x(R)(\psi(x))$$ также представляет собой wff, в которой вхождение переменной $x$ уже связано квантором. Например, предикат $\exists x(R)(r(x))$ утверждает, что реализация отношения $r$ не пуста.
3. Аналогично второму правилу, тольно вместо $\exists$ используется $\forall$. Например, $\forall x(R) (x[A]\neq\empty)$ утверждает, что для атрибута $A$ определено ограничение `NOT NULL`.
4. Если у нас определены правильно построенные формулы $\psi(x)$ и $\varphi(x)$, в которых вхождение переменной $x$ может быть как свободным, так и связанным, то в результате использования логических операций над этими формулами тоже получаются wff, в которой вхождение переменной $x$ сохраняется таким, каким было.
5. Если $\psi(x)$ -- wff, в которой вхождение переменной $x$ либо свободное, либо связанное, то если заключить её в круглые скобки $(\psi(x))$ мы получим точно такую же формулу. Это правило позволяет при необходимости, используя скобки, изменять порядок вычисления квантора.
6. Обычно ещё добавляется шестое правило: "ничто иное не является правильно построенной формулой". То есть в правильно построенной формуле могут использоваться только атомы, кванторы, логические операции и скобки.

### Порядок вычислений
1. Атомы, в которых могут быть использованы арифметические операции сравнения
2. Другие атомы
3. Кванторы. Сами кванторы равноприоритетны и порядок их записи не влияет на результат вычисления: $$\exists x(\forall y(\psi(x, y))\equiv\forall y(\exists x(\psi(x, y))\equiv\exists x\forall y (\psi(x, y))$$ Это позволяет записывать формулы с кванторами без круглых скобок.
4. Отрицание
5. И
6. ИЛИ

Скобки используются для изменения порядка вычисления формулы

### Выражение реляционного исчисления

Выражение реляционного исчисления с переменными кортежами имеет вид $$\{t(R) | \psi(t)\}$$То есть это множество кортежей $t(R)$, удовлетворяющих схеме $R$ и для которых правильно построенная формула $\psi(t)$ возвращает значение истина. При этом в этой формуле $t$ -- это единственная переменная, имеющая свободное вхождение в формулу, и именно эта переменная определяет значение данного выражения. Если в записи данной формулы используются другие переменные, то все они должны быть связаны какими-то кванторами.

#### Пример

Есть отношение $r$ со схемой R<i>(Имя, Стипендия)</i>. 

Атрибут *Стипендия* определен на домене D = {"да", "нет"}.

Имена всех студентов, получающих стипендию:
$$\{t(Имя)|\exists x(R) (r(x)\land x[Стипендия]=да\land x[Имя]=t[Имя])\}$$Это множество кортежей $t$, удовлетворяющих одноатрибутной схеме, то есть содержащих только имя; а далее указывается предикат -- то есть записывается правильно построенная формула. Поскольку имена студентов надо брать из существующего отношения в базе данных, то здесь используется квантор существования $\exists$: "найдётся хотя бы одна переменная $x$" (здесь вводится новая переменная, связанная квантором существования), удовлетворяющая схеме $R$ и принадлежащая данной реализации отношения $r(x)$, у которой значение по атрибуту *Стипендия* -- "да", а значение по атрибуту *Имя* определяет результат данного запроса (дополнительное сравнение x[Имя] = t[Имя], в котором участвуют атрибуты переменных, которые определены как результат выполнения запроса).

При вычислении, если атрибут *Имя* определён на каком-то домене, а домен имеет ограниченное множество значений, то из этого домена выбираются последовательно все значения, и эти значения подставляются в правильно построенную формулу в качестве t[Имя]. И если найдётся запись с соответствующим значением атрибута *Имя*, и у этой записи атрибут *Стипендия* будет иметь значение "да", то этот кортеж определяет результат, и имя студента мы получим в качестве результата вычисления данного выражения.

### Безопасные выражения

Рассмотрим такое выражение реляционного исчисления: $$\{t | \neg r(t)\}$$Это множество кортежей $t$, которые *не* принадлежат реализации данного отношения $r$. Однако реализация отношения имеет конечное ограниченное множество кортежей, следовательно, можно построить неограниченное множество кортежей, которые не принадлежат данной реализации отношения. В общем случае такое  выражение возвращает неограниченное множество кортежей, а в РМД обязательное условие при написании запросов -- получение **ограниченного множества**.

Поэтому данное выражение с точки зрения РМД является **небезопасным**, и такого типа запросы нельзя использовать на практике.

**Безопасные** выражения вида $\{t \space| \space\psi(t)\}$ гарантированно дают ограниченное количество кортежей. Поэтому для того, чтобы гарантировать безопасность выражений и ограниченность возвращаемого множества, обычно значения атрибутов кортежа $t$ -- то есть тех кортежных переменных, которые определяют результат выражения, берутся из **некоторого ограниченного универсального множества $\rm DOM(\psi)$**, которое для каждого выражения $\psi$ определяется по своему.

**DOM($\psi$)** -- унарное отношение, элементами которого являются символы, которые либо явно появляются в $\psi$, либо служат компонентами какого-либо кортежа в некотором отношении $R$, упоминаемом в $\psi$. 

То есть если в нашей формуле упоминается какое-то отношение, а в отношении много кортежей, и в каждом кортеже значения атрибутов определены на каких-то доменах -- а доменах представляют собой ограниченное множество значений, то в универсальное множество DOM записываются все значения этих доменов, и получается тоже ограниченное множество. Если в правильно построенной формуле используются какие-то константы, то эти константы также записываются во множество DOM. В результате множество DOM ограничено, и при формировании результата вычисления выражения переменные $t$ строятся на основании тех значений, которые выбираются из DOM. Раз DOM ограничено, то и множество возможных значений $t$ тоже ограничено. Каждое возможное $t$ подставляется в формулу, и если значение формулы истинно, то оно записывается в соответствующий результат. Но поскольку $t$ берётся из ограниченного множества, то результат вычисления тоже будет ограниченным множеством.

## Эквивалентность выражений

Два математических аппарата, которые используются в манипуляционной части РМД -- реляционная алгебра и реляционное исчисление, могут давать эквивалентные выражения. Если $E$  -- выражение реляционной алгебры, то существует эквивалентное ему безопасное выражение реляционного исчисления с переменными-кортежами. Порядок перечисления кортежей в результате, однако, может быть разным, но важно, что все кортежи будут одними и теми же.

#### Примеры

Например, для проекции $\pi_L(R), r(R), L\subseteq R$ эквивалентное ему выражение выглядит так $$\{t(L)|\exists u(R)\left(r(u)\land u[L]=t[L]\right)\}$$Результат -- множество кортежей, удовлетворяющих схеме $L$. Строится он так: найдётся хотя бы одна кортежная переменная $u$, удовлетворяющая схеме $R$ и принадлежащая реализации $r$, для которой значение переменной $u$ по списку атрибутов $L$ определяет результат вычисления выражения.

Или, что то же самое: $$\{t(L)|\exists u(R) (u[L]=t[L])\}$$То есть можно объединить два условия "удовлетворяет схеме" и "принадлежит реализации отношения".

**На экзамене может возникнуть задание написать выражение реляционной алгебры и эквивалентное ему выражение реляционного исчисления.** Здесь приведён пример для эквивалентности операции проекции. Аналогично можно увидеть эквивалентности и для всех других операций реляционной алгебры, кроме операции деления.

### Деление

$r_1\div r_2, r_1(AB), r_2(B)$  эквивалентно $$\{t(A)|\forall x(B)(\exists y(AB) (r_1(y)\land r_2(x)\land y[B]=x[B]\land y[A]=t[A])\}$$Результатом является множество кортежей, удовлетворяющих схеме $A$, таких, что для всех кортежей $x$ из реализации отношения $r_2$ найдётся хотя бы один кортеж из реализации отношения $r_1$, такие, что $y$ принадлежит реализации $r_1$, $x$ принадлежит реализации $r_2$, значения переменой $y$ по атрибуту $B$ совпадают со значениями переменной $x$ по атрибуту $B$ (сцепление) и значения переменной $y$  по атрибуту $A$ определяют результат.

Поскольку в SQL есть квантор существования, но нет квантора всеобщности, это выражение можно записать так $$\{t(A)|\neq\exists x(B)\left(\neg\exists y(AB)\left(r_1(y)\land r_2(x)\land y[B]=x[B]\land y[A]=t[A]\right)\right)$$

### Естественное соединение

$r_1\Join r_2, r_1(AB), r_2(BC)$

эквивалентно

$$\{t(ABC) | \exists u(AB) \exists v(BC)(r_1(u)\land r_2(u)\land\\\land u[B]=v[B]\land t[A]=u[A]\land t[B]=u[B] \land t[C]=v[C])\}$$

## Примеры запросов

**1. Получить имена поставщиков, поставляющих деталь с номером Р1**

$$\{t(SN) | \exists u(S)\exists v(SP) (s(u)\land sp(v)\rm \land u[sId]=v[sId]\land v[Pid]=P1\land u[SN=t[SN])\}$$

<a href="https://imgbb.com/"><img src="https://i.ibb.co/Hr7x5ys/image.png" alt="image" border="0"></a>

<a href="https://imgbb.com/"><img src="https://i.ibb.co/qF3pxwC/image.png" alt="image" border="0"></a>

<a href="https://imgbb.com/"><img src="https://i.ibb.co/3yjwBDb/image.png" alt="image" border="0"></a>

<a href="https://imgbb.com/"><img src="https://i.ibb.co/b2gfMfP/image.png" alt="image" border="0"></a>

## Реляционное исчисление с переменными на доменах

Различают две разновидности реляционного исчисления в зависимости от того, как определены предикатные переменные. Если они представляют собой кортежи отношения, то говорят о реляционном исчислении **с переменными-кортежами**, если же предикатные переменные определены на доменах, то рассматривают реляционной исчисление с **переменными на доменах**.

Поскольку здесь опять используется исчисление, то есть мы задаём предикатную формулу, то принципы построения предикатной формулы остаются неизменными -- просто переменные определены по-другому. Поэтому здесь также рассматривается понятие *атомов* с такими же, как и в РИ с переменными-кортежами, типами с точностью до обозначений.
- $r(x_1, x_2, \dots, x_n)$, где $r$ -- отношение, удовлетворяющее схеме $R(A_1, A_2, \dots, A_n)$, и каждое $x_i$ есть константа или переменная на домене, на котором определён $A_i$. Этот атом утверждает, что совокупность значений переменных $x_i$ принадлежит реализации отношения $r$, причём эта совокупность переменных $x_1, \dots, x_n$ представляет собой кортеж, принадлежащий отношению -- то есть значения этих переменных встречаются в одном кортеже или, что эквивалентно, в одной строке таблицы.
- $u\space\theta\space v$, где $u$ и $v$ -- константы или переменные, определённые на доменах, совместимых по операции $\theta$, $\theta$ -- арифметическая операция сравнения $(<, =, >, \geq, \neq, \leq)$. Этот атом возвращает значение ИСТИНА, если для соответствующих значений переменных данное сравнение выполняется.


При построении формулы также рассматривается понятие *правильно построенной формулы*, которое определяется точно так же, как и в реляционном исчислении с переменными-кортежами. Переменные могут иметь свободное вхождение, а могут быть связаны соответствующими кванторами.

Запрос в реляционном исчислении с переменными на доменах формируется с помощью следующего выражения $$\{t_1, t_2, \dots, t_n \space|\space \psi(t_1, t_2, \dots, t_n)\}$$Отличие от реляционного исчисления с переменными-кортежами в том, что здесь в левой части будет не одна переменная, а, возможно, какая-то совокупность переменных. Здесь
- $t_i$ -- переменные, определенные на доменах $D_i$
- $\psi(t_1, t_2, \dots, t_n)$ -- правильно построенная формула
- $t_i$ -- единственные переменные, имеющие свободное вхождение в формулу $\psi(t_1, t_2, \dots, t_n)$. Именно эти переменные, имеющие свободное вхождение, возвращаются в качестве результата запроса.

## Эквивалентность

Для каждого безопасного выражения с переменными кортежами существует эквивалентное безопасное выражение с переменными на доменах.

Это утверждение позволяет определить некоторые правила преобразования.

Пусть дано выражение $\{t(R) \space | \space\psi(t)\}, R = (A_1, \dots, A_n)$ -- выражение исчисления с переменными-кортежами. Тогда эквивалентное ему выражение с переменными на доменах: $$\{t_1, t_2, \dots, t_n\space|\space\psi'(t_1, t_2, \dots, t_n)\}$$ Оно получается достаточно просто -- за счёт того, что одна переменная-кортеж заменяется совокупность переменных на доменах. Количество этих переменных определяется *арностью* схемы отношения -- то есть сколько атрибутов включается в схему отношения.

Все эти преобразования выполняются в соответствии с правилами
1. Переменная-кортеж $t$ заменяется $n$ новыми переменными на доменах $t_1, t_2, \dots, t_n$.
2. $\psi'$ представляет собой $\psi$, в которой
	-  любой атом $r(t)$ заменяется атомом $r(t_1, \dots, t_n)$
	 - каждое свободное вхождение $t[A_j]$ заменено переменной $t_j$
	 - для каждого квантора $\exists u$ или $\forall u$ вводится $m$ новых переменных $u_1, \dots, u_m$, где $m$ -- арность $u$.
3. Кванторы $\exists u$ или $\forall u$ заменяются кванторами $\exists u_1, \exists _2, \dots, \exists u_3$ ($\forall u_1, \forall u_2, \dots, \forall u_3$ соответственно); в подчинённых кванторам выражениях $u[A_j]$ заменяются $u_j$, а $r(u)$ -- $r(u_1, u_2, \dots, u_m)$. 


#### Пример

<a href="https://ibb.co/4FCphzx"><img src="https://i.ibb.co/GdGRzyj/image.png" alt="image" border="0"></a>


## Заключение

Реляционное исчисление:
1. показывает, **что** должно быть получено
2. понятие предиката, кванторы, свободное и связанное вхождение переменных
3. область определения предиката -- база данных
4. понятие атома, правильно построенной функции, выражение реляционного исчисления
5. понятие безопасного вычисления
6. эквивалентность выражений реляционной алгебры и реляционного исчисления

# 7. Язык SQL

Язык, в котором можно (по крайней мере) моделировать исчисление с переменными-кортежами, либо, что равносильно, реляционную алгебру или исчисление с переменными на доменах, называется **полным**.

## Обзор языков манипулирования данными

На ранних порах сразу после создания теории реляционной модели данных стали появляться различные экспериментальные СУБД, которые создавались для проверки возможности реализации теории реляционных баз данных на практике.

- **ISBM: Information System Base Language** -- IBM.
	- Чистый язык реляционной алгебры. Нет агрегатных операций, а также средств для вставки, модификации и удаления кортежей. Первые реализации языков как раз ориентировались на проверку возможности получить *доступ* к данным.
- **SEQUEL (Structured English Query Language)**: IBM, 1974; 1976 -- СУБД System R
	- Использует реляционную алгебру, но имеет синтаксис, схожий с реляционным исчислением с переменными-кортежами. Само название языка подчеркивает, что при записи выражений использовались конструкции на основе естественного английского языка. 
	- В 1976 году на основе переработанного языка SEQUEL корпорация IBM выпустила экспериментальную СУБД System R. Она позволяла проверить осуществимость реляционной модели данных, а кроме того при разработке именно этой СУБД был разработан язык SQL.
- **QUEL** -- конец 70х
	- В основе лежит реляционное исчисление с переменными-кортежами. Этот язык был разработан для СУБД INGRES, которая в дальнейшем переросла в Postgres.
	- Включает в свой состав агрегатные функции
	- Запросы на языке QUEL более структурированы, чем SQL
- **QBE: Query By Example** -- IBM
	- Построен на основе реляционного исчисления с переменными на доменах
	- На экране отображается структура схемы базы данных, и с помощью мышки перетаскиваются значения соответствующих атрибутов для формирования запроса
- **SQL**

## SQL

- В 1986 году был разработан первый вариант стандарта ANSI, в 1987 он был утверждён  (SQL-87 / SQL-1)
- 1992 г -- первая версия стандарта ISO: SQL-92 или SQL-2
- 1999 -- стандарт SQL-1999 (SQL-3); реляционные и объектно-ориентированные свойства (возможность создания новых типов данных), базовые процедурные расширения
- 2003 -- действует в настоящее время


Суть всех этих стандартов в том, что ни одна реальная СУБД не поддерживает стандарт SQL в полном объёме, особенно это касается реализации прикладной логики. Производители СУБД часто предлагают собственные расширения языка SQL, предоставляющие дополнительные возможности, которые касаются, в первую очередь, управлением обработки транзакций.

Поэтому описание стандарта включает в себя несколько уровней стандарта. Если утверждается, что СУБД удовлетворяет стандарту SQL, это не значит, что в ней соблюдается всё, что написано в стандарте: возможно, там на самом деле соблюдаются только какие-то начальные уровни.

Хотя для реализации доступа к данным используется один и тот же стандарт, для реализации расширенной логики, например, процедур, используются диалекты языка, и у каждой СУБД они могут отличаться.

## Предложения SQL

Сам язык SQL включает в себя два подмножества языка: подмножество языка описания данных (DDL) и подмножество языка манипулирования данными (DML).

В DDL включены следующие предложения:

```sql
insert into table_name (column_name, ...) 
	values (value1, ...), (...)
	subquery;

delete from table_name
	where condition

update table_name
	set column1=expr1, ...
	where condition
```

С точки зрения SQL предложения атомарны -- то есть либо выполняются полностью, либо не выполняются вообще. Например, если одна из строк при вставке в `insert into` будет некорректной, не выполнится весь запрос, и не будет вставлена ни одна строка из этого запроса.

### Формирование запросов

В более поздних работах в язык включается третье подмножество языка формирования запросов с помощью предложения `select`

```sql
select [distinct] output
from sources -- table, view or table expr (table-like expressions)
where selection_condition
group by grouping_list -- attributes
	having group_selection_condition
order by ordering_list
```

## Соответствие между ЯМД РМД и SQL

### Теоретико-множественные операции

#### 1. Объединение

$$РА: r_1\cup r_2$$$$РИ: \{ t(R)\space|\space r_1(t)\vee r_2(t)\}$$

```sql
select * from t1	|	select * from r1
union				|	union all -- дубликаты выброшены не будут
select * from r2	|	select * from r2
```

#### 2. Вычитание


$$РА: r_1- r_2$$$$РИ: \{ t(R)\space|\space r_1(t)\land\neg r_2(t)\}$$

```sql
select * from r1	|	select * from r1
except				|	where r1.id not in
select * from r2	|	(select r2.id from r2)
```

#### 3. Пересечение

$$РА: r_1\cap r_2$$$$РИ: \{ t(R)\space|\space r_1(t)\land r_2(t)\}$$

```sql
select * from r1
intersect 
select * from r2;

select r1.*
from r1, r2
where r1.id = r2.id
```

#### 4. Декартово произведение

$$РА: r_1\times r_2$$$$РИ: \{ t(R_1, R_2)\space|\space\exists u(R_1)\exists v(R_2)(r_1(u)\land r_2(v)\land u[R_1]=t[R_1]\land v[R_2]=t[R_2])\}$$

```sql
select * from r1, r2;

select * from r1 cross join r2
```

### Специальные операции
#### 1. Проекция

$$РА: \pi_L(r)$$$$РИ: \{ t(L)\space|\space \exists u(R)(r(u)\land u[L]=t[L])\}$$

```sql
select L from r
```

#### 2. Выбор (селекция)

$$РА: \sigma_F(r)$$$$РИ: \{ t(R)\space|\space \exists u(R)(r(u)\land F)\}$$

```sql
select * from r where F
```

#### 3. Естественное соединение

$$РА: r_1\Join r_2$$

<a href="https://ibb.co/3T8kXRF"><img src="https://i.ibb.co/Bf7wDn6/image.png" alt="image" border="0"></a>

```sql
-- ошибки: references a, b, c are ambigious
select a, b, c
from r1 [inner] join r2
	on r1.b = r2.b;

select a, b, c
from r1, r2
where r1.b = r2.b;

select a, b, c
from r1 left [outer] join r2
	on r1.b = r2.b
```

#### 4. Деление

$$РА: r_1\div r_2$$

<a href="https://ibb.co/qnjQgCN"><img src="https://i.ibb.co/DbW2MY9/image.png" alt="image" border="0"></a>

```sql
select a from r1 t
where not exists(
	select null from r2 v
	where not exists(
		select null from r1 u
		where u.b = v.b and u.a = t.a
	)
)
```

## Агрегатные функции

```sql
sum([distinct] column_name)
max([distinct] column_name)
min([distinct] column_name)
avg([distinct] column_name)
count([distinct] column_name)
count(*)
```

В РМД нет возможности выполнять арифметические вычисления. Максимум, что позволяет модель -- выполнять операции сравнения (например, в атоме сравниваются значения отдельных колонок в кортеже). Но в реальных СУБД ЯМД включает в свой состав расширения, которые позволяет реализовать сложные и нестандартные запросы: например, агрегатные функции.

В общем случае результатом выполнения запроса является множество кортежей отношения, применительно к БД это множество строк таблицы. Порядок вывода никак не определяется, но в ЯМД есть возможность эти сроки переупорядочивать с помощью группирования. И для полученных групп уже можно выполнять более слоные вычисления с помощью агрегатных функций.

Если в группе в какой-то строчке значение колонки отсутствует, то есть `NULL`, то, как правило, результатом выполнения агрегатной функции тоже будет `NULL`, а для фукнции `count` -- 0.

### Использование агрегатных функций

**1. Для всех поставщиков получить отчёт в виде SN | Total QTY**
```sql
select SN, coalesce(sum(QTY), 0) as "Total QTY"
from S
left outer join SP on S.Sid = SP.Sid
group by SN

-- coalesce вместо null отдаёт последующий аргумент до тех пор пока не получим непустое значение 
```

**2. Для поставщиков, поставляющих более одной разновидности товара, получить отчет в виде SN | Total QTY | Number of products**

```sql
select 
	SN, 
	sum(QTY) as "Total QTY",
	count(Pid) as "Number of Products"
from S 
join SP on S.Sid = SP.Sid
group by SN
having count(Pid) > 1
```

Простое правило: если в `select` стоит хотя бы один атрибут за пределами агрегатных функций, нужно обязательно по нему группировать.

**3. Получить имена поставщиков, поставляющих все детали**

```sql
select SN
from S
join SP on S.Sid = SP.Sid
group by SN
having count(Pid) = (select count(Pid) from P)
```

**4. Для поставщиков, поставляющих максимальное количество товара, получить ответ в виде SN | QTY**

```sql
select SN, Qty
from S join SP on S.Sid = SP.id
where Qty = (select max(Qty) from SP) -- скалярный подзапрос, возвращает единственное значение
```

**5. Для поставщиков, поставляющих максимальное суммарное количество товара, получить отчет в виде SN | Total QTY**

В агрегатных функциях в качестве аргумента не может быть использована другая агрегатная функция. Там могут быть только имена колонок и скалярные выражения.

Поэтому сначала надо сформировать суммарное количество товара для всех поставщиков, как бы сохранить полученный результат и уже из этого результата вытаскивать максимальное суммарное количество.

Это можно сделать с помощью представления (view). View -- это объект, который по всем своим характеритикам аналогичен таблицам за одним исключением -- если таблица реально сохранятеся в базе данных и имеет связанные с ней значения, то view в объектах базы данных реально не сохраняется, а его значения формируются только тогда, когда к нему происходит обращение. Как только запрос, инициировавший обращение к view, завершается, view и все его результаты удаляются из ОП.

В базе данных представление хранится в виде текста соответствующего запроса.
```sql
-- создание view
create view v1(Sid, Qty) as
	select Sid, sum(Qty) from SP
	group by Sid;

select SN, Qty as "Total QTY"
from S
join V1 on S.Sid = V1.Sid
where Qty = (select max(Qty) from V1);

drop view v1; -- удалить view из системных словарей
```

Вместо view можно просто писать сам запрос, но поскольку к нему надо будет ещё обращаться, этому запросу надо будет указывать имя:

```sql
select SN, Q1 as "Total QTY"
from S join
	(select Sid, sum(Qty) Q1 from SP group by Sid) V1 
	on S.Sid = V1.Sid
where Q1 = (select max(Q2) from
	(select Sid, sum(Qty) Q2 from SP group by Sid) V1
	)
```
Кроме того, можно использовать *табличные выражения*:

```sql
with V1(Sid, Qty) as (select Sid, sum(Qty) from SP group by Sid)
select SN, Qty as "Total QTY"
from S join V1 on S.Sid = V1.Sid
where Qty = (select max(Qty) from v1)
```

У нас не создаётся никакой дополнительный объект базы данных, поэтому ничего в словаре БД не хранится память лишняя не тратится, а табличное выражение связывается с тем запросом, в котором оно используется, и когда запрос завершился, табличное выражение уничтожается ⇒ не нужны конструкции типа `drop view`

Результатом табличного выражения является таблица. Таблица должна иметь име и список имён колонок.

# 8. Разработка приложений

## Архитектура клиент-сервер

**Клиент-сервер** -- это модели взаимодействия компьютеров в ести.

**Сервер** -- компьютер (или программный продукт), управляющий тем или иным ресурсом

**Клиент** -- компьютер (или программный продукт), желающий воспользоваться тем или иным ресурсом

Системы СУБД состоит из двух частей: сервера базы данных и клиента (или внешний интерфейс)


### Функции информационной системы

- функции ввода и отображения данных
- прикладные функции, характерные для данной предметной области
- фундаментальные функции организации хранения информации и управления информационными ресурсами
- служебные функции, играющие роль связок между функциями первых трех групп

### Структура интерактивного приложения

<a href="https://ibb.co/Z26GBQd"><img src="https://i.ibb.co/HhDBtc7/image.png" alt="image" border="0"></a>

Информационные системы отличаются друг от друга именно по **прикладному** компоненту, который реализует бизнес-логику.

Компонент доступа к данным реализует СУБД.

Раз структура приложения предполагает три компонента, а архитектура клиент-сервер -- двухзвенная, то есть несколько разных способов отображать три компонента в два звена.

### Модель сервера базы данных

Поддерживает традиционную двухзвенную архитектуру клиент-сервер

<a href="https://ibb.co/4SYFJxh"><img src="https://i.ibb.co/Smd6JpF/image.png" alt="image" border="0"></a>

В такой системе прикладной компонент, размещённый на сервере базы данных, реализуется на SQL. Однако такой подход не очень удобен, потому что расширения SQL, превращающие его в полноценный язык программирования, не стандартизованы, сложны и в каждой СУБД реализуется по своему, а кроме того, СУБД обычно не включает в себя удобные средства для отладки написанных на SQL прикладных компонентов. 

Поэтому сегодня чаще рассматривают не двух-, а трёхзвенные архитектуры, где отдельно рассматриваются компонент представления, отдельно прикладной компонент (**сервер приложений**) и отдельно компонент доступа к данным (СУБД). Это позволяет реализовывать бизнес-логику не на SQL, а на нормальных алгоритмических языках. Все современные СУБД позволяют писать процедуры на алгоритмических ЯП.

## Прикладной компонент SQL

Обычно включает в себя два вида процедур:
- триггеры
	- проверка дополнительных ограничений
	- формирование значений вычисляемых колонок: есть рекомендация "то, что можно вычислить, хранить не надо": если приходится формировать вычисляемые значения колонок, то система работает медленнее при любом запросе, а если формируется отчёт, то пользователь морально готов к задержкам
- хранимые процедуры
	- реализует какую-то конкретную операцию бизнес-логики

Пишутся на диалекте SQL для написания бизнес-логики (напр. pgplsql)

### Триггеры

**Триггер** -- особый вид хранимой процедуры; связан с конкретной таблицей и конкретным предложением SQL -- `INSERT`, `DELETE` или `UPDATE`.

Триггер срабатывает каждый раз, когда выполняется соответствующее предложение для связанной с триггером таблицы.

У триггеров не может быть ни параметров, ни возвращаемых значений.

Явно вызвать триггер невозможно.

Также возможно приведение данных с помощью стандартной функции `cast`:

```sql
cast(тип as строковый_тип)
```

### Хранимые процедуры

Реализация отношения в БД представляет собой *result set*, а в процедурах может понадобиться обрабатывать каждую его конкретную строку -- это можно сделать с помощью курсоров.

**Курсоры** обеспечивают последовательный доступ к отдельным строкам результата некоторого запроса
- объявление курсора и связь с каким-то запросом
- открытие курсора и выполнение связанного запроса, который возвращает result set
- позиционирование курсора на ту строку result set, с которой мы хотим работать
- закрытие курсора и освобождение ресурсов, с ним связанных
- уничтожение курсора

При открытии курсор позиционируется **перед** первой строкой result set.

<!--stackedit_data:
eyJoaXN0b3J5IjpbLTIxMzk5NTk0MjksMTQ5NzA5ODkzNSwxMD
A0Njc5MjQ1LDU1NzU4NzkzNSwtMTEwNDgwNjk2NCwtMTA5NjI2
Nzc3NiwxOTk5NjQxMDk0LDE5MjAzMTcxMjksMTc0MTY3ODUzOS
wtNjUyOTI0MDc3LC0xMjY2NTA2NjQxLC0xOTE2ODIwNTk4LDU4
MDQ5MjI4LC0xNDM1ODE5NDMwLC02ODEyMDU5NTQsMTg5MDczMj
IyOCwtMTQ2Mzk4Nzg0NCwtMTI1MDA3MjYxLC0zNjY5NjM1ODYs
NDQ2NDczMzA4XX0=
-->