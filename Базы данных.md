## Содержание курса

| Этапы жизненного цикла | Используемые средства
|--|--|
Проектирование | Модели данных, модель "сущность-связь"
Разработка | Реляционная модель данных
Реализация | Язык SQL конкретной СУБД; внутренние структуры хранения



В этом семестре мы будем проектировать базу данных как часть некоторой информационной системы. Обычно информационные системы создаются для решения задач, специфических для предметной области; они используются для поддержки текущей деятельности предприятия, а поскольку для этого требуется хранить большие объёмы информации, то если раньше она хранилась в бумажном виде, сейчас это, конечно же, неудобно, и она сохраняется в электронном виде на машинах.

Если посмотреть на историю вычислительной техники, то первые вычислительные машины были построены в конце 40-ых - начале 50-ых годов прошлого века, и получили название **вычислительные**, потому что они изначально разрабатывались для организации и автоматизации вычислительных работ: необходимо было обрабатывать большие объёмы данных, получаемых в результате физических экспериментов.

Но поскольку в состав вычислительной системы входят в том числе и средства, позволяющие надёжное и долговременное хранение данных, то такие вычислительные системы почти сразу же стали активно использоваться для разработки **информационных систем**, целью которых является накопление, обработка и долговременное хранение больших объёмов информации. Естественно, центральной частью таких ИС стали системы хранения данных. Первые варианты таких СХД получили название **базы данных**.

ИС, которые были разработаны для поддержки текущей деятельности предприятия, получили название **транзакционных систем** *(OLTP -- OnLine Transaction Processing  --  системы обработки транзакций)*. Это связано с тем, что текущая деятельность предприятия предполагает выполнение большого количества однотипных операций, которые получили название **транзакции**. Соответственно, в этом курсе мы рассматриваем проектирование баз данных, используемых в транзакционных системах.

Применительно к базам данных можно выделить некоторые этапы жизненного цикла -- проектирование, разработка и реализация.

Для описания данных, которые хранятся в БД, используется **информационная модель**, которую на разных этапах жизненного цикла можно описывать разными средствами.

На этапе **проектирования**, когда мы разрабатываем саму информационную модель, ориентируясь на предметную область, обычно используются **модели данных**, которые явились развитием модели "сущность-связь" (ER), которая удобна тем, что она имеет свой диаграммный язык, с помощью которого эту модель легко представить, и она понятна. 

Здесь стоит отметить, что разработчик ИС, как правило, не является конечным её пользователем. Если он является специалистом в области IT, то конечный пользователь таковым специалистом не является, зато он хорошо погружён в предметную область, в отличие от разработчика. Поэтому на этапе проектирования разработчик должен представить информационную модель в виде, который может понять пользователь, и учесть все их пожелания.

Сегодня на этапе проектирования мы используем не саму модель данных, а её модификацию -- модель **IDF1X**. Такую диаграмму уже легко перевести на язык реляционной модели данных.

Так как БД предполагают хранение больших объёмов данных на внешней памяти, а для её обработки нужно выгружать данные в ОП, то возникает вопрос производительности таких систем: объёмы данных в ОП очень большие, и как найти то, что нас интересует с тем, чтобы пользователь, формирующий какой-то запрос, не просиживал перед чёрным экраном недопустимо долгое время? Поэтому очень важно понимать, как организуется хранение данные во внешней памяти так, чтобы время отклика системы было приемлемым. Для таких ИС главными требованиями являются два (и они очень часто вступают друг с другом в противоречия):
- обеспечить целостность и достоверность информации
- обеспечить приемлемое время отклика

# 1. Модели данных. Общая характеристика

На разных этапах проектирования и разработки ИС используются разные модели данных, которые, в сущности, описывают одно и то же. Поэтому очень часто в разных моделях данных для обозначения каких-то схожих понятий используются одни и те же термины, но семантика в них может отличаться.

Что такое информация и как она используется? Конкретные ИС предназначены для поддержки текущей деятельности предприятия, которое опирается на какие-то внешние явления. Эти внешние явления, которые представляют интерес для предприятия, должны быть каким-то образом описаны. Для этого обычно используется понятие **данных**, с которыми связаны две характеристики:
- конкретные значения данных, то есть **факты**: 127, 7 февраля, ...
- **семантика** -- интерпретация, смысл значений: вес груза в кг, начало весеннего семестра, ...

При этом важно, что семантика определяет ещё и возможные операции над данными: например, если 12 -- это номер сотрудника, то его нельзя складывать, а можно только сравнивать, и т.д.

Обычно в памяти вычислительных машин мы храним только факты, при этом семантика отрывается от них. Этот отрыв в целом ряде случаев весьма усложняет обработку фактических значений.

Когда используется термин **информация**, то обычно он предполагает соединение фактов и их семантики. Если мы описываем их на естественном языке, это позволяет объединить их, получив "вес перевозимого груза 167 кг". Но для хранения на машине такое использование естественного языка считается невозможным.

Очень часто для удобного представления информации используется табличный способ -- например, расписание занятий, где названия строк  и столбцов задают семантику, а значения на их пересечениях -- факты.

### Файловые системы

Первые разновидности ИС организовывали хранение фактов именно в файлах, а семантику -- в прикладных программах, с помощью которых можно было вытащить конкретные факты из файлов и соответствующим образом обработать. Поэтому доступ к данным в таких системах осуществлялся только через прикладные программы.

**Файловые системы** -- набор программ, выполняющих операции, связанные с обработкой данных. При этом каждая программа, которая включается в такую файловую систему, по сути определяет свои собственные данные и управляется своими собственными данными.

#### Недостатки

Файловые системы обладают существенным рядом недостатков, которые привели к необходимости разработки каких-то других типов ИС.

- разделение и изоляция данных: интерпретация данных осуществляется прикладной программой ⇒
- дублирование данных: одни и те же данные могут дублироваться в разных программах, работающих с одними данными но решающих разные задачи
- зависимость от файлов: прикладные программы обрабатывают файлы с жёстко заданной структурой, и мы не можем перевести программу на обработку файлов другого типа
- несовместимость данных: обычно дата-время представляется либо в виде структуры, либо в виде строки
- фиксированные запросы к данным: в программу жёстко закладываются те запросы, которая она может выполнять

Причина этих недостатков в том, что факты и семантика разделены. 

На смену файловым системам пришли системы баз данных.

### Системы баз данных

**База данных** -- совместно используемый набор логически связанных данных и их описаний, предназначенных для удовлетворения информационных потребностей организации. В таких системах описание данных часто называется **метаданными**.

**СУБД** -- ПО, осуществляющее управление данными

**Система баз данных** - компьютеризованная система хранения записей: база данных, СУБД, аппаратура и люди, которые используют эту информацию


<a href="https://ibb.co/Bw4PtJK"><img src="https://i.ibb.co/CWJtzys/image.png" alt="image" border="0"></a>

**Сервер** владеет каким-то ресурсам и предоставляет соответствующие услуги, а **клиент** ими пользуется.

В **двухзвенной архитектуре** прикладные программы, которые обрабатывают данные, реализованы на стороне клиента. Она обращается к серверу за данными и обрабатывает их в соответствии со своей логикой.

В последнее время чаще всего вместо двухзвенной архитектуры используется **трёхзвенная**:


<a href="https://ibb.co/GWhD6ph"><img src="https://i.ibb.co/9bM0DgM/image.png" alt="image" border="0"></a>

В этом случае есть чистый сервер -- сервер, на котором установлена БД и СУБД, есть чистый клиент, на котором установлены средства для формирования необходимых запросов и отображения результатов их выполнения -- чистый интерфейс пользователя, а для реализации прикладной логики выделяется особый компонент -- **сервер приложений**, который по отношению к серверу БД выполняет роль клиента, а по по отношению к клиенту -- роль сервера.

Такая архитектура удобна, если разные прикладные программы используют более или менее одинаковые прикладные модули обработки данных, то это модули могут бтыь реализованы в виде одной копии на стороне сервера приложений.

Кроме того, на сервере приложений для реализации прикладной логики можно использовать языки высокого уровня, что облегчает их разработку.

Сама СУБД также реализует двухзвенную логику: есть серверная часть, которая отвечает за управление доступа к данным, и есть клиентская часть, которая реализует интерфейс пользователя.


## Категории пользователей

### Администраторы данных и баз данных

**Задачи:**
- обеспечение бесперебойной работы ИС
- поддержание необходимого качества данных

**Требования к СУБД:**
- обеспечение контроля доступа
- надёжность
- высокая производительность
- поддержка больших объёмов хранимой информации
- масштабируемость системы

### Разработчики баз данных

**Задачи**
- проектирование структуры БД
- реализация БД в рамках заданной СУБД

**Требования к СУБД**

- стандартизованные средства создания БД и манипулирования данными

## История развития СУБД

### СУБД первого поколения

- середина 60-х иерархическая СУБД IMS
- сетевая модель IDS (Interpreted Data Store)

Сетевая модель позволяла представлять более сложные связи, чем иерархическая модель.


СУБД, где используется сетевая или иерархическая модели данных, называются **унаследованными**.

Однако в иерархической модели для создания сложных связей будут дублироваться данные.

<a href="https://ibb.co/QJd94zV"><img src="https://i.ibb.co/PrQxd3y/image.png" alt="image" border="0"></a>



## Архитектура ANSI-SPARC

**Внешний уровень (view)** ориентирован на представление БД для конечного пользователя в зависимости от его нужд -- для каждой категории пользователей оно мб разным. Но эти представления могут в чём-то пересекаться, поэтому во избежание дублирования информации они все воедино собираются в **концептуальный** уровень (логическое описание), а **внутренняя схема** уже организует физическое хранение данных в БД.

<a href="https://ibb.co/Hh9L54v"><img src="https://i.ibb.co/SfZDFyT/image.png" alt="image" border="0"></a>

Внутренняя схема объединяет в себе все характеристики каждого из представлений. Поэтому чтобы пользователи получали доступ только к той информации, которая им нужна, эта внутренняя схеме *отображается* во view для каждого конкретного пользователя/группы. Это гарантирует, что каждый пользователь будет иметь доступ только к той информации, которая нужна ему.


Чтобы с этими данными работать, надо концептуальный уровень отобразить на физический -- на организацию хранения данных. Если мы ориентируемся на какой-нибудь ЯП, например, С, то для описания сотрудника создаётся соответствующая структура. Это позволяет, с одной стороны, исключить дублирование информации, а с другой, представлять её удобной для обработки.

Термин **информация** заключается в том, что мы не только храним конкретные *значения* данных, но и их *семантику*.

СХД начинались с создания файловых систем (где факты хранятся отдельно от семантики), им на смену пришли системы БД, которые объединяют факты и семантику.

СУБД строились на основании модели, которая позволяла описывать эти данные. СУБД используют три модели: сетевая и иерархическая (это уже в пролом), и реляционная -- основная на сегодняшний день.

Проектирование таких баз данных осуществляется в соответствии с положениями, принятыми при разработке архитектуры СУБД, определёнными в рамках комитета ANSI/SPARC.



# 2. Модели данных

Поскольку при разработке СУБД и при разработке информационных систем, в основе которых лежат СХД, используются какие-то модели данных -- и мы будем проектировать свою БД в соответствии с реляционной моделью данных, рассмотрим общие положения, касающиеся определения, а что же такое модель данных.

**Модель данных** -- это интегрированный набор понятий для описания **данных**, **связей** между данными и **ограничений**, накладываемых на данные в некоторой организации.

В какой-то степени в качестве аналогии можно привести алгоритмы -- это тоже набор понятий для описания обработки данных. Модель данных позволяет описать данные, которые существуют в реальном мире -- а они обязательно взаимодействуют между собой, поэтому надо описывать и связи.

При этом в разных предметных областях на одни и те же данные могут накладываться разные ограничения, поэтому описание данных, связей и ограничений рассматривается применительно к конкретной предметной области.

<a href="https://ibb.co/B3GzqG1"><img src="https://i.ibb.co/vqhwZht/image.png" alt="image" border="0"></a>

Модели данных принято делить на две категории: **сильно типизированные** и **слабо типизированные**.

В **сильно типизированных** МД все данные, описывающиеся в рамках данной модели, относятся к каким-то конкретным категориям: поскольку мы реально описываем всё, что происходит во внешнем мире, то, наблюдая за этим внешним миром и выявляя общие характеристики объектов и явлений, можно всё, что мы наблюдаем, разделить на какие-то категории. Например, можно использовать типы данных в ЯП -- это по сути такое категории, по отношению к которым мы выбираем объекты, обрабатывающиеся в программах.

В **слабо типизированных** МД распределить данные между какими-то категориями не представляется возможным. Но для того, чтобы можно было рассматривать связи и ограничения, то реальные объекты, явления и элементы из реального мира просто относятся либо к одной категории, либо к другой категории.

## Сильно типизированные модели данных

Большинство моделей данных, используемых в ИС, относятся к сильно типизированным. Это позволяет нам рассматривать все свойства данных, связи между данными, оперируя понятием **категории** -- не рассматривая каждый конкретный экземпляр данных, а рассматривая их общие характеристики.

Поэтому сильно типизированные модели данных делятся на две категории в зависимости от того, как эти категории определяются -

В моделях данных **на основе объектов** данные распределяются между разными объектами. Все элементы, размещаемые в одном объекте (в данном случае объект означает множество), характеризуются общим набором свойств. К таким моделям относятся объектно-ориентированная модель данных, а также семантические модели --в частности, сущность-связь. Однако модель сущность-связь не лежит в основе никакой реальной СУБД, хотя она очень активно используется на этапе проектирования.

Втора группа сильно типизированных МД -- **на основе записей**. Это реляционная модель, сетевая и иерархическая.

В сильно типизированных МД выделяются следующие основные компоненты: **категория** -- обобщённое понятие, с каждой категорией связывается некоторый набор **свойств** категории -- и тогда все экземпляры, которые включаются в ту или иную категорию, обладают одинаковым набором свойств -- но значения свойств, конечно же, могут быть разными. И поскольку модель данных должна отражать **связи** между категориями, они тоже входят в компоненты сильно типизированных моделей данных.

Например, транспортное предприятие в своём составе имеет средства передвижения (автомобиль - первая категория), и водители -- вторая категория. Для категории ВОДИТЕЛЬ определяются свойства имя, возраст, стаж работы, а для категории АВТОМОБИЛЬ -- модель, госномер, дата ТО и так далее. Между этими двумя категориями устанавливаем определённую связь, которую можно сформулировать в виде предложения: "водитель управляет автомобилем". Связь в данном случае -- "управляет" -- глагол.

В конкретном применении модели данных совокупность именованных категорий, их свойств и связей между ними, называется **схемой**. Таким образом, всё, что выделено синим на слайде, -- это схема, позволяющая описать работу транспортного предприятия.

Например:

ВОДИТЕЛЬ (Имя, Возраст, Стаж работы, ...)
АВТОМОБИЛЬ (Модель, ГОсномер, Дата,...)
УПРАВЛЯЕТ (ВОДИТЕЛЬ, АВТОМОБИЛЬ)


**Реализация БД** -- совокупность данных, структура которых соответствует некоторой схеме.

**База данных** -- совокупность реализаций, полученных в результате некоторых преобразований и удовлетворяющих одной и той же схеме.

<a href="https://ibb.co/RgzpMBr"><img src="https://i.ibb.co/Fhgbf0Z/image.png" alt="image" border="0"></a>

Определение БД содержит в себе некоторую связь со временем: конкретная реализация БД соответствует конкретному моменту времени -- это то, что есть сейчас. Но в нашей БД были какие-то реализации в прошлом и будут какие-то реализации в будущем, и все такие реализации -- те, которые были, и те, которые будут -- и называются базой данных.

Поэтому термин БД не означает моментальный снимок данных, хранящихся на машине -- это то, что изменяется во времени.

В зависимости от конкретной предметной области, если для них используется одна и та же МД, мы можем описать и разные схемы: например, можно попытаться описать схему учебного процесса (тогда будут категории группа, предмет, преподаватель и связи между ними).

Каждой конкретной схеме соответствует реализация. Эти реализации могут изменяться за счёт использования каких-то преобразований и операций, и вся эта совокупность реализаций и называется БД, причём она не ограничена: потому что могло быть что-то и до первой реализации, и будет что-то после последней реализации.

Так как мы имем дело с сильно типизированным МИ, мы можем определить схему, и все наши данные будут ей удовлетворять.

Поскольку БД меняется в времени, то когда мы описываем конкретную предметную область, мы сталкиваемся с необходимостью представления **статических** неизменяемых свойств и **динамических** изменяющихся свойств. Например, схема базы данных -- это статическая информация, а реализация отражает динамику.

Поэтому для реализации статических и динамических свойств в сильно типизированных моделях данных используются какие-то языки: для описания статических свойств рассматриваются **правила порождения**, которые позволяют описать схему базы данных и какие-то ограничения. Обычно правила порождения не различают, порождается ли структура или ограничения, и задаются средствами языка описания данных. Хотя в последнее время всё чаще язык описания данных как бы разбивается на два подмножества: дя описания структуры рассматривается DDL, а для описания ограничений рассматривается подмножество этого языка -- язык описания ограничений.

Для описания операций преобразования динамических свойств рассматривается подмножества языка манипулирования данными.

Таким образом, языки БД делятся на DDL (ЯОД) и ЯМД (DML, Data Manipulation Language)

<a href="https://ibb.co/84tqCLp"><img src="https://i.ibb.co/jZsmNP2/image.png" alt="image" border="0"></a>

Например, в реляционных БД существует один общий язык SQL, в который включены подмножества и DDL и DML.

При описании структуры мы тут же определяем какие-то ограничения, если они очевидны и мы можем их сразу сформулировать. Например, на должность водителя можно принимать только совершеннолетних (возраст > 17), а стаж работы < возраст - 17: только человек, достигший совершеннолетия, может получить права по управлению автомобилем: поэтому это гарантирует, что на предприятии не появится 18-летний водитель с 10-летним стажем. Конечно, все эти ограничения разрабатываются применительно к предметной области, и заказчик, который хорошо знает специфику работы своего предприятия, может чётко определить эти ограничения, поэтому с ним надо работать активно.

Поскольку мы должны описать **структуру** -- совокупность категорий, свойств и связей между категориями, рассмотрим, какие компоненты мы используем для её описания.

### Структурные компоненты

**Множество** -- собрание правильно идентифицированных объектов, удовлетворяющих правилу принадлежности.

<a href="https://ibb.co/H2FTXG8"><img src="https://i.ibb.co/3srmkSZ/image.png" alt="image" border="0"></a>

Для множества мы должны определить какое-то условие: правило принадлежности, которому должны удовлетворять все элементы этого множества.

В зависимости от того, как задаются множества, они делятся на две группы -- множества-домены и множества-отношения.

**Отношения **-- это некоторый агрегат построенный на других множествах. В зависимости от того, на каких множествах отношение построено, рассматривают **отношения сущности** -- построены на доменах, и **отношения связи** -- построены на отношениях сущности.

При определении множества мы должны задать две важные характеристики -- **интенсионал** (характеристика типа, определяющая допустимые множества значений). По сути интенсионал -- это тип переменной `int`

Кроме того, **экстенсионал** -- определяет конкретное значение множества. По аналогии с ЯП -- это конкретное значение переменной типа `int`, например, 27

### Домены и атрибуты

**Домены** -- множества, элементы которых более или менее однородны. Обычно в МД роль доменов выполняют типы данных: например, целое число.

Значения, входящие в домен, могут использоваться для задания свойств категории.

**Атрибуты** -- именованные домены, представляющие семантически значимые объекты. Они позволяют называть свойства категорий.

В этом примере все атрибуты приведены на одном и том же домене -- целые числа. Атрибуты позволяют связать факты и их семантику -- способы их обработки: например, возраст с целыми числами. 

<a href="https://ibb.co/t4XczXw"><img src="https://i.ibb.co/Cz2v62p/image.png" alt="image" border="0"></a>

### Отношение сущности

**Отношение сущности** -- агрегат, построенный на множествах-*доменах*.

В соответствии с определением этого отношения (это определение берётся из математической теории отношений с уточнениями, специфическими для МД):

Пусть дана некоторая совокупность доменов $D_1, D_2, \dots, D_n$, не обязательно различных. Тогда отношение -- это множество упорядоченных кортежей вида $\lang d_1, d_2, \dots, d_n\rang$, в которых каждый $d_i$ принадлежит соответствующем домену $D_i$: $$R = \{\lang d_1, d_2, \dots, d_n\rang|d_i\in D_i, i=\overline{1, n}\}$$

Само отношение -- неупорядоченное множество, но кортежи, в него входящие, упорядочены в соответствии с порядком следования доменов.

**Степень** отношения (**арность** кортежа) -- количество множеств, на которых построено это отношения (в данном случае равно $n$)

**Мощность** отношения -- количество кортежей в конкретной реализации отношения.

Если арность -- характеристика *интенсионала*, то мощность -- характеристика *экстенсионала*, то есть конкретной реализации отношения.

Если в качестве доменов рассматриваются, например, $$D_1 = \mathtt{int} \{1, 4, 8\}\\D_2=\mathtt{char}\{a, c, x\},$$то отношение, построенное на этих двух доменах, может включать в себя следующее множество кортежей: $$\{\lang 1, a\rang, \lang 1, x\rang,  \lang 8, c\rang, \dots\}$$


Степень кортежей -- 2 (потому что 2 домена), а мощность конкретно этого отношения равна 3 (потому что 3 кортежа).

**Схема отношения** -- именованный список пар <имя атрибута: имя домена >.

$$имя\_схемы(имя\_атрибута : имя\_домена, \dots)$$

Атрибут в отношении -- это семанически значимый объект, определяющий способ использования домена в отношений. Атрибуты как раз и позволяют внести семантику в описание данных.

D1 предсталвяет собой интенсионал : строчная английская буква, а эстенционал -- {a, b, c, d, e}

На основе этих двух доменов создаётся отношение. В данном случае -- это множество бинарных кортежей (по два элемента в каждом кортеже), причём первый элемент каждого кортежа принадлежит D1, а второй -- D2.

Схема отношения: R(Категория: D~1~, Индекс:D~2~). Так как интекс принадлежит десятичным цифрам (D2), то мы теперь знаем, что индексы мы можем не только сравнивать на равенство, но ещё и определять < и >

В таком отношении арность равна 2, а мощность -- 3. Если арность -- характеристика типа и не зависит от конкретной реализации отношения, то мощность зависит от конкретной реализации и будет меняться.

### Отношение связи

**Отношение связи** -- агрегат, построенный на множествах-*сущностях*

Определяются точно так же: если у нас есть некоторая совокупность множеств сущностей, то отношение связи -- неупорядоченное множество упорядоченных кортежей вида $\lang s_1, s_2, \dots, s_n\rang$, где $s_i\in S_i$: $$R = \{\lang s_1, s_2, \dots, s_n\rang|s_i\in S_i, i=\overline{1, n}\}$$


#### Характеристики связи

**Арность** характеризует, на каком количестве множеств сущностей рассматривается связь. Мы ограничиваемся бинарными связями -- связями между двумя множествами сущностей. Это ограничение определяется тем, что реляционная модель данных поддерживает только бинарные связи, но используя только их, можно реализовать сколь угодно сложные ИС.

Для бинарной связи определяются два **отображения**: $$R: S_1\to S_2; R^{-1}: S_2\to S_1,$$Какое из отображений определить как прямое, а какое -- как обратное, значения не имеет

А вот уже отображение обладает своими характеристиками.

**Кардинальное число отображения** -- количество элементов одного множества, связанных с одним элементом другого множества $$R(S_1(\min_1, \max_1):S_2(\min_2, \max_2)$$

То есть количество экземпляров из множества сущностей $S_2$, связанное с одним экземпляром из множества сущностей $S_1$, определяет **кардинальность** отображения $S_1\to S_2$.



У каждого отображения своя кардинальность. Поскольку каждый экземпляр $S_1$ может быть связан с разным количеством $S_2$, то обычно рассматриваются минимальное и максимальное значение.

Каждый экземпляр из $S_1$ связан с минимум $\min_2$, максимум с $\max_2$ экземплярами $S_2$. Именно эти характеристики -- $\min_1, \dots, \max_2$ -- определяют тип связи.

Например, курсы по выбору: ВЫБИРАЕТ(СТУДЕНТ(5, 100): КУРС(1, 3))

Каждый студент должен выбрать какие-то курсы по выбору. Каждый студент должен выбрать по крайней мере один из трёх курсов, но курс состоится в том случае, если его выберут минимум 5 студентов из 100.

### Типы отображений

В зависимости от того, каким условиям удовлетворяют эти кардинальные числа, рассматриваются различные конкретные типы отображений.

**1. $R(S_1(0,\infty):S_2(1, \infty)), S_1\to S_2$ -- полностью определённое на $S_1$**

<a href="https://imgbb.com/"><img src="https://i.ibb.co/KsNGqwV/image.png" alt="image" border="0"></a>

Каждый экземпляр множества S1 связан минимум с одним экземпляром множества S2.

Для существования экземпляра множества сущностей S1 необходимо, чтобы он был связан с каким-то одним экземпляром множества сущностей S2 (по крайней мере, одним, но можно и больше)

Такое отображение называется **полностью определённым на S1**: экземпляр S1 не может существовать вне связи с экземплярами S2

#### Неполное функциональное отображение

<a href="https://ibb.co/2y6PvDG"><img src="https://i.ibb.co/yXR56wH/image.png" alt="image" border="0"></a>

Минимальное кардинальное число отображения равно 0, то есть экземпляр из S1 мб не связан ни с каким экземпляром из S2, а максимальное число равно 1 -- то есть максимум можно связаться с одним экземпляром S2. А это значит, что если мы можем берём соответствующий экземпляр из S1, мы всегда можем по нему найти соответствующий экземпляр S2 -- такое отображение называется **неполным функциональным**.


#### Полное функциональное отображение

<a href="https://ibb.co/2vNWsMh"><img src="https://i.ibb.co/6HBr1tw/image.png" alt="image" border="0"></a>

Когда минимальное и максимальное кардинальные числа равны 1, то есть каждый экземпляр из S1 обязательно связан с одним и только одним экземпляром из S2 -- получаем **полное функциональное отображение**: получив некоторый экземпляр S1, мы всегда найдём один единственный экземпляр S2, ему соответствующий -- то есть получаем функцию, которая по значению $x\in S_1$ находит значение $y\in S_2$. 


Эти типы функциональных отображений влияют на типы связи.



## Ограничения целостности

В общем случае модели данных включают в себя представление трёх компонентов:
- **структурные** компоненты, позволяющие описать информационную модель. В них входят отношения сущности и отношения связи.
- **ограничения целостности**, накладываемые на данные
- **манипуляционные характеристики**: база данных представляет собой совокупность реализаций, получаемых путём преобразования, и этот компонент как раз определяет, какие преобразования можно выполнять с данными.

Для описания этих трёх компонент -- структурной, целостной и манипуляционной, в языках, которые предназначены для описания информационной модели, обычно выделяют два подмножества языка:
- язык описания данных, который определяет структуру данных и **статические** ограничения, накладываемые на данные
- язык манипулирования данными, который определяет правила преобразования реализаций, на которые также оказывают влияние ограничения, накладываемые на данные.

**Ограничения целостности** -- логические ограничения, накладываемые на данные (**constraints**) в условиях соответствующей предметной области. Разрабатывая схему БД, на этапе определения связей сущностей и построения диаграмм бывает очень полезно также определять какие-то ограничения, которые накладываются на данные.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/JtR1Wj9/image.png" alt="image" border="0" height="200" align="left"></a>

Рассмотрим, где на каком этапе используются ограничения целостности. У нас есть модель данных МД, средствами которой мы можем представить некоторую совокупность схем баз данных S. Схем в рамках одной модели может быть много: всё определяется той предметной областью, которую мы реализуем; а сама база данных представляет собой совокупность реализаций DBS~i~, удовлетворяющих данной одной и той же схеме, получаемых в результате каких-то преобразований.

На уровне описания данных используется подмножество языка описания данных, а для преобразования реализаций используется подмножество языка манипулирования данными.


На этих этапах и при описании схемы, и при реализации преобразований между отдельными реализациями базы данных действуют какие-то правила, которые определяют допустимые (или достоверные) состояния БД. В силу того, что мы описываем как статические свойства, так и динамические свойства преобразований, ограничения, которые накладываются на данные, тоже делятся на две категории:
- **статические спецификации** выражают правила, которые определяют допустимые (достоверные) состояния БД. Эти правила накладываются на каждую конкретную реализацию БД
- **динамические спецификации** определяют возможные допустимые переходы из одного состояния БД в другое -- преобразования из одной реализации БД в другую: не все такие преобразования могут быть разрешены, учитывая ограничения, накладываемые на данные.

Обычно все логические ограничения, которые накладываются на данные, связаны с состоянием базы данных и включают в себя и статические, и динамические спецификации. 

Допустим мы разработали соответствующую информационную модель, для которой мы определили некоторую совокупность ограничений, накладываемых на данные. Поскольку ограничения связаны со схемой БД, а схеме БД удовлетворяют отдельные реализации, состояния БД, то между ограничением, схемой и состоянием БД существуют определённые зависимости, выраженные следующими определениями:

#### Правила, накладываемые на ограничения целостности C~i~

Ограничение C~i~:
- **правильно построено**, если оно соответствует синтаксическим правилам спецификации ограничений. Для спецификации ограничений в SQL есть средства, которые позволяют эти спецификации указать
- **удовлетворено состоянием DBS~i~** (состоянием БД -- конкретной её реализации), если оно истинно для данного состояния. Поскольку ограничения целостности -- это обычно логические условия, они могут принимать значения истина или ложь, то ограничение удовлетворено состоянием, если для данного состояния ограничение принимает значение истина.
- **удовлетворяемо**, если есть хотя бы одна реализация состояния БД DBS~i~, которая удовлетворяет этому ограничению, то есть на этом состоянии ограничение принимает значение истина.
- **недостоверно**, если никакое состояние базы данных ему не удовлетворяет.

При определении ограничений целостности надо использовать синтаксически правильные конструкции и нужно выбирать такие ограничения целостности, которые соответствуют предметной области, чтобы не оказалось так, что выбранное ограничение будет недостоверным.

#### Правила, накладываемые на конкретную реализацию состояния БД DBS~i~

DBS~i~ -- это конкретный набор данных, удовлетворяющих схеме.
- **удовлетворяет схеме S**, если он удовлетворяет всем ограничениям, определённым для этой схемы. То есть данные не просто структурно удовлетворяют схеме, но ещё должны выполняться и все ограничения целостности, которые для этой схемы сформулированы
- **непротиворечиво**, если оно удовлетворяет всем ограничениям, накладываемым на схему БЖ

#### Правила, накладываемые на схему S

Схема S:
- **удовлетворяема**, если существует некоторое состояние БД, которое удовлетворяет данной схеме
- **противоречива**, если никакое состояние базы данных этой схеме не удовлетворяет.

При проектировании схемы для неё надо определить и какие-то ограничения целостности, и гарантировать, что данная схема не окажется противоречивой, то есть могут существовать реализации, которые удовлетворяют всем ограничениям, накладываемым на данные.

### Манипуляционный компонент

Это правила переходов состояния БД. Они обычно не определяются, а разрабатываются для тех моделей данных, которые лежат в основе некоторой конкретной СУБД, а поскольку для моделей *вообще* никакой реальной СУБД существовать не может, то эту часть мы пока оставим в стороне.

Здесь можно только отметить, что языки манипулирования данными применительно к любой МД делятся на две категории:
- **навигационные** языки, которые учитывают конкретную организацию структуры информационной модели. К ним относятся языки манипулирования данными в иерархической и сетевой МД
- **ненавигационные** языки: чтобы найти нужные данные, достаточно указать, каким свойствам эти данные должны удовлетворять, не указывая конкретного маршрута движения по схеме.



В общем случае применительно к МД ограничения целостности могут быть разделены, в свою очередь, на **внутренние** и **явные**.

**Внутренние** ограничения поддерживаются самой моделью данных. Например, атрибут всегда определён на каком-то домене, а значит, значение атрибута может только принадлежать этому домену. Модель данных сама определяет понятия домена, атрибута, и поэтому своими средствами гарантирует, что атрибут не сможет принимать недопустимые значения. От разработчика БД выявление таких внутренних ограничений не накладывает никаких доп требований на реализацию таких ограничений: контроль за правильным значением того или иного атрибута берёт на себя СУБД, работающая в соответствии с конкретной моделью данных

**Явные** ограничения не мб реализованы МД. Для их реализации разработчику надо создавать какие-то дополнительные конструкции, чтобы проверить соответствующее условие. Например, в предприятии сумма окладов должна быть меньше зарплаты. Так что если предметная область предъявляет какие-то явные ограничения, их надо определить функционально или процедурно, а может быть, с помощью триггера. 


Обязательное условие: на этапе проектирования информационная модель будет представлена в виде FA диаграммы и помимо всего прочего, надо продумать и ограничения целостности: помимо описания отдельных отношений и связей между отношениями, надо сформулировать возможные условия связи: например, водителем автобуса не мб несовершеннолетний и так далее.

## Операции над данными

По своему смыслу эти операции делятся на выборку (чтение, поиск) и модификацию данных -- в основном добавление (хотя можно и удалять, но удаление на практике применяется нечасто, потому что если вдруг надо будет что-то восстановить, а копии нет, то этого сделать уже не получится). Поэтому, как правило, если данные больше уже не нужны и не используются в текущий момент времени, сохраняются в каких-то архивах и исключаются из текущей реализации БД, а при необходимости всегда можно будет обратиться к этим архивным записям.

Организация доступа к данным реализуется языками, которые делятся на две группы: ненавигационные, которые не учитывают конкретную организацию хранения данных на физическом уровне с точки зрения формирования запросов к данным (например, в СУБД на основе реляционной модели данных), и навигационные, которые это учитывают.

# 3. Модель данных "сущность-связь"

## Введение

Это семантическая высокоуровневая модель. Нет ни одной реальной СУБД, в основе которой лежит модель сущность-связь. Есть объектно-ориентированные СУБД, у которых многие характеристики похожи на модель сущность-связь.

Модель была предложена Питером Ченом (P. Chen) в 1976 году. В этом время уже велись интенсивные работы по изучению реляционной модели, поэтому в этой статье используются те же термины, что и в общем описании МД, но их семантика может отличаться: в каждой модели данных подчёркиваются какие-то особенности, которые она накладывает на то или иное понятие.

Прежде всего, он выделил разные уровни представления информации:

#### Уровень 1: информация о сущностях и связях

Этот уровень ориентирован на человека и пытается описать то, что пользователь хочет получить от будущей информационной системы, так что тут информация представлена так, как она существует в представлении людей. 

На этом уровне обычно используется описание на естественном языке, а естественный язык обладает большими степенями свободы, поэтому здесь описание может быть довольно расплывчатым и не очень строгим, а главное -- может иметь разные способы реализации. 

#### Уровень 2: структура информации

Это организация информации, в которой сущности и связи представлены данными -- по сути, выбор способов идентификации конкретных экземпляров сущностей и конкретных экземпляров связей.

#### Уровень 3: структура данных - способ доступа

Это структура данных, независимая от способа доступа к этим данным: чисто на логическом уровне. 

#### Уровень 4: структура данных + способ доступа

Здесь уже учитывается способ доступа к данным.

Чен показал, что для представления информации о сущности и связях, как она существует в нашем представлении (1 уровень) и описания структуры информации на 2 уровне подходит модель данных "сущность-связь". На 3 уровне используется реляционная модель, а 4 уровень соответствует иерархической и сетевой моделям данных.

## Уровень 1

**Сущность** -- нечто, принадлежащее объективной реальности, облаченное в материальную форму или форму идеи; любой объект, который может быть идентифицирован некоторым способом, отличающим его от других объектов, и информацию о котором надо хранить в базе данных.

Сущность -- это нечто, что может существовать реально (например, автомобиль) или в форме идеи (например, банковский счёт -- идея, в которой отражается, кто какие операции с деньгами определяет, или факт продажи -- это идея, которая говорит, что данный материальный товар был когда-то продан за какую-то стоимость).

Важно, что экземпляры сущности всегда могут быть идентифицированы и отличимы друг от друга по каким-то характеристикам.

**Связь** -- некоторая ассоциация, устанавливаемая между двумя или более сущностями.

Модель данных сущность-связь не ограничиваются только бинарным связями: здесь рассматриваются n-арные связи в общем случае.

### Сущность -- Entity

Поскольку сущности -- это нечто, принадлежащее объективной реальности, в результате наблюдения каких-то явлений, выделяется некоторое *множество* сущностей $E = \{e_i\}$. Когда рассматривается это множество, с этим множеством обязательно связывается **предикат** -- правило, на основании которого мы можем определить, принадлежит ли конкретный наблюдаемый объект в реальном мире данному множеству сущностей или нет. Предикат определяет, что может являться экземпляром сущности, а что нет.

Например, если у нас есть множество сущностей-городов, то предикатом для неё может быть какое-то ограничение на численность населения и на площадь.

С учётом свойств множества и предиката определяется **тип** сущности -- некоторое обобщённое представление однородных сущностей. Например, в нашем примере это город. Тогда **экземпляр** сущности  $e_i$ -- это конкретный элемент  множества сущностей $E$.

Если рассматривается термин *сущность* (entity), часто подразумевают конкретный экземпляр множества сущностей. Однако часто с ним связывают и понятие типа сущностей (само множество), поэтому лучше использовать чёткую трактовку. В нашем случае *сущность*  будет интерпретироваться как тип сущностей, то есть название множества сущностей. А если надо обратиться к элементу этого множества, то будем называть это *экземпляром*.

Для каждого множества сущностей определяется некоторый набор свойств, общих для всех сущностей из этого множества. В этот набор в том числе входит и предикат -- правило принадлежности.

### Связь -- Relationship

Поскольку связь -- это ассоциация, устанавливаемая между двумя или более сущностями как множествами сущностей, то каждая конкретная связь -- это связь между конкретными экземплярами сущностей. С другой стороны, этих связей много, и они тоже образуют множество. Поэтому тут, как и в случае с сущностями, есть двоякая трактовка термина связь. 

**Множество связей** -- математическое отношение между сущностями: $$R = \{\lang e_1, e_2, \dots, e_n\rang|e_1\in E_1, e_2\in E_2, \dots, e_n\in E_n\}$$Множество связей представляет собой множество упорядоченных по порядку перечисления сущностей кортежей $\lang e_1, e_2, \dots, e_n\rang$, в которых каждый элемент кортежа $e_i$ принадлежит соответствующему множеству сущностей $E_i$. 

Множество связей -- это характеристика знака, экстенсионал. Есть ещё и внутренняя характеристика -- интенсионал: тип связи. **Тип связи** определяет соответствующую ассоциацию типов сущностей.

Поскольку связь -- это также и множество, то мы можем рассматривать и **экземпляр** связи как отдельный элемент этого множества.

Кроме того, есть ещё одна важная характеристика связей -- **роль сущности в связи $r$** -- функция, которую сущность выполняет в данной связи: $$\lang r_1/e_1, r_2/e_2, \dots, r_n/e_n\rang$$Роль сущности в связи очевидна исходя из того, какие множества сущностей вовлекаются в эту связь. Например, если у нас есть два множества сущностей -- проект и сотрудник организации, то если мы рассматриваем связь -- какой исполнитель над каким проектом работает, то эта связь представляет множество бинарных кортежей вида <проект/e~1~, исполнитель/e~2~>. Поскольку элементы e~1~ и e~2~ извлекаются из разных множеств сущностей, то они уже чётко определяют, какую роль данный экземпляр сущности играет в данной связи: e~1~ -- проект, над которым работает исполнитель, а e~2~ -- исполнитель, который работает над проектом.

В целом ряде случаев при определении связи необходимость в указании роли сущностей в ней отпадает. Хотя есть ситуации, при которых эта роль должна быть очень чётко задана. Например, сущность "денежная единица" и сущность "курс", где имя роли денежной единице в связи с курсом надо обязательно указывать -- из неё переводим или в неё.

Другой пример -- сущность "личность". Если рассматривать связь между личностями  <e~1~, e~2~>, которая выражает отношения между ними, то надо чётко определять, какая сущность какую роль играет: например, e~1~ -- отец, а e~2~ -- ребёнок.

### Значения -- values

Информация о сущностях и связях представляется в виде множества пар "атрибут-значение".

Для этого используется **множество значений - values**, в которые входят
- сами значения
- предикат

Чен переопределил термин "атрибут" по сравнению с общей теорией моделей данных: **атрибут** -- функция, отображающая множество сущностей или множество связей в множество значений $$f:S_i\xrightarrow{f}V_i$$ или декартово произведение множества значений: $$f: S_i\xrightarrow{f}V_{i1}\times V_{i2}\times\dots\times V_{in}$$

### Информация о сущностях

Допустим, мы определили множество сущностей СОТРУДНИК. Далее мы определили некоторую совокупность множеств значений: здесь 5 множеств значений: НОМЕР СОТРУДНИКА, ФАМИЛИЯ, ИМЯ, ОТЧЕСТВО и КОЛИЧЕСТВО ЛЕТ. 

<div align="center"><a href="https://ibb.co/d0qvxnG"><img src="https://i.ibb.co/BVxJF8q/image.png" alt="image" border="0" height="300"></a></div>

Тогда атрибут -- это *функция*, которая отображает множество сущностей на множество значений. Эта функция с каждым экземпляром сущности связывает одно значение из множества значений: например, первый атрибут F~1~ -- это номер сотрудника, который отображает экземпляр сущности СОТРУДНИК на значение НОМЕР СОТРУДНИКА. С каждым экземпляром сущности связано в точности *одно* значение из множества значений -- это полное функциональное отображение.

Множество сущностей СОТРУДНИК отображается на множество значений КОЛИЧЕСТВО ЛЕТ с помощью двух функций, то есть двух атрибутов: возраст сотрудника и стаж его работы.

Также множество сущностей e~1~ отображается на декартово произведение множеств значений, если мы рассматриваем атрибут "полное имя сотрудника", который содержит в себе ФИО.

### Информация о связях

Чен не ограничивается бинарными связями, а рассматривает в общем случае n-арные связи. Например, у нас есть множества сущностей СОТРУДНИК, ПРОЕКТ и множество значений ПРОЦЕНТ. 

<div align="center"><img src="https://i.ibb.co/6mGQVYm/image.png" alt="image" border="0" height="300"></div>

Мы рассматриваем связь -- ассоциацию между сущностями СОТРУДНИК и ПРОЕКТ. Эту ассоциацию мы определяем как "исполнитель проекта" -- мы определяем, какой сотрудник над каким проектом работает. Сотрудников много, проектов тоже много, и множество связей тоже может включать в себя большое количество кортежей.

У каждой связи, помимо всего прочего, могут быть ещё и собственные атрибуты: например, доля времени, которую данный сотрудник затрачивает на работу над данным проектом. Этот атрибут не является атрибутом множества сущностей СОТРУДНИК, ни свойством проекта -- он характеризует именно связь.

## Уровень 2

Поскольку здесь речь идёт уже о возможности идентифицировать каждый экземпляр сущности и каждый экземпляр связи, то эта идентификация означает, как мы можем представить конкретный экземпляр сущности и конкретный экземпляр связи для того, чтобы отличить его от других.

### Представление сущности

Чтобы идентифицировать каждый экземпляр сущности, нужно использовать понятие **первичного ключа** сущности -- совокупность одного или несколько атрибутов, уникальных для каждого экземпляра сущности.

<div align="center"><img src="https://i.ibb.co/x6yQbrv/image.png" alt="image" border="0" height="250"></div>

Если у нас есть множество сущностей СОТРУДНИК и для идентификации сотрудников мы используем множество значений НОМЕР СОТРУДНИКА, в котором каждому экземпляру сотрудника соответствует в точности одно значение, но для ключа важно, что это соответствие является **взаимно однозначным**: то есть с каждым экземпляром сотрудника связано своё уникальное значение из множества значений НОМЕР СОТРУДНИКА, но и наоборот, каждому значению номера сотрудника соответствует только один экземпляр сущности СОТРУДНИК. Поэтому для того, чтобы представить сотрудника, достаточно указать его первичный ключ -- номер сотрудника. 

Для такого представления множества сущностей это самое множество уже не используется. Чен ограничивается просто множеством значений НОМЕР СОТРУДНИКА, потому что зная его, мы чётко определим и сам экземпляр сущности СОТРУДНИК.

Для удобства Чен предложил все эти множества сущностей и связей иллюстрировать с помощью таблиц:

<div align="center"><img src="https://i.ibb.co/Q6r5dCX/image.png" alt="image" border="0"></div>

Раз у нас выделяется колонка первичного ключа, то это гарантирует, что у каждого сотрудника будет свой уникальный номер.

### Представление связи

Для представления связи Чен предложил использовать **первичный ключ связи**. Поскольку связь -- это ассоциация между экземплярами сущностей, то первичный ключ связи здесь создаётся на основе первичных ключей сущностей, вовлечённых в эту связь.

<div align="center"><img src="https://i.ibb.co/FVNZdWf/image.png" alt="image" border="0"></div>

Однако такое представление информационной модели в виде таблицы неудобно: оно громоздкое и не наглядное. Поэтому Чен предложил свой диаграммный язык для представления этой информационной модели.

### Диаграмма сущность-связь

Для представление отношения сущности используется прямоугольник, внутри которого записывается имя множества сущностей.

Для представления связи используется ромбик. Имя множества связей записывается внутри этого ромбика.

Для задания атрибутов используется овал, внутри которого записывается имя атрибута. Атрибуты связываются с соответствующими сущностями или связями. Атрибуты, выполняющие функцию первичного ключа, подчёркиваются.

Рассматриваются два типа сущностей: **регулярное** отношение сущности и **слабое** отношение сущности.

**Регулярное** отношение сущности: для однозначной уникальной идентификации каждого экземпляра сущности в данном множестве достаточно использовать только собственные атрибуты сущности.

**Слабое** отношение сущности -- отношение, в котором для уникальной идентификации каждого экземпляра во множестве сущностей нужно учитывать связь: то, что в IDEF1x определяется как сущность, зависимая по идентификации. Такие сущности обозначаются прямоугольник с двойными границами.

Аналогично связь может быть представлена простым ромбиком или ромбиком со сдвоенными границами, если связь устанавливается со слабым отношением сущности, или, с точки зрения IDEF1x -- идентифицирующая или неидентифицирующая связи.

#### Представление n-арных связей

n-арные связи могут быть представлены так:

<div align="center"><a href="https://ibb.co/Thf16gp"><img src="https://i.ibb.co/HgSC6H1/image.png" alt="image" border="0" height="200"></a></div>

В нотации IDEF1x, которая ограничивается *только* бинарными связями, связь ПОСТАВКА была бы представлена отдельной сущностью ПОСТАВКА.

Наличие таких n-арных связей позволяет в какой-то степени описать предметную область более точно. 

#### Определение связей на одном множестве сущностей

<div align="center"><a href="https://ibb.co/hm74tL4"><img src="https://i.ibb.co/HHFbkBb/image.png" alt="image" border="0" height="150"></a></div>

#### Указание типов связей -- 1:n и n:n

<div align="center"><a href="https://ibb.co/jMmkxjt"><img src="https://i.ibb.co/wWVhb2t/image.png" alt="image" border="0" height="150"></a></div>

#### Слабое отношение сущности

<div align="center"><a href="https://imgbb.com/"><img src="https://i.ibb.co/gjNskHy/image.png" alt="image" border="0" height="150"></a></div>

Каждый сотрудник как член бригады зачисляется в бригаду к какому-то руководителю. Каждый сотрудник предприятия имеет свои уникальные характеристики -- первичный ключ, но для того, чтобы идентифицировать члена бригады, собственная идентификация сотрудника оказывается неприемлемой, потому что один и тот же сотрудник для выполнения разных работ может быть зачислен в разные бригады. Поэтому для идентификации члена бригады приходится использовать собственный атрибут сотрудника плюс атрибут руководителя.

Итоговая диаграмма может выглядеть так:

<div align="center"><a href="https://ibb.co/W3qMx9s"><img src="https://i.ibb.co/N3QJVh7/image.png" alt="image" border="0" height="300"></a></div>

Как видно, диаграммный язык не очень удобный, и сами диаграммы получаются громоздкие, поэтому и самим Ченом, и впоследствии в других организациях были предложены другие языки диаграмм (при этом важно, что изменения касались только самих диаграмм, не затрагивая саму суть модели сущность-связь). Например, мы используем нотацию IDEF1x, которая имеет, пожалуй, только одно принципиальное отличие от ER-модели: в IDEF1x рассматриваются только бинарные связи, тогда как в оригинальной модели допускалось использование в общем случае N-арных связей.


### Ограничения целостности

В общем случае, как уже было сказано, модель данных состоит из трёх компонент.

Первая -- это струкут
#### 1. На допустимые значения в множестве значений


<!--stackedit_data:
eyJoaXN0b3J5IjpbNjg2MDg3NTA1LDE5ODAzNDQxNDQsLTkwMz
c1OTc1NiwtMTM2MDQ0Mjg5MiwxMDM2Njc2MTEwLDM5MjY2MTg4
Niw0Njk5MDMzODYsMTE1MjAzNzU5OSw4NTA4NDAzMzEsLTE1ND
EyNTI4NDgsMTYwNTY4MTY5OSwtNjg0MTQ4MDYsMTIxNDA1NDIz
LC0xMTc5MzEyOTM1XX0=
-->