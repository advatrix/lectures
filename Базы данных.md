## Содержание курса

| Этапы жизненного цикла | Используемые средства
|--|--|
Проектирование | Модели данных, модель "сущность-связь"
Разработка | Реляционная модель данных
Реализация | Язык SQL конкретной СУБД; внутренние структуры хранения



В этом семестре мы будем проектировать базу данных как часть некоторой информационной системы. Обычно информационные системы создаются для решения задач, специфических для предметной области; они используются для поддержки текущей деятельности предприятия, а поскольку для этого требуется хранить большие объёмы информации, то если раньше она хранилась в бумажном виде, сейчас это, конечно же, неудобно, и она сохраняется в электронном виде на машинах.

Если посмотреть на историю вычислительной техники, то первые вычислительные машины были построены в конце 40-ых - начале 50-ых годов прошлого века, и получили название **вычислительные**, потому что они изначально разрабатывались для организации и автоматизации вычислительных работ: необходимо было обрабатывать большие объёмы данных, получаемых в результате физических экспериментов.

Но поскольку в состав вычислительной системы входят в том числе и средства, позволяющие надёжное и долговременное хранение данных, то такие вычислительные системы почти сразу же стали активно использоваться для разработки **информационных систем**, целью которых является накопление, обработка и долговременное хранение больших объёмов информации. Естественно, центральной частью таких ИС стали системы хранения данных. Первые варианты таких СХД получили название **базы данных**.

ИС, которые были разработаны для поддержки текущей деятельности предприятия, получили название **транзакционных систем** *(OLTP -- OnLine Transaction Processing  --  системы обработки транзакций)*. Это связано с тем, что текущая деятельность предприятия предполагает выполнение большого количества однотипных операций, которые получили название **транзакции**. Соответственно, в этом курсе мы рассматриваем проектирование баз данных, используемых в транзакционных системах.

Применительно к базам данных можно выделить некоторые этапы жизненного цикла -- проектирование, разработка и реализация.

Для описания данных, которые хранятся в БД, используется **информационная модель**, которую на разных этапах жизненного цикла можно описывать разными средствами.

На этапе **проектирования**, когда мы разрабатываем саму информационную модель, ориентируясь на предметную область, обычно используются **модели данных**, которые явились развитием модели "сущность-связь" (ER), которая удобна тем, что она имеет свой диаграммный язык, с помощью которого эту модель легко представить, и она понятна. 

Здесь стоит отметить, что разработчик ИС, как правило, не является конечным её пользователем. Если он является специалистом в области IT, то конечный пользователь таковым специалистом не является, зато он хорошо погружён в предметную область, в отличие от разработчика. Поэтому на этапе проектирования разработчик должен представить информационную модель в виде, который может понять пользователь, и учесть все их пожелания.

Сегодня на этапе проектирования мы используем не саму модель данных, а её модификацию -- модель **IDF1X**. Такую диаграмму уже легко перевести на язык реляционной модели данных.

Так как БД предполагают хранение больших объёмов данных на внешней памяти, а для её обработки нужно выгружать данные в ОП, то возникает вопрос производительности таких систем: объёмы данных в ОП очень большие, и как найти то, что нас интересует с тем, чтобы пользователь, формирующий какой-то запрос, не просиживал перед чёрным экраном недопустимо долгое время? Поэтому очень важно понимать, как организуется хранение данные во внешней памяти так, чтобы время отклика системы было приемлемым. Для таких ИС главными требованиями являются два (и они очень часто вступают друг с другом в противоречия):
- обеспечить целостность и достоверность информации
- обеспечить приемлемое время отклика

# 1. Модели данных. Общая характеристика

На разных этапах проектирования и разработки ИС используются разные модели данных, которые, в сущности, описывают одно и то же. Поэтому очень часто в разных моделях данных для обозначения каких-то схожих понятий используются одни и те же термины, но семантика в них может отличаться.

Что такое информация и как она используется? Конкретные ИС предназначены для поддержки текущей деятельности предприятия, которое опирается на какие-то внешние явления. Эти внешние явления, которые представляют интерес для предприятия, должны быть каким-то образом описаны. Для этого обычно используется понятие **данных**, с которыми связаны две характеристики:
- конкретные значения данных, то есть **факты**: 127, 7 февраля, ...
- **семантика** -- интерпретация, смысл значений: вес груза в кг, начало весеннего семестра, ...

При этом важно, что семантика определяет ещё и возможные операции над данными: например, если 12 -- это номер сотрудника, то его нельзя складывать, а можно только сравнивать, и т.д.

Обычно в памяти вычислительных машин мы храним только факты, при этом семантика отрывается от них. Этот отрыв в целом ряде случаев весьма усложняет обработку фактических значений.

Когда используется термин **информация**, то обычно он предполагает соединение фактов и их семантики. Если мы описываем их на естественном языке, это позволяет объединить их, получив "вес перевозимого груза 167 кг". Но для хранения на машине такое использование естественного языка считается невозможным.

Очень часто для удобного представления информации используется табличный способ -- например, расписание занятий, где названия строк  и столбцов задают семантику, а значения на их пересечениях -- факты.

### Файловые системы

Первые разновидности ИС организовывали хранение фактов именно в файлах, а семантику -- в прикладных программах, с помощью которых можно было вытащить конкретные факты из файлов и соответствующим образом обработать. Поэтому доступ к данным в таких системах осуществлялся только через прикладные программы.

**Файловые системы** -- набор программ, выполняющих операции, связанные с обработкой данных. При этом каждая программа, которая включается в такую файловую систему, по сути определяет свои собственные данные и управляется своими собственными данными.

#### Недостатки

Файловые системы обладают существенным рядом недостатков, которые привели к необходимости разработки каких-то других типов ИС.

- разделение и изоляция данных: интерпретация данных осуществляется прикладной программой ⇒
- дублирование данных: одни и те же данные могут дублироваться в разных программах, работающих с одними данными но решающих разные задачи
- зависимость от файлов: прикладные программы обрабатывают файлы с жёстко заданной структурой, и мы не можем перевести программу на обработку файлов другого типа
- несовместимость данных: обычно дата-время представляется либо в виде структуры, либо в виде строки
- фиксированные запросы к данным: в программу жёстко закладываются те запросы, которая она может выполнять

Причина этих недостатков в том, что факты и семантика разделены. 

На смену файловым системам пришли системы баз данных.

### Системы баз данных

**База данных** -- совместно используемый набор логически связанных данных и их описаний, предназначенных для удовлетворения информационных потребностей организации. В таких системах описание данных часто называется **метаданными**.

**СУБД** -- ПО, осуществляющее управление данными

**Система баз данных** - компьютеризованная система хранения записей: база данных, СУБД, аппаратура и люди, которые используют эту информацию


<a href="https://ibb.co/Bw4PtJK"><img src="https://i.ibb.co/CWJtzys/image.png" alt="image" border="0"></a>

**Сервер** владеет каким-то ресурсам и предоставляет соответствующие услуги, а **клиент** ими пользуется.

В **двухзвенной архитектуре** прикладные программы, которые обрабатывают данные, реализованы на стороне клиента. Она обращается к серверу за данными и обрабатывает их в соответствии со своей логикой.

В последнее время чаще всего вместо двухзвенной архитектуры используется **трёхзвенная**:


<a href="https://ibb.co/GWhD6ph"><img src="https://i.ibb.co/9bM0DgM/image.png" alt="image" border="0"></a>

В этом случае есть чистый сервер -- сервер, на котором установлена БД и СУБД, есть чистый клиент, на котором установлены средства для формирования необходимых запросов и отображения результатов их выполнения -- чистый интерфейс пользователя, а для реализации прикладной логики выделяется особый компонент -- **сервер приложений**, который по отношению к серверу БД выполняет роль клиента, а по по отношению к клиенту -- роль сервера.

Такая архитектура удобна, если разные прикладные программы используют более или менее одинаковые прикладные модули обработки данных, то это модули могут бтыь реализованы в виде одной копии на стороне сервера приложений.

Кроме того, на сервере приложений для реализации прикладной логики можно использовать языки высокого уровня, что облегчает их разработку.

Сама СУБД также реализует двухзвенную логику: есть серверная часть, которая отвечает за управление доступа к данным, и есть клиентская часть, которая реализует интерфейс пользователя.


## Категории пользователей

### Администраторы данных и баз данных

**Задачи:**
- обеспечение бесперебойной работы ИС
- поддержание необходимого качества данных

**Требования к СУБД:**
- обеспечение контроля доступа
- надёжность
- высокая производительность
- поддержка больших объёмов хранимой информации
- масштабируемость системы

### Разработчики баз данных

**Задачи**
- проектирование структуры БД
- реализация БД в рамках заданной СУБД

**Требования к СУБД**

- стандартизованные средства создания БД и манипулирования данными

## История развития СУБД

### СУБД первого поколения

- середина 60-х иерархическая СУБД IMS
- сетевая модель IDS (Interpreted Data Store)

Сетевая модель позволяла представлять более сложные связи, чем иерархическая модель.


СУБД, где используется сетевая или иерархическая модели данных, называются **унаследованными**.

Однако в иерархической модели для создания сложных связей будут дублироваться данные.

<a href="https://ibb.co/QJd94zV"><img src="https://i.ibb.co/PrQxd3y/image.png" alt="image" border="0"></a>



## Архитектура ANSI-SPARC

**Внешний уровень (view)** ориентирован на представление БД для конечного пользователя в зависимости от его нужд -- для каждой категории пользователей оно мб разным. Но эти представления могут в чём-то пересекаться, поэтому во избежание дублирования информации они все воедино собираются в **концептуальный** уровень (логическое описание), а **внутренняя схема** уже организует физическое хранение данных в БД.

<a href="https://ibb.co/Hh9L54v"><img src="https://i.ibb.co/SfZDFyT/image.png" alt="image" border="0"></a>

Внутренняя схема объединяет в себе все характеристики каждого из представлений. Поэтому чтобы пользователи получали доступ только к той информации, которая им нужна, эта внутренняя схеме *отображается* во view для каждого конкретного пользователя/группы. Это гарантирует, что каждый пользователь будет иметь доступ только к той информации, которая нужна ему.


Чтобы с этими данными работать, надо концептуальный уровень отобразить на физический -- на организацию хранения данных. Если мы ориентируемся на какой-нибудь ЯП, например, С, то для описания сотрудника создаётся соответствующая структура. Это позволяет, с одной стороны, исключить дублирование информации, а с другой, представлять её удобной для обработки.

Термин **информация** заключается в том, что мы не только храним конкретные *значения* данных, но и их *семантику*.

СХД начинались с создания файловых систем (где факты хранятся отдельно от семантики), им на смену пришли системы БД, которые объединяют факты и семантику.

СУБД строились на основании модели, которая позволяла описывать эти данные. СУБД используют три модели: сетевая и иерархическая (это уже в пролом), и реляционная -- основная на сегодняшний день.

Проектирование таких баз данных осуществляется в соответствии с положениями, принятыми при разработке архитектуры СУБД, определёнными в рамках комитета ANSI/SPARC.



# 2. Модели данных

Поскольку при разработке СУБД и при разработке информационных систем, в основе которых лежат СХД, используются какие-то модели данных -- и мы будем проектировать свою БД в соответствии с реляционной моделью данных, рассмотрим общие положения, касающиеся определения, а что же такое модель данных.

**Модель данных** -- это интегрированный набор понятий для описания **данных**, **связей** между данными и **ограничений**, накладываемых на данные в некоторой организации.

В какой-то степени в качестве аналогии можно привести алгоритмы -- это тоже набор понятий для описания обработки данных. Модель данных позволяет описать данные, которые существуют в реальном мире -- а они обязательно взаимодействуют между собой, поэтому надо описывать и связи.

При этом в разных предметных областях на одни и те же данные могут накладываться разные ограничения, поэтому описание данных, связей и ограничений рассматривается применительно к конкретной предметной области.

<a href="https://ibb.co/B3GzqG1"><img src="https://i.ibb.co/vqhwZht/image.png" alt="image" border="0"></a>

Модели данных принято делить на две категории: **сильно типизированные** и **слабо типизированные**.

В **сильно типизированных** МД все данные, описывающиеся в рамках данной модели, относятся к каким-то конкретным категориям: поскольку мы реально описываем всё, что происходит во внешнем мире, то, наблюдая за этим внешним миром и выявляя общие характеристики объектов и явлений, можно всё, что мы наблюдаем, разделить на какие-то категории. Например, можно использовать типы данных в ЯП -- это по сути такое категории, по отношению к которым мы выбираем объекты, обрабатывающиеся в программах.

В **слабо типизированных** МД распределить данные между какими-то категориями не представляется возможным. Но для того, чтобы можно было рассматривать связи и ограничения, то реальные объекты, явления и элементы из реального мира просто относятся либо к одной категории, либо к другой категории.

## Сильно типизированные модели данных

Большинство моделей данных, используемых в ИС, относятся к сильно типизированным. Это позволяет нам рассматривать все свойства данных, связи между данными, оперируя понятием **категории** -- не рассматривая каждый конкретный экземпляр данных, а рассматривая их общие характеристики.

Поэтому сильно типизированные модели данных делятся на две категории в зависимости от того, как эти категории определяются -

В моделях данных **на основе объектов** данные распределяются между разными объектами. Все элементы, размещаемые в одном объекте (в данном случае объект означает множество), характеризуются общим набором свойств. К таким моделям относятся объектно-ориентированная модель данных, а также семантические модели --в частности, сущность-связь. Однако модель сущность-связь не лежит в основе никакой реальной СУБД, хотя она очень активно используется на этапе проектирования.

Втора группа сильно типизированных МД -- **на основе записей**. Это реляционная модель, сетевая и иерархическая.

В сильно типизированных МД выделяются следующие основные компоненты: **категория** -- обобщённое понятие, с каждой категорией связывается некоторый набор **свойств** категории -- и тогда все экземпляры, которые включаются в ту или иную категорию, обладают одинаковым набором свойств -- но значения свойств, конечно же, могут быть разными. И поскольку модель данных должна отражать **связи** между категориями, они тоже входят в компоненты сильно типизированных моделей данных.

Например, транспортное предприятие в своём составе имеет средства передвижения (автомобиль - первая категория), и водители -- вторая категория. Для категории ВОДИТЕЛЬ определяются свойства имя, возраст, стаж работы, а для категории АВТОМОБИЛЬ -- модель, госномер, дата ТО и так далее. Между этими двумя категориями устанавливаем определённую связь, которую можно сформулировать в виде предложения: "водитель управляет автомобилем". Связь в данном случае -- "управляет" -- глагол.

В конкретном применении модели данных совокупность именованных категорий, их свойств и связей между ними, называется **схемой**. Таким образом, всё, что выделено синим на слайде, -- это схема, позволяющая описать работу транспортного предприятия.

Например:

ВОДИТЕЛЬ (Имя, Возраст, Стаж работы, ...)
АВТОМОБИЛЬ (Модель, ГОсномер, Дата,...)
УПРАВЛЯЕТ (ВОДИТЕЛЬ, АВТОМОБИЛЬ)


**Реализация БД** -- совокупность данных, структура которых соответствует некоторой схеме.

**База данных** -- совокупность реализаций, полученных в результате некоторых преобразований и удовлетворяющих одной и той же схеме.

<a href="https://ibb.co/RgzpMBr"><img src="https://i.ibb.co/Fhgbf0Z/image.png" alt="image" border="0"></a>

Определение БД содержит в себе некоторую связь со временем: конкретная реализация БД соответствует конкретному моменту времени -- это то, что есть сейчас. Но в нашей БД были какие-то реализации в прошлом и будут какие-то реализации в будущем, и все такие реализации -- те, которые были, и те, которые будут -- и называются базой данных.

Поэтому термин БД не означает моментальный снимок данных, хранящихся на машине -- это то, что изменяется во времени.

В зависимости от конкретной предметной области, если для них используется одна и та же МД, мы можем описать и разные схемы: например, можно попытаться описать схему учебного процесса (тогда будут категории группа, предмет, преподаватель и связи между ними).

Каждой конкретной схеме соответствует реализация. Эти реализации могут изменяться за счёт использования каких-то преобразований и операций, и вся эта совокупность реализаций и называется БД, причём она не ограничена: потому что могло быть что-то и до первой реализации, и будет что-то после последней реализации.

Так как мы имем дело с сильно типизированным МИ, мы можем определить схему, и все наши данные будут ей удовлетворять.

Поскольку БД меняется в времени, то когда мы описываем конкретную предметную область, мы сталкиваемся с необходимостью представления **статических** неизменяемых свойств и **динамических** изменяющихся свойств. Например, схема базы данных -- это статическая информация, а реализация отражает динамику.

Поэтому для реализации статических и динамических свойств в сильно типизированных моделях данных используются какие-то языки: для описания статических свойств рассматриваются **правила порождения**, которые позволяют описать схему базы данных и какие-то ограничения. Обычно правила порождения не различают, порождается ли структура или ограничения, и задаются средствами языка описания данных. Хотя в последнее время всё чаще язык описания данных как бы разбивается на два подмножества: дя описания структуры рассматривается DDL, а для описания ограничений рассматривается подмножество этого языка -- язык описания ограничений.

Для описания операций преобразования динамических свойств рассматривается подмножества языка манипулирования данными.

Таким образом, языки БД делятся на DDL (ЯОД) и ЯМД (DML, Data Manipulation Language)

<a href="https://ibb.co/84tqCLp"><img src="https://i.ibb.co/jZsmNP2/image.png" alt="image" border="0"></a>

Например, в реляционных БД существует один общий язык SQL, в который включены подмножества и DDL и DML.

При описании структуры мы тут же определяем какие-то ограничения, если они очевидны и мы можем их сразу сформулировать. Например, на должность водителя можно принимать только совершеннолетних (возраст > 17), а стаж работы < возраст - 17: только человек, достигший совершеннолетия, может получить права по управлению автомобилем: поэтому это гарантирует, что на предприятии не появится 18-летний водитель с 10-летним стажем. Конечно, все эти ограничения разрабатываются применительно к предметной области, и заказчик, который хорошо знает специфику работы своего предприятия, может чётко определить эти ограничения, поэтому с ним надо работать активно.

Поскольку мы должны описать **структуру** -- совокупность категорий, свойств и связей между категориями, рассмотрим, какие компоненты мы используем для её описания.

### Структурные компоненты

**Множество** -- собрание правильно идентифицированных объектов, удовлетворяющих правилу принадлежности.

<a href="https://ibb.co/H2FTXG8"><img src="https://i.ibb.co/3srmkSZ/image.png" alt="image" border="0"></a>

Для множества мы должны определить какое-то условие: правило принадлежности, которому должны удовлетворять все элементы этого множества.

В зависимости от того, как задаются множества, они делятся на две группы -- множества-домены и множества-отношения.

**Отношения **-- это некоторый агрегат построенный на других множествах. В зависимости от того, на каких множествах отношение построено, рассматривают **отношения сущности** -- построены на доменах, и **отношения связи** -- построены на отношениях сущности.

При определении множества мы должны задать две важные характеристики -- **интенсионал** (характеристика типа, определяющая допустимые множества значений). По сути интенсионал -- это тип переменной `int`

Кроме того, **экстенсионал** -- определяет конкретное значение множества. По аналогии с ЯП -- это конкретное значение переменной типа `int`, например, 27

### Домены и атрибуты

**Домены** -- множества, элементы которых более или менее однородны. Обычно в МД роль доменов выполняют типы данных: например, целое число.

Значения, входящие в домен, могут использоваться для задания свойств категории.

**Атрибуты** -- именованные домены, представляющие семантически значимые объекты. Они позволяют называть свойства категорий.

В этом примере все атрибуты приведены на одном и том же домене -- целые числа. Атрибуты позволяют связать факты и их семантику -- способы их обработки: например, возраст с целыми числами. 

<a href="https://ibb.co/t4XczXw"><img src="https://i.ibb.co/Cz2v62p/image.png" alt="image" border="0"></a>

### Отношение сущности

**Отношение сущности** -- агрегат, построенный на множествах-*доменах*.

В соответствии с определением этого отношения (это определение берётся из математической теории отношений с уточнениями, специфическими для МД):

Пусть дана некоторая совокупность доменов $D_1, D_2, \dots, D_n$, не обязательно различных. Тогда отношение -- это множество упорядоченных кортежей вида $\lang d_1, d_2, \dots, d_n\rang$, в которых каждый $d_i$ принадлежит соответствующем домену $D_i$: $$R = \{\lang d_1, d_2, \dots, d_n\rang|d_i\in D_i, i=\overline{1, n}\}$$

Само отношение -- неупорядоченное множество, но кортежи, в него входящие, упорядочены в соответствии с порядком следования доменов.

**Степень** отношения (**арность** кортежа) -- количество множеств, на которых построено это отношения (в данном случае равно $n$)

**Мощность** отношения -- количество кортежей в конкретной реализации отношения.

Если арность -- характеристика *интенсионала*, то мощность -- характеристика *экстенсионала*, то есть конкретной реализации отношения.

Если в качестве доменов рассматриваются, например, $$D_1 = \mathtt{int} \{1, 4, 8\}\\D_2=\mathtt{char}\{a, c, x\},$$то отношение, построенное на этих двух доменах, может включать в себя следующее множество кортежей: $$\{\lang 1, a\rang, \lang 1, x\rang,  \lang 8, c\rang, \dots\}$$


Степень кортежей -- 2 (потому что 2 домена), а мощность конкретно этого отношения равна 3 (потому что 3 кортежа).

**Схема отношения** -- именованный список пар <имя атрибута: имя домена >.

$$имя\_схемы(имя\_атрибута : имя\_домена, \dots)$$

Атрибут в отношении -- это семанически значимый объект, определяющий способ использования домена в отношений. Атрибуты как раз и позволяют внести семантику в описание данных.

D1 предсталвяет собой интенсионал : строчная английская буква, а эстенционал -- {a, b, c, d, e}

На основе этих двух доменов создаётся отношение. В данном случае -- это множество бинарных кортежей (по два элемента в каждом кортеже), причём первый элемент каждого кортежа принадлежит D1, а второй -- D2.

Схема отношения: R(Категория: D~1~, Индекс:D~2~). Так как интекс принадлежит десятичным цифрам (D2), то мы теперь знаем, что индексы мы можем не только сравнивать на равенство, но ещё и определять < и >

В таком отношении арность равна 2, а мощность -- 3. Если арность -- характеристика типа и не зависит от конкретной реализазции отношения, то мощность зависит от конкретнкнернтой реализации и будет меняться.

### Отношение связи

**Отношение связи** -- агрегат, построенный на множествах-*сущностях*

Определяются точно так же: если у нас есть некоторая совокупность множеств сущностей, то отношение связи -- неупорядоченное множество упорядоченных кортежей вида $\lang s_1, s_2, \dots, s_n\rang$, где $s_i\in S_i$: $$R = \{\lang s_1, s_2, \dots, s_n\rang|s_i\in S_i, i=\overline{1, n}\}$$


#### Характеристики связи

**Арность** характеризует, на каком количестве множеств сущностей рассматривается связь. Мы ограничиваемся бинарными связями -- связями между двумя множествами сущностей. Это ограничение определяется тем, что реляционная модель данных поддерживает только бинарные связи, но используя только их, можно реализовать сколь угодно сложные ИС.

Для бинарной связи определяются два **отображения**: $$R: S_1\to S_2; R^{-1}: S_2\to S_1,$$Какое из отображений определить как прямое, а какое -- как обратное, значения не имеет

А вот уже отображение обладает своими характеристиками.

**Кардинальное число отображения** -- количество элементов одного множества, связанных с одним элементом другого множества $$R(S_1(\min_1, \max_1):S_2(\min_2, \max_2)$$

То есть количество экземпляров из множества сущностей $S_2$, связанное с одним экземпляром из множества сущностей $S_1$, определяет **кардинальность** отображения $S_1\to S_2$.



У каждого отображения своя кардинальность. Поскольку каждый экземпляр $S_1$ может быть связан с разным количеством $S_2$, то обычно рассматриваются минимальное и максимальное значение.

Каждый экземпляр из $S_1$ связан с минимум $\min_2$, максимум с $\max_2$ экземплярами $S_2$. Именно эти характеристики -- $\min_1, \dots, \max_2$ -- определяют тип связи.

Например, курсы по выбору: ВЫБИРАЕТ(СТУДЕНТ(5, 100): КУРС(1, 3))

Каждый студент должен выбрать какие-то курсы по выбору. Каждый студент должен выбрать по крайней мере один из трёх курсов, но курс состоится в том случае, если его выберут минимум 5 студентов из 100.

### Типы отображений

В зависимости от того, каким условиям удовлетворяют эти кардинальные числа, рассматриваются различные конкретные типы отображений.

**1. $R(S_1(0,\infty):S_2(1, \infty)), S_1\to S_2$ -- полностью определённое на $S_1$**

<a href="https://imgbb.com/"><img src="https://i.ibb.co/KsNGqwV/image.png" alt="image" border="0"></a>

Каждый экземпляр множества S1 связан минимум с одним экземпляром множества S2.

Для существования экземпляра множества сущностей S1 необходимо, чтобы он был связан с каким-то одним экземпляром множества сущностей S2 (по крайней мере, одним, но можно и больше)

Такое отображение называется **полностью определённым на S1**: экземпляр S1 не может существовать вне связи с экземплярами S2

#### Неполное функциональное отображение

<a href="https://ibb.co/2y6PvDG"><img src="https://i.ibb.co/yXR56wH/image.png" alt="image" border="0"></a>

Минимальное кардинальное число отображения равно 0, то есть экземпляр из S1 мб не связан ни с каким экземпляром из S2, а максимальное число равно 1 -- то есть максимум можно связаться с одним экземпляром S2. А это значит, что если мы можем берём соответствующий экземпляр из S1, мы всегда можем по нему найти соответствующий экземпляр S2 -- такое отображение называется **неполным функциональным**.


#### Полное функциональное отображение

<a href="https://ibb.co/2vNWsMh"><img src="https://i.ibb.co/6HBr1tw/image.png" alt="image" border="0"></a>

Когда минимальное и максимальное кардинальные числа равны 1, то есть каждый экземпляр из S1 обязательно связан с одним и только одним экземпляром из S2 -- получаем **полное функциональное отображение**: получив некоторый экземпляр S1, мы всегда найдём один единственный экземпляр S2, ему соответствующий -- то есть получаем функцию, которая по значению $x\in S_1$ находит значение $y\in S_2$. 


Эти типы функциональных отображений влияют на типы связи.



## Ограничения целостности

В общем случае модели данных включают в себя представление трёх компонентов:
- **структурные** компоненты, позволяющие описать информационную модель. В них входят отношения сущности и отношения связи.
- **ограничения целостности**, накладываемые на данные
- **манипуляционные характеристики**: база данных представляет собой совокупность реализаций, получаемых путём преобразования, и этот компонент как раз определяет, какие преобразования можно выполнять с данными.

Для описания этих трёх компонент -- структурной, целостной и манипуляционной, в языках, которые предназначены для описания информационной модели, обычно выделяют два подмножества языка:
- язык описания данных, который определяет структуру данных и **статические** ограничения, накладываемые на данные
- язык манипулирования данными, который определяет правила преобразования реализаций, на которые также оказывают влияние ограничения, накладываемые на данные.

**Ограничения целостности** -- логические ограничения, накладываемые на данные (**constraints**) в условиях соответствующей предметной области. Разрабатывая схему БД, на этапе определения связей сущностей и построения диаграмм бывает очень полезно также определять какие-то ограничения, которые накладываются на данные.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/JtR1Wj9/image.png" alt="image" border="0" height="200" align="left"></a>

Рассмотрим, где на каком этапе используются ограничения целостности. У нас есть модель данных МД, средствами которой мы можем представить некоторую совокупность схем баз данных S. Схем в рамках одной модели может быть много: всё определяется той предметной областью, которую мы реализуем; а сама база данных представляет собой совокупность реализаций DBS~i~, удовлетворяющих данной одной и той же схеме, получаемых в результате каких-то преобразований.

На уровне описания данных используется подмножество языка описания данных, а для преобразования реализаций используется подмножество языка манипулирования данными.


На этих этапах и при описании схемы, и при реализации преобразований между отдельными реализациями базы данных действуют какие-то правила, которые определяют допустимые (или достоверные) состояния БД. В силу того, что мы описываем как статические свойства, так и динамические свойства преобразований, ограничения, которые накладываются на данные, тоже делятся на две категории:
- **статические спецификации** выражают правила, которые определяют допустимые (достоверные) состояния БД. Эти правила накладываются на каждую конкретную реализацию БД
- **динамические спецификации** определяют возможные допустимые переходы из одного состояния БД в другое -- преобразования из одной реализации БД в другую: не все такие преобразования могут быть разрешены, учитывая ограничения, накладываемые на данные.

Обычно все логические ограничения, которые накладываются на данные, связаны с состоянием базы данных и включают в себя и статические, и динамические спецификации. 

Допустим мы разработали соответствующую информационную модель, для которой мы определили некоторую совокупность ограничений, накладываемых на данные. Поскольку ограничения связаны со схемой БД, а схеме БД удовлетворяют отдельные реализации, состояния БД, то между ограничением, схемой и состоянием БД существуют определённые зависимости, выраженные следующими определениями:

#### Правила, накладываемые на ограничения целостности C~i~

Ограничение C~i~:
- **правильно построено**, если оно соответствует синтаксическим правилам спецификации ограничений. Для спецификации ограничений в SQL есть средства, которые позволяют эти спецификации указать
- **удовлетворено состоянием DBS~i~** (состоянием БД -- конкретной её реализации), если оно истинно для данного состояния. Поскольку ограничения целостности -- это обычно логические условия, они могут принимать значения истина или ложь, то ограничение удовлетворено состоянием, если для данного состояния ограничение принимает значение истина.
- **удовлетворяемо**, если есть хотя бы одна реализация состояния БД DBS~i~, которая удовлетворяет этому ограничению, то есть на этом состоянии ограничение принимает значение истина.
- **недостоверно**, если никакое состояние базы данных ему не удовлетворяет.

При определении ограничений целостности надо использовать синтаксически правильные конструкции и нужно выбирать такие ограничения целостности, которые соответствуют предметной области, чтобы не оказалось так, что выбранное ограничение будет недостоверным.

#### Правила, накладываемые на конкретную реализацию состояния БД DBS~i~

DBS~i~ -- это конкретный набор данных, удовлетворяющих схеме.
- **удовлетворяет схеме S**, если он удовлетворяет всем ограничениям, определённым для этой схемы. То есть данные не просто структурно удовлетворяют схеме, но ещё должны выполняться и все ограничения целостности, которые для этой схемы сформулированы
- **непротиворечиво**, если оно удовлетворяет всем ограничениям, накладываемым на схему БЖ

#### Правила, накладываемые на схему S

Схема S:
- **удовлетворяема**, если существует некоторое состояние БД, которое удовлетворяет данной схеме
- **противоречива**, если никакое состояние базы данных этой схеме не удовлетворяет.

При проектировании схемы для неё надо определить и какие-то ограничения целостности, и гарантировать, что данная схема не окажется противоречивой, то есть могут существовать реализации, которые удовлетворяют всем ограничениям, накладываемым на данные.

### Манипуляционный компонент

Это правила переходов состояния БД. Они обычно не определяются, а разрабатываются для тех моделей данных, которые лежат в основе некоторой конкретной СУБД, а поскольку для моделей *вообще* никакой реальной СУБД существовать не может, то эту часть мы пока оставим в стороне.

Здесь можно только отметить, что языки манипулирования данными применительно к любой МД делятся на две категории:
- **навигационные** языки, которые учитывают конкретную организацию структуры информационной модели. К ним относятся языки манипулирования данными в иерархической и сетевой МД
- **ненавигационные** языки: чтобы найти нужные данные, достаточно указать, каким свойствам эти данные должны удовлетворять, не указывая конкретного маршрута движения по схеме.



В общем случае применительно к МД ограничения целостности могут быть разделены, в свою очередь, на **внутренние** и **явные**.

**Внутренние** ограничения поддерживаются самой моделью данных. Например, атрибут всегда определён на каком-то домене, а значит, значение атрибута может только принадлежать этому домену. Модель данных сама определяет понятия домена, атрибута, и поэтому своими средствами гарантирует, что атрибут не сможет принимать недопустимые значения. От разработчика БД выявление таких внутренних ограничений не накладывает никаких доп требований на реализацию таких ограничений: контроль за правильным значением того или иного атрибута берёт на себя СУБД, работающая в соответствии с конкретной моделью данных

**Явные** ограничения не мб реализованы МД. Для их реализации разработчику надо создавать какие-то дополнительные конструкции, чтобы проверить соответствующее условие. Например, в предприятии сумма окладов должна быть меньше зарплаты. Так что если предметная область предъявляет какие-то явные ограничения, их надо определить функционально или процедурно, а может быть, с помощью триггера. 


Обязательное условие: на этапе проектирования информационная модель будет представлена в виде FA диаграммы и помимо всего прочего, надо продумать и ограничения целостности: помимо описания отдельных отношений и связей между отношениями, надо сформулировать возможные условия связи: например, водителем автобуса не мб несовершеннолетний и так далее.

## Операции над данными

По своему смыслу эти операции делятся на выборку (чтение, поиск) и модификацию данных -- в основном добавление (хотя можно и удалять, но удаление на практике применяется нечасто, потому что если вдруг надо будет что-то восстановить, а копии нет, то этого сделать уже не получится). Поэтому, как правило, если данные больше уже не нужны и не используются в текущий момент времени, сохраняются в каких-то архивах и исключаются из текущей реализации БД, а при необходимости всегда можно будет обратиться к этим архивным записям.

Организация доступа к данным реализуется языками, которые делятся на две группы: ненавигационные, которые не учитывают конкретную организацию хранения данных на физическом уровне с точки зрения формирования запросов к данным (например, в СУБД на основе реляционной модели данных), и навигационные, которые это учитывают.

# 3. Модель данных "сущность-связь"

## Введение

Это семантическая высокоуровневая модель. Нет ни одной реальной СУБД, в основе которой лежит модель сущность-связь. Есть объектно-ориентированные СУБД, у которых многие характеристики похожи на модель сущность-связь.

Модель была предложена Питером Ченом (P. Chen) в 1976 году. В этом время уже велись интенсивные работы по изучению реляционной модели, поэтому в этой статье используются те же термины, что и в общем описании МД, но их семантика может отличаться: в каждой модели данных подчёркиваются какие-то особенности, которые она накладывает на то или иное понятие.

Прежде всего, он выделил разные уровни представления информации:

#### Уровень 1: информация о сущностях и связях

Этот уровень ориентирован на человека и пытается описать то, что пользователь хочет получить от будущей информационной системы, так что тут информация представлена так, как она существует в представлении людей. 

На этом уровне обычно используется описание на естественном языке, а естественный язык обладает большими степенями свободы, поэтому здесь описание может быть довольно расплывчатым и не очень строгим, а главное -- может иметь разные способы реализации. 

#### Уровень 2: структура информации

Это организация информации, в которой сущности и связи представлены данными -- по сути, выбор способов идентификации конкретных экземпляров сущностей и конкретных экземпляров связей.

#### Уровень 3: структура данных - способ доступа

Это структура данных, независимая от способа доступа к этим данным: чисто на логическом уровне. 

#### Уровень 4: структура данных + способ доступа

Здесь уже учитывается способ доступа к данным.

Чен показал, что для представления информации о сущности и связях, как она существует в нашем представлении (1 уровень) и описания структуры информации на 2 уровне подходит модель данных "сущность-связь". На 3 уровне используется реляционная модель, а 4 уровень соответствует иерархической и сетевой моделям данных.

## Уровень 1

**Сущность** -- нечто, принадлежащее объективной реальности, облаченное в материальную форму или форму идеи; любой объект, который может быть идентифицирован некоторым способом, отличающим его от других объектов, и информацию о котором надо хранить в базе данных.

Сущность -- это нечто, что может существовать реально (например, автомобиль) или в форме идеи (например, банковский счёт -- идея, в которой отражается, кто какие операции с деньгами определяет, или факт продажи -- это идея, которая говорит, что данный материальный товар был когда-то продан за какую-то стоимость).

Важно, что экземпляры сущности всегда могут быть идентифицированы и отличимы друг от друга по каким-то характеристикам.

**Связь** -- некоторая ассоциация, устанавливаемая между двумя или более сущностями.

Модель данных сущность-связь не ограничиваются только бинарным связями: здесь рассматриваются n-арные связи в общем случае.

### Сущность -- Entity

Поскольку сущности -- это нечто, принадлежащее объективной реальности, в результате наблюдения каких-то явлений, выделяется некоторое *множество* сущностей $E = \{e_i\}$. Когда рассматривается это множество, с этим множеством обязательно связывается **предикат** -- правило, на основании которого мы можем определить, принадлежит ли конкретный наблюдаемый объект в реальном мире данному множеству сущностей или нет. Предикат определяет, что может являться экземпляром сущности, а что нет.

Например, если у нас есть множество сущностей-городов, то предикатом для неё может быть какое-то ограничение на численность населения и на площадь.

С учётом свойств множества и предиката определяется **тип** сущности -- некоторое обобщённое представление однородных сущностей. Например, в нашем примере это город. Тогда **экземпляр** сущности  $e_i$ -- это конкретный элемент  множества сущностей $E$.

Если рассматривается термин *сущность* (entity), часто подразумевают конкретный экземпляр множества сущностей. Однако часто с ним связывают и понятие типа сущностей (само множество), поэтому лучше использовать чёткую трактовку. В нашем случае *сущность*  будет интерпретироваться как тип сущностей, то есть название множества сущностей. А если надо обратиться к элементу этого множества, то будем называть это *экземпляром*.

Для каждого множества сущностей определяется некоторый набор свойств, общих для всех сущностей из этого множества. В этот набор в том числе входит и предикат -- правило принадлежности.

### Связь -- Relationship

Поскольку связь -- это ассоциация, устанавливаемая между двумя или более сущностями как множествами сущностей, то каждая конкретная связь -- это связь между конкретными экземплярами сущностей. С другой стороны, этих связей много, и они тоже образуют множество. Поэтому тут, как и в случае с сущностями, есть двоякая трактовка термина связь. 

**Множество связей** -- математическое отношение между сущностями: $$R = \{\lang e_1, e_2, \dots, e_n\rang|e_1\in E_1, e_2\in E_2, \dots, e_n\in E_n\}$$Множество связей представляет собой множество упорядоченных по порядку перечисления сущностей кортежей $\lang e_1, e_2, \dots, e_n\rang$, в которых каждый элемент кортежа $e_i$ принадлежит соответствующему множеству сущностей $E_i$. 

Множество связей -- это характеристика знака, экстенсионал. Есть ещё и внутренняя характеристика -- интенсионал: тип связи. **Тип связи** определяет соответствующую ассоциацию типов сущностей.

Поскольку связь -- это также и множество, то мы можем рассматривать и **экземпляр** связи как отдельный элемент этого множества.

Кроме того, есть ещё одна важная характеристика связей -- **роль сущности в связи $r$** -- функция, которую сущность выполняет в данной связи: $$\lang r_1/e_1, r_2/e_2, \dots, r_n/e_n\rang$$Роль сущности в связи очевидна исходя из того, какие множества сущностей вовлекаются в эту связь. Например, если у нас есть два множества сущностей -- проект и сотрудник организации, то если мы рассматриваем связь -- какой исполнитель над каким проектом работает, то эта связь представляет множество бинарных кортежей вида <проект/e~1~, исполнитель/e~2~>. Поскольку элементы e~1~ и e~2~ извлекаются из разных множеств сущностей, то они уже чётко определяют, какую роль данный экземпляр сущности играет в данной связи: e~1~ -- проект, над которым работает исполнитель, а e~2~ -- исполнитель, который работает над проектом.

В целом ряде случаев при определении связи необходимость в указании роли сущностей в ней отпадает. Хотя есть ситуации, при которых эта роль должна быть очень чётко задана. Например, сущность "денежная единица" и сущность "курс", где имя роли денежной единице в связи с курсом надо обязательно указывать -- из неё переводим или в неё.

Другой пример -- сущность "личность". Если рассматривать связь между личностями  <e~1~, e~2~>, которая выражает отношения между ними, то надо чётко определять, какая сущность какую роль играет: например, e~1~ -- отец, а e~2~ -- ребёнок.

### Значения -- values

Информация о сущностях и связях представляется в виде множества пар "атрибут-значение".

Для этого используется **множество значений - values**, в которые входят
- сами значения
- предикат

Чен переопределил термин "атрибут" по сравнению с общей теорией моделей данных: **атрибут** -- функция, отображающая множество сущностей или множество связей в множество значений $$f:S_i\xrightarrow{f}V_i$$ или декартово произведение множества значений: $$f: S_i\xrightarrow{f}V_{i1}\times V_{i2}\times\dots\times V_{in}$$

### Информация о сущностях

Допустим, мы определили множество сущностей СОТРУДНИК. Далее мы определили некоторую совокупность множеств значений: здесь 5 множеств значений: НОМЕР СОТРУДНИКА, ФАМИЛИЯ, ИМЯ, ОТЧЕСТВО и КОЛИЧЕСТВО ЛЕТ. 

<div align="center"><a href="https://ibb.co/d0qvxnG"><img src="https://i.ibb.co/BVxJF8q/image.png" alt="image" border="0" height="300"></a></div>

Тогда атрибут -- это *функция*, которая отображает множество сущностей на множество значений. Эта функция с каждым экземпляром сущности связывает одно значение из множества значений: например, первый атрибут F~1~ -- это номер сотрудника, который отображает экземпляр сущности СОТРУДНИК на значение НОМЕР СОТРУДНИКА. С каждым экземпляром сущности связано в точности *одно* значение из множества значений -- это полное функциональное отображение.

Множество сущностей СОТРУДНИК отображается на множество значений КОЛИЧЕСТВО ЛЕТ с помощью двух функций, то есть двух атрибутов: возраст сотрудника и стаж его работы.

Также множество сущностей e~1~ отображается на декартово произведение множеств значений, если мы рассматриваем атрибут "полное имя сотрудника", который содержит в себе ФИО.

### Информация о связях

Чен не ограничивается бинарными связями, а рассматривает в общем случае n-арные связи. Например, у нас есть множества сущностей СОТРУДНИК, ПРОЕКТ и множество значений ПРОЦЕНТ. 

<div align="center"><img src="https://i.ibb.co/6mGQVYm/image.png" alt="image" border="0" height="300"></div>

Мы рассматриваем связь -- ассоциацию между сущностями СОТРУДНИК и ПРОЕКТ. Эту ассоциацию мы определяем как "исполнитель проекта" -- мы определяем, какой сотрудник над каким проектом работает. Сотрудников много, проектов тоже много, и множество связей тоже может включать в себя большое количество кортежей.

У каждой связи, помимо всего прочего, могут быть ещё и собственные атрибуты: например, доля времени, которую данный сотрудник затрачивает на работу над данным проектом. Этот атрибут не является атрибутом множества сущностей СОТРУДНИК, ни свойством проекта -- он характеризует именно связь.

## Уровень 2

Поскольку здесь речь идёт уже о возможности идентифицировать каждый экземпляр сущности и каждый экземпляр связи, то эта идентификация означает, как мы можем представить конкретный экземпляр сущности и конкретный экземпляр связи для того, чтобы отличить его от других.

### Представление сущности

Чтобы идентифицировать каждый экземпляр сущности, нужно использовать понятие **первичного ключа** сущности -- совокупность одного или несколько атрибутов, уникальных для каждого экземпляра сущности.

<div align="center"><img src="https://i.ibb.co/x6yQbrv/image.png" alt="image" border="0" height="250"></div>

Если у нас есть множество сущностей СОТРУДНИК и для идентификации сотрудников мы используем множество значений НОМЕР СОТРУДНИКА, в котором каждому экземпляру сотрудника соответствует в точности одно значение, но для ключа важно, что это соответствие является **взаимно однозначным**: то есть с каждым экземпляром сотрудника связано своё уникальное значение из множества значений НОМЕР СОТРУДНИКА, но и наоборот, каждому значению номера сотрудника соответствует только один экземпляр сущности СОТРУДНИК. Поэтому для того, чтобы представить сотрудника, достаточно указать его первичный ключ -- номер сотрудника. 

Для такого представления множества сущностей это самое множество уже не используется. Чен ограничивается просто множеством значений НОМЕР СОТРУДНИКА, потому что зная его, мы чётко определим и сам экземпляр сущности СОТРУДНИК.

Для удобства Чен предложил все эти множества сущностей и связей иллюстрировать с помощью таблиц:

<div align="center"><img src="https://i.ibb.co/Q6r5dCX/image.png" alt="image" border="0"></div>

Раз у нас выделяется колонка первичного ключа, то это гарантирует, что у каждого сотрудника будет свой уникальный номер.

### Представление связи

Для представления связи Чен предложил использовать **первичный ключ связи**. Поскольку связь -- это ассоциация между экземплярами сущностей, то первичный ключ связи здесь создаётся на основе первичных ключей сущностей, вовлечённых в эту связь.

<div align="center"><img src="https://i.ibb.co/FVNZdWf/image.png" alt="image" border="0"></div>

Однако такое представление информационной модели в виде таблицы неудобно: оно громоздкое и не наглядное. Поэтому Чен предложил свой диаграммный язык для представления этой информационной модели.

### Диаграмма сущность-связь

Для представление отношения сущности используется прямоугольник, внутри которого записывается имя множества сущностей.

Для представления связи используется ромбик. Имя множества связей записывается внутри этого ромбика.

Для задания атрибутов используется овал, внутри которого записывается имя атрибута. Атрибуты связываются с соответствующими сущностями или связями. Атрибуты, выполняющие функцию первичного ключа, подчёркиваются.

Рассматриваются два типа сущностей: **регулярное** отношение сущности и **слабое** отношение сущности.

**Регулярное** отношение сущности: для однозначной уникальной идентификации каждого экземпляра сущности в данном множестве достаточно использовать только собственные атрибуты сущности.

**Слабое** отношение сущности -- отношение, в котором для уникальной идентификации каждого экземпляра во множестве сущностей нужно учитывать связь: то, что в IDEF1x определяется как сущность, зависимая по идентификации. Такие сущности обозначаются прямоугольник с двойными границами.

Аналогично связь может быть представлена простым ромбиком или ромбиком со сдвоенными границами, если связь устанавливается со слабым отношением сущности, или, с точки зрения IDEF1x -- идентифицирующая или неидентифицирующая связи.

#### Представление n-арных связей

n-арные связи могут быть представлены так:

<div align="center"><a href="https://ibb.co/Thf16gp"><img src="https://i.ibb.co/HgSC6H1/image.png" alt="image" border="0" height="200"></a></div>

В нотации IDEF1x, которая ограничивается *только* бинарными связями, связь ПОСТАВКА была бы представлена отдельной сущностью ПОСТАВКА.

Наличие таких n-арных связей позволяет в какой-то степени описать предметную область более точно. 

#### Определение связей на одном множестве сущностей

<div align="center"><a href="https://ibb.co/hm74tL4"><img src="https://i.ibb.co/HHFbkBb/image.png" alt="image" border="0" height="150"></a></div>

#### Указание типов связей -- 1:n и n:n

<div align="center"><a href="https://ibb.co/jMmkxjt"><img src="https://i.ibb.co/wWVhb2t/image.png" alt="image" border="0" height="150"></a></div>

#### Слабое отношение сущности

<div align="center"><a href="https://imgbb.com/"><img src="https://i.ibb.co/gjNskHy/image.png" alt="image" border="0" height="150"></a></div>

Каждый сотрудник как член бригады зачисляется в бригаду к какому-то руководителю. Каждый сотрудник предприятия имеет свои уникальные характеристики -- первичный ключ, но для того, чтобы идентифицировать члена бригады, собственная идентификация сотрудника оказывается неприемлемой, потому что один и тот же сотрудник для выполнения разных работ может быть зачислен в разные бригады. Поэтому для идентификации члена бригады приходится использовать собственный атрибут сотрудника плюс атрибут руководителя.

Итоговая диаграмма может выглядеть так:

<div align="center"><a href="https://ibb.co/W3qMx9s"><img src="https://i.ibb.co/N3QJVh7/image.png" alt="image" border="0" height="300"></a></div>

Как видно, диаграммный язык не очень удобный, и сами диаграммы получаются громоздкие, поэтому и самим Ченом, и впоследствии в других организациях были предложены другие языки диаграмм (при этом важно, что изменения касались только самих диаграмм, не затрагивая саму суть модели сущность-связь). Например, мы используем нотацию IDEF1x, которая имеет, пожалуй, только одно принципиальное отличие от ER-модели: в IDEF1x рассматриваются только бинарные связи, тогда как в оригинальной модели допускалось использование в общем случае N-арных связей.


### Ограничения целостности

В общем случае, как уже было сказано, модель данных состоит из трёх компонент.

Первая -- это структурные компоненты, средства, которые позволяют описать структуру -- информационную модуль

Далее, поскольку информационная модель предназначена для отображения процессов и явлений, которые меняются во времени, то модель данных должна предоставлять какие-то средства, позволяющие изменять необходимые данные. Поэтому второй компонент модели данных -- *манипуляционный*, который предназначен для определения допустимых данных, которые хранятся в БД.

Наконец, третий компонент. На данные накладываются некоторые ограничения, поэтому МД должна в том числе и представлять какие-то средства для описания ограничений.

В модели "сущность-связь" манипуляционная часть отсутствует полностью, представлена структурная часть и в достаточно ограниченном виде представлены какие-то средства, позволяющие задавать ограничения целостности. Причём эти ограничения целостности определяются главным образом именно структурными компонентами.

Выделено три вида ограничений, которые задаёт сама модель данных. Если модель данных определяет какие-то ограничения, то это означает, что разработчик не должен предусматривать и прилагать какие-то дополнительные усилия для того, чтобы соответствующие ограничения реализовать.

#### 1. На допустимые значения в множестве значений

Поскольку основной структурный компонент -- отношение -- представляет собой агрегат, построенный на доменах, и включает в себя некоторый перечень атрибутов, каждый из которых определён на доменах -- множествах значений, то значения атрибутов ограничены.

Например, у нас есть множество сущностей СОТРУДНИК, и у каждого экземпляра этой сущности определены два атрибута -- стаж работы, который определён на домене КОЛИЧЕСТВО ЛЕТ, и атрибут "Возраст" сотрудника, который определён на том же самом домене.

<div align="center"><img src="https://i.ibb.co/r7SvNH7/image.png" alt="image" border="0"></div>

Поскольку любое множество задаётся в том числе с указанием правила принадлежности, которое позволяет определить, какие значения могут присутствовать в этом множестве, а какие нет, то если домен КОЛИЧЕСТВО ЛЕТ определён как множество целых неотрицательных значений, то допустимые значения этого домена могут быть такими, как представлено на рисунке. Значит, допустимое значение атрибута -- это любое значение из заданного множества.

Следовательно, могут существовать экземпляры сущности СОТРУДНИК, у которых стаж работы, допустим, равен 12 годам, а возраст равен 29 годам, или возраст 29 лет и стаж работы 33 года. Все эти значения допускаются, поскольку они принадлежат соответствующему домену, но с точки зрения предметной области это бессмысленно.

#### 2. На разрешённые значения некоторых атрибутов

Поэтому вторая категория ограничений целостности -- ограничения на разрешённые значения некоторых атрибутов. Они обычно задаются какими-то другими средствами, очень часто для этого используется язык исчисления предикатов. В данном случае ограничение записывается на естественном языке, и дополнительные разрешённые значения атрибутов могут устанавливать некоторые соотношения между значениями атрибутов.

Например $$(Возраст(e)\geq17) \land (Возраст(e)\leq 70) | \forall e\inСОТРУДНИК$$

#### 3. На существующие значения в базе данных

То есть когда каждое из этих значений могут существовать в базе данных по отдельности, а в совокупности уже не могут.

<div align="center"><img src="https://i.ibb.co/30TxP55/image.png" alt="image" border="0"></div>

Здесь сумма бюджетов всех отделов предприятия не должна превышать бюджет самого предприятия.


Специфика модели ER заключается в том, что раз она ориентирована на человека, то все определяемые в ней ограничения записываются в виде, понятном человеку, и обычно записываются на каких-то языках, которые не являются языками описания модели. 

# 4. Реляционная модель данных

## Общая характеристика


Разработана сотрудником IBM Коддом в 1969-70 гг. Она появилась раньше, чем модель данных сущность-связь, поэтому Чен, естественно, использовал какие-то термины и понятия из реляционной модели данных. Тут мы будем использовать те же понятия атрибута, отношения, ключей и так далее, но для каждой МД эти понятия чем-то чуть-чуть отличаются.

Реляционная модель обладает рядом неоспоримых достоинств, благодаря которым до сих пор современные самые популярные СУБД построены на реляционной модели данных, хотя, например, СУБД Oracle использует объектную модель данных.

Достоинствами этой модели являются:

-   Относительно небольшой набор абстракция для описания предметной области
- Модель базируется на мощном математическом аппарате, что позволяет обосновать все возможности использования модели данных
-   К моменту, когда была опубликована статья Кодда о реляционной модели, ИС уже создавались, но классификация модели данных Чена появилась примерно в середине 70-ых: до того, как модели данных были названы сетевой или иерархической, эти термины по сути не использовались. Когда появились разные модели данных для описания структуры, они и получили свои названия: в частности, реляционная модель данных получила название реляционной
-   Для манипулирования данными (реляционная МД разрабатывалась уже с целью её использования в реальных системах управления данными) эта модель данных должна обязательно включать в себя все три компонента: и структуру, о ограничения целостности, и манипуляционный компонент. Поэтому в РМД были описаны соответствующие операции манипулирования данными, которые были определены как ненавигационные: чтобы получить доступ к элементам данных, пользователю или разработчику совсем не обязательно знать, как эти данные реально хранятся во внешней памяти -- а это то, что необходимо для иерархической и сетевой МД. Чтобы найти нужные данные, достаточно просто задать те свойства, которым они должны удовлетворять, а как они будут найдены -- это дело конкретной СУБД.

РМД, несмотря на такие очень важные достоинства, обладает и рядом недостатков, в результате чего позднее, когда появилась необходимость решать дополнительные задачи, которые РМД решает не очень хорошо, появились другие системы управления данными NoSQL -- системы, в основе которых лежит не язык SQL. (Язык SQL -- ярчайшая характеристика РМД, поэтому в основе NoSQL систем лежит не РМД) 

Недостатки РМД

-   Возможности РМД не безграничны, и при использовании таких систем в некоторых областях применения, которые требуют очень сложных структур данных -- например, а САПР, РМД никакого выигрыша не даёт, а может быть, даже даёт и проигрыш, увеличивая время отклика таких систем. В таких системах используются какие-то другие МД и способы организации хранения данных
-   РМД не даёт возможности адекватного отображения семантики предметной области. Хотя с одной стороны появление таких СУБД ставило перед собой соединение значений данных с их семантикой, в полном объёме точно отобразить семантику предметной области при использовании РМД, увы, не удаётся.

Все современные СУБД, даже MySQL (которые уже не реляционные), используют некоторые элементы реляционной модели данных. Поэтому, кстати, MySQL не приветствуется в этом курсе, там многие вещи реализуются на уровне приложения. Так как мы рассматриваем БД как способ организации и хранения данных в транзакционных (OLTP) системах, в таких системах главное внимание уделяется проблеме **целостности** данных, так чтобы целостность и достоверность данных обеспечивалась самими СУБД, а на уровне прикладных программ разработчики не занимались проблемами обеспечения целостности. Если эти проблемы выносятся на приложение, то с течением времени может потребоваться разработка новой прикладной программы, а ограничения все могут забыть, в результате чего в БД могут появляться данные, которые по-хорошему не должны появляться в них. Поэтому в OLTP-системах, которые в своей основе используют РМД, реляционные СУБД гарантируют целостное состояние базы.

В общем случае структурная и целостная части в МД описываются как бы одной частью модели, для которых используется подмножества языка описания данных (DDL): DDL позволяет не только описать данные, но и описать те ограничения, которые на них накладываются.

Второе подмножество языков - это язык манипулирования данными (DML). Манипулирование данными, в свою очередь, тоже учитывает те ограничения, которые накладываются на данные.

Особенностью РМД является то, что в ней уже определена манипуляционная часть. Она содержит конкретный набор операций, которые можно применять для манипулирования данными, какую-то функциональность, и в SQL есть средства, которые позволяют описать все три компоненты модели данных.

Ещё одним несомненным достоинством РМД является то, что все СУБД, построенные на этой модели, используют единый язык SQL, в котором объединены и средства описания данных, и средства манипулирования данными, и даже какие-то средства описания ограничений.

## Структурные компоненты

<div align="center"><img src="https://i.ibb.co/JHL073D/image.png" alt="image" border="0"></div>

Здесь все домены разделены на две категории -- простые и составные. **Простой** домен -- домен, элементы которого атомарны и не имеют внутренней структуры.

**Составной** домен -- это отношение, построенное на простых доменах. Но домены, использующиеся в этом отношении, никаким специальным образом не обозначаются.

### Отношение

Даны $D_1, \dots, D_n$.

Отношение -- это $$\{\lang d_1, d_2, \dots, d_n\rang|d_i\in D_i, i=\overline{1, n}\}$$

В РМД семантика отношения сужается - это не любое отношение, которое мб определено в математической теории отношений. Это агрегат, построенный на доменах. Здесь рассматривается некоторая совокупность доменов, и отношение - это неупорядоченное множество упорядоченных кортежей вида d1 … dn в котором каждый элемент кортежа принадлежит соответствующему домену: соответствие устанавливается по порядку перечисления.

В РМД отношение определяется точно так же, как и в теории множеств. 

Но далее Кодд уже чуть-чуть меняет окраску понятий. Домен -- это множество элементов. Отношение -- агрегат, построенный на доменах. А далее он уточняет понятие атрибута:

**Атрибут** -- способ использования домена в отношении. 

Тем самым с атрибутом связывается некоторая семантика, что как раз и позволяет в таких системах соединить значения, факты и их семантику -- способ обработки этих значений.

**Схема отношения** -- именованная совокупность пар <имя атрибута : имя домена>

Например, если у нас определены домены ЧИСЛО и СТРОКА, то мы можем ввести схему отношения ОТДЕЛ, которая может включать себя бинарные кортежи. Первый элемент кортежа задаёт способ использования домена ЧИСЛО в отношении ОТДЕЛ (задаётся номер отдела), а второй элемент кортежа Название задаёт способ использования домена СТРОКА в отношении ОТДЕЛ:

> ОТДЕЛ (Номер отдела: ЧИСЛО, Название: СТРОКА)

#### Свойства отношения

Поскольку само понятие отношения активно используется в математической теории множеств и в РМД, с ним связан целый набор свойств. Какие-то из них определяются как свойства из математической теории множеств: 
- Кортежи внутри отношения не упорядочены. Это обычное правило теории множеств: элементы множества не упорядочены
- Домены внутри кортежей упорядочены, потому что соответствие между элементами кортежей и доменами устанавливается именно по порядку следования.

#### Свойства отношения РМД

Кроме того, отношения, которые уже определяются в РМД, имеют целый ряд дополнительный свойств, которые отсутствуют в математической теории отношений.

-   Атрибут отношения обязательно уникален: в отношении не могут появиться два атрибута с одним названием
-   Атрибут должен быть определён на каком-то одном домене
-   На одном и том же домене могут быть определены несколько атрибутов
-   Имя атрибута может совпадать с именем домена, если в этом есть надобность
-   Порядок следования атрибутов определяется порядком следования доменов, когда определяется отношение
-   Каждый кортеж отношения РМД уникален (этого нет в математической теории), то есть в множестве отношения не могут появиться два одинаковых кортежа
-   Порядок следования кортежей не устанавливается
-   При определении схемы БД, которая определяется совокупностью схем отношений, а схема отношения -- это именованная совокупность пар, то есть у каждого отношения есть своё имя. В конкретной схеме БД имя отношения должно быть уникально: мы не можем в БД создать два отношения с одинаковыми именами.

### Нормализация отношения

Далее введено очень важное понятие, с которым явно мы не сталкивались, но которое обязательно учитывается при проектировании РБД -- это **нормализация**.

#### Ненормализованное отношение

Отношение **нормализовано**, если каждый атрибут отношения определён только на простом домене.

Рассмотрим ненормализованное отношение:

> СОТРУДНИК(Номер сотрудника: ЧИСЛО, Имя: СТРОКА, Зарплата: ИСТОРИЯ ЗАРПЛАТЫ)

В этом отношении определено три атрибута
- Номер сотрудника определён на простом домене ЧИСЛО
- Имя сотрудника определено на просто домене СТРОКА
- А вот Зарплата сотрудника определена на *составном* домене ИСТОРИЯ ЗАРПЛАТЫ

Тогда конкретная реализация такого отношения может выглядеть в виде такой таблицы:

| Номер сотрудника | Имя | Зарплата
|--|--|--
1 | Иванов | $\begin{array}{c}1985,&500\\2000,&1000\end{array}$
2 | Петров | $\begin{array}{c}1985, &850\\2000, &500\\2003, &1000\end{array}$

Видно, что значения атрибута ЗАРПЛАТА не атомарные: мало того, что они могут включать в себя несколько значений (несколько строчек), но ещё и каждая строчка имеет свою сложную структуру. Таким образом, этот атрибут ЗАРПЛАТА определён на составном домене, и такое отношение является *ненормализованным*.

В реляционной базе данных все отношения должны быть нормализованными, поэтому такое отношение в  таком виде в ней существовать не может. 

#### Нормализованное отношение

Но такое ненормализованное отношение очень легко нормализовать, если атрибут Зарплата, который был определён на составном домене, заменить атрибутами, которые использовались для формирования этого составного домена, -- год и выплаты, и для каждого элемента составного домена значения всех других атрибутов повторить:

| Номер сотрудника | Имя | Год | Выплаты
|--|--|--|--|
1 | Иванов | 1985 | 500
1 | Иванов | 2000 | 1000
2 | Петров | 1985 | 850
2 | Петров | 2000 | 500
2 | Петров | 2003 | 1000

И в результате нормализации отношение из всего двух строк преобразовалось в отношение из 5 строк.

Есть два эквивалентный определения нормализованного отношения:
- **Нормализованное** отношение -- отношение, в котором не используются составные домены
- **Нормализованное** отношение -- отношение, в котором каждое значение атрибута является атомарным, или все атрибуты определены только на простых доменах.

Как видно, ненормализованные отношения очень легко можно преобразовать в нормализованные: да, памяти может потребоваться больше, но, тем не менее, СУБД Oracle -- первая СУБД на основе РМД,
с течением времени от этой теории нормализованных отношений чуть чуть отошла в сторону: там можно определять атрибуты на составных доменах, создавая собственные составные домены. В некоторых случаях для некоторых предметных областей такое решение может быть эффективным.

### Представление сущности


**Ключ**  - совокупность атрибутов, однозначно идентифицирующих каждый кортеж отношения. Другими словами, в отношении не могут появиться разные кортежи, у которых значения ключевых атрибутов совпадают.

Поскольку для каждого отношения может быть определено несколько наборов ключевых атрибутов, то они могу быть разделены на два подмножества:
- **Первичный ключ** PK -- это подмножество включает в себя единственный набор уникальных атрибутов, для которого характерна **не избыточность** (то есть это уникальный набор атрибутов) и **неприводимость** (то есть мы не можем из атрибутов ПК удалить какой-то атрибут так, чтобы уникальность оставшегося ключа при этом не изменилась)
-   Если в отношении есть несколько наборов ключевых атрибутов, какой-то набор мы определяем в виде ПК, а все остальные в виде **альтернативного ключа** АК. Например, для кафедры есть ПК - номер кафедры и АК название кафедры.

> КАФЕДРА (<u>Номер кафедры</u>, Название (АК))

Первичный ключ в теле отношения подчёркивается.

На основе ПК строятся индексы, которые представлены в виде В - дерева. Чем больше ключей мы можем разместить в одном узле В-дерева, тем более низким оно будет. А поскольку все узлы дерева размещаются во внешней памяти, для реализации поиска по дереву СУБД приходится каждый раз обращаться к внешней памяти за очередным узлом. Поэтому чем ниже дерево (чем большее количество ключей может разместиться в одном узле дерева), тем эффективнее будет БД.

Если ключ числовой, то в одном узле можно разместить много таких ключей. А если ключ представляет собой строку, да ещё и если длина её может быть разной, то в одном узле дерева будет размещаться меньшее количество индексов. Поэтому в реальности, если у отношения есть собственный ключевой атрибут, но он не удобен для представления в системе: длинная текстовая строка, или что-то ещё, то часто для таких сущностей вводят суррогатный ключ (в данном случае номер кафедры), который, как правило, числовой, что позволяет повысить эффективность работы с системой.

Представление сущности означает возможность уникальной идентификации каждого кортежа отношения по его атрибутам. Вообще говоря, так как отношения обладают таким свойством, что дубликатов кортежей у них нет, то в принципе вся схема отношений целиком является уникальной, и значит, может рассматриваться как ключ. Но чаще всего такое представление избыточно, так как всегда можно выделить какое-то подмножество атрибутов, которое позволяет уникально идентифицировать каждый кортеж в отношении. Значит, вся схема отношения, по сути, -- это альтернативный ключ.

### Представление связи

В РМД для представления связи рассматривается особы итп ключа -- внешний ключ.

**Внешний ключ** -- FK -- это атрибут или некоторое множество атрибутов отношения R~1~, которые не являются собственными атрибутами отношения R~1~ (они используются лишь для того, чтобы установить связь этого отношения с каким-то другим отношением), но их значение совпадает со значениями первичного ключа некоторого отношения R~2~ (при этом возможность идентичности R~1~ и R~2~ не исключается, например, в иерархических связях).

#### Представление связи 1 : n

<div align="center"><img src="https://i.ibb.co/GnFPL7V/image.png" alt="image" border="0"></div>

Например, здесь сотрудник работает в каком-то конкретном отделе. Номер отдела,  в котором работает сотрудник, не является собственным его атрибутом. Он просто отражает связь с отделом. Значение атрибута номер отдела будет совпадать со значением ПК в отношении отдел.

Рассматривается ситуация, когда в одном отделе мб 0 или больше сотрудников, но сотрудник в конкретный момент времени работает только в одном отделе (тут не рассматривается временной фактор).

Эта связь не очень удобна, поэтому появились другие разновидности модели ER, которые отличаются только диаграммным языком, например IDEF1x.

<div align="center"><img src="https://i.ibb.co/yy1gBR4/image.png" alt="image" border="0"></div>

Это представление связи на уровне данных. Чтобы определить, в каком отделе работает сотрудник, для отношения сотрудник вводится атрибут внешнего ключа номер отдела: самого сотрудника этот атрибут никак не характеризует, он характеризует именно его связь с отделом, в котором в данный момент времени работает данный сотрудник.

<div align="center"><img src="https://i.ibb.co/f0TTvCf/image.png" alt="image" border="0"></div>




Если мы хотим использовать ФК для идентификации сотрудника, то он мигрирует в ПК сотрудника и связь будет сплошной, а не пунктирной.

#### Представление связи n : n

<div align="center"><img src="https://i.ibb.co/TK9ZvLQ/image.png" alt="image" border="0"></div>

Между поставщиком и деталью устанавливаем связь ПОСТАВКА типа многие ко многим. При этом связь у Чена представляется отдельной фигурой - ромбиком и у неё мб свои атрибуты.

В РМД мы сталкиваемся со следующим: у нас есть отношения ПОСТАВЩИК и ДЕТАЛЬ, и мы должны каким-то образом представить связь многие ко многим. Мы не можем включить внешний ключ ни в отношение ПОСТАВЩИК, ни в отношение ДЕТАЛЬ, потому что значения атрибутов должны быть атомарными. В этом случае эта связь типа многие ко многим представляется собственным отдельным отношением, которые включает в себя два атрибута внешнего ключа. 

<div align="center"><img src="https://i.ibb.co/pJkMvWR/image.png" alt="image" border="0"></div>

Первичным ключом отношения связи будет составной ключ, включающие номер поставщика и номер детали. Этот ПК составляется из двух ФК, каждый из которых устанавливает связь с конкретным отношением.

<div align="center"><img src="https://i.ibb.co/bbnjDsG/image.png" alt="image" border="0"></div>

Поскольку связь типа многие ко многим представляется собственным отношением, эта особенность как раз и реализована в нотации IDEF1x: если мы на диаграмме ER определили где-то связь многие ко многим, то на след этапе проектирования мы на этом этапе избавляемся от такой связи

<div align="center"><img src="https://i.ibb.co/yf947rK/image.png" alt="image" border="0"></div>

Такую схему легко преобразовать к представлению в РМД. Поэтому эти разные языки диаграмм ориентированы на то, чтобы в рамках реляционной СУБД все необходимые объекты информационной модели можно было представить достаточно легко.

### Ограничения целостности

РМД используется уже в конкретных информационных системах, поэтому она содержит средства, позволяющие задать ограничения, накладываемые на данные.

<div align="center"><img src="https://i.ibb.co/GtzCcMH/image.png" alt="image" border="0"></div>

Манипуляционная часть, поскольку она изменяет состояние значения отношения, она какой-то частью может нарушить те ограничения, которые накладываются на данные. Поэтому когда рассматриваются ограничения целостности в РМД, их принято делить на дву группы: **целостность сущностей**, которая определяет, какие значения могут быть занесены в отношения сущности, и **ссылочная целостность** -- ограничения, которые накладываются на манипуляцию, на изменение данных: может ли быть выполнено такое изменение или нет.


Этти две группы целостностей могут быть заданы следующим образом:

#### Целостность сущностей
- Если мы какой-то атрибут или группу атрибутов определили как ПК, тем самым мы гарантируем, что в нашем отношении не могут появиться кортежи с одинаковыми значениями атрибутов этого первичного ключа -- **ограничение первичного ключа**
- Аналогично, если мы в сущности определили какие-то альтернативные ключи, они тоже являются уникальными -- **уникальность других атрибутов**
- **Обязательность значений атрибутов `NOT NULL`**: мы можем подчеркнуть, что значения каких-то атрибутов обязательно должны присутствовать в каждом кортеже отношения. И наоборот, если мы допускаем отсутствие значения атрибута, можно указать ключевое слово `NULL`
- **Допустимость значений атрибутов `CHECK`**: при всех операциях проверяется соответствующее ограничение, и если данные этому ограничению не удовлетворяют, они не появятся в отношении.

#### Ссылочная целостность

<div align="center"><img src="https://i.ibb.co/xDqGrpb/image.png" alt="image" border="0"></div>

Внешний ключ -- это **ссылка** на какую-то запись родительского отношения. Поэтому те правила, которые накладываются на связи разных сущностей, определяются как *ссылочная целостность*.

Например, между отношениями ОТДЕЛ и СОТРУДНИК определена связь: ОТДЕЛ состоит из нуля или большего количества сотрудников. Отношение, которое стоит на конце связи "один", получило название **родительского** отношения; отношение на конце связи "много" --  **дочернего**.


Нарушение ограничений может возникнуть, когда с родительским или дочернем отношением выполняются какие-то действия -- *манипуляции*. Манипуляции в реляционных БД предполагают выполнение одной из трёх операций -- **вставки** нового кортежа, **удаления** существующего кортеже или **модификации** -- изменения значений атрибутов существующего кортежа.

При этом на ссылочную целостность может повлиять только модификация ключевых атрибутов: внешний ключ дочернего отношения должен совпадать с первичным ключом родительского отношения. Поэтому если мы в родительском отношении изменяем значение ключа в каком-то кортеже, то такая модификация оказывает влияние на ссылочную целостность.

Вообще говоря, именно поэтому менять первичный ключ сущности не очень хорошо. Но если такая ситуация возникает, но надо обеспечить ссылочную целостность, или просто запретить модификацию первичного ключа.

При создании БД надо определить все такие ограничения, чтобы гарантировать, что никакое изменение в базе не приведёт к нарушению целостности.

##### Операции с дочерним отношением

- **Вставка**: значение FK должно быть корректно и ссылаться на какое-то конкретное значение первичного ключа в родительском отношении. Если при вставке неправильно задаётся значение внешнего ключа (то есть в родительском отношении нет кортежа с соответствующим значением первичного ключа), такая запись не должна вставляться
- **Удаление** без каких-либо ограничений (хотя тут надо думать о сохранении истории, поэтому вместо тупого безвозвратного удаления можно просто перенести кортеж в другую табличку)
- **Модификация FK**: новое значение FK также должно быть корректно

##### Операции с родительским отношением

- **Вставка** -- без ограничений
- **Удаление** -- надо указать реакцию на связанные записи: что делать с теми записями, которые ссылаются на кортеж
	- не удалять -- самый частый вариант, вообще это вариант по умолчанию. Если тем не менее запись надо удалить, надо сначала что-то сделать с теми записями, которые ссылаются на удаляемую (удалить их самих или изменить им ПК), и только после этого удалять родительскую сущность
	- удалить все -- как правило это делается на уровне процедуры, потому что если менять состояние БД с помощью некорректной операции, то восстановить исходное состояние бывает сложно. Так что такие рисковые операции выполняются на уровне процедур, которые могут проверить правильность предполагаемых действий
	- установить пустое значение (отсутствие связи), если в атрибуте FK дочерних сущностей указано ограничение 	`NULL`, то есть ему разрешено быть пустым. 
- **Модификация ПК** -- реакция аналогична
	- не модифицировать
	- модифицировать все значения внешнего ключа, ассоциированные с этой записью
	- установить пустое значение


Неслучайно реакция по умолчанию -- не делать ничего. Если нужно что-то другое, то это достигается с помощью процедур, основанных на бизнес-логике, чтобы предотвратить возможные проблемы. В БД накапливается информация, которая отражает длительность предприятия за длительный срок, и если эта информация будет искажена, то БД будет хранить информацию, не соответствующую реальным условиям функционирования предприятия, посему дальнейшее использование такой испорченной базы будет только во вред.

### Язык описания данных

Существуют СУБД, в основе которых лежит РМД. Для таких МД был разработан язык, включающий в себя подмножества ЯОД и ЯМД. 

Поскольку отношение -- агрегат, построенный на доменах, то ЯОД должен каким-то образом позволить создавать или определять домены, позволять создавать и отношения, и, поскольку при создании отношения мы можем указать какие-то ограниения, ЯОД должен позволять нам определять ограничения целонстности.

Все современные диалекты SQL позволяют создать отношения и ограничения целостности. Где-то можно определить домены, но, как правило, вместо доменов в них используются типы данных.

4.22

Структурный компонент РМД |Элемент РБД
--|--
Домен | Тип данных
Отношение | Таблица
Атрибут | Колонка таблицы
Кортеж отношения | Строка таблицы

Тип ограничения целостности | Представление в SQL
--|--
Первичный ключ | `PRIMARY KEY`
Уникальность значения (альтернативные ключи)| `UNIQUE` 
Обязательность значения | `NULL` / `NOT NULL`
Допустимость значения | `CHECK`
Ссылочные ограничения | 	`FOREIGN KEY`


Ограничение `NULL` в языке SQL не эквивалентно использованию слова `NULL` в С. Если мы говорим, что значение какого-то атрибута может быть опущено, это значит, что значение этого атрибута отсутствует **физически** и не заменяется никаким специальным значением -- его просто нет.

```sql
create тип_объекта
drop тип_объекта
alter тип_объекта

типы объектов:
database	index
table		trigger
view		procedure
...
```

Если мы определяем какие-то атрибуты как `UNIQUE`, то СУБД сама создаёт индексы для облегчения поиска по этим ключам.

Триггеры используются для поддержания тех ограничений целостности, которые не мб представлены средствами SQL -- например, проверка значений строк в других таблицах.

Для обеспечения бизнес-логики используют процедуры, чтобы было удобнее выполнять соответствующие операции бизнес логики.

Триггеры и процедуры разрабатываются разработчиками системы, которые имеют неограниченный доступ к базе. Поэтому надо следить за тем, чтобы это всё было корректно -- так, чтобы процедуры было легко использовать тем, кто не шарит в БД.

В первых версиях РСУБД разработчики создавали для каждой конкретной СУБД свой язык. Но со временем возникла необходимость в определении стандарта. Этот стандарт был принят, но к тому времени уже были РСУБД, которые использовали какие-то свои языки, так что по отношению к каждой СУБД используется термин **диалект SQL**: в каждой конкретной СУБД реализация языка SQL немного отличаются -- как правило, типами данных и некоторыми особенностями синтаксиса. Но основные  операции у всех диалектов одинаковые.


#### Создание таблицы

```sql
CREATE TABLE имя_таблицы (
	имя_колонки тип_данных
	ограничения_на_колонку,
	...
	табличное ограничение,
	...
)
```

В соответствии со стилем кода рекомендуется писать все зарезервированные слова SQL капсом, а все собственные имена -- буквами нижнего регистра.

Несмотря на то, что в РМД порядок атрибутов не важен, в РБД в таблице колонки упорядочены и размещаются в порядке их перечисления в предложении `CREATE TABLE`.

Запятая ставится после ограничения на колонку: сначала мы полностью описываем колонку, и только после этого ставим запятую.

Некоторые ограничения не удаётся представить в виде колоночных ограничений -- обычно это те, которые связаны с несколькими колонками, например, составные ключи. Такие ограничения оформляются как табличные, и это отдельная фраза в предложении `CREATE TABLE`, которая тоже заканчивается запятой.

После предложения `CREATE TABLE` можно указывать `;`, но это зависит от диалекта.

#### Ограничение на колонку

Ссылочное ограничение (FK)
```sql
... REFERENCES родительская_таблица (имя_PK_в_родительской_таблице)
	ON DELETE реакция

Реакция:
RESTRICT	(NO ACTION) -- не выполнять операцию
CASCADE -- удалить все записи из дочерней таблицы
SET NULL -- разрешается только если FK может быть пустым
```

Имя PK в родительской таблице можно не писать, если имена ПК и FK совпадают.


#### Табличные ограничения

```sql
имя_ограничения (PRIMARY KEY, UNIQUE, CHECK, FOREIGN KEY, etc) (список_колонок_таблицы) -- порядок должен строго соответствовать порядку перечисления колонок при создании таблицы
	REFERENCES родительская_таблица (PK_из_родительской_таблицы) -- если имена атрибутов совпадают, то РК можно не указывать. Если нет, то их надо перечислять и порядок перечисления должен быть одним и тем же
	ON DELETE реакция
```

Другие ограничения:
```sql
UNIQUE / CHECK / PRIMARY KEY (список_колонок_таблицы)
```

### Объект последовательность

Когда мы работаем с БД и в таблице определяем атрибуты ПК при вставке новых строк в эту таблицу надо гарантировать, что ПК будет каждый раз принимать новое значение. Для этого чень часто используются какие-то средства, позволяющие определять автоинкрементный тип данных.

```sql
CREATE SEQUENCE имя_последовательности
	AS целочисленный_тип
	START WITH константа
	INCREMENT BY константа -- шаг изменения последовательности
	MINVALUE КОНСТАНТА | NO MINVALUE
	MAXVALUE константа | NO MAXVALUE
	CYCLE | NO CYCLE
	CACHE константа | NO CACHE -- если указываем CACHE константа, это значит, что при первом обращении к последовательности указывается не одно значение последовательности, а несколько
	--
```


<!--stackedit_data:
eyJoaXN0b3J5IjpbMTMwNjk2Nzg3OCwxNTYzMTc4MTQ2LC04MD
gzNDY5MjgsNjk4MzAwNjk5LC0yNTAzNzU2OTcsNTM3MDE1NDE2
LDE2Mjk3Mjc1MTcsMjA0MDM4MjM4OSwtMTQ5OTI1NTk5MiwtMT
kxMzQ3MDUzMCwtNTU2MzQ1OTQ0LC0xMTQzNzQ3NjIsLTgzMzAz
NzkxMSwxOTgwMzQ0MTQ0LC05MDM3NTk3NTYsLTEzNjA0NDI4OT
IsMTAzNjY3NjExMCwzOTI2NjE4ODYsNDY5OTAzMzg2LDExNTIw
Mzc1OTldfQ==
-->