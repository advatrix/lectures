## Содержание курса

| Этапы жизненного цикла | Используемые средства
|--|--|
Проектирование | Модели данных, модель "сущность-связь"
Разработка | Реляционная модель данных
Реализация | Язык SQL конкретной СУБД; внутренние структуры хранения



В этом семестре мы будем проектировать базу данных как часть некоторой информационной системы. Обычно информационные системы создаются для решения задач, специфических для предметной области; они используются для поддержки текущей деятельности предприятия, а поскольку для этого требуется хранить большие объёмы информации, то если раньше она хранилась в бумажном виде, сейчас это, конечно же, неудобно, и она сохраняется в электронном виде на машинах.

Если посмотреть на историю вычислительной техники, то первые вычислительные машины были построены в конце 40-ых - начале 50-ых годов прошлого века, и получили название **вычислительные**, потому что они изначально разрабатывались для организации и автоматизации вычислительных работ: необходимо было обрабатывать большие объёмы данных, получаемых в результате физических экспериментов.

Но поскольку в состав вычислительной системы входят в том числе и средства, позволяющие надёжное и долговременное хранение данных, то такие вычислительные системы почти сразу же стали активно использоваться для разработки **информационных систем**, целью которых является накопление, обработка и долговременное хранение больших объёмов информации. Естественно, центральной частью таких ИС стали системы хранения данных. Первые варианты таких СХД получили название **базы данных**.

ИС, которые были разработаны для поддержки текущей деятельности предприятия, получили название **транзакционных систем** *(OLTP -- OnLine Transaction Processing  --  системы обработки транзакций)*. Это связано с тем, что текущая деятельность предприятия предполагает выполнение большого количества однотипных операций, которые получили название **транзакции**. Соответственно, в этом курсе мы рассматриваем проектирование баз данных, используемых в транзакционных системах.

Применительно к базам данных можно выделить некоторые этапы жизненного цикла -- проектирование, разработка и реализация.

Для описания данных, которые хранятся в БД, используется **информационная модель**, которую на разных этапах жизненного цикла можно описывать разными средствами.

На этапе **проектирования**, когда мы разрабатываем саму информационную модель, ориентируясь на предметную область, обычно используются **модели данных**, которые явились развитием модели "сущность-связь" (ER), которая удобна тем, что она имеет свой диаграммный язык, с помощью которого эту модель легко представить, и она понятна. 

Здесь стоит отметить, что разработчик ИС, как правило, не является конечным её пользователем. Если он является специалистом в области IT, то конечный пользователь таковым специалистом не является, зато он хорошо погружён в предметную область, в отличие от разработчика. Поэтому на этапе проектирования разработчик должен представить информационную модель в виде, который может понять пользователь, и учесть все их пожелания.

Сегодня на этапе проектирования мы используем не саму модель данных, а её модификацию -- модель **IDF1X**. Такую диаграмму уже легко перевести на язык реляционной модели данных.

Так как БД предполагают хранение больших объёмов данных на внешней памяти, а для её обработки нужно выгружать данные в ОП, то возникает вопрос производительности таких систем: объёмы данных в ОП очень большие, и как найти то, что нас интересует с тем, чтобы пользователь, формирующий какой-то запрос, не просиживал перед чёрным экраном недопустимо долгое время? Поэтому очень важно понимать, как организуется хранение данные во внешней памяти так, чтобы время отклика системы было приемлемым. Для таких ИС главными требованиями являются два (и они очень часто вступают друг с другом в противоречия):
- обеспечить целостность и достоверность информации
- обеспечить приемлемое время отклика

# 1. Модели данных. Общая характеристика

На разных этапах проектирования и разработки ИС используются разные модели данных, которые, в сущности, описывают одно и то же. Поэтому очень часто в разных моделях данных для обозначения каких-то схожих понятий используются одни и те же термины, но семантика в них может отличаться.

Что такое информация и как она используется? Конкретные ИС предназначены для поддержки текущей деятельности предприятия, которое опирается на какие-то внешние явления. Эти внешние явления, которые представляют интерес для предприятия, должны быть каким-то образом описаны. Для этого обычно используется понятие **данных**, с которыми связаны две характеристики:
- конкретные значения данных, то есть **факты**: 127, 7 февраля, ...
- **семантика** -- интерпретация, смысл значений: вес груза в кг, начало весеннего семестра, ...

При этом важно, что семантика определяет ещё и возможные операции над данными: например, если 12 -- это номер сотрудника, то его нельзя складывать, а можно только сравнивать, и т.д.

Обычно в памяти вычислительных машин мы храним только факты, при этом семантика отрывается от них. Этот отрыв в целом ряде случаев весьма усложняет обработку фактических значений.

Когда используется термин **информация**, то обычно он предполагает соединение фактов и их семантики. Если мы описываем их на естественном языке, это позволяет объединить их, получив "вес перевозимого груза 167 кг". Но для хранения на машине такое использование естественного языка считается невозможным.

Очень часто для удобного представления информации используется табличный способ -- например, расписание занятий, где названия строк  и столбцов задают семантику, а значения на их пересечениях -- факты.

### Файловые системы

Первые разновидности ИС организовывали хранение фактов именно в файлах, а семантику -- в прикладных программах, с помощью которых можно было вытащить конкретные факты из файлов и соответствующим образом обработать. Поэтому доступ к данным в таких системах осуществлялся только через прикладные программы.

**Файловые системы** -- набор программ, выполняющих операции, связанные с обработкой данных. При этом каждая программа, которая включается в такую файловую систему, по сути определяет свои собственные данные и управляется своими собственными данными.

#### Недостатки

Файловые системы обладают существенным рядом недостатков, которые привели к необходимости разработки каких-то других типов ИС.

- разделение и изоляция данных: интерпретация данных осуществляется прикладной программой ⇒
- дублирование данных: одни и те же данные могут дублироваться в разных программах, работающих с одними данными но решающих разные задачи
- зависимость от файлов: прикладные программы обрабатывают файлы с жёстко заданной структурой, и мы не можем перевести программу на обработку файлов другого типа
- несовместимость данных: обычно дата-время представляется либо в виде структуры, либо в виде строки
- фиксированные запросы к данным: в программу жёстко закладываются те запросы, которая она может выполнять

Причина этих недостатков в том, что факты и семантика разделены. 

На смену файловым системам пришли системы баз данных.

### Системы баз данных

**База данных** -- совместно используемый набор логически связанных данных и их описаний, предназначенных для удовлетворения информационных потребностей организации. В таких системах описание данных часто называется **метаданными**.

**СУБД** -- ПО, осуществляющее управление данными

**Система баз данных** - компьютеризованная система хранения записей: база данных, СУБД, аппаратура и люди, которые используют эту информацию


<a href="https://ibb.co/Bw4PtJK"><img src="https://i.ibb.co/CWJtzys/image.png" alt="image" border="0"></a>

**Сервер** владеет каким-то ресурсам и предоставляет соответствующие услуги, а **клиент** ими пользуется.

В **двухзвенной архитектуре** прикладные программы, которые обрабатывают данные, реализованы на стороне клиента. Она обращается к серверу за данными и обрабатывает их в соответствии со своей логикой.

В последнее время чаще всего вместо двухзвенной архитектуры используется **трёхзвенная**:


<a href="https://ibb.co/GWhD6ph"><img src="https://i.ibb.co/9bM0DgM/image.png" alt="image" border="0"></a>

В этом случае есть чистый сервер -- сервер, на котором установлена БД и СУБД, есть чистый клиент, на котором установлены средства для формирования необходимых запросов и отображения результатов их выполнения -- чистый интерфейс пользователя, а для реализации прикладной логики выделяется особый компонент -- **сервер приложений**, который по отношению к серверу БД выполняет роль клиента, а по по отношению к клиенту -- роль сервера.

Такая архитектура удобна, если разные прикладные программы используют более или менее одинаковые прикладные модули обработки данных, то это модули могут бтыь реализованы в виде одной копии на стороне сервера приложений.

Кроме того, на сервере приложений для реализации прикладной логики можно использовать языки высокого уровня, что облегчает их разработку.

Сама СУБД также реализует двухзвенную логику: есть серверная часть, которая отвечает за управление доступа к данным, и есть клиентская часть, которая реализует интерфейс пользователя.


## Категории пользователей

### Администраторы данных и баз данных

**Задачи:**
- обеспечение бесперебойной работы ИС
- поддержание необходимого качества данных

**Требования к СУБД:**
- обеспечение контроля доступа
- надёжность
- высокая производительность
- поддержка больших объёмов хранимой информации
- масштабируемость системы

### Разработчики баз данных

**Задачи**
- проектирование структуры БД
- реализация БД в рамках заданной СУБД

**Требования к СУБД**

- стандартизованные средства создания БД и манипулирования данными

## История развития СУБД

### СУБД первого поколения

- середина 60-х иерархическая СУБД IMS
- сетевая модель IDS (Interpreted Data Store)

Сетевая модель позволяла представлять более сложные связи, чем иерархическая модель.


СУБД, где используется сетевая или иерархическая модели данных, называются **унаследованными**.

Однако в иерархической модели для создания сложных связей будут дублироваться данные.

<a href="https://ibb.co/QJd94zV"><img src="https://i.ibb.co/PrQxd3y/image.png" alt="image" border="0"></a>



## Архитектура ANSI-SPARC

**Внешний уровень (view)** ориентирован на представление БД для конечного пользователя в зависимости от его нужд -- для каждой категории пользователей оно мб разным. Но эти представления могут в чём-то пересекаться, поэтому во избежание дублирования информации они все воедино собираются в **концептуальный** уровень (логическое описание), а **внутренняя схема** уже организует физическое хранение данных в БД.

<a href="https://ibb.co/Hh9L54v"><img src="https://i.ibb.co/SfZDFyT/image.png" alt="image" border="0"></a>

Внутренняя схема объединяет в себе все характеристики каждого из представлений. Поэтому чтобы пользователи получали доступ только к той информации, которая им нужна, эта внутренняя схеме *отображается* во view для каждого конкретного пользователя/группы. Это гарантирует, что каждый пользователь будет иметь доступ только к той информации, которая нужна ему.


Чтобы с этими данными работать, надо концептуальный уровень отобразить на физический -- на организацию хранения данных. Если мы ориентируемся на какой-нибудь ЯП, например, С, то для описания сотрудника создаётся соответствующая структура. Это позволяет, с одной стороны, исключить дублирование информации, а с другой, представлять её удобной для обработки.

Термин **информация** заключается в том, что мы не только храним конкретные *значения* данных, но и их *семантику*.

СХД начинались с создания файловых систем (где факты хранятся отдельно от семантики), им на смену пришли системы БД, которые объединяют факты и семантику.

СУБД строились на основании модели, которая позволяла описывать эти данные. СУБД используют три модели: сетевая и иерархическая (это уже в пролом), и реляционная -- основная на сегодняшний день.

Проектирование таких баз данных осуществляется в соответствии с положениями, принятыми при разработке архитектуры СУБД, определёнными в рамках комитета ANSI/SPARC.



# 2. Модели данных

Поскольку при разработке СУБД и при разработке информационных систем, в основе которых лежат СХД, используются какие-то модели данных -- и мы будем проектировать свою БД в соответствии с реляционной моделью данных, рассмотрим общие положения, касающиеся определения, а что же такое модель данных.

**Модель данных** -- это интегрированный набор понятий для описания **данных**, **связей** между данными и **ограничений**, накладываемых на данные в некоторой организации.

В какой-то степени в качестве аналогии можно привести алгоритмы -- это тоже набор понятий для описания обработки данных. Модель данных позволяет описать данные, которые существуют в реальном мире -- а они обязательно взаимодействуют между собой, поэтому надо описывать и связи.

При этом в разных предметных областях на одни и те же данные могут накладываться разные ограничения, поэтому описание данных, связей и ограничений рассматривается применительно к конкретной предметной области.

<a href="https://ibb.co/B3GzqG1"><img src="https://i.ibb.co/vqhwZht/image.png" alt="image" border="0"></a>

Модели данных принято делить на две категории: **сильно типизированные** и **слабо типизированные**.

В **сильно типизированных** МД все данные, описывающиеся в рамках данной модели, относятся к каким-то конкретным категориям: поскольку мы реально описываем всё, что происходит во внешнем мире, то, наблюдая за этим внешним миром и выявляя общие характеристики объектов и явлений, можно всё, что мы наблюдаем, разделить на какие-то категории. Например, можно использовать типы данных в ЯП -- это по сути такое категории, по отношению к которым мы выбираем объекты, обрабатывающиеся в программах.

В **слабо типизированных** МД распределить данные между какими-то категориями не представляется возможным. Но для того, чтобы можно было рассматривать связи и ограничения, то реальные объекты, явления и элементы из реального мира просто относятся либо к одной категории, либо к другой категории.

## Сильно типизированные модели данных

Большинство моделей данных, используемых в ИС, относятся к сильно типизированным. Это позволяет нам рассматривать все свойства данных, связи между данными, оперируя понятием **категории** -- не рассматривая каждый конкретный экземпляр данных, а рассматривая их общие характеристики.

Поэтому сильно типизированные модели данных делятся на две категории в зависимости от того, как эти категории определяются -

В моделях данных **на основе объектов** данные распределяются между разными объектами. Все элементы, размещаемые в одном объекте (в данном случае объект означает множество), характеризуются общим набором свойств. К таким моделям относятся объектно-ориентированная модель данных, а также семантические модели --в частности, сущность-связь. Однако модель сущность-связь не лежит в основе никакой реальной СУБД, хотя она очень активно используется на этапе проектирования.

Втора группа сильно типизированных МД -- **на основе записей**. Это реляционная модель, сетевая и иерархическая.

В сильно типизированных МД выделяются следующие основные компоненты: **категория** -- обобщённое понятие, с каждой категорией связывается некоторый набор **свойств** категории -- и тогда все экземпляры, которые включаются в ту или иную категорию, обладают одинаковым набором свойств -- но значения свойств, конечно же, могут быть разными. И поскольку модель данных должна отражать **связи** между категориями, они тоже входят в компоненты сильно типизированных моделей данных.

Например, транспортное предприятие в своём составе имеет средства передвижения (автомобиль - первая категория), и водители -- вторая категория. Для категории ВОДИТЕЛЬ определяются свойства имя, возраст, стаж работы, а для категории АВТОМОБИЛЬ -- модель, госномер, дата ТО и так далее. Между этими двумя категориями устанавливаем определённую связь, которую можно сформулировать в виде предложения: "водитель управляет автомобилем". Связь в данном случае -- "управляет" -- глагол.

В конкретном применении модели данных совокупность именованных категорий, их свойств и связей между ними, называется **схемой**. Таким образом, всё, что выделено синим на слайде, -- это схема, позволяющая описать работу транспортного предприятия.

Например:

ВОДИТЕЛЬ (Имя, Возраст, Стаж работы, ...)
АВТОМОБИЛЬ (Модель, ГОсномер, Дата,...)
УПРАВЛЯЕТ (ВОДИТЕЛЬ, АВТОМОБИЛЬ)


**Реализация БД** -- совокупность данных, структура которых соответствует некоторой схеме.

**База данных** -- совокупность реализаций, полученных в результате некоторых преобразований и удовлетворяющих одной и той же схеме.

<a href="https://ibb.co/RgzpMBr"><img src="https://i.ibb.co/Fhgbf0Z/image.png" alt="image" border="0"></a>

Определение БД содержит в себе некоторую связь со временем: конкретная реализация БД соответствует конкретному моменту времени -- это то, что есть сейчас. Но в нашей БД были какие-то реализации в прошлом и будут какие-то реализации в будущем, и все такие реализации -- те, которые были, и те, которые будут -- и называются базой данных.

Поэтому термин БД не означает моментальный снимок данных, хранящихся на машине -- это то, что изменяется во времени.

В зависимости от конкретной предметной области, если для них используется одна и та же МД, мы можем описать и разные схемы: например, можно попытаться описать схему учебного процесса (тогда будут категории группа, предмет, преподаватель и связи между ними).

Каждой конкретной схеме соответствует реализация. Эти реализации могут изменяться за счёт использования каких-то преобразований и операций, и вся эта совокупность реализаций и называется БД, причём она не ограничена: потому что могло быть что-то и до первой реализации, и будет что-то после последней реализации.

Так как мы имем дело с сильно типизированным МИ, мы можем определить схему, и все наши данные будут ей удовлетворять.

Поскольку БД меняется в времени, то когда мы описываем конкретную предметную область, мы сталкиваемся с необходимостью представления **статических** неизменяемых свойств и **динамических** изменяющихся свойств. Например, схема базы данных -- это статическая информация, а реализация отражает динамику.

Поэтому для реализации статических и динамических свойств в сильно типизированных моделях данных используются какие-то языки: для описания статических свойств рассматриваются **правила порождения**, которые позволяют описать схему базы данных и какие-то ограничения. Обычно правила порождения не различают, порождается ли структура или ограничения, и задаются средствами языка описания данных. Хотя в последнее время всё чаще язык описания данных как бы разбивается на два подмножества: дя описания структуры рассматривается DDL, а для описания ограничений рассматривается подмножество этого языка -- язык описания ограничений.

Для описания операций преобразования динамических свойств рассматривается подмножества языка манипулирования данными.

Таким образом, языки БД делятся на DDL (ЯОД) и ЯМД (DML, Data Manipulation Language)

<a href="https://ibb.co/84tqCLp"><img src="https://i.ibb.co/jZsmNP2/image.png" alt="image" border="0"></a>

Например, в реляционных БД существует один общий язык SQL, в который включены подмножества и DDL и DML.

При описании структуры мы тут же определяем какие-то ограничения, если они очевидны и мы можем их сразу сформулировать. Например, на должность водителя можно принимать только совершеннолетних (возраст > 17), а стаж работы < возраст - 17: только человек, достигший совершеннолетия, может получить права по управлению автомобилем: поэтому это гарантирует, что на предприятии не появится 18-летний водитель с 10-летним стажем. Конечно, все эти ограничения разрабатываются применительно к предметной области, и заказчик, который хорошо знает специфику работы своего предприятия, может чётко определить эти ограничения, поэтому с ним надо работать активно.

Поскольку мы должны описать **структуру** -- совокупность категорий, свойств и связей между категориями, рассмотрим, какие компоненты мы используем для её описания.

### Структурные компоненты

**Множество** -- собрание правильно идентифицированных объектов, удовлетворяющих правилу принадлежности.

<a href="https://ibb.co/H2FTXG8"><img src="https://i.ibb.co/3srmkSZ/image.png" alt="image" border="0"></a>

Для множества мы должны определить какое-то условие: правило принадлежности, которому должны удовлетворять все элементы этого множества.

В зависимости от того, как задаются множества, они делятся на две группы -- множества-домены и множества-отношения.

**Отношения **-- это некоторый агрегат построенный на других множествах. В зависимости от того, на каких множествах отношение построено, рассматривают **отношения сущности** -- построены на доменах, и **отношения связи** -- построены на отношениях сущности.

При определении множества мы должны задать две важные характеристики -- **интенсионал** (характеристика типа, определяющая допустимые множества значений). По сути интенсионал -- это тип переменной `int`

Кроме того, **экстенсионал** -- определяет конкретное значение множества. По аналогии с ЯП -- это конкретное значение переменной типа `int`, например, 27

### Домены и атрибуты

**Домены** -- множества, элементы которых более или менее однородны. Обычно в МД роль доменов выполняют типы данных: например, целое число.

Значения, входящие в домен, могут использоваться для задания свойств категории.

**Атрибуты** -- именованные домены, представляющие семантически значимые объекты. Они позволяют называть свойства категорий.

В этом примере все атрибуты приведены на одном и том же домене -- целые числа. Атрибуты позволяют связать факты и их семантику -- способы их обработки: например, возраст с целыми числами. 

<a href="https://ibb.co/t4XczXw"><img src="https://i.ibb.co/Cz2v62p/image.png" alt="image" border="0"></a>

### Отношение сущности

**Отношение сущности** -- агрегат, построенный на множествах-*доменах*.

В соответствии с определением этого отношения (это определение берётся из математической теории отношений с уточнениями, специфическими для МД):

Пусть дана некоторая совокупность доменов $D_1, D_2, \dots, D_n$, не обязательно различных. Тогда отношение -- это множество упорядоченных кортежей вида $\lang d_1, d_2, \dots, d_n\rang$, в которых каждый $d_i$ принадлежит соответствующем домену $D_i$: $$R = \{\lang d_1, d_2, \dots, d_n\rang|d_i\in D_i, i=\overline{1, n}\}$$

Само отношение -- неупорядоченное множество, но кортежи, в него входящие, упорядочены в соответствии с порядком следования доменов.

**Степень** отношения (**арность** кортежа) -- количество множеств, на которых построено это отношения (в данном случае равно $n$)

**Мощность** отношения -- количество кортежей в конкретной реализации отношения.

Если арность -- характеристика *интенсионала*, то мощность -- характеристика *экстенсионала*, то есть конкретной реализации отношения.

Если в качестве доменов рассматриваются, например, $$D_1 = \mathtt{int} \{1, 4, 8\}\\D_2=\mathtt{char}\{a, c, x\},$$то отношение, построенное на этих двух доменах, может включать в себя следующее множество кортежей: $$\{\lang 1, a\rang, \lang 1, x\rang,  \lang 8, c\rang, \dots\}$$


Степень кортежей -- 2 (потому что 2 домена), а мощность конкретно этого отношения равна 3 (потому что 3 кортежа).

**Схема отношения** -- именованный список пар <имя атрибута: имя домена >.

$$имя\_схемы(имя\_атрибута : имя\_домена, \dots)$$

Атрибут в отношении -- это семанически значимый объект, определяющий способ использования домена в отношений. Атрибуты как раз и позволяют внести семантику в описание данных.

D1 предсталвяет собой интенсионал : строчная английская буква, а эстенционал -- {a, b, c, d, e}

На основе этих двух доменов создаётся отношение. В данном случае -- это множество бинарных кортежей (по два элемента в каждом кортеже), причём первый элемент каждого кортежа принадлежит D1, а второй -- D2.

Схема отношения: R(Категория: D~1~, Индекс:D~2~). Так как интекс принадлежит десятичным цифрам (D2), то мы теперь знаем, что индексы мы можем не только сравнивать на равенство, но ещё и определять < и >

В таком отношении арность равна 2, а мощность -- 3. Если арность -- характеристика типа и не зависит от конкретной реализации отношения, то мощность зависит от конкретной реализации и будет меняться.

### Отношение связи

**Отношение связи** -- агрегат, построенный на множествах-*сущностях*

Определяются точно так же: если у нас есть некоторая совокупность множеств сущностей, то отношение связи -- неупорядоченное множество упорядоченных кортежей вида $\lang s_1, s_2, \dots, s_n\rang$, где $s_i\in S_i$: $$R = \{\lang s_1, s_2, \dots, s_n\rang|s_i\in S_i, i=\overline{1, n}\}$$


#### Характеристики связи

**Арность** характеризует, на каком количестве множеств сущностей рассматривается связь. Мы ограничиваемся бинарными связями -- связями между двумя множествами сущностей. Это ограничение определяется тем, что реляционная модель данных поддерживает только бинарные связи, но используя только их, можно реализовать сколь угодно сложные ИС.

Для бинарной связи определяются два **отображения**: $$R: S_1\to S_2; R^{-1}: S_2\to S_1,$$Какое из отображений определить как прямое, а какое -- как обратное, значения не имеет

А вот уже отображение обладает своими характеристиками.

**Кардинальное число отображения** -- количество элементов одного множества, связанных с одним элементом другого множества $$R(S_1(\min_1, \max_1):S_2(\min_2, \max_2)$$

То есть количество экземпляров из множества сущностей $S_2$, связанное с одним экземпляром из множества сущностей $S_1$, определяет **кардинальность** отображения $S_1\to S_2$.



У каждого отображения своя кардинальность. Поскольку каждый экземпляр $S_1$ может быть связан с разным количеством $S_2$, то обычно рассматриваются минимальное и максимальное значение.

Каждый экземпляр из $S_1$ связан с минимум $\min_2$, максимум с $\max_2$ экземплярами $S_2$. Именно эти характеристики -- $\min_1, \dots, \max_2$ -- определяют тип связи.

Например, курсы по выбору: ВЫБИРАЕТ(СТУДЕНТ(5, 100): КУРС(1, 3))

Каждый студент должен выбрать какие-то курсы по выбору. Каждый студент должен выбрать по крайней мере один из трёх курсов, но курс состоится в том случае, если его выберут минимум 5 студентов из 100.

### Типы отображений

В зависимости от того, каким условиям удовлетворяют эти кардинальные числа, рассматриваются различные конкретные типы отображений.

**1. $R(S_1(0,\infty):S_2(1, \infty)), S_1\to S_2$ -- полностью определённое на $S_1$**

<a href="https://imgbb.com/"><img src="https://i.ibb.co/KsNGqwV/image.png" alt="image" border="0"></a>

Каждый экземпляр множества S1 связан минимум с одним экземпляром множества S2.

Для существования экземпляра множества сущностей S1 необходимо, чтобы он был связан с каким-то одним экземпляром множества сущностей S2 (по крайней мере, одним, но можно и больше)

Такое отображение называется **полностью определённым на S1**: экземпляр S1 не может существовать вне связи с экземплярами S2

#### Неполное функциональное отображение

<a href="https://ibb.co/2y6PvDG"><img src="https://i.ibb.co/yXR56wH/image.png" alt="image" border="0"></a>

Минимальное кардинальное число отображения равно 0, то есть экземпляр из S1 мб не связан ни с каким экземпляром из S2, а максимальное число равно 1 -- то есть максимум можно связаться с одним экземпляром S2. А это значит, что если мы можем берём соответствующий экземпляр из S1, мы всегда можем по нему найти соответствующий экземпляр S2 -- такое отображение называется **неполным функциональным**.


#### Полное функциональное отображение

<a href="https://ibb.co/2vNWsMh"><img src="https://i.ibb.co/6HBr1tw/image.png" alt="image" border="0"></a>

Когда минимальное и максимальное кардинальные числа равны 1, то есть каждый экземпляр из S1 обязательно связан с одним и только одним экземпляром из S2 -- получаем **полное функциональное отображение**: получив некоторый экземпляр S1, мы всегда найдём один единственный экземпляр S2, ему соответствующий -- то есть получаем функцию, которая по значению $x\in S_1$ находит значение $y\in S_2$. 


Эти типы функциональных отображений влияют на типы связи.



## Ограничения целостности

В общем случае модели данных включают в себя представление трёх компонентов:
- **структурные** компоненты, позволяющие описать информационную модель. В них входят отношения сущности и отношения связи.
- **ограничения целостности**, накладываемые на данные
- **манипуляционные характеристики**: база данных представляет собой совокупность реализаций, получаемых путём преобразования, и этот компонент как раз определяет, какие преобразования можно выполнять с данными.

Для описания этих трёх компонент -- структурной, целостной и манипуляционной, в языках, которые предназначены для описания информационной модели, обычно выделяют два подмножества языка:
- язык описания данных, который определяет структуру данных и **статические** ограничения, накладываемые на данные
- язык манипулирования данными, который определяет правила преобразования реализаций, на которые также оказывают влияние ограничения, накладываемые на данные.

**Ограничения целостности** -- логические ограничения, накладываемые на данные (**constraints**) в условиях соответствующей предметной области. Разрабатывая схему БД, на этапе определения связей сущностей и построения диаграмм бывает очень полезно также определять какие-то ограничения, которые накладываются на данные.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/JtR1Wj9/image.png" alt="image" border="0" height="200" align="left"></a>

Рассмотрим, где на каком этапе используются ограничения целостности. У нас есть модель данных МД, средствами которой мы можем представить некоторую совокупность схем баз данных S. Схем в рамках одной модели может быть много: всё определяется той предметной областью, которую мы реализуем; а сама база данных представляет собой совокупность реализаций DBS~i~, удовлетворяющих данной одной и той же схеме, получаемых в результате каких-то преобразований.

На уровне описания данных используется подмножество языка описания данных, а для преобразования реализаций используется подмножество языка манипулирования данными.


На этих этапах и при описании схемы, и при реализации преобразований между отдельными реализациями базы данных действуют какие-то правила, которые определяют допустимые (или достоверные) состояния БД. В силу того, что мы описываем как статические свойства, так и динамические свойства преобразований, ограничения, которые накладываются на данные, тоже делятся на две категории:
- **статические спецификации** выражают правила, которые определяют допустимые (достоверные) состояния БД. Эти правила накладываются на каждую конкретную реализацию БД
- **динамические спецификации** определяют возможные допустимые переходы из одного состояния БД в другое -- преобразования из одной реализации БД в другую: не все такие преобразования могут быть разрешены, учитывая ограничения, накладываемые на данные.

Обычно все логические ограничения, которые накладываются на данные, связаны с состоянием базы данных и включают в себя и статические, и динамические спецификации. 

Допустим мы разработали соответствующую информационную модель, для которой мы определили некоторую совокупность ограничений, накладываемых на данные. Поскольку ограничения связаны со схемой БД, а схеме БД удовлетворяют отдельные реализации, состояния БД, то между ограничением, схемой и состоянием БД существуют определённые зависимости, выраженные следующими определениями:

#### Правила, накладываемые на ограничения целостности C~i~

Ограничение C~i~:
- **правильно построено**, если оно соответствует синтаксическим правилам спецификации ограничений. Для спецификации ограничений в SQL есть средства, которые позволяют эти спецификации указать
- **удовлетворено состоянием DBS~i~** (состоянием БД -- конкретной её реализации), если оно истинно для данного состояния. Поскольку ограничения целостности -- это обычно логические условия, они могут принимать значения истина или ложь, то ограничение удовлетворено состоянием, если для данного состояния ограничение принимает значение истина.
- **удовлетворяемо**, если есть хотя бы одна реализация состояния БД DBS~i~, которая удовлетворяет этому ограничению, то есть на этом состоянии ограничение принимает значение истина.
- **недостоверно**, если никакое состояние базы данных ему не удовлетворяет.

При определении ограничений целостности надо использовать синтаксически правильные конструкции и нужно выбирать такие ограничения целостности, которые соответствуют предметной области, чтобы не оказалось так, что выбранное ограничение будет недостоверным.

#### Правила, накладываемые на конкретную реализацию состояния БД DBS~i~

DBS~i~ -- это конкретный набор данных, удовлетворяющих схеме.
- **удовлетворяет схеме S**, если он удовлетворяет всем ограничениям, определённым для этой схемы. То есть данные не просто структурно удовлетворяют схеме, но ещё должны выполняться и все ограничения целостности, которые для этой схемы сформулированы
- **непротиворечиво**, если оно удовлетворяет всем ограничениям, накладываемым на схему БЖ

#### Правила, накладываемые на схему S

Схема S:
- **удовлетворяема**, если существует некоторое состояние БД, которое удовлетворяет данной схеме
- **противоречива**, если никакое состояние базы данных этой схеме не удовлетворяет.

При проектировании схемы для неё надо определить и какие-то ограничения целостности, и гарантировать, что данная схема не окажется противоречивой, то есть могут существовать реализации, которые удовлетворяют всем ограничениям, накладываемым на данные.

### Манипуляционный компонент

Это правила переходов состояния БД. Они обычно не определяются, а разрабатываются для тех моделей данных, которые лежат в основе некоторой конкретной СУБД, а поскольку для моделей *вообще* никакой реальной СУБД существовать не может, то эту часть мы пока оставим в стороне.

Здесь можно только отметить, что языки манипулирования данными применительно к любой МД делятся на две категории:
- **навигационные** языки, которые учитывают конкретную организацию структуры информационной модели. К ним относятся языки манипулирования данными в иерархической и сетевой МД
- **ненавигационные** языки: чтобы найти нужные данные, достаточно указать, каким свойствам эти данные должны удовлетворять, не указывая конкретного маршрута движения по схеме.



В общем случае применительно к МД ограничения целостности могут быть разделены, в свою очередь, на **внутренние** и **явные**.

**Внутренние** ограничения поддерживаются самой моделью данных. Например, атрибут всегда определён на каком-то домене, а значит, значение атрибута может только принадлежать этому домену. Модель данных сама определяет понятия домена, атрибута, и поэтому своими средствами гарантирует, что атрибут не сможет принимать недопустимые значения. От разработчика БД выявление таких внутренних ограничений не накладывает никаких доп требований на реализацию таких ограничений: контроль за правильным значением того или иного атрибута берёт на себя СУБД, работающая в соответствии с конкретной моделью данных

**Явные** ограничения не мб реализованы МД. Для их реализации разработчику надо создавать какие-то дополнительные конструкции, чтобы проверить соответствующее условие. Например, в предприятии сумма окладов должна быть меньше зарплаты. Так что если предметная область предъявляет какие-то явные ограничения, их надо определить функционально или процедурно, а может быть, с помощью триггера. 


Обязательное условие: на этапе проектирования информационная модель будет представлена в виде FA диаграммы и помимо всего прочего, надо продумать и ограничения целостности: помимо описания отдельных отношений и связей между отношениями, надо сформулировать возможные условия связи: например, водителем автобуса не мб несовершеннолетний и так далее.

## Операции над данными

По своему смыслу эти операции делятся на выборку (чтение, поиск) и модификацию данных -- в основном добавление (хотя можно и удалять, но удаление на практике применяется нечасто, потому что если вдруг надо будет что-то восстановить, а копии нет, то этого сделать уже не получится). Поэтому, как правило, если данные больше уже не нужны и не используются в текущий момент времени, сохраняются в каких-то архивах и исключаются из текущей реализации БД, а при необходимости всегда можно будет обратиться к этим архивным записям.

Организация доступа к данным реализуется языками, которые делятся на две группы: ненавигационные, которые не учитывают конкретную организацию хранения данных на физическом уровне с точки зрения формирования запросов к данным (например, в СУБД на основе реляционной модели данных), и навигационные, которые это учитывают.

# 3. Модель данных "сущность-связь"


<!--stackedit_data:
eyJoaXN0b3J5IjpbNDY5OTAzMzg2LDExNTIwMzc1OTksODUwOD
QwMzMxLC0xNTQxMjUyODQ4LDE2MDU2ODE2OTksLTY4NDE0ODA2
LDEyMTQwNTQyMywtMTE3OTMxMjkzNV19
-->