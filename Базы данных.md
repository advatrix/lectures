### Основные понятия БД
**Сущность** -- класс, хранящийся в базе данных, таблица.
**Объект** -- экземпляр сущности, хранится в таблице в виде записи.
**Атрибут** -- свойства, характеризующие сущность, название столбца в таблице
**Кортеж** -- строка в таблице, набор значений конкретных атрибутов
**Домен** -- набор допустимых значений атрибута
**Идентификатор** -- атрибут с уникальным значением для данной таблицы.

### Архитектура СУБД
Основные компоненты:

- Ядро -- процессы, сеть, память, файловая система и т.д.
- Диспетчер данных -- транзакции, кэш
- Диспетчер запросов -- парсер запроса, оптимизатор, исполнитель
- Набор инструментов для служебных операций -- резервное копирование, восстановление, мониторинг

### Характеристики реляционных СУБД
Преимущества:
- простая схема данных для пользователя
- логическая и физическая независимость от данных
- целостность и защищенность данных
- методологический подход к проектированию

Недостатки:
- относительно низкая скорость доступа к данным
- не универсальное решение для любой предметной области
- меньшая гибкость при добавлении своих типов данных и операций

### Базовые операции SQL
```sql
use billing_sample;  # какую базу данных использовать

create table if not exists 
```
#### Агрегация данных
- суммировать значения по указанному атрибуту для записей с определенными условиями
- статистика в разрезе значений указанного атрибута
```sql
select count(1) from project;  # выбрать число строк в таблице
select avg(budget) from project;  # найти средний бюджет

select avg(datediff(project_finish, project_start)) as avg_days, client_name
from project
where project_finish is not null  # выбрать среднюю длительность завершённых проектов для каждого клиента
group by client_name
order by avg_days desc
limit 10;  # ограничение на число выводимых записей
```

# Основы реляционных баз данных
## Введение в реляционную модель данных
Модель данных описывается частями:
- набор понятий (объектов)
- набор операций
- описание структуры и ограничений доступа к данным.

Общая характеристика модели данных (Кристофер Дейт)
- структурная часть: например, для иерархической модели данных это описание схемы данных в виде дерева
- манипуляционная часть
- ограничения целостности: например, для той же иерархической модели это возможность каждого узла иметь несколько потомков, но при этом только одного предка.

## Реляционная модель данных
### Структурная часть
Все элементы, хранящиеся в реляционной базе данных, строго типизированы.

Типы данных в РМД близки к понятию типа данных в языках программирования: они определяются множеством значений, которые может принимать переменная, некими операциями и наборами литералов, которыми можно их задать.

Например,
- Целочисленные типы данных: INT, BIGINT, SMALLINT
- Данные с дробной частью: NUMERIC/DECIMAL, FLOAT/DOUBLE
- Строковые: CHAR, VARCHAR, STRING
- Календарные: DATE, TIME, DATETIME, TIMESTAMP
- NULL
- Другие: XML, JSON и т.д.

**Домен** -- совокупность базового типа данных и некоторого логического выражения, которое можно применить над элементом данного базового типа. Это некоторое подмножество значений типа данных.

Например, если мы имеем дело с количеством чего-то, можно ограничить соответствующее поле не только целочисленным типом, но и ввести для него специальный домен: только нулевое и положительное значение из данного типа.

**Атрибут** -- некоторая именованная характеристика, свойство сущности, которое определяется на некотором типе данных или домене.

Например, для таблицы сотрудников с колонками "имя", "фамилия", "дата рождения",  "оклад" атрибутами будут как раз имя, фамилия, дата рождения и доклад, каждый из которых определён на каком-то домене или типе данных.

При этом можно сказать, что для атрибута дата рождения можно создать домен, чтобы нельзя было вводить слишком ранние даты или слишком поздние.

**Кортеж** -- множество упорядоченных триплетов: имя атрибута, типа данных или домен, значение.

Например, для таблицы с сотрудниками кортежем будет являться строка, описывающая какого-то сотрудника:
(name, VARCHAR, Sasha), ... (salary, DECIMAL, 10.50).

**Схема отношения** -- именованное множество упорядоченных пар: имя атрибута, тип данных или домен. По сути это некий заголовок таблицы.

**Схема БД** -- множество именованных схем отношений. Например, база данных может состоять из нескольких таблиц, каждая из которых имеет свою структуру и эти таблицы могут быть связаны друг с другом.

**Отношение**
- **Тело отношения** -- множество кортежей, соответствующих схеме отношения. Интуитивно -- данные в таблице
- **Значение отношения** -- пара множеств: схема отношения, тело отношения

Посмотреть структуру таблицы в MySQL:
```sql
describe data_base.project;
```

#### Свойства отношений
- отсутствие дубликатов кортежей -- вытекает из определения тела отношения как множества кортежей
- отсутствие упорядоченности кортежей
	- формально -- из множественной природы отношений
	- на практике -- эффективно
- отсутствие упорядоченности атрибутов (аналогично упорядоченности кортежей)
- атомарность значений атрибутов
	- на сегодняшний день это условность
	- схема отношения принадлежит первой нормальной форме: все данные во всех ячейках отношения атомарные

### Манипуляционная часть
Использует в качестве своей основы реляционную алгебру и реляционное исчисление.
Используется DML SQL.

### Ограничения целостности
#### Целостность сущности
Кортежи должны быть отличимы. То есть все строки в таблице должны отличаться хоть чем-нибудь.

Если кортежи чем-то друг от друга отличаются, то существует некое подмножество множества атрибутов отношения такое, что для любого кортежа отношения этот набор значения отличается от другого (**потенциальный ключ**). Он обладает двумя свойствами:
- уникальность
- минимальность: не должно быть возможности из этого набора хотя бы один атрибут исключить.

Для отношения может быть определён один или несколько потенциальных ключей, при этом вырожденный случай -- когда потенциальным ключом является совокупность всех атрибутов отношения.

Один из таких потенциальных ключей принято называть **первичным**.

Сами по себе ключи бывают
- простые (из одного атрибута)
- составные (из нескольких атрибутов)

##### Практическая значимость:
- в таблице не должно быть повторяющихся записей. Иначе, не имея возможности адресовать, то есть идентифицировать отдельную строку, мы не сможем эту строку изменить.
	- однако в большинстве SQL-БД такое требование явно не выполняется.
- ключ идентифицирует кортеж/строку таблицы 
- атрибуты, входящие в состав ключа, не могут содержать неопределенных значений
	- в большинстве случаев в SQL СУБД не даст возможность ввести строку таблицы такую, что в ключевом поле будет `NULL`.
#### Целостность ссылок
**Внешний ключ** -- специальный атрибут (набор атрибут) отношения такой, что значения данного атрибута (набора) в некотором отношении будут соответствовать значениям атрибутов первичного ключа некоторого (другого) отношения.

Можно сказать, что множество значений внешнего ключа некоторого отношения $R_2$ является нестрогим подмножеством множества значений потенциального ключа некоторого отношения $R_1$.

Терминология: в приведённом выше примере отношение $R_1$ называются главным/целевым/родительским ($\operatorname{master}$), $R_2$ -- подчиненным ($\operatorname{slave}$)

Целостность ссылок заключается в том, что для каждого указанного значения внешнего ключа должен найтись кортеж в отношении, на которое ссылается набор атрибутов внешнего ключа.
- SQL: или значения внешнего ключа должны быть неопределёнными (`NULL`)

Способы поддержания ссылочной целостности:
- блокировка операции
- указание `NULL`
- каскадное удаление, может привести к печальным последствиям в больших БД.

### Преимущества реляционной модели данных
- контроль целостности данных
- гибкость: выборка, изменение схемы
- физическая и логическая независимость
- разработка прикладных программ (простая обработка выборок)
- основа -- небольшое число интуитивно понятных абстракций
- теоретическим базисом реляционного подхода к организации баз данных служит простой и мощный математический аппарат теории множеств и математической логики
- декларативные языки определения и манипулирования данными (SQL)
- средства разграничения доступа (созданий ролей, прав и т.д.)

### Недостатки
- производительность/масштабируемость
- большое количество таблиц в реальных БД
- сложность поддержки
- некоторые предметные области плохо представляются в форме отношений
- разработка прикладных программ (работа в ОО-языках не всегда удобна и привычна)
- репликация

## Архитектура ANSI-SPARK
Определяет принцип организации СУБД (не обязательно РМД). Цель -- введение уровней абстракции для пользователей и архитекторов БД:
- разные уровни пользователей должны иметь разные представления данных
- пользователи должны быть абстрагированы от физической и логической организации данных
- администраторы БД должны иметь возможность вносить изменения в схему данных без учета особенностей физического хранения данных
- внутренняя структура БД не должна зависеть от физических аспектов хранения информации

Уровни и функции
1. Внешний уровень -- пользовательские представления
2. Концептуальный уровень -- логическая структура БД
3. Внутренний уровень -- аспекты физической реализации

**Логическая независимость** -- защищённость внешних схем от изменений, вносимых в концептуальную схему. Сохранение представлений внешнего уровня при изменении схемы данных.

**Физическая независимость** -- защищённость концептуальной схемы от изменений, вносимых во внутреннюю схему. Файловые системы и системные функции, организация хранения данных, настройки и внутренние структуры данных.

## Выборки из нескольких источников
### Запросы из нескольких таблиц. Виды соединений
Оператор SELECT возвращает результат соединения, если обращается в нескольким источникам данных -- таблицам, представлениям или к результатам предыдущих запросов (вложенных запросов). Результат соединения -- нестрого подмножество декартова произведения результатов выборок из нескольких источников

Можно это декартово произведение ограничить:
```sql
cross join -- никак не ограничить
inner join -- внутреннее соединение
left outer join, right outer join -- левое и правое внешнее соединение
full outer join -- полное внешнее соединение
natural join -- естественное соединение
```
Рассмотрим пример двух таблиц:
```sql
Таблица product
	product_id int
	product_name varchar(255)
	price decimal(18, 2)
	category_id int  -- внешний ключ

Таблица category
	category_id int
	category_name varchar(45)
```
### Декартово произведение
Количество строк в соединении равно произведению количества строк в соединяемых результатах. Декартово произведение получается в результате любого запроса, содержащего более одного источника и не имеющего ограничивающих условий.

```sql
select * from product, category  # декартово произведение
select * from product cross join category  # аналогично
```

### Тета-соединение
Результат тета-соединения содержит кортежи из декартова произведения, удовлетворяющие некоторому условию.

В языке SQL операция тета-соединения -- INNER JOIN (внутреннее соединение), NATURAL JOIN.

Если это условие -- условие эквивалентности, то это эквисоединение.
```sql
# вывод списка продуктов с наименованием категории для каждого продукта
select product.product_name, category.category_name, product.price
 from product inner join category on product.category_id = category.category_id

```
В SELECT необходимо явно указывать, из какой таблицы берутся данные, если атрибуты разных таблиц совпадает и интерпретатор SQL не сможет решить, какую таблицу выбирать.

Также можно использовать алиасы -- краткие обозначения таблиц:
```sql
select p.product_name, c.category_name, p.price
from product as p
inner join category as c
on p.category_id = c.category_id
```

### Левое, правое внешнее соединения
Результат левого внешнего соединения содержит кортежи из внутреннего соединения источников и не вошедшие во внутреннее соединение кортежи левого источника.

Атрибуты в кортежах, которые не имеют совпадений по общим столбцам, заполняются неопределёнными значениями.

```sql
select * from category as c 
left outer join product as p on p.category_id = c.category_id;

# помимо inner join, будут возвращены не попавшие туда значения из левого источника.
```
### Полное внешнее соединение
Результат полного внешнего соединения содержит кортежи
- из внутреннего соединения источников
- не вошедшие во внутреннее соединение кортежи левого источника
- не вошедшее во внутреннее соединение кортежи правого источника

Атрибуты в кортежах, которые не имеют совпадений по общий столбцам, заполняются неопределёнными значениями.

### Объединение (UNION)
Результат объединения -- кортежи из каждого источника. Если добавлено ключевое слово ALL, то не выполняется проверка на уникальность кортежей в результирующем объединении. Выборки из источников должны совпадать по атрибутам с точностью до типа данных.
```sql
select * from product where price > 1000
union
select * from product where price < 100;
```

## Триггеры и хранимые процедуры
### Процедурные расширения SQL
Описаны в части стандарта SQL/PSM и делают язык SQL вычислительно полным.

Использование: хранимые процедуры и триггеры. Вариативность языка зависит от конкретной СУБД.

### Хранимые процедуры
- исполняются сервером БД, то есть там же или очень близко к месту расположения данных
- могут осуществлять изменение данных и структуры БД
- могут возвращать работы данных аналогично оператору SELECT
- однократно компилируются и уже в откомпилированном виде хранятся на сервере
- могут кэшировать планы исполнения, результаты: кэшируемые данные могут существенно повысить эффективность выполнения.

В зависимости от СУБД могут различаться разные виды хранимых процедур:
- пользовательские функции, типа тех, которые можно использовать в операторе SELECT (avg, min, concatenate)
- нативные хранимые процедуры
- процедуры, реализуемые на языках общего назначения (на тех языках, которые поддерживаются конкретной СУБД: Microsoft SQL -- C#, Postresql -- Python, Oracle -- Java, Perl, Python)

#### Преимущества в сравнении с реализацией аналогичного функционала непосредственно в прикладной программе
- производительность: обработка данных производятся там, где эти данные хранятся, (например, при кэшировании там всегда будет наиболее актуальная информация)
- организация поддержки целостности (согласованность)
- скрытие структуры данных
- модульность: возможность повторного использования хранимых процедур
- безопасность

#### Недостатки
- разделение бизнес-логики: всю логику перенести в процедуру часто не получается, поэтому часть логики размазывается между приложением и БД
- меньшая языковая выразительность процедурных расширений SQL
- непереносимость: с одной СУБД на другую перенести код непросто
- погружение в особенности СУБД: чтобы понимать, как работают хранимые процедуры, необходимо хорошо понимать, как работает конкретно именно эта СУБД
- отладка: для многих СУБД нет способ отладки процедур
- версионирование

### Триггеры
Позволяют обрабатывать определенные события внесения изменений в базу данных. Эти события называются инициирующими операциями.

Триггер можно определить только для изменений в **одну** таблицу. Он может быть вызван как до, так и после операций с предметной (той, для которой специфицирован триггер) таблицей.

#### Особенности работы
- могут быть инициированы изменением схемы или данных
- могут выполняться для каждой строки или для всего блока
- могут содержать дополнительные условия исполнения
- возможности использования старых и новых значений
- вызов процедур, инициирование триггеров
- транзакционность и сохранение состояния: например, если во время выполнения триггера было выброшено исключение, состояние таблицы должно быть возвращено к моменту до выполнения триггера. Если вызов триггера влечёт за собой вызов других триггеров, то текущий контекст будет положен в стек и т.д.
- последовательность исполнения нескольких триггеров. Исполняются триггеры в той последовательности, в которой были созданы.

#### Варианты использования
- проверка данных
- поддержка согласованности
- журналирование и аудит
- запуск процедур, не связанных с обработкой данных

#### Недостатки
- непрозрачность
- сложность отладки, особенно в случае каскадного запуска триггеров
- производительность: триггеры задерживают выполнение операции
- глобальность: триггеры не зависят от прав доступа и существуют для таблицы в любое время

```sql
# изменить структуру таблицы
alter table table_name modify id integer auto_increment;
alter table table_name modify active datetime;

drop procedure update_order_history;  // позволяет удалить процедуру

delimiter //       # позволяет переопределить разделитель команд
# по умолчанию это ;, но в определении процедуры мы также будем использовать ;
# для того, чтобы определить конец определения процедуры, переопределяем разделитель

create procedure update_order_history ( # список аргументов
	order_id integer,
	status_id integer,
	sum decimal(10, 2)
)
begin
	declare now datetime;
	set now = now();

	update order_history
		set active_to = now
	where order_id = order_id and active_to is null
	limit 1;

	insert into order_history
		   (order_id, status_id, sum, active_from, active_to)
	values (order_id, status_id, sum, now, null);
end
//	

```
Вызов процедуры: 
```sql
call update_order_history(1, 0, 195.23);
```

Теперь можно добавить триггер, чтобы эта процедура выполнялась автоматически: 
```sql
delimiter //
create trigger on_update_order
	after update
	on order_table for each row
begin
	call update_order_history(new.id, new.status_id, new.sum);
end
//
```

# Задача проектирования баз данных
## Задачи проектирования
Необходимо спроецировать нашу предметную область или её часть в базу данных, при этом должны быть выполнены следующие требования:
- отображение объектов предметной области средствами модели данных
- отображение связей объектов
- достаточность представления предметной области для пользователей
- формирование ограничений целостности
- минимизация аномалий

### Проектирование БД в реляционной модели
Для реальных предметных областей набор отношений и ограничений целостности на эти отношения буду достаточно сложными. Например, даже для задачи проектирования базы данных для магазина может потребоваться несколько десятков таблиц. Таким образом, мы получаем структуру, которая не всегда проста в понимании -- и самое главное, что отображение предметной области в виде набора отношений немножко маскирует семантику: мы не всегда понимаем, какая конкретно сущность представляется каким отношением и каким образом они связаны друг с другом в реальной жизни.

Отсутствие формальных правил для преобразования требований предметной области в схему БД также усложняет задачу проектировщика.

Также не всегда можно отделить сущность от связи.

Поэтому необходимо использовать модели данных с лучшим отображением семантики данных.

### Проектирование с использованием семантических моделей
- формирование концептуальной схемы данных
- преобразование к логической схеме данных на основе некоторой модели данных
- преобразование к физической схеме данных

### Модель сущность-связь (ER)
Чаще всего используется графическое представление -- диаграмма сущность-связь (ER-диаграмма)

**Сущность** -- некий конкретный объект реального мира, отличимый от других. Например, если рассматривать библиотеку, то конкретная книга -- сущность, а **тип сущности** -- книга.

**Связь** описывает, каким образом сущности могут быть описаны между собой. Связи являются бинарными.

**Атрибут** может как иметь некоторый тип данных, так и не иметь.

**Ключ** -- некоторый набор атрибутов, который определяет некоторую сущность

## Концептуальное проектирование
Этапы:
- выделение сущностей
- определение связей
- атрибуты, типы данных, домены
- ключи
- ограничения целостности
	- допустимые значения: например, для возраста -- это положительное число от 0 до ста с лишним
	- разрешенные значения: например, для сотрудников организации -- до 18 до 65
	- существующие значения: например, размер отчислений не должен превышать зп
### Выделение типов сущностей
- работа бизнес-аналитика и проектировщика БД
- выяснение потребностей и представления предметной области для каждой роли пользователя
- выделяются независимые типы сущностей
- отбрасываются ненужные
- именование типов сущностей

### Определение связей
Наиболее сложный и творческий процесс.

#### Типы связей
- один ко многим (например, одному источнику прихода может соответствовать много клиентов; один клиент может совершать много заказов)
- многие к одному
- многие ко многим (можно реализовать несколькими связями один-ко-многим). Например, товар может принадлежать к нескольким категориям, а в одной категории может быть несколько товаров.
- один к одному (можно представить в виде одного отношения)

#### Кратность связей
Определяет возможное количество сущностей в каждом экземпляре связи с какой-либо стороны.
- 1
- 0 .. 1
- 0 .. n
- 1 .. n

### Определение атрибутов
- выделяются атрибуты типов сущностей
- выделяются атрибуты связей
- простые и составные атрибуты
- определение типов данных, доменов
- именование атрибутов


### Выбор ключей
- определяются ключевые атрибуты
- выбирается первичный ключ
	- простота
	- минимальность
	- редкие изменения
- для слабых сущностей (то есть для таких, которые не могут быть однозначно определены даже по совокупности всех атрибутов) вводятся синтетические ключевые атрибуты

### Проверка

- наличие связей один к одному: она может быть представлена в виде одной таблицы.
- наличие избыточных связей: несколько связей между одними и теми же типами сущностей, пусть даже разной семантики может быть избыточным
- проверка выполнимости пользовательских операций -- мысленный эксперимент
- обсуждение с пользователями


### Особые случаи
#### Связь с ООП. Супертипы и подтипы
Наличие наследования для типов сущностей. Например, пользователи степика имеют два явных подтипа -- слушатель (выполнение заданий) и преподаватель (авторство курсов).

При этом ER-модель накладывает явные ограничения на формирование супертипов сущностей и подтипов:
- сущность любого подтипа является сущностью супертипа
- сущность супертипа обязательно является сущностью некоторого подтипа
- не должно быть сущностей одновременно нескольких подтипов
#### Взаимоисключающие связи
Ситуация, когда сущность одного типа при одних значениях атрибутов должна быть связана с сущностью некоторого другого типа, а при других (альтернативных) значениях атрибутов -- с сущностью третьего типа.

Например, автомобиль может в зависимости от ситуации быть связанным с водителем автомобиля или с мастером автосервиса.

## Логическое проектирование
- реализация схемы данных на основе выбранной модели
- для РМД может быть в значительной степени автоматизирован переход от концептуальной модели к логической. В этом случае должны быть выделены
	- набор схем отношений
	- выделенные первичные ключи
	- выделенные внешние ключи

### Правила перехода
1. Каждый простой тип сущности отображается в отношение
2. Атрибуты ER-модели отображаются в атрибуты отношений
3. Компоненты уникального идентификатора отображаются в первичный ключ
4. Связи один к одному и один ко многим отображаются в виде внешних ключей
5. Связи многие ко многим отображаются с созданием дополнительного промежуточного отношения, которое будет содержать внешние ключи обоих типов сущностей.
6. Сложные связи (более, чем между двумя типами сущностей) декомпозируются с выделением нового типа сущности. Например, связь фильм-роль-человек сложная, и в РМД не отражается. Надо выделять новый тип сущности -- "участие": какой человек в каком фильме какую роль выполнял.
7. Многозначные атрибуты декомпозируются с выделением нового типа сущности: например, история заказа -- некий сложный атрибут заказа, и его надо выводить в отдельное отношение.

### Нормализация

### Особые случаи
#### Супертипы и подтипы
Можно поступить по-разному: хранить всё в одной таблице (в этом случае в таблице будут содержаться все атрибуты всех подтипов, из-за чего многие значения буду пустыми, что не хорошо сказывается на производительности) или формирование нескольких таблиц для каждого подтипа и, возможно, отдельная таблица для супертипа. 
#### Взаимоисключающие связи
- общее хранение внешних ключей
- раздельное хранение внешних ключей
## Физическое проектирование БД
### Перенос логической модели в конкретную СУБД
- определение типов данных для атрибутов
- определение допустимости неопределенных значений
- выбор стратегии обработки исключительных ситуацией при попытках нарушения ссылочной целостности
- уточнение названий таблиц, атрибутов: хорошей практикой является непересечение пространства имён ключевых слов, операторов языка конкретной СУБД и названий объектов
- хранение и/или вычисление производных атрибутов
- реализация ограничений целостности, процедурная обработка
- формирование описания модели данных в рамках выбранной СУБД
- формирование индексов
- секционирование и партицирование: определение способов хранения базы данных. Например, для бОльшей производительности таблица может быть разбита как по строчкам, так и по столбцам и разнесена по разным файлам или узлам кластера.
### Критерии
- пропускная способность: среднее количество операций с БД, которые она может выполнять в единицу времени
- время ответа
- утилизируемые ресурсы

## SQL-DDL
### Создание схемы
```
<schema definition> ::=
	CREATE SCHEMA <schema name clause>
		[ <schema character set specification> ]
		[ <schema element> ... ]
```

Например,
```sql
create schema if not exists `store` default character set utf8;
```

### Создание домена
```
domain_definition ::= CREATE DOMAIN domain_name [AS] data_type
					  [ default_definition ]
					  [ domain_constraint_definition_list ]

default_definition ::= DEFAULT [ literal | niladic_function | NULL ]

domain_constraint_definition_list ::= [CONSTRAINT constraint_name] CHECK (conditional_expression)
```

Например, PostreSQL
```sql
create domain sale_status as varchar(45)
	default 'new'
	check (value in ('new', 'process', 'assembly', 'ready', 'delivering', 'issued', 'rejected'))
	constraint sale_status_not_null check (value is not null);
```

### Создание таблицы
```
base_table_definition ::= CREATE TABLE base_table_name (base_table_element_commalist)

base_table_element ::= column_definition | base_table_constraint_definition

column_definition ::= column_name { data_type | domain_name }
						[ default_definition ]
						[ column_constraint_definition_list ]

column_constraint_definition ::= [ CONSTRAINT constraint_name ] NOT NULL
								 | { PRIMARY KEY | UNIQUE }
								 | references_definition
								 | CHECK (conditional_expression)

references_definition ::= REFERENCES base_table_name [ (column_commalist) ]
						  [ MATCH { SIMPLE | FULL | PARTIAL } ]
						  [ ON DELETE referential_action ]
						  [ ON UPDATE referential_action ]
	
```

Оператор создания таблицы требует явного указания названия таблицы и некоторого списка, который может состоять из определения столбцов или определения каких-либо ограничений на уровне таблиц.

Соответственно, каждое определение столбца может состоять и обязано, как минимум, состоять из его названия, указания для типа данных или домена этого столбца. Далее опционально определение значений по умолчанию или каких-либо ограничений столбца.

Ограничения в описании столбца: можем указать, что столбец не может иметь неопределённого значения; можем указать, что столбец является частью или полностью первичным ключом или просто наложить на него ограничение уникальности, дальше указание references или возможность каких-либо ограничений на значения элементов данного столбца.

References: мы можем в определении столбца указать, что он является внешним ключом и указать таблицу и колонку, на который этот внешний ключ ссылается. Дальше есть описание типов проверки значения внешнего ключа (в основном это касается составных внешних ключей): 
- SIMPLE позволяет либо какому-либо элементу, составляющему первичный ключ, иметь неопределённое значение, либо, если все элементы, входящие во внешний ключ, определены, то должна быть запись в таблице, куда ссылается набор этих элементов, которая соответствует по значению. (по умолчанию)
- FULL обозначает либо, что все элементы внешнего ключа не определены, либо обязательно совпадает значение первичного ключа с какой-либо записью ключа из таблицы, на которую мы ссылаемся
- PARTIAL требует, чтобы каждый элемент был определён во внешнем ключе либо те элементы, которые не определены в значении внешнего ключа, так же были не определены и в таблице, на которую мы ссылаемся.

Далее идут стратегии выполнения операции при попытках нарушения ссылочной целостности: что должно происходить при обновлении или удалении значения из главной таблицы.

```
base_table_constrain_definition ::= [CONSTRAINT constraint_name]
									{ PRIMARY KEY | UNIQUE } (column_commalist)
									| FOREIGN KEY (column_commalist) references_definition
									| CHECK (conditional_expression)


referential_action ::= { NO ACTION | RESTRICT | CASCADE | SET DEFAULT | SET NULL }
```
Далее мы говорим о том, какими могут быть ограничения не отдельного столбца, а самой таблицы. Это ограничения первичного ключа или уникальности для набора полей (например, первичный ключ является составным). Отдельно здесь можно определить внешний ключ и набор составляющих его атрибутов. Можно дополнительно указать какую-либо функцию проверки.

Действие при нарушении ссылочной целостности:
- NO ACTION, RESTRICT -- отмена выполнения операции
- CASCADE -- каскадное изменений

Например: 
```sql
-- создание таблицы
create table if not exists `store`.`category` (
	`id` int not null,
	`name` varchar(255) null,  // может принимать неопределённые значения
	primary key (`id`))
engine = InnoDB  // используемый для хранения данных движок
default character set = utf8  // кодировка для хранения символьных данных
collate = utf8_general_ci;  // набор правил для сравнения символьных строк
```

```sql
-- таблица для реализации связи многие ко многим
create table if not exists `store`.`category_has_good` (
	`category_id` int not null,
	`good_id` int not null,
	primary key (`category_id`, `good_id`),  // составной первичный колюч
	index `fk_category_has_good_good_idx` (`good_id` asc),
	index `fk_category_has_good_category_idx` (`category_id` asc),
	constraint `fk_category_has_good_category`  // ограничение внешнего ключа для индентификатора категории
		foreign key (`category_id`) references `store.category` (`id`)
		on delete no action
		on update no action,
	constraint `fk_category_has_good_good`  // ограничение внешнего ключа для идентификатора товара
		foreign key (`good_id`) references `store.good` (`id`)
		on delete no action
		on update no action,
	engine = InnoDB
	default character set = utf8
```
Многие СУБД автоматически создают индекс по первичному или по внешнему ключу в предположении, что вероятнее всего значения этого ключа будут использоваться в условиях выборок.

### Изменение таблицы
```
base_table_alteration ::= ALTER TABLE base_table_name
						  column alteration_action
						  | base_table_constraint_alternation_action

column_alteration_action ::= ADD [COLUMN] column_definition
							 | ALTER [COLUMN] column_name {SET default_definition | DROP DEFAULT}
							 | DROP [COLUMN] column_name {RESTRICT | CASCADE}
```
Оператор изменения таблицы состоит из оператора изменения столбцов (изменить, добавить или удалить столбец) или изменения каких-либо ограничений (изменить, добавить или удалить)
```
base_table_constraint_alternation_action ::= ADD [CONSTRAINT] base_table_constraint_definition
											 | DROP CONSTRAINT constraint_name {RESTRICT | CASCADE}
```

Пример
```sql
alter table store.sale
	drop foreign key fk_order_client;

alter table store.sale
	drop index fk_order_client_idx;

alter table store.sale
	drop column client_id;

alter table store.sale
	add column
		is_exclusive_case boolean not null default 0;

alter table store.sale
	drop column dt_created,
	drop column dt_modified,
	drop foreign key fk_order_status,
	drop column status_id,
	add column ts_modified timestamp 
		on update current_timestamp,
	add column sale_status varchar(45) not null default 'new'
		check (value in ('new', 'process', 'assembly', 'ready', 'delivering', 'issued', 'rejected'));  // имитируем создание домена
```

# Нормализация
Создание набора отношений на основе некоторых требований. 

**Основная задача** -- найти наилучшую группировку атрибутов по отношениям в данной схеме

## Процесс нормализации
Идентификация отношений по 
- первичному или потенциальному ключу
- функциональной зависимости

Проверка отдельных отношений на соответствие правилам нужной нормальной формы.

### Нормальные формы
- ННФ -- ненормальная форма: без требований
- 1НФ -- первая нормальная форма -- обязательное требование реляционных БД: в каждой ячейке находится только одно значение.
- 2НФ, 3НФ, **БКНФ** -- устранение часто возникающих аномалий
- 4НФ -- решение проблем с многозначной зависимостью
- 5НФ -- решение проблем с зависимостями соединения

Существуют и нормальные формы после пятой, но, как правило, проектирование баз данных заканчивается на БКНФ.

**Функциональная зависимость** описывает связь между атрибутами отношения. Если в отношении один атрибут зависит от другого, то каждое значение первого атрибута связано только с одним значением второго. (например, если в отношении $R$ имеются атрибуты $X$ и $Y$, то любому значению $X$ соответствует только одно значение $Y$).

**Детерминант** -- атрибут, от которого полностью функционально зависит некоторый другой атрибут. Самый простой пример -- первичный ключ.

## Первая нормальная форма
**Ненормализованная форма** -- отношение содержит повторяющиеся группы данных в одной ячейке.

| Задание |Исполнитель  |
|--|--|
| Нормализовать БД | Иванов, Петров |
| Составить ER-модель | Петров |


**Первая нормальная форма (1НФ)** --  отношение, в котором на пересечении строки и столбца содержится только одно значение.



### Решения
1. Декомпозировать записи, продублировав остальные данные


| Задание |Исполнитель  |
|--|--|
| Нормализовать БД | Иванов|
| Нормализовать БД | Петров|
| Составить ER-модель | Петров |


2. Декомпозиция отношений: выделить списки в отдельную сущность
**Задача**

| ID |Название  |
|--|--|
|1 | Нормализовать БД |
| 2 | Составить ER-модель |

**Исполнитель**


| ID | Имя  |
|--|--|
| 1| Иванов|
| 2 | Петров |


**Задачи и исполнители** (для реализации связи многие ко многим)

| ID задачи | ID исполнителя  |
|--|--|
| 1 | 1 |
| 1 | 2 |
| 2 | 2 |


### Полная функциональная зависимость
В отношении атрибут $B$ полностью функционально зависит от атрибута $A$, если 
- $B$ функционально зависит от полного значения $А$ (в случае если атрибут $А$ составной)
- $B$ не зависит от подмножества полного значения $А$

## Вторая нормальная форма
1. Отношение находится в 1НФ
2. Каждый атрибут, не входящий в первичный ключ, полностью функционально зависит от первичного ключа.

Если первичный ключ только один (id), то отношение уже находится в 2НФ.

Составной первичный ключ возникает при декомпозиции в 1НФ связей многие ко многим.

**Решение** -- перенести не полностью функционально зависящие от первичного ключа атрибуты в другое отношение.

### Транзитивная зависимость
Если для атрибутов $A$, $B$ и $C$ существуют зависимости $$A\to B\quad\land\quad B\to C$$значит $C$ транзитивно зависит от $A$ через $B$, если $A$ функционально не зависит от $B$ и $C$.


## Третья нормальная форма
1. Находится во 2 НФ
2. Нет атрибутов, не входящих в первичный ключ, которые находится в транзитивной зависимости от первичного ключа. То есть все атрибуты зависят только от первичного ключа напрямую.


** Решение** -- выносить не зависящие напрямую атрибуты в отдельную сущность


## Нормальная форма Бойса-Кодда
1. Находится в 3НФ
2. Каждый детерминант является потенциальным ключом.

**Решение** - найти все детерминанты и убедиться, что они являются потенциальными ключами, то есть однозначно определяют запись в таблице. Если есть непотенциальные ключи, то их надо вынести в отдельную сущность.

Другой вариант -- убрать лишние ключи, оставив в таблице только один первичный ключ.


### Многозначная зависимость
Для каждого значения атрибута А есть наборы значений атрибутов В и С, но входящие в эти наборы значения не зависят от В и С. (то есть есть два набора значений, которые между собой никак не связаны)

**Тривиальная многозначная зависимость** -- $B \subset A$ или $A\cup B$ -- всё множество отношения.

## Четвертая нормальная форма
Не должно быть нетривиальных многозначных зависимостей или может быть единственная (т.е. функциональная) многозначная зависимость и отношение в НФБК (то есть есть один потенциальный ключ)


# ORM
**Объектно-реляционное отображение (Object-Relational Mapping)** -- технология, связывающая модель базы данных и концепции ООП. Позволяет работать с данными как с объектами.


### Преимущества ORM
- представление модели данных в ORM независимо от СУБД
- упрощенное моделирование базы данных
- ORM предоставляет больше механизмов обеспечения целостности данных
- возможность использовать наследование моделей 

### Недостатки ORM
- медленнее, чем голый SQL
- возможны проблемы с комплексными запросами
- идея всех ORM схожа, но реализации различны: нужно дополнительное обучение

## Django ORM

```py
from django.db import models

class Category(models.Model):  # отношение
	name = models.CharField(max_length=100)  # атрибут отношения типа VARCHAR(100)

	def get_available_products(self):  
		""" Gets products of current category with quantity > 0 """
		return Products.objects.filter(category=self, quantity__gte=0)  # создаём запрос средствами ORM
	

class Product(models.Model):
	name = models.CharField(max_length=100)
	price = models.DecimalField(max_digits=10, decimal_places=2)  # отношение типа DECIMAL(10, 2)
	quantity = models.IntegerField(default=0)  # здесь указано значение по умолчанию
	category = models.ForeignKey(Category, null=True)  # внешний ключ, ссылающийся на Categiry
```

### Миграции
Нужны для того, чтобы упростить работу с различными версиями схемы базы данных. Это набор инструкций для ORM, который позволяет перейти на конкретную схему БД, в том числе и откатывать изменения

`manage.py makemigrations` создаёт не привязанные к СУБД инструкции для отображения текущего состояния моделей (создаёт файл миграции, который затем можно применить с помощью migrate)

`manage.py migrate` -- используя миграции приводит базу данных, указанную в *settings.py* к виду, актуальному *models.py*.

### Пример
База данных онлайн-магазина:
- **Товар**: название, цена, количество, категории
- **Категория**: название
- **Пользователь**: почта, пароль
- **Корзина**: пользователь, товары, итоговая сумма

![](https://i.ibb.co/CQ3MP71/image.png)

![](https://i.ibb.co/tY0CnFh/image.png)

```py
from django.db import models
from django.contrib.auth.models import User  # часто используемая модель уже встроена в Django и связана с механизмами авторизации

class Category(models.Model):
	name = models.CharField(max_length=100)


class Product(models.Model):
	name = models.CharField(max_length=100)
	price = models.DecimalField(max_digits=10, decimal_places=2)
	quantity = models.IntegerField(default=0)
	categories = models.ManyToManyField(Category)  # самостоятельно создаст промежуточную таблицу


class Basket(models.Model):
	user = modes.OneToOneField(User)  # по сути создаёт foreign key с флажком unique
	products = models.ManyToManyField(Category, null=True)
	total_sum = models.DecimalField(max_digits=10, decimal_places=2)
```

Как только мы сделаем миграции и применим их к нашей базе, Django создаст ряд таблиц (наше приложение в Django называлось catalog):
- auth_user (входит во встроенное приложение авторизации)
- catalog_category
- catalog_basket
- catalog_basket_products: промежуточная таблица
- catalog_product
- catalog_product_categories: промежуточная таблица
#### ManyToManyField
```sql
sqlite> .schema catalog_product_categories

create table catalog_product_categories (
	id integer not null primary key autoincrement, -- создано автоматически
	product_id integer not null references catalog_product(id),
	category_id integer not null references catalog_category(id),
);

create unique index catalog_product_categories_product_id_9802d7aa_uniq 
	on catalog_product_categories(product_id, category_id);

create index ...;
create index ...; 
```

#### OneToOneField
```sql
sqlite> .schema catalog_basket

create table catalog_basket (
	id integer not null primary key auto_increment,
	total_sum decimal not null,
	user_id integer not null unique references auth_user(id) -- поле ссылается на модель Django-авторизации
);
```

# Администрирование MySQL
## План выполнения запроса
Описание того, какие отношения и как будут использоваться для выполнения запроса.

Показывает
- количество задействованных кортежей
- использование ключей: фактически и возможные

### Стратегия составления плана
- с какой таблицы начать: выбирает ту, где меньше кортежей
- какие условия лучше обработать первыми. чтобы отфильтровать больше
- какие ключи использовать, чтобы как можно раньше как можно больше отфильтровать

```sql
explain -- посмотреть план того, как mysql будет выполнять этот запрос
select * from sale_good
	join sale on sale.id = sale_has_good.sale_id,
	join good on good.id = sale_has_good.good_id;
```

## Индексы
Позволяют не сканировать целиком всю таблицу, а создавать ключи, которые в дальнейшем будут использованы при построении плана запроса и при выполнении запроса.

### Как хранятся данные в базе

Чтобы не сканировать большой список значений, нам сперва следует его упорядочить, и в упорядоченном списке бинарным поиском мы намного быстрее сможем найти конкретное значение. При этом, поскольку наш список постоянно меняется: у нас добавляются и убавляются кортежи, нам необходимо поддерживать этот список в упорядоченном виде.

Для этого необходимо использовать дерево, позволяющее достаточно легко добавить новый элемент и при этом сохранить список упорядоченным.

Эти списки, представленные в виде деревьев, и есть индексы,которые позволяют существенно ускорить выполнение запросов на больших данных, не сканируя таблицы целиком.

При этом есть два класса индексов:
- кластерный индекс: упорядоченное дерево, на листьях которого находятся сами данные. Он связан с первичным ключом и может быть только один у каждой таблицы. Он определяет, как именно данные будут храниться непосредственно в файловой системе. Но не всегда нам подходит обращаться исключительно по первичному ключу к данным: нередко нужно обращаться и по каким-то другим атрибутам.
- некластерный индекс: структуры, выстраиваемые вокруг данных со ссылками на кортежи. Они не определяют, как именно будут храниться данные. Работают чуть медленнее, чем первичный ключ, потому что нам нужно выполнить две операции для получения данных: сначала надо найти в структуре ссылку на нужный кортеж, а потом уже по этой ссылке получить данные в кластерном индексе, однако это всё равно намного быстрее, чем сканировать все кортежи в поисках каких-то значений.

В отношение можно добавить много некластерных индексов не только на каждый из атрибутов, но и на различные комбинации этих атрибутов.

Но при этом при изменении данных надо будет учитывать, что в этих структурах также должны быть сделаны некоторые изменения и любое изменение будет чуть медленнее, чем в случае отсутствия этих структур.

По умолчанию используется структура **В-дерево**. Индексы, построенные на В-дерево, хорошо подходят для
- операций сравнения
- проверки `is (not) null`
- сортировки
- группировки

Вторым по популярности типом индексов являются **хэш-индексы** (используются во внешних ключах). Для больших наборов данных они подходят для
- сравнений на равенство/неравенство
- проверки на вхождение

#### Другие типы индексов
- геолокация
- перекрывающие индексы
- многомерные структуры
- битовые индексы


Итак, индексы создают ключи, которые СУБД может использовать в плане запроса. СУБД выбирает наиболее подходящий ключ среди доступных, но пользователь может указать, какой ключ использовать лучше.

```sql
create index good_name_index on good (name);

drop index
```

# NoSQL
### Причины возникновения NoSQL (Not Only SQL) -- решений
- рост в потребности в распределённых СУБД с ростом объёма данных
- потребность в быстрой работе с данными: обычная реляционная СУБД имеет множетсво компонентов для того, чтобы было удобно писать запрос и можно было взаимодействовать практически с любой ОС или файловой системой. Однако это накладывает ограничения на скорость доступа к данным, что особенно заметно на простых операциях. В нереляционных СУБД отказываются от компонент, обеспечивающих универсальный доступ к данным (например, посредством языка SQL) для того, чтобы обеспечить быстрый доступ к данным и работу с ними для некоторых операций.
- некоторые часто встречаемые задачи можно моделировать проще (например, хранение документа со списками)

### Особенности NoSQL
- объект данных -- более сложная структура, чем просто строка из таблицы
- нет строго определённой схемы. В реляционных БД есть язык DDL, который определяет схему: таблицы, атрибуты и ограничения. В нереляционных это не так, поэтому они не подходят, если надо поддерживать порядок хранения данных
- нет операций соединения JOIN: следствие сложности хранимых структур данных и произвольности схемы
- простота масштабирования
- нет SQL, но бывает что-то похожее

### Теорема САР
Для распределённых систем можно выбрать только 2 свойства в ущерб третьего:
- **Consistency**: информация на разных узлах согласована
- **Availability**: система отвечает на все запросы пользователя
- **Partition tolerance** -- связи между узлами могут обрываться 

### BASE-архитектура
Некоторые правила, по которым действуют большинство современных NoSQL-СУБД
- **Basically Available** -- сбой узла приводит к отказу только для части пользователей/части функционала
- **Soft-state** -- система может находиться в неустойчивом состоянии (например, незавершенная транзакция), но должна стремиться из него выйти
- **Eventual Consistency** -- данные когда-нибудь согласуются на всех серверах: возможна ситуация, при которой на одних серверах уже применилось обновление, а на других оно ещё не применилось. Но в конце концов оно должно примениться на всех серверах.

### СУБД ключ-значение
Используется для работы с данными в реальном времени. Использует, как правило, оперативную память и SSD, что ускоряет работу с данными, но накладывает ограничениние на объём хранимых данных. Используется, например, в чатах, в играх и т.д.

Также используется для кэширования результатов долгих операций. Как правило, выстраивают следующую систему: есть реляционная БД, с которой выполняется сложный запрос. Кэширование позволяет избежать выполнение этого сложного долгого запроса лишний раз, если изменения в БД происходят намного реже запросов на чтение.

Ещё используются в качестве файловой системы: полный путь объектов к некоторому значению будет ключом, а значением будет файл.

**Примеры**: Berkeley DB, **Redis**, Memcache

### Документоориентированные

Создавались для хранения вложенных друг в друга документов и поиска по ним. 

Также используются в информационных ресурсах: например, главная страница сайта содержит новости с комментариями. В случае документоориентированной СУБД можно хранить комментарии прямо в новостях.

Также обеспечивает доступ к слабоструктурированным данным с нечеткой схемой

**Примеры**: MongoDB

### СУБД типа семейство столбцов

Используется для хранения данных, собранных с веб-страниц: нужна огромная таблица с большим множеством атрибутов. Они заточены под поиск большого объёма данных

Есть много общего с документоориентированными СУБД. Однако семейство столбцов рассчитано именно на большие объёмы данных, и в ней невыгодно хранить немного информации.

**Примеры**: Cassandra, HBase

# Redis
Чемпион по скорости считывания данных: вся информация хранится в оперативной памяти, и нет необходимости считывать что-то с диска, но есть и ограничения: если произойдёт какой-то сбой в узле редиса, то всё, что было в оперативке, скорее всего, пропадёт. Поэтому редис периодически скидывает свои слепки на жесткий диск.

- 100к операций в секунду для одного узла + масштабируемость
- всего больше сотни команд
- все команды работы с данными по крайней мере содержат ключ: мы не можем обратиться к данным напрямую
- для каждого типа данных свой набор CRUD команд, различаются префиксами, например, LPOP -- достать из списка, SPOP -- достать из множества

**Ключ** -- уникальная строка для одного набора данных.

Значения:
- строки: скалярные значения, для разных подтипов есть разные операции
- хэши -- для хэш-таблиц внутри значений (получается key-value хранилище внутри key-value хранилище)
- списки как `list` в Python
- множества как `set` в Python
- упорядоченные множества

### Репликация
У нас есть мастер-сервер, получающий данные на изменения. Когда данные на нём обновились, он постепенно посылает запросы с обновлёнными данными к серверам, которые работают только на чтение. Как только некоторая часть из серверов получила данные, они могут поделиться этими изменениями с другими серверами: так децентрализуется операция распространения изменений по всем серверам, уменьшая нагрузку на местер-сервер.

Между собой узлы в Redis обмениваются непосредственно самими изменениями, а не операциями, так как все изменения автомарные и достаточно простые (задействуется только один ключ).

### Подписки (PubSub)
Не нужно каждый раз спрашивать, есть ли новые данные: сервер сам пройдётся по активным подписчикам и отправит им изменения, когда они появятся. Это позволяет избежать лишних запросов о состоянии изменений и разгружает трафик между узлами.

# MongoDB
- Самая популярная ==> самая стабильная
- Простота хранения данных ==> нет проблем с миграциями
- сложность восприятия запросов, но легко писать интепретаторы и генераторы ==> разнообразие ORM

Запросы к MongoDB написаны на JavaScript и их условия -- JSON-конструкции. Зато легко найти драйвер с подходящим синтаксисом в любом языке.

```javascript
db.unicorns.find({gender: 'f', $or: [{loves: 'apple'}, {loves: 'orange'}, {weight: {$lt: 500}}]})
```
### Что есть вместо JOIN
#### Ссылки и списки ссылок на объекты
Не делаем никакий JOIN, в атрибуты объектов заносим ссылки на другие объекты. Но нужно делать несколько запросов.

#### Встраивание документов
Маленькую информацию или списки выгодно хранить прямо внутри документа: например, контакты как вложенный словарь. Однако, если данные дублируются, может возникнуть аномалия

#### DBRef
Тип данных для использования в драйверах и ORM
```javascript
db.post.find({'author': DBRef("user", ObjectId('...'))})
```

### Репликация
Схема репликация аналогична Redis, за исключением того, что между slave-серверами (то есть теми, которые работают только на чтение), нет прямого обмена данными, то есть всё передаётся через мастер.

Если мастер падает, MongoDB инициализирует перевыборы нового мастера и назначает одного из слейвов новым мастером. Таким образом обеспечивается basically availability.

> Written with [StackEdit](https://stackedit.io/).
