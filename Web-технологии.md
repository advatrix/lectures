## Internet и WWW
Интернет -- глобальная сеть передачи данных. Это просто среда для передачи данных

В интернете работает большое количество протоколов -- алгоритмов, обеспечивающих различные сервисы по передаче данных. Эти протоколы образуют стек, то есть одни протоколы работают поверх других протоколов.

- HTTP, SSH, P2P, FTP - прикладные протоколы. Реализуют логику, связанную с какой-то конкретной доменной областью. Например, FTP -- для передачи больших файлов, P2P -- передавать файлы быстро, SSH -- безопасным образом получить удалённый доступ к какой-то машине. Нас будет интересовать протокол HTTP: он позволяет передавать вместе с файлами метаинформацию.
- DNS
- TCP -- работает поверх IP. Обеспечивает надёжную доставку данных: если с одной машины через протокол TCP передать какой-то кусочек данных, то они будут гарантированно доставлены, но время доставки не гарантируется. Он обеспечивает интерфейс, похожий на работу с файлами.Данные передаются в виде потока, внутренняя структура которого TCP совершенно не интересует.
- IP -- глобальная адресация, передача в гетерогенной среде. Позволяет передавать данные между двумя произвольными устройствами в сети. Он вводит глобальную адресацию, то есть у каждой машины, подключенной к сети (с некоторыми оговорками), есть уникальный IP-адрес. Этот IP-адрес состоит из 4 байт и позволяет уникально идентифицировать машину в сети и эффективно доставлять к ней информацию. Он работает с дельтаграммами -- небольшими кусочками данных и не гарантирует доставку данных.

WWW -- множество взаимосвязанных документов, работающих поверх интернета, располагающихся на машинах, подключенных к интернету. С другой стороны, это набор протоколов, по которым эти документы передаются с сервера на клиент. Это лишь один из частных случаев применения сети интернет.

На сайтах лежат гипертекстовые документы (HTML), которые ссылаются друг на друга с помощью гиперссылок. 

Помимо HTML-файлов, в WWW лежат и другие документы: картинки, стили (CSS), JavaScript. Эти документы часто называют ресурсами. Ресурсы также являются документами.

## Документы
### Типы документов (MIME-типы)
- text/html
- text/css
- text/javascript
- image/png
- video/mp4
- text/xml (строже html, обычно используется для обмена данными между приложениями), также возможна неоднозначность в представлении данных (данные могут быть атрибутами или тегами)
- application/json
- ...

Он указывает получателю (клиенту) способ, которым можно отобразить данный документ.

Расширение документа на диске не играет роли. То, каким образом обрабатывается файл, определяется именно его MIME-типом.

MIME-тип может быть определён по расширению, по содержимому файла или в ручном режиме.

Документы могут быть
- статическими
	- это файлы на дисках сервера
	- как правило, обладают постоянным адресом
- динамические
	- генерируются на лету по каждому запросу
	- содержимое зависит от времени и пользователя
	- адрес может быть постоянным или меняться

## URL -- Unified resource locator

```http
http://server.org:8080/path/doc.html?a=1&b=2#part1
```
- http -- протокол, с помощью которого нужно этот URL загружать.
- server.org -- DNS имя сервера. здесь также может указываться IP-адрес конкретной машины
- 8080 -- TCP порт.
- /path/doc.html -- путь к файлу
- a=1&b=2 -- опции запроса, опции генерации для динамических документов
- part1 -- якорь, положение на странице

С помощью URL можно однозначно определить, откуда документ получать.

По умолчанию протокол HTTP использует порт 80, HTTPS -- 443.

### Абсолютные и относительные URL
- `https://server.org/1.html` -- абсолютный
- `//server.org/1.html` -- абсолютный schemeless. Используется при разработке веб-сайтов, которые работают как по протоколу HTTP, так и по протоколу HTTPS. Браузер автоматически подставит в начало URL тот протокол, по которому был загружен данный документ.
- `/another/page.html?a=1` -- относительный в пределах домена: начинается с одного слеша. Используется для загрузки документов со своего сайта: не зависит от доменного имени.
- `pictures/1.png` -- относительный (от URL текущего документа): начинается не со слэша.
- `?a=1&b=2` -- относительный (от URL текущего документа). Это URL того же самого документа, который мы смотрим, но с другими опциями.
- `#part2` -- относительный в пределах текущего документа. Если нужно промотать документ от одной позиции к другой.

### Как документы могут ссылаться друг на друга?
#### HTML-гиперссылки
```html
Список товаров в <a href="/cart.php">корзине</a>
```

#### HTML-формы
```html
<form action="https://duckduckgo.com/">
	<input type="text" name="q" value="">
	<input type="hidden" name="ia" value="images">
	<button type="submit">Найти</a>
</form>
```
В атрибуте `action` тега `form` указан URL, на который будет отправлена форма после нажатия кнопки. Таким образом, с помощью формы можно перейти от одного документа к другому, дополнительно при этом передав некоторые данные, которые пользователь ввёл в этой форме.

#### HTML-ресурсы
Для каждого из ресурсов используется свой способ загрузки:
```html
<link rel="stylesheet" href="/css/index.css">
<script src="http://code.jquery.com/jquery-2.1.4.js"></script>
<img src="pictures/network.png" width="200">
```

#### CSS-ресурсы
```css
.slide {
	background-image: url(../pictures/network.png)
}
@font-face {
	font-family: Terminus;
	src: url(fonts/terminus.ttf)
}
```

#### JavaScript
```javascript
var saveApiUrl = '/items/save';
var newTitle = 'Duck tales';
$.ajax({ // ajax запрос к браузеру с помощью jQuery
	type: 'POST',
	url: saveApiUrl,
	data: { id: 10, title: newTitle }
});
```

## Клиент-серверная архитектура
Web-клиенты работают на компьютерах конечных пользователей. Задача Web-клиентов состоит в получении и отображении документов, а также отображение различных связанных с этими документами ресурсов. Это может быть браузер или мобильное приложение.

Web-сервера работают, как правило, на серверах в датацентрах. 

### Преимущества
- открытый прокол: HTTP-протокол открыт и очень хорошо документирован, реализован на огромном количестве языков.
- стандартный клиент: не нужно писать новое клиентское приложение, если уже есть браузер.
- прозрачный способ взаимодействия приложений: один сайт может ссылаться на другой сайт с помощью URL
- распределенная и масштабируемая система: одно приложение может быть запущено сразу на нескольких серверах. Когда браузер загружает документ и обращается к приложению, произвольным образом выбирается один из доступных серверов, и в дальнейшем взаимодействие происходит только с ним. Таким образом, нагрузка на приложение балансируется между несколькими серверами.

## Web-клиенты
### Разновидности веб-клиентов
- Библиотеки в ЯП: libcurl, urlllib и тд.
- Консольные утилиты: wget, curl, telnet
- роботы: поисковики, вредоносные скрипты
- браузеры:
	- полноценные: firefox, chrome и т.д.
	- встроенные: web-view, webkit и т.д.
### Особенности библиотек веб-клиентов
- предоставляют максимум опций для работы с HTTP
- осуществляют кодирование/декодирование данных
	- в некоторых случаях текстовые данные могут быть сжаты, например, алгоритмом gzip. В этом случае библиотеки сами распакуют текст.
- перенаправления, куки - опционально

#### Пример
```py
import urllib
import urllib2

url = 'http://api.site.com/method'
values = {'argument1': 'value1',
		  'argument2': 'value2'}
headers = {'User-Agent': 'python urllib2'}
data = urllib.urlencode(values)
req = urllib2.Request(url, data, headers)
response = urllib2.urlopen(req)  # предоставляет интерфейс, как у файлового дескриптора
result = response.read()
```

### Консольные клиенты
- автоматизация в shell-скриптах
- создание статической копии сайта: рекурсивно скачать все необходимые сайты
- отладка веб приложений

Telnet -- простейшее средство отладки. Открывает tcp-соединение и связывает его с консолью, позволяя общаться с веб-серверов напрямую с клавиатуры.
```bash
[user@user]$ telnet www.ru 80
...
// подключение
...
GET /index.html HTTP/1.1
Host: www.ru
...
Ответ
```

Curl -- полноценный консольный клиент:
`curl -vv 'http://...'` -- GET-запрос к серверу с отображением всех заголовков
`curl -vv -d 'arg1' -H 'X-Token: 123' 'http://...'` -- POST запрос к серверу с авторизацией и передачей доп. заголовков

### Браузер
#### Сценарий работы веб-приложения (каким веб задумывался изначально)
1. Пользователь вводит URL
2. Браузер загружает веб-страницу -- HTML-документ
3. Браузер парсит HTML и загружает доп. ресурсы
4. Браузер рендерит HTML страницу
5. Пользователь переходит по гиперссылке или отправляет форму
6. Цикл повторяется

#### Веб-сервер и Application сервер

Веб-сервер работает со статичными документами, Application сервер генерит их на лету.

#### Сценарий работы современного веб приложения
1. Браузер загружает веб страницу, ресурсы и отображает её
2. Javascript загружает данные с помощью AJAX запросов
3. Javascript обеспечивает полноценный UI на странице
4. Пользователь взаимодействует с UI, что приводит к вызову Javascript
5. Javascript отправляет данные на сервер или загружает новые, используя AJAX

AJAX-запрос -- такой же как и HTTP-запрос, только инициируется javascript'ом.

При этом сервер в ответ на AJAX возвращает, как правило, не новую веб-страницу, а сырые данные в формате JSON/XML, которые затем обрабатывает Javascript на стороне клиента. Таким образом, пользователь фактически всё время сидит на одной веб-странице с динамически меняющимся контентом.

#### Особенности SPA (Single Page Applications)
1. UI находится на одной или нескольких страницах
2. UI полностью статичен: HTML, CSS, JS -- статические файлы
3. Логика UI полностью работает на стороне клиента
4. Используется шаблонизация в Javascript
5. Application сервер возвращает чистые данные (JSON или XML  а не HTML)


## HTML
Представляет смесь текста с тегами.
```html
<!DOCTYPE html>
```

### Особенности:
- произвольный регистр
- атрибуты без скобок: color=red
- сокращённые атрибуты: disabled (могут состоять только из имени)
- непарные тэги: `<p>` вместо `<p></p>`
- перестановки тэгов: `<b><i></b></i>`
- свои тэги: `<magic>`

### Особенности XHTML разметки
- только нижний регистр тэгов
- атрибуты со скобками: `color="red"`
- атрибуты без сокращений: `disabled="disabled"`
- тэги всегда парные
- строгая вложенность
- id вместо name
- необходим DOCTYPE

### DOCTYPE
Уточняет тип содержимого, указывает HTML парсеру, как правильно разобрать данный документ. Формально в DOCTYPE должна содержаться ссылка на .dtd документ с описаниями возможных тэгов и их правил. Для HTML5: `<!DOCTYPE html>`

### HTML-тэги
#### Тэги верхнего уровня
- `html` -- обёртка. Весь HTML-документ должен содержаться внутри этого тэга. Иногда указывается атрибут `lang="en"`.
- `head` -- заголовок страницы, не отображается
- `body` -- тело страницы, внутри него содержится то, что видит пользователь

#### Тэги внутри head
- `title` -- отображается в заголовке окна браузера
- `meta` -- содержит информацию для user-агентов
- `link` -- указание связанных ресурсов, например, CSS
- `script` -- загрузка Javascript

Загрузку CSS (тэг `link`) рекомендуется ставить в тэге `head`, а загрузку Javascript (тэг `script`) -- наоборот, ближе к концу страницы. Это повышает скорость отрисовки страницы, так как при получении новых стилей браузер перерисовывает документ, и идеальным вариантом будет получить все стили ещё до начала отрисовки документа.

#### Тэги внутри body
##### Блочные тэги
- `h1` - `h6` -- различные уровни заголовков
- `p` -- разбиение текста на параграфы
- `hr` -- горизонтальная линия
- `pre` -- блок преформатированного текста, например, исходный код
- `blockquote` -- цитирование длинного блока текста
- `div` -- абстрактный блочный контейнер. Используются для задания структуры, визуально никак не отображается.

Блочные тэги занимают всю предоставленную ширину при отрисовке, хотя ширину можно прописать в коде. Также они всегда начинаются с новой строки, даже если в коде они записаны в одной строки.

##### Строчные тэги
- `a` -- гиперссылки
- `em`, `i` -- акцентирование
- `strong`, `b` -- выделение жирным
- `img` -- вставка изображений
- `sub` -- нижний индекс
- `sup` -- верхний индекс
- `span` -- абстрактный строчный контейнер

Строчные тэги занимают минимально возможную ширину и не прерывают строчку. Задать их размер нельзя.

### Списки
- `ul` -- маркированный
- `ol` -- нумерованный
- `li` -- выделение одного элемента

```html
<ul>
	<li>Первый элемент списка</li>
	<li>Второй элемент списка</li>
<ul>
```
### Таблицы
- `table` -- контейнер таблицы
- `tr` -- строчка таблицы
- `td` -- одна ячейка внутри одной строки таблицы
	- атрибуты `colspan`, `rowspan` позволяют объединять ячейки.
- `caption` -- название таблицы
- `thead` содержит строки
- `tbody` можно не писать
- `th` -- ячейки заголовков

### Гиперссылки
```html
<a href="http://duckduckgo.com" target="_blank">
	<img src="duck.png">
</a>
```
- `href` -- URL гиперссылки
- `target` -- в каком окне открывать ссылку (по умолчанию ссылка открывается в текущем окне)
- `name` -- имя якоря, вместо `href`:

```html
<a href="#1">... -- при нажатии сюда произойдёт переход в то место документа, где написано <a name="1">
```

#### Действия браузера при переходе по ссылке
Поведение браузера зависит от протокола в URL:
- `http`, `https`, `ftp` -- переход по ссылке
- `mailto` -- запуск почтового клиента
- `javascript` -- выполнение Javascript кода
- `#anchor` -- прокрутка текущей страницы

### Формы
Состоит из тэга `form`. Атрибуты:
- `method`: метод, с помощью которого форма будет отправлена на сервер -- GET или POST.
- `action`: указывает URL, на который будет отправлена форма
- `target`: окно, в котором будет загружена открытая форма.
- `enctype`: способ кодирования данных формы. По умолчанию -- `application/x-www-form-urlencoded`. Если форма содержит поля для ввода файлов, то должно быть `multipart/form-data`

#### application/x-www-form-urlencoded
Это способ кодирования данных формы для передачи непосредственно через URL.  Например, `id=3&name=%D0%92&friend=4&friend=5`

#### Поля для ввода данных
- `input` -- универсальное поле, может быть
	- `type="hidden"` -- невидимое
	- `type="text"` -- текстовое, `type="password"` -- для ввода паролей
	- `type="checkbox"` -- чекбокс
	- `type="file"` -- кнопка выбора файла для загрузки
- `button` -- кнопка
- `textarea` -- многострочное поле ввода
- `select`, `option` -- выпадающий список

#### Атрибуты элементов ввода

- `type` определяет внешний вид и функционал
- `name` -- имя, с которым данный элемент попадет в запрос
- `value` -- начальное значение, пользователь может изменить
- `placeholder` -- подсказка для пользователя
- `autocomplete` -- управление автозаполнением


## CSS
**Как задать оформление страницы?**

HTML,  в отличие от XML, обладает семантикой, то есть браузер знает, как отображать тот или иной тэг HTML. В HTML есть тэги для управления внешним видом (`color`, `font`, `big`, ...), но их возможности явно недостаточны.

Решение -- описывать внешний вид отдельно от структуры документа с помощью языка **Cascading Style Sheets**.

### Синтаксис
CSS состоит из правил. Правило состоит из селектора и в фигурных скобках для данного стиля задаются стили: 
```css
.mid-play {
	padding: 13px 0px 0px 13px;
}
/* селектор { имя стиля1: значение1; } */
```

### Где могут быть заданы стили?
- в браузер зашиты стили по умолчанию: когда мы смотрим чистый HTML-файл, мы его видим в контексте заданных по умолчанию стилей в браузере.
- во внешнем файле 
```html
<link rel="stylesheet" href="style.css">
```
- в коде HTML документа
```html
<style>...</style>
```
- стили могут быть привязаны к конкретному тэгу
```html
<img style="margin: 3px" src="...">
```

### Какие бывают стили
- `width`, `height` -- размеры элемента
- `margin`, `padding` -- границы и отступы
- `display`, `visibility` -- режим отображения
- `top`, `left`, `right`, `bottom` -- расположение
- `background` -- фон элемента
- `font` -- управление шрифтом
- `text-align` -- выравнивание текста

### CSS селекторы
Селектор -- способ задать множество элементов, к которому мы применяем определённые стили.
#### Классы и идентификаторы
Атрибуты `id` и `class` могут быть указаны у любого HTML-элемента. Причём
- значение атрибута `id` должно быть уникальным в пределах страницы. Это способ выделить ровно один элемент на странице.
- значение атрибута `class` определяет класс элемента и может повторяться

```html
<div id="userpic"><img src="..."></div>
<button class="btn btn-main">Одобрить</div>  // данный элемент принадлежит двум классам
<button class="btn">Написать комментарий</div>
```

#### Базовые селекторы
- универсальный селектор `*` выбирает вообще все элементы на странице. Часто используется, чтобы сбросить все стили браузера.
- имена тэгов `p`
- имена классов (с точки) `.btn`
- id тэгов (с решётки) `#userpic`

#### Сложные селекторы
- контекстные (вложенные) 
	- Например, `div.article a` означает, что нужно выбрать все тэги `a` находящие внутри элементов `div` с классом `article`
- дочерние (1 уровень вложенности): 
	- `a > img`: выбрать все элементы `img`, которые находятся сразу внутри гиперссылки
- соседние
	- `h2.sic + p` -- выбрать все параграфы, которые идут после тэга `h2` с классом `sic`
- группировка: `h1, h2`

#### Псевдоклассы
Эти классы автоматически добавляются браузером:
- `a.visited` -- посещённая ссылка
- `a:link` -- непосещенная ссылка
- `div:hover` -- элемент при наведении мыши
- `input:focus` -- элемент при получении фокуса
- `li:first-child`: выбирает первого потомка среди множества элементов


#### Псевдоэлементы
Тэги, которые не присутствуют в исходном файле, а которые создаются браузером при применении некоторых стилей. 
- `#el:after` -- виртуальный элемент сразу после `#el`
- `#el:before` -- виртуальный элемент непосредственно перед `#el`

```css
.jack-sparrow:before {
	content: "Captain";
	display: inline;
}
```
### Наследование и приоритеты
Некоторые стили имеют свойство применяться не только к элементу, для которого они написаны, но и для всех вложенных в него элементов.

Например,
```html
<head>
	<style>
		body { color: darkgray; font-family: Arial; }
		p { font-size: 110% }
	</style>
</head>
<body>
	<p> Привет, <a href="/">Мир</a></p>
</body>
```
Стиль, описанный внутри тэга `style`, применяется к тэгу `body`. Но непосредственно в тэге `body` никакого текста нет, зато есть во вложенных, и эти стили наследуются.

Аналогично наследуется и стиль параграфа, в который вложена ссылка. Ссылка будет иметь унаследованный от `body` темно-серый цвет и унаследованный от `p` размер 110%.

Как правило, наследуются стили, связанные с оформлением текста, цветом, шрифтами и тому подобным. 

Синтаксис CSS позволяет создать конфликтующие стили. В случае если два разных стиля конфликтуют между собой, применяется тот, что обладает большей **специфичностью**. Если специфичность двух стилей совпадает, применяется тот, что расположен **ниже** в HTML/CSS коде.

Указание в значение стиля флага `!important` позволяет перекрыть проверку специфичности.

#### Правила расчёта специфичности
- id -- 100 баллов
- классы и псевдоклассы -- 10 баллов
- тэги и псевдоэлементы -- 1 баллов

Все баллы складываются.

### Отображение элементов
#### Режимы отображения элементов
- `display: none` -- элемент невидим и не занимает места
- `display: block` -- элемент занимает максимальную ширину, начинается с новой строки, учитывает width, height
- `display: inline` -- элемент занимает минимальную ширину и не прерывает строку. Игнорирует width, height.
- `display: inline-block`: блочный элемент, но не разрывает строку, примерно как img.

#### Всплывание
- `float: left` -- всплывание влево (например, картинки в тексте)
- `float: right`
- `clear: both` -- отменяет всплывание, "проводит черту"

#### Позиционирование
- `position: static` -- обычное расположение, по умолчанию
- `position: relative` -- смещение относительно начального местоположения на странице
- `position: absolute`: если родитель relative, absolute или fixed -- относительно родителя, иначе -- относительно начала документа
- `position: fixed` -- относительно окна браузера
- `top/right/bottom/left` -- отступы, могут быть отрицательными


### Отступы и box-model
**Box-model**: содержимое -> padding -> border -> margin

По умолчанию высотой и шириной элемента считается высота и ширина содержимого (content-box).

Для управления тем, что считать размерами элемента, можно использовать стиль `box-sizing`. По умолчанию он равен `content-box`. Однако если применить стиль `box-sizing: border-box`, то под размерами объекта будут пониматься размеры содержимого + padding + border. Такой подход удобнее для построения интерфейсов.

### Bootstrap
Bootstrap -- это готовая библиотека стилей. Позволяет быстро разработать приемлемый дизайн даже при базовых знаниях CSS.

# Сетевые протоколы
Что делает браузер при HTTP-запросе?

1. Анализирует введенный URL и извлекает имя хоста
2. Используя систему DNS, преобразует домен в IP-адрес веб-сервера
3. Устанавливает TCP-соединение с веб-сервером
4. Если протокол HTTPS, устанавливает TLS соединение поверх TCP
5. Формирует HTTP запрос, отправляет его и получает документ
6. Браузер закрывает соединение (для HTTP/1.0)
7. Браузер загружает связанные ресурсы



![enter image description here](https://i.ibb.co/4jmwQnw/image.png)
Здесь 1 -- браузер клиента, 2 -- ОС клиента, 3 -- веб-сервер, 4 -- ОС на сервере.

## DNS
DNS -- это распределенная база данных, хранящая информацию о доменах, в первую очередь отображение доменных имен на IP адреса машин, обслуживающих эти домены.

### Пространство доменных имен

Пространство доменных имён -- это строки, состоящие из слов, разделённых через точку.
![](https://i.ibb.co/Xjw75QB/image.png)

Корень дерева доменных имён -- точка. Но обычно её не пишут.

Далее идут домены уровня стран и организаций -- доменные имена. Их список фиксирован и изменяется очень редко

Далее идут домены второго уровня -- они примерно соответствуют организациям.

Далее идут домены третьего и более низких уровней.

### Домены и зоны

База DNS разделена на **зоны**. Каждая зона находится под единым административным контролем, проще говоря, обслуживается одной организацией.

Хранение информации о доменах более высокого уровня может быть **делегировано** другим зонам.

![](https://i.ibb.co/Q8k30vj/image.png)

### Обработка DNS-запроса

![](https://i.ibb.co/LgT31YW/image.png)

Когда ОС запускается, в ней должен быть изначально настроен какой-либо DNS-сервер.

- Он может быть явно прописан 
- Он может быть получен по протоколу DHCP при подключении к провайдеру
- Существует заранее известный список корневых серверов с фиксированными адресами

DNS-клиент -- браузер. Ему необходимо преобразовать доменное имя в IP-адрес.

 Операционной системе известен адрес какого-то DNS-сервера (скорее всего, это DNS провайдера). Клиент делает запрос по протоколу DNS к DNS-серверу: "скажи нам адрес сервера dobro.mail.ru". 

DNS-сервер, естественно, об этом сайте ничего не знает. Он знает адреса корневых серверов, и первым делом запрашивает корневой сервер DNS со словами "мне нужен адрес сайта dobro.mail.ru".

Корневой DNS-сервер тоже ничего про этот адрес не знает. Зато он знает, кто обслуживает зону .ru. Поэтому корневой сервер возвращает адреса серверов рунета.

DNS-сервер провайдера повторяет свой запрос, но уже к одному из серверов рунета. Сервера рунета тоже не знают адрес этого сайта, зато они знают адрес DNS-сервера mail.ru, и они возвращают этот адрес.

Повторяя тот же запрос уже к серверу mail.ru, DNS-сервер получает  IP-адрес dobro.mail.ru и его возвращает.

Таким образом, этот IP-адрес попадает в браузер.


Тут есть несколько нюансов:
- кэширование адресов на DNS-сервере провайдера. Например, он будет сразу ходить на сервера рунета или сразу на mail.ru. Таким образом снижается нагрузка на корневые сервера, которых немного.

DNS-сервер возвращает не только IP-адрес, но и ту информацию, которая у него прописана в зоне конкретного домена:
- А -- IPv4 для данного домена
- АААА -- IPv6 адрес(а)
- NS -- адрес(а) DNS-серверов, обслуживающих данную зону
- MX -- адреса почтовых серверов для данного домена (хранятся отдельно)

На локальной машине есть файл **etc hosts**, который проверяется в первую очередь.

## TCP
Итак, браузер получил адрес сервера и теперь необходимо установить TCP-соединение. Зачем нужен TCP, почему бы просто не передавать данные через IP? Дело в том, что протокол IP не реализует надежную доставку данных и позволяет передавать данные между двумя машинами. Нам же нужно передавать данные между двумя программами -- есть небольшая разница: на веб-сервере может быть запущено большое количество разных программ, и когда мы передаём данные, необходимо указать, для какой именно программы мы эти данные передаём. 

TCP и нужен для решения этих двух задач.

TCP -- протокол, обеспечивающий надежную последовательную доставку данных. Фактически, TCP предоставляет интерфейс, похожий на файловый ввод/вывод для сетевых соединений.

- надёжная доставка: после того, как вы получили ответ о том, что данные переданы, они будут доставлены в том виде, в котором вы их передали. Если данные тем или иным образом потерялись, они будут доставляться до тех пор, пока они не будут доставлены. Если же протокол понимает, что никак дальше продолжать нельзя, то он вернёт ошибку и вы узнаете о том, что передача действительно не удалась. В том случае, если передача удаётся, корректность и правильность данных гарантируется протоколом TCP  с помощью проверочных сумм (чек-сумм).
- полнодуплексная передача: двусторонняя передача данных, можно передавать как данные от клиента к серверу, так и от сервера к клиенту.
- контроль потока -- защита от переполнения: при передаче данных важно синхронизировать клиент и сервер, либо сервер или клиент в зависимости от того, в какую сторону идет передача так, чтобы передающая сторона данных передавала не больше, чем получатель может потребить, иначе будет происходить переполнение буфера и данные будут теряться или отбрасываться.

### TCP-порты
TCP-порт -- это "адрес" сетевого соединения в пределах одного хоста. ТСР порты позволяют поддерживать множество открытых соединений на одной машине.

Номер порта -- целое число не больше 65535. Порты ниже 1024 требуют привелегий суперпользователя для использования.

Каждый порт связан с какой-то одной конкретной программой, и ОС знает об этой связи, поэтому данные, которые передаются на этот порт, будут попадать в конкретную программу на данной машине. 

Адреса портов могут выбираться произвольно, но исторически некоторые номера закреплены за определёнными приложениями:
- 20, 21 -- FTP
- 22 -- SSH
- 25 -- SMTP
- 80 -- HTTP
- 443 -- HTTPS

![](https://i.ibb.co/TbRq2mS/image.png)
При установлении TCP-соединения клиент и сервер обмениваются тремя пакетами -- **тройное рукопожатие**.

Сначала клиент отправляет серверу TCP-сегмент со специальным флагом `SYN` (синхронизация). В этом пакете он отправляет порядковый номер пакета (число, начиная с которого TCP-сегменты будут нумероваться в потоке). Сервер отвечает клиенту, возвращая TCP-сегмент с флагами `SYN` и `ACK` (принятие пакета SYN от клиента и открытие обратного соединения), отправляет свой порядковый номер своего потока, на что клиент отвечает сегментом `ACK`.

После тройного рукопожатия у клиента и у сервера есть два числа -- порядковые номера передачи и они могут приступать к передаче данных.

Мы видим, что между началом, когда клиент открывает соединение (`connect`) и моментом, когда он может что-то передавать проходит некоторое время установления соединения. Примерно такое же время проходит и на сервере (RTT). Это время примерно равно так называемому **Round Trip Time** -- время путешествия данных от клиента к серверу и обратно. Оно сильно зависит от того, как близко сервер находится к клиенту: если они в одном датацентре, время мало; а если на разных континентах -- это может быть до 150 мс.

После рукопожатия протокол ТСР готов к передаче данных. Но до этого должно пройти некоторое время.

### Пример  ТСР клиента
```py
import socket

req = 'Hello tcp!'
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  # создаётся новый объект socket, указываем две опции
# AF_INET показывает, что мы работаем с сетевыми сокетами (в Unix бывают ещё и локальные)
# SOCK_STREAM указывает на то, что мы будем использовать сокет для работы с протоколом ТСР.

s.connect(('127.0.0.1', 1234))  # подключаемся к удаленной машине. Происходит тройное рукопожатие
s.send(req)  # отправляем данные

rsp = s.recv(1024)  # получаем данные (размер буфера 1024 байт)
s.close()  # закрываем соединение
```


### Пример TCP-сервера 
Эхо сервер
```py
import socket

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  # создаём новый сокет
s.bind(('127.0.0.1', 1234))  # данный сокет связывается с адресом и портом
s.listen(10)  # начать принимать сетевые соединения на данном адресе
# таким образом, s становится серверным сокетом, то есть сокетом, принимающим соединение
# 10 -- длина очереди клиентов к серверу

while True:
	conn, addr = s.accept()  # если установлено новое соединение от клиента. Метод возвращает сокет для работы с конкретным клиентом и адрес клиента
	while True:
		data = conn.recv(1024)  # читаем данные
		if not data: break  # данные не пришли, выходим
		conn.send(data)
	conn.close()  # соединение закрывается и сервер обслуживает следующего клиента
```

### Как правильно читать данные из сокета?
При чтении из сокета никто не гарантирует нам, что там окажется столько данных, сколько мы ожидаем. Например, мы ожидаем 1024 байта, но из-за работы сети нам удалось доставить только первые 10, оставшиеся данные не получается доставить. Таким образом, при вызове функции получения мы не знаем, какой объем данных она нам вернёт, поэтому при чтении какого-то объёма данных из сети желательно знать, сколько данных мы хотим прочитать и следить за тем, сколько мы уже прочли.
```py
def myreceive(sock, msglen):
	msg = ''
	while len(msg) < msglen:
		chunk = sock.recv(msglen - len(msg))
		if not chunk: raise RuntimeError('broken')
		msg += chunk
	return msg
```
Допустим, мы знаем, что мы хотим прочитать 1 Мб. Мы заводим буфер `msg` и в бесконечном цикле, пока мы не прочитали нужное количество, мы читаем какой-то кусочек из сокета (`sock.recv(msglen-len(msg))`), читая не больше, чем нам осталось. Если ничего не пришло, кидаем ошибку, иначе дописываем пришедшее в буфер. Таким образом, мы читаем небольшими кусочками, пока не прочитаем тот объём, который нам изначально необходим.
### Как правильно записывать данные в сокет?

Аналогичная ситуация и с записью. Мы не можем просто написать `sock.send(msg)` и отправить весь документ, потому что пользователь может быть не готов принять такой объём данных.
```py
def mysend(sock, msg):
	totalsent = 0
	while totalsent < len(msg):
		sent = sock.send(msg[totalsent:])  # возвращает, сколько байт удалось отправить
		if not sent: raise RuntimeError('broken')
		totalsent += sent
```
## TLS
Браузер установил ТСР-соединение и далее, в принципе, он может работать по протоколу HTTP. Но если он использует HTTPS, необходимо поверх ТСР соединения установить TLS.

**TLS** (а ранее SSL) -- криптографический протокол, обеспечивающий безопасную передачу данных между хостами в интернете.

В ТСР данные передаются в открытом виде и их легко перехватить. TLS обеспечивает шифрование данных.

- аутентификация сервера и клиента: при ТСР-подключении мы доверяем тому хосту, к которому мы подключаемся. Но на самом деле есть уязвимости, при которых можно подключаться не к тому серверу, которые желаешь: например, если испорчен файл */etc/hosts*. Надо проверить, что сервер, к которому мы подключаемся -- именно тот, к которому мы хотим подключиться.
- шифрование и сжатие передаваемой информации
- защита от подмены и проверка целостности сообщений: решается задача подписи передаваемых данных

TLS -- прозрачная обёртка над TCP с тем же интерфейсом.
![](https://i.ibb.co/PTz30R6/image.png)

Начинается всё с отправки сообщения ClientHello. В этом сообщение клиент указывает те опции соединения, которые он бы хотел использовать: в частности, нужно ли ему шифрование, сжатие данных и каким именно шифром он хотел бы пользоваться.

Сервер получает это сообщение и отвечает сообщением ServerHello. Это подтверждение того, что сервер действительно согласен с клиентом и может работать с такими параметрами шифрования, сжатия и т.п. После этого сервер отправляет свой сертификат. Он нужен для аутентификации сервера: в большинстве случаев в протоколе HTTPS аутентифицируется именно сервер. Сертификат содержит в себе публичный ключ для асимметричного шифрования и подписан другим сертификатом, принадлежащим авторизационному центру. Это некоторый кусочек данных, по которому можно проверить, что сервер действительно тот, за кого он себя выдаёт.

Проверка сертификата -- сама по себе длительная процедура. После этого, если клиент доверяет серверу, они приступают к установке и настройке симметричного шифрования. А если сертификат не удалось проверить, появится сообщение о том, что сервер предлагает вам неподписанный сертификат. 

Чтобы работало симметричное шифрование, у клиента и у сервера должен быть один и тот же ключ. Есть разные варианты: клиент может просто передать какой-то ключ на сервер, зашифровав его с помощью публичного ключа из сертификата, либо может использовать специальный алгоритм для генерации ключа одновременно на клиенте и на сервере, когда передаётся некоторая опция (схема Диффи-Хеллмана). При этом ключ шифрования появляется и на сервере, и на клиенте, но в явном виде он не передаётся.

После того, как ключ шифрования получен, сервер отвечает Finished и это значит, что мы готовы к передаче данных.

Неприятный момент -- время, которое тратится на установление соединения: это как минимум 2 RTT.

## HTTP
Предназначен для передачи гипертекстовых документов.

### Какие задачи решает HTTP
Эти задачи не решает TCP и они должны быть решены.

- необходимо каким-то образом структурировать поток данных. ТСР посылает сплошной поток данных без начала и конца. Клиент и сервер должны каким-то образом договориться, в каком виде данные будут делиться на части: когда можно считать, что запрос закончен, или ответ получен.
- передача мета-информации о документах: у каждого документа есть MIME-тип, без которого будет непонятно, что с этим документом делать. Аналогично нужно передавать длину документа, чтобы клиент мог знать, сколько данных ему нужно будет принять.
- авторизация и проверка прав доступа
- поддержка сессий: это вызвано тем, что HTTP работает по принципу запрос-ответ и не предполагает постоянного соединения и надо поддерживать состояние.
- кэширование документов: позволяет не передавать документы, если они уже присутствуют на клиенте: например, стили и javascript'ы на многих страницах одного сайта могут совпадать и нет смысла их каждый раз передавать.
- согласование содержимого (negotiation): позволяет клиенту и серверу согласовать, в каком виде они будут принимать документы: например, сжимать документы с помощью gzip или только на французском языке.
- управление соединением: протокол ТСР не предусматривает никакого управления, кроме закрытия. HTTP позволяет, например, оставлять соединение открытым для последующих запросов.

![](https://i.ibb.co/DVbRCxK/image.png)

Протокол работает по принципу запрос-ответ. Клиент формирует запрос, отправляет его на сервер, а сервер генерирует ответ и отправляет его клиенту.

### Ключевые особенности HTTP
- работает поверх TCP/TLS
- протокол запрос-ответ
- не поддерживает состояние (соединение) - **stateless**. Он позволяет передавать информацию о клиенте в специальных заголовках, но при этом нет никакой гарантии, что один клиент будет работать с одним и тем же сервером.
- **текстовый** протокол: данные передаются в виде простого текста и их можно просматривать с помощью текстового редактора.
- расширяемый протокол: следствие из того, что он текстовый. Различные опции передачи задаются в виде заголовков и могут его расширять.

### HTTP/1.0 запрос
```http
GET http://www.ru/robots.txt HTTP/1.0
Accept: text/html, text/plain
User-Agent: telnet/hands
If-Modified-Since: Fri, 24 Jul 2015 22:53:05 GMT
```
Перевод строки: `\r\n`

В первой строке передаются метод (что надо сделать), полный URL и версия протокола, чтобы сервер мог понимать, какой набор атрибутов поддерживает данный клиент.

Дальше идут строчки, содержащие заголовки вида `имя: значение`. Имена заголовков не могут содержать пробелы.

После всех заголовков идёт пустая строка. Далее может идти тело запроса, если оно предусмотрено данным методом.

### HTTP/1.1 запрос
```http
GET /robots.txt HTTP/1.1
Accept: text/html, application/xhtml+xml
Accept-Encoding: gzip, deflate
Cache-Control: max-age=0
Connection: keep-alive
Host: www.ru
User-Agent: Mozilla/5.0
```

URL, который передаётся в запросе, не абсолютный, а относительно. Но вместо этого хост передан в виде отдельного заголовка.

Также присутствуют дополнительные заголовки, например, `Connection`, который позволяет управлять соединением. В данном случае он говорит, что соединение не должно быть закрыто.


### HTTP/1.1 ответ

```http
HTTP/1.1 404 Not Found
Server: nginx/1.5.7
Date: Sat, 25 Jul 2015 09:58:17 GMT
Content-Type: text/html, charset=iso-8859-1  // MIME-тип и кодировка
Connection: close

<!DOCTYPE HTML PUBLIC "...">
<HTML><HEAD>...
```

Первая строка -- строка ответа. В ней содержится версия протокола, по которой отвечает сервер. Далее идёт некоторое число -- код ответа. Он говорит о результате операции, после идёт текстовая расшифровка.

Ниже идут заголовки, затем пустая строка и сам документ.

Как узнать длину ответа? Можно читать до тех пор, пока соединение не будет закрыто. Другой вариант -- передать заголовок `Content-Length` с длиной документа, тогда соединение можно оставить открытым.

### HTTP методы
- **GET** -- получение документа
- **HEAD** -- получение только заголовков
- **POST** -- отправка данных на сервер
- PUT -- отправка документа на сервер
- DELETE -- удаление документа
- CONNECT, TRACE, OPTIONS -- редко
- COPY, MOVE, MKCOL -- расширения WebDAV


### HTTP коды ответа

- 1хх -- информационные (для координации действий клиента и сервера)
- 2хх -- успешное выполнение
- 3хх -- перенаправление (данный запрос завершился неудачно, но документ можно получить с другого URL)
- 4хх -- ошибка на стороне клиента
- 5хх -- ошибка на стороне сервера

.
- 200 ОК -- запрос успешно выполнен
- 204 No Content -- запрос успешно выполнен, но документ пуст
- 301 Moved Permanently -- документ сменил URL, сервер возвращает этот URL (предполагается, что документ назад никогда не вернётся, это можно закэшировать)
- 302 Found -- повторить запрос по другому URL (временный редирект)
- 304 Not Modified -- документ не изменился, использовать кэш
- 400 Bad Request -- неправильный синтаксис запроса, сервер не смог разобрать запрос: например, слишком длинная строка запроса
- 401 Unauthorized -- требуется авторизация
- 403 Forbidden -- нет доступа (неверная авторизация)
- 404 Not Found -- документ не найден
- 500 Internal Server Error -- неожиданная ошибка сервера, в частности, application-сервера: например, выброшено необработанное исключение
- 502 Bad Gateway -- проксируемый отвечает с ошибкой
- 504 Gateway Timeout -- проксируемый сервер не отвечает

### HTTP заголовки
#### Общие (могут присутствовать как в запросе, так и в ответе)
Используются для управления соединением и форматом сообщения (документа).

- **Content-Type** -- MIME тип документа
- **Content-Length** -- длина сообщения
- Content-Encoding -- кодирование документа, например,  gzip сжатие
- Transfer-Encoding -- формат передачи, например, chunked
- Connection -- управление соединением
- Upgrade -- смена протокола

#### Заголовки запросов
- Authorization -- авторизация, чаще всего логин/пароль
- Cookie -- передача состояния (сессии) на сервер. Каждый следующий запрос может прийти на новый сервер. Таким образом, сервер не поддерживает постоянное соединение с пользователем и должен каждый раз узнавать, какой пользователь к нему присоединился. Ключ сессии -- это и есть кука: браузер автоматически для каждого запроса определяет, какую куку отправить.
- Referer -- URL предыдущего документа, контекст запроса. Например, при запросе картинок мы будем знать, на какой странице она потребовалась.
- User-Agent -- описание клиента, версия браузера
- If-Modified_Since -- условный GET запрос. Работает вместе с кодом ответа 304, если загружаемый документ закэширован на клиенте и с тех пор он не поменялся на сервере.
- Accept-* -- согласование содержимого и формата документа. В частности, указываются Accept-Encoding, Accept-Charset и тому подобное. Так, например, браузер показывает, какие документы он готов принять, например, готов ли он применять сжатые gzip-документы или он не умеет этого делать.

#### Заголовки ответов
- Location (301, 302) -- новый URL документа при перенаправлениях
- Set-Cookie -- установка состояния (сессии) в браузере. По этой куке в дальнейшем сервер сможет понять, какой пользователь к нему обращается.
- Last-Modified (304) -- дата последнего изменения документа
- Date -- дата на сервере для согласования кешей
- Server -- описание веб-сервера, название и версия

### HTTP/1.1 Управление соединением
Не нужно закрывать TCP и TLS соединения, можно в рамках одного соединения обрабатывать много запросов подряд.

#### Общие принципы
Протокол HTTP/1.0 предполагает закрытие ТСР соединения сразу после ответа сервера.

Протокол HTTP/1.1 предполагает удержание ТСР соединения, если не было заголовка `Connection: close`.


#### Логика управления в HTTP/1.1
Соединение должно быть закрыто, если
- сервер или клиент использует HTTP младше 1.1
- сервер или клиент передал заголовок `Connection: close`
- по истечении таймаута (обычно небольшой, около 10 с)

Иначе соединение остается открытым для последующих запросов. За счёт этого загрузка дополнительных ресурсов (стилей, картинок, javascript) идёт по тому же ТСР соединению, что и загрузка основной страницы, что существенно ускоряет загрузку.

# Веб-сервера
Это сетевой сервер, который занимается обработкой протокола НТТР.
### Запуск веб-сервера
Команда на запуск
```bash
sudo /etc/init.d/nginx start
```
При этом запускается исполняемый код веб-сервера. Он читает файл конфигурации и пытается открыть и прослушать порт 80.

Далее он начинает писать логи, и для этого ему тоже нужны права суперпользователя, чтобы логи не мог прочитать кто угодно. Дальше он понижает привилегии, чтобы веб-сервер постоянно не работал от лица суперпользователя, приводя к уязвимости ОС.

Опционально он запускает дочерние процессы (воркеры, потоки) и после всего этого он готов к обработке запроса.

### Файлы веб-сервера
- конфиг `/etc/nginx/nginx.conf`. Поскольку он большой, обычно он хранится по частям.
- init-скрипт `/etc/init.d/nginx [start|stop|restart]`
- pid-файл `/var/run/nginx.pid`. Когда сервер запущен, он полностью отключается от консоли, и чтобы к нему обратиться, нужен идентификатор его процесса. Он как раз и лежит в этом файле.
- error-лог `/var/log/nginx/error.log`. Здесь содержатся сообщения об ошибках сервера, формат более или менее произвольный.
- access-лог `/var/log/nginx/access.log`. Здесь хранятся сообщения об успешности/неуспешности выполнения запросов и имеет жёсткий формат.

### Процессы веб-сервера
**Master (root, 1 процесс)**
- чтение и валидация конфига
- открытие сокета(ов) и логов
- запуск и управление дочерними процессами
- graceful restart, binary updates

**Worker (www-data, 1+ процессов)**
- обработка входящих запросов

Иногда ещё бывают процессы, следящие за очисткой кэша (кэш-менеджеры).

#### Цикл работы воркер-процесса
![](https://i.ibb.co/mhp4vyb/image.png)Это упрощённый цикл работы воркера.

Он начинается сверху, с чтения НТТР-запроса. Предполагается, что воркер получил с помощью системного вызова `accept` новое сетевое соединение с каким-то конкретным клиентом, и цикл начинается с того, что он читает из этого соединения НТТР-запрос и разбирает его в некоторое внутренне представление для того, чтобы в ним можно было удобно работать. 

После того, как НТТР-запрос прочитан, происходит выбор virtual host. Фактически, определяется некоторая часть конфига, которая отвечает за данный запрос. Virtual host определяется на основе заголовка `host` в НТТР/1.1 либо на основе домена в HTTP/1.0.

Далее выбирается location -- это более мелкая часть конфига, котрая отвечает за обработку конкретной группы урлов.

Когда location выбран, веб-сервер может определить конкретный файл, который следует отдать с помощью склеивания урла и пути, указанного внутри location -- document root. Когда мы определили конкретный файл, который мы собираемся отдавать, сервер проверяет права доступа, то есть может ли он отдать этот файл. Проверка прав доступа состоит из нескольких частей: во-первых, веб-серверу можно задать определённые правила по IP-адресам: каким клиентам можно отдавать файлы, каким нельзя вообще, и это задаётся в конфиге. Во-вторых, можно потребовать авторизацию с помощью логина и пароля, и это тоже задаётся в конфиге. Наконец, веб-сервер проверяет просто доступ к файловой системе.

Если доступа нет, мы пропускаем дальнейшие стадии и сразу отправляем ответ о том, что доступа нет.

Иначе происходит чтение файла из диска, применяем к нему различные выходные фильтры (сжатие, отправка по частям), устанавливаем заголовки ответа (например, критически важный для браузера `Content-Type`, без которого он не будет знать, что с этим документом делать), после чего у нас есть готовый HTTP-ответ. Причём если файл большой, то ответ может отправляться по частям: сначала заголовки, потом тело файла небольшими кусочками.

Когда мы отправили файл, производится запись в Access лог: какой файл и кому мы отправили, с каким кодом ответа (200, 404 и т.д.) и прочую информацию. После чего происходит очистка памяти и цикл повторяется.

### Модульная архитектура
Веб-сервер можно было бы написать как единое целое приложение, но веб-сервера это достаточно сложный и громоздкий софт, который склонен к расширению. Чтобы обеспечить лёгкость и простоту изменения кода веб-сервера, его делают модульным: внутри сервера выделяют ядро, которое отвечет за ввод/вывод данных (чтение запроса, формирование ответа, парсинг HTTP заголовков) и модули, которые добавляют функционал серверу на различных этапах.

Модули могут загружаться динамически (например, в Apache есть директива `LoadModule`, с помощью которой можно загрузить shared library); либо они могут быть вкомпилированы в код сервера (nginx). После того, как модуль прилинкован или скомпилирован, он добавляет дополнительные директивы, то есть некоторые опции в конфиг веб-сервера. Кроме того, модуль регистрирует свои обработчики на этапах цикла воркер-процесса.

Например, у нас есть этап проверки доступа и есть разные модули, которые проверяют доступ: например, с помощью модуля radius, проверку логина и пароля с помощью похода в базу MySQL или на основе IP-адреса (net). При старте сервера эти три модуля регистрируют свои функции как обработчики на определённый этап цикла. Когда ядро веб-сервера доходит до данного этапа, оно вызывает все три обработчика, передавая им специальный объект: как правило, в процессе работы в цикле у веб-сервера существует некоторый объект запроса `req` -- структура, содержащая всю информацию про текущий запрос. Обладая запросом, модули могут выполнить необходимую работу (сходить и проверить авторизацию), после чего они отдают команду ядру, что либо можно продолжать обработку данных, либо её нужно прервать. Таким образом, код разделяется между ядром и модулями, которые реализуют дополнительный функционал.

Модули могут быть как простыми, которые работают только на одном этапе, так и более сложные: например, есть модуль mod_lua в nginx, который позволяет расширять функционал nginx с помощью скриптов на языке Lua. Он может помещать свои обработчики на всех этапах цикла.

Таким образом, ядро читает запрос, создаёт структуру `req` и далее идёт по циклу, вызывая функции из различных модулей, которые зарегестрировались на данный этап цикла.

Модули могут добавлять некоторые дополнительные опции и директивы в конфиг. Если модуль загружен, то эта директива будет расцениваться как валидная, если нет -- сервер не поймёт директиву и не сможет запуститься.

#### Примеры модулей
- mod_mime занимается определением mime-типа, исходя из расширения
- mod_mime_magic делает то же самое, но исходя из первх байт документа
- mod_autoindex может сгенерировать html-страничку со списком файлов, если запрос идёт к директории
- mod_rewrite позволяет в процессе запроса изменить текущий урл
- mod_cgi: вместо отдачи файла этот файл запускается и генерирует динамическую страницу
- mod_gzip сжимает документ

## Конфигурация веб-сервера
Рассмотрим пример конфига nginx
**virtual host** -- секция конфига, отвечающая за обслуживание определенного домена: зачастую один веб-сервер обрабатывает разные домены: как правило, есть основной домен, есть специальный домен для мобильных устройств, для отдачи статических файлов и т.д.

**location** -- секция конфига, отвечающая за обслуживание определенной группы URL: сайт может состоять из множества URL и нет смысла прописывать логику для каждого из них. На практике существует несколько рановидностей документов, которые отдаёт веб-сайт, и такие разновидности группируют по урлам, и эту группу урлов называют location.

```nginx
user www www;  # имя пользователя
error_log /var/log/nginx.error_log info;  # указан файл лога с ошибками и уровень ошибок
# то есть помещать сообщения информационного и более важных уровней
http {  # начинается конфиг веб-сервера
    include conf/mime.types;  # подключается файл с описанием расширений и mime типов
    default_type application/octet-stream;  # тип по умолчанию, если не удалось определить
    log_format simple '$remote_addr $request $status';
    server {  # начало virtual host
	listen one.example.com;  # на каком ip-адресе и порту слушает данный хост (по умолчанию 80)
	server_name one.example.com www.one.example.com;  # указывает, каким доменам данный virtual host соответствует
	access_log /var/log/nginx/access_log simple;
	location / { # вообще любой урл
	    root /www/one.example.com;
	}
	location ~* ^.+\.(jpg|jpeg|gif)$ { # ~* regexp
	    root /www/images;
	    access_log off;
	    expires 30d;
	}
    }
}	
```
### Приоритеты location в nginx
- `location = /img/1.jpg`-- точное совпадение
- `location ^~ /pic/` -- совпадение по префиксу, но более приоритетное, чем регулярное выражение
- `location ~* \.jpg$` -- совпадение по регулярному выражению
- `location /img/` -- совпадение по префиксу

При одинаковом приоритете используется тот location, что находится **выше** в конфиге.

### Секции и директивы
- `http` -- конфигурация для HTTP сервера
- `server` -- конфигурация домена (вирт. хоста)
- `serer_name` -- имена доменов
- `location` -- локейшен, группа URL
- `root`, `alias` -- откуда нужно брать файлы
- `error_log` -- лог ошибок сервера
- `access_log` -- лог запросов


### Отдача статических документов
С помощью директивы `location` мы можем выделить некоторый набор урлов. Например, мы можем выделить все картинки и сказать, что мы отдаем их из определённой директории. Для этого мы задаём локейшен по регулярному выражению, соответствующему всем документам с расширением картинок и внутри него зададим директиву `root`:
```nginx
location ~* ^.+\.(jpg|jpeg|gif|png)$ {
	root /www/images;
}
```
Путь, который находится в урле, склеивается с директорией, которая указана в директире `root`, и получается полный путь к файлу:
`/2015/10/ae2b5.png` $\to$ `/www/images/2015/10/ae2b5/png`

Директива `alias` заменяет совпавшую часть урла:
```nginx
location /sitemap/ {
	alias /home/www/generated;
}
```
Здесь урл `/sitemap/index.xml` будет заменён на `/home/www/generated/index.xml`. Заметим, что такой подход работает только с локейшенами с совпадением по префиксу. С регулярками `alias` не работает.

Чаще всего в веб-сервере есть одна директория, в которой лежат все статические файлы. Эту директорию называют **document root**. 

### Атрибуты файлов и процессов
Когда веб-сервер определил, какой файл нужно отдать, ему нужно определить права доступа к нему. Помимо того, что происходит проверка авторизации, серверу необходимо проверить права доступа на файловой системе.

У каждого запущенного в Unix процесса есть эффективный пользователь и эффективная группа, с правами которых данный процесс выполняется.

У файла на диске также есть пользователь -- владелец файла, группа, и помимо этого, права доступа -- rwx.

Атрибуты процесса можно узнать с помощью команды `ps`. Атрибуты файла -- с помощью `ls -lah`

### Проверка доступа
Для того, чтобы открыть файл, необходимо иметь права на чтение `r` самого файла и на исполнение `x` директорий, в которых он находится. Наличие прав проверяется следующим образом: 
- если совпадает пользователь (совпадатю пользователь, под которым работает веб-сервер и обладатель файла): `-[rw-]r--r--` -- первая тройка
- если совпадает группа: `-rw-[r--]r--`
- иначе `-rw-r--[r--]`


Если веб-серверу не удалось открыть файл, чтобы его отправить, он вернёт ошибку 403 и, скорее всего, сделает запись в error-log о том, что этот файл ему не удалось отправить.

### Модели обработки сетевых соединений
#### Простейший TCP - сервер
```py
import socket
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.bind(('127.0.0.1', 8080))
s.listen(10)

while True:
	conn, addr = s.accept()
	path = conn.recv(512).decode('utf8').rstrip('\r\n')  # мы считаем, что к нам пришёл файл
	file = open('/www' + str(path), 'r')
	data = file.read().encode('utf-8')
	conn.sendall(data)  # отправляем данные клиенту
	file.close(); conn.close()
```
Это простейший раздатчик файлов.

С точки зрения производительности тут есть проблема: когда сервер находится внутри цикла, он обрабатывает ровно одного клиента и до тех пор, пока он не выйдет из этого цикла, остальные клиенты будут его ожидать. Если бы сервер внутри цикла ни на что не отвлекался, например, проводя какие-то вычисления, с этим ничего поделать было бы нельзя. Однако ситуация здесь хуже.

Вызовы `conn.recv()` и `conn.sendall()` работают с сетью. Вызов `read()` работает в диском. Все эти вызовы могут занять большое количество времени, и в этот момент наш сервер не будет делать вообще ничего. Это называется блокирующий ввод-вывод.

После вызова `conn.recv()` управление передаётся в операционную систему. Она выполняет часть своей работы, в частности, отрабатывая протокол ТСР, и если данных в сокете ещё нет, процесс переходит в режим ожидание и становится заблокированным на операции ввода/вывода. ОС такой процесс усыпляет: он не использует процессор и ничего не делает в ожидании, пока завершится операция ввода/выводы. Через некоторое время данные появляются в сокете. ОС опять выполняет некоторые операции (ТСР-стек), процесс пробуждается и происходит возврат из системного вызова. Далее срабатывает код приложения и происходит возврат из метода `conn.recv()`

Проблема здесь в том, что во время ожидания появления данных в сокете ни процесс, ни ОС ничего полезного не делают. Хотя ОС в это время может заниматься другими приложениями, наш процесс просто спит.

#### Решение проблемы
- множество потоков -- multithreading: внутри одного процесса создаётся несколько тредов и каждый новый клиент обрабатывается в отдельном треде. Когда один тред засыпает, остальные продолжают работать.
	- экономия памяти: 1 клиент = 1 поток
	- требует аккуратной работы с памятью
	- как следствие, накладывает ограничение на выбор библиотек
- множество процессов -- prefork, pool of workers. Вместо тредов используются отдельные процессы
	- простота разработки
	- можно использовать любые библиотеки
	- большое потребление памяти: 1 клиент = 1 процесс
	- проблема с долгоживущими соединениями
- комбинированный подход

### Неблокирующий ввод-вывод
Схема примерно такая же: сервер принимает запрос и делает вызов чтения из сокета. Ядро ОС выполняет свою работу и понимает, что данных в сокете нет, процесс надо бы усыплять. Но конкретно данный сокет был создан со специальной опцией неблокирующего ввода-вывода, поэтому ядро ОС вместо того, чтобы усыпить процесс, возвращает управление (происходит возврат из функции `recv()`) со специальным кодом `EAGAIN` или `E_WOULDBLOCK`, который говорит, что системный вызов `recv()` должен был бы заблокировать этот процесс. В этот момент приложение может заняться обработкой других клиентов.

В какой-то момент приложение решит, что, возможно стоит заново проверить первого клиента и повторно сделать вызов `recv()`. К этому моменту времени данные уже могут прийти и ОС сразу их вернёт.

При неблокирующем вводе-выводе приложение не засыпает, таким образом мы реализуем параллельную обработку клиентов.

Такой приём называется мультиплексирование
```py
readsocks, writesocks = [...], [...]  # сокеты
while True:
	readables, writeables, exceptions = \
		select(readsocks, writesocks, [])
	for sockobj in readables:
		data = sockobj.recv(512)
		if not data:
			sockobj.close()
			readsocks.remove(sockobj)
		else:
			print('\tgot', data, 'on', id(sockobj))
```
У нас есть списки сокетов, на которых мы ожидаем чтение и запись. Сервер работает в бесконечном цикле. В начале цикла он вызывает функцию `select` и передаёт ей списки `readsocks` и `writesocks`. В результате этого вызовы мы получаем три списка: `readable` -- сокеты, в которых уже есть данные то есть из которых можно читать и не быть заблокированным, `writeable` -- список тех сокетов, в которые можно писать, то есть в их буфере достаточно места, чтобы записать данные, `exception` -- список токенов с ошибкой.

Мы проходим по списку `readable` и для каждого сокета из этого списка делаем операцию чтения. Если данных нет, а так скорее всего будет, если пришёл ТСР-сегмент с флагом `fin` или `reset`, означающий, что соединение закрыто, мы закрываем соединение и удаляем сокет из списка. Иначе мы обрабатываем полученные данные, после чего цикл повторяется.

Вся логика сервера кроется в строчке `print`, но на самом деле мы получили какой-то кусочек данных из сетевого соединения и можем обработать их куда более хитро.

Мы видим, что существенно изменилось поведение программы. Если она раньше работала сверху вниз, то сейчас она работает по принципу обработки событий: в какой-то момент времени у нас появляется список событий `readable` и мы обрабатываем каждое событие. Нюанс в том, что данных может быть недостаточно, например, если на какой-то сокет пришёл не весь запрос целиком, и нам потребуется к этому сокету обратиться повторно, но в будущем.

Вся эта конструкция называется **event-driven разработка**.  Для неё характерно множество открытых файловых дескрипторов. Для выбора готового дескриптора используется какой-то метод мультиплексирования: `select`, `kqueue`, `epoll`, `aio` и т.д. И вместо последовательного исполнения программы она распадается на обработчики событий.

`select` плохо работает с длинными списками файловых дескрипторов, поэтому современные веб-сервера используют другие системные вызовы.

#### Плюсы и минусы event-driven
- работает быстро, программа не блокируется: один процесс выжимает максимум из ядра ОС
- экономия памяти: 1 клиент = 1 объект
- обработка большого количества клиентов
- обработка медленных или долгоживущих клиентов
- тяжело программировать: программа распадается на кучу колбэков, функции вызывают одна другую
- использование блокирующих вызовов всё портит

### Кто есть кто
- **Apache** -- prefork, worker, threads, C
- **Tomcat, Jetty** -- threads, Java
- **Starman, Gunicorn** -- prefork, языки высокого уровня
- **Nginx, Lighttpd** -- асинхронные, С
- **Node.js, Tornado** -- асинхронные, высокого уровня

## Frontend и Backend
В случае серверов Frontend -- web-сервер (он отдаёт только статические файлы), Backend -- Application сервер.

Когда клиенты обращаются за документами к нашему сайту, они непосредственно соединяются именно с фронтенд-сервером. Далее фронтенд-сервер (например, nginx) определяет, какого типа запрос к нему пришёл. Если запрос за каким-то статическим документом: картинкой, стилем, либо js, такой запрос отправляется сразу на диск и на этом история заканчивается.

Если же пришёл запрос за HTML-страничкой, которой нет на диске, или же фронтенд-сервер сконфигурирован так, что он знает, что такого типа запросы нужно передавать на бэкенд, он его передаёт на бэкенд: происходит **проксирование**. На бэкенд-сервере происходит бизнес-логика: генерация HTML-странички, либо данных в формате json, либо ещё что-то: в процессе работы бэкенд, вероятно, будет общаться с базами данных.

Потом, когда ответ будет сформирован, бэкенд сервер отдаёт его фронтенд серверу, а тот отправляет его клиенту.

### Задачи фронтенд (веб) сервера
- отдача статических документов
- проксирование (reverse proxy): передача запросов на бэк
- балансировка нагрузки: фронт выбирает тот бэк, который меньше нагружен
- кеширование документов: допустим, фронт сделал некоторый запрос к бэку, тот ему отдал документ. Этот документ может быть закэширован на диске фронта и последующий запрос будет обработан из кэша.
- сборка SSI: сборка веб-странички из небольших кусочков
- авторизация, SSL, нарезка картинок, gzip (задачи, связанные с клиентским соединением)

#### Reverse proxy
- frontend медленно читает запрос от клиента
- frontend быстро передаёт запрос свобдному backend
- backend генерирует страницу
- backend быстро возвращает ответ frontend серверу
- frontend медленно возвращает ответ клиенту

Результат: backend занят минимально возможное время и позволяет бороться с медленными клиентами.


### Настройка проксирования в nginx
```nginx
proxy_set_header Host $host;
proxy_set_header X-Real-IP $remote_addr;
location / {
	proxy_pass http://backend;
}
location /partner/ {
	proxy_pass http://www.partner.com;
}
location ~ \.\w\w\w?\w?$ {
	root /www/static;
} 
```
Это пример конфига для проксирования запросов.

Если нам нужно передать урл на бэкенд сервер, указывается директива `proxy_pass`. Она означает, что вместо того, чтобы пытаться отдавать файл с диска, нужно передать запрос на указанный URL. У этой директивы могут быть разные значения: в первом случае указано имя upstream'а, то есть `http://backend` -- это не доменное имя, а имя апстрима: здесь нет точки, а далее в конфиге зада апстрим с именем backend. Nginx, видя такую директиву, понимает, что нужно передать этот запрос по протоколу HTTP в upstream backend.

В `proxy_pass` можно явно указывать урл. Во втором случае nginx приклеит урл к тому, что написано в директиве `proxy_pass` и получит новый урл документа и передаст на него запрос: в данном случае веб-сервер выступает на клиент, формируя новый http запрос и передавая его на сформированный урл. При этом проксирование подразумевает то, что сохраняются заголовки, которые nginx получил изначально от пользователя, а те заголовки, которые придут с бэкенда, вернутся пользователю. Тем не менее, может потребоваться добавить какие-то дополнительные заголовки. Два наиболее частых случая -- заголовки `Host` и `X-Real-IP`. `Host` нужен, потому что бэк может находиться на другом домене, и если туда придёт запрос с изначальным заголовком `Host: site.com`, то, например, `partner.com` не сможет его обработать, потому что он ничего не знает про этот домен, у него нет вирт. хоста для данного домена. Поэтому с помощью директивы `proxy_set_header` мы подменяем хост. (в нашем примере хост сохраняется, так как это нужно для нашего бэкенда, но вместо `$host` можно было бы написать `$proxy-host`: это означало бы, что при проксировании нужно было бы взять имя хоста, к которому мы обращаемся (`www.partner.com`)).

Также с помощью директивы `proxy_set_header` можно добавить дополнительный заголовок для проксируемого запроса. Второй важный момент: при проксировании запроса теряется IP-адрес. Когда клиент подключен непосредственно к серверу, сервер может получить его IP вместе с соединением, то есть когда делается вызов `accept()`. В данном случае фронтенд выступает в роли клиента и подключается к `backend` или `partner.com`, поэтому `partner.com` получит IP адрес нашего фронтенд-сервера, что в большинстве случаев ему совершенно не нужно. Чтобы сохранить IP адрес клиента, используют заголовок `X-Real-IP`. Тогда бэк сможет проанализировать  этот заголовок и узнать настоящий адрес клиента.

### Настрока upstream в nginx
```nginx
upstream backend {
	server back1.example.com:8080 weight=1 max_fails=3;
	server back2.example.com:8080 weight=2;
	server unix:/tmp/backend.sock;
	server backup1.example.com:8080 backup;
	server backup2.example.com:8080 backup;
}
```
Upstream в терминологии nginx -- это группа серверов, то есть набор бэкенд-серверов, работающих под общим именем. Он задаётся с помощью директивы `upstream`.

Директива `weight` позволяет создать вес той или иной машины в апстриме.

Кроме того, если один из серверов перестаёт отвечать на запросы, он удаляется из списка серверов. Параметр `max_fails` показывает, сколько раз должен не ответить сервер, чтобы его из этого списка удалить. Таким образом nginx отбрасывает упавшие сервера и балансирует нагрузку между оставшимися работающими. Со временем nginx повторит запрос к упавшему серверу, и если тот ответит, он вернётся в строй.

Помимо указания IP-адресов, можно также указывать и unix-сокеты.

Также есть специальная опция `backup`, показывающая, что данный сервер не должен подключаться к обычной нагрузке, а должен включаться только в режиме бэкапа, то есть когда остальные серверы не могут обслужить запрос.

Обычно на сайтах используется один апстрим со всеми бэкенд серверами.

В более сложных ситуациях сервера делят на группы, называемые фермами. Например, видимую часть сайта обрабатывает одна группа серверов, а обработку запросов API или моб приложения -- другая группа серверов.

## Application сервер
Роль application сервера заключается в исполнении бизнес-логики приложения и генерации динамических документов. На каждый HTTP запрос application сервер запускает некоторый обработчик в приложении. Это может быть функция, класс или программа, в зависимости от технологии.

### Протоколы запуска веб-приложений
- Servlets и др. специализированное API
- mod_perl, mod_python, mod_php
- CGI: обработчик должен являться обычной программой ОС
- FastCGI
- SCGI
- PSGI, **WSGI**, Rack для разных ЯП

#### CGI -- Common Gateway Interface
Идея: у нас есть веб-сервер, который умеет отдавать файлы с диска. Мы хотим лёгкий и простой способ получить динамическую генерацию веб-страниц. Нужно вместо того, чтобы эти файлы отдавать, их запускать. Запущенные программы сами решат, что нужно вернуть пользователю.

Соглашения протокола CGI:
- метод запроса, query string (аргументы, идущие с урлом), все заголовки передаются через переменные окружения. Переменные окружения -- это механизм ОС, когда при запуске программы можно её передать набор строк - переменных окружения.
- тело запроса передаётся через stdin: оно может быть очень большим и его передавать через переменную нельзя.
- заголовки и тело ответа возвращаются через stdout
- HTTP код ответа (200 ОК, 404 Not Found и т.д.) передаются через псевдозаголовок Status
- Поток ошибок stderr направляется в лог ошибок сервера

Это позволяет любую программу использовать в качестве веб-приложения. Главное, чтобы эта программа анализировала переменные окружения и выводила в stdout код страницы.

После получения ответа программа завершается. Проблема в том, что на каждый HTTP запрос происходит полный запуск программы, её инициализация и установка всех необходимых соединений (например, с базой данных), и это долго и повышает нагрузку на сервер.

##### Переменные окружения CGI
- `REQUEST_METHOD` -- метод запроса
- `PATH_INFO` -- путь из URL
- `QUERY_STRING` -- фрагмент URL после `?`
- `REMOTE_ADDR` -- IP адрес пользователя
- `CONTENT_LENGTH` -- длина тела запроса
- `HTTP_COOKIE` -- заголовок `Cookie`
- `HTTP_ANY_HEADER_NAME` -- любой другой HTTP заголовок.

#### FastCGI и SCGI
Основная проблема CGI -- низкая производительность. Протоколы FastCGI и SCGI призваны решить эту проблему путём демонизации приложения. Иногда это возможно сделать даже без изменения када CGI приложения.

При этом скрипт запускается либо заранее, либо при первом запросе, но смысл в том, что после отдачи ответа он не завершается, а продолжает работать.

В протоколе FastCGI взаимодействие между Application сервером и скриптом происходит через сокет. При передаче запроса в скрипт через этот сокет происходит вызов функции внутри скрипта, которая возвращает некоторый ответ.

#### WSGI
Протоколы CGI, FastCGI и SCGI предполагает, что приложение запускается в рамках отдельного процесса. Современные протоколы предполают, что приложение запускается в одном процессе вместе с Application сервером и Application сервер реализован на том же языке, что и само приложение.

**WSGI-обработчик**
```py
def wsgi_application(environ, start_response):
	# business logic
	status = '200 OK'
	headers = [
		('Content-Type', 'text/plain')
	]
	body = 'Hello, world!'
	start_response(status, headers)
	return [body]
```
Один обработчик -- это одна функция. Все аргументы этой функции и формат возвращаемого ею значения строго фиксированы.

Первый аргумент `environ` -- это словарь, в котором содержатся все переменные окружения. 

Второй аргумент -- специальная функция (в нашем примере это `start_response`), нужная, чтобы начать ответ и отправить заголовки клиенту.

На каждый HTTP запрос application сервер вызывает эту функцию.

После отработки бизнес-логики обработчик вызывает `start_response` и в этот момент заголовки отправляются клиенту. Далее функция должна вернуть тело ответа -- HTML страничку. Вообще говоря, она может быть достаточно большой и не помещаться в память, поэтому обработчик должен вернуть нечто итерируемое -- в данном случае мы просто оборачиваем тело ответа в список.

Application сервер получит этот список и начнёт постепенно его передавать клиенту.

**Web Server Gateway Interface**
- обработчик -- функция или класс (callable)
- метод, query string, заголовки запроса -- через аргумент **environ**
- тело запроса -- через file-handle **wsgi.input**
- http код ответа и заголовки ответа передаются через вызов функции **start_response**
- тело ответа возвращается в виде iterable из обработчика
- поток ошибок должен быть направлен в file-handle **wsgi.stderr**

**Переменные environ**
- CGI-like переменные: `REQUEST_URL`, ...
- `wsgi.version` -- версия wsgi протокола
- `wsgi.url_scheme`: схема текущего URL: https или http
- `wsgi.input` -- file-handle для чтения тела запроса
- `wsgi.errors` -- file-handle для вывода ошибок
- `wsgi.multithreaded` -- флажок запуска приложения внутри многопоточного сервера
- `wsgi.multiprocess` -- флажок запуска приложения в префорк режиме

В типичной схеме работают два процесса: веб сервер и application сервер, которые общаются по 
- `wsgi.multiprocess`протоколу НТТР. Внутри application сервера находится приложение-обработчик, с которым application сервер взаимодействует по протоколу WSGI.

**Что ложится на приложение**
- анализ `PATH_)INFO` и выбор конкретного обработчика (url routing)
- разбор конкретных заголовков, например, `Cookie`
- разбор `QUERY_STRING`
- разбор тела запроса: `x-www-form-urlencoded`, `multipart/form-data`
- вывод правильных заголовков ответа

Решение подобных задач предоставляют фреймворки.

# Веб приложения
### Основные типы запросов
- запросы статических документов (обслуживанием занимается фронтенд-сервер, до бэкенда они не доходят)
- запросы динамических документов
- отправка данных форм
- ajax-запросы
- запросы к API сайта
- персистентные соединения -- запросы, предназначенные либо для передачи real-time сообщений, либо для постоянной передачи данных. Требуют наличия на бэкенде event-driven сервера, поэтому, как правило, обслуживаются отдельным сервером

### Основные задачи веб-приложения при обработке запросов
Эти задачи не решаются другими слоями.

- маршрутизация URL: по входящему URL нужно понять, какую функцию вызвать для обработки данного запроса
- парсинг заголовков и параметров запроса: так как Application сервер не анализирует содержимое самих заголовков, это должно сделать приложение.
- хранения состояния (сессии) пользователя: протокол HTTP -- stateless, то есть каждый новый запрос приходит, вообще говоря, к новому серверу, поэтому мы не можем связывать пользователя с каким-то сетевым соединением. Нам надо поддерживать сессию и хранить некоторое состояние пользователя
- выполнение бизнес логики
- работа с базами данных
- генерация HTML страницы или JSON ответа

## MVC
MVC (Model View Controller) -- архитектурный паттерн, который задаёт структуру веб-приложения.
![](https://i.ibb.co/DLdyY0t/image.png)

Как правило, WSGI-функция находится внутри фреймворка, и Application сервер вызывает именно её. Выполняется код фреймворка для промежуточных действий (middleware). Далее необходимо определить, какую функцию вызвать в нашем приложении (**Application**), то есть нужно определить конкретную точку входа в приложение. Для этого используется **Router** -- компонент веб-приложения, который представляет собой отображение (mapping) URL на функции. Это может быть просто большая хэш таблица или дерево -- так или иначе, router это именно декларативное описание того, какому урлу (или паттерну урлов) какая функция соответствует.

Фреймворк просматривает все записи в роутере и выбирает подходящую. Таким образом, определяется, какой **Controller** (точка входа в приложение) будет выполняться и затем фреймворк передаёт управление в контроллер, и он начинает выполняться.

Контроллер делает вызовы к **Model** (модели) -- той части приложения, которая реализует бизнес-логику: походы в базы данных, обращения к внешним сервисам, какие-то вычисления и т.п. Она возвращает контроллеру готовые данные для отображения.

Контроллер передаёт эти данные в компонент **View**, который по имеющимся данным генерирует HTML/JSON/XML документ и полученная страничка возвращается клиенту.

### Плюсы фреймворков
- готовая архитектура
- повторное использование кода
- экономия ресурсов
- участие в open source
- проще найти программистов
- проще обучать программистов


# Django
### Соглашение о именовании
| MVC | Django |
|--|--|
| Model | Model |
| Router | urls.py |
| Controller | views |
|View | templates |

### Структура проекта
`django-admin startproject project` -- создание проекта
```
project // корневая директория, директория проекта
|--- crm  // директория приложения (создается вручную)
|    |--- models.py
|    |--- urls.py
|    |--- views.py
|--- manage.py  // скрипт управления проектом для автоматизации поддержания приложения
|--- project // директория приложения project, создается сразу
	 |--- settings.py  // файл с настройками
	 |--- urls.py  // главный роутер
	 |--- wsgi.py  // wsgi приложение: точка входа в Django приложение
```

Структура не open-source проекта:
```
anyname // наш проект
|--- project // уровень Django-проекта
|    |--- crm
|    |--- blog
|    |--- manage.py
|    |--- project
|         |--- settings.py
|         |--- urls.py
|         |--- wsgi.py
|--- templates // создаются вручную
|--- static
```

## Конфигурация Django
Конфиг -- это просто Python модуль
```py
# project/project/settings.py
ROOT_URLCONF = 'project.urls'  # начиная с какого файла начинает работу маршрутизатор
DATABASES = {  # список баз данных, к которым подключается приложение
	'default': {
		'ENGINE': 'django.db.backends.sqlite3',
		'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
	}
}
TEMPLATE_DIRS = (  # список директорий, где нужно искать шаблоны
	BASE_DIR + '/templates',
)
```
Также в Django есть переменная `INSTALLED_APPS`, показывающая, какие приложения сейчас используются: это список с названиями активно использующихся приложений в данном проекте

### Пути в конфиге
Проблемы:
- проект может быть развернут в любой директории
- несколько копий проекта на одном сервере

Соответственно, приложение должно уметь запускаться из разных директорий.

Решения
- абсолютные пути в каждом конфиге: редактирование каждого конфига под свою директорию, плохо работает с системой контроля версий
- переменные окружения, `$PROJECT_PATH`
- относительные пути

### Относительные пути в конфиге
```py
import os.path
BASE_DIR = os.path.abspath(__file__)  # __file__ -- полное имя текущего файла
BASE_DIR = os.path.dirname(BASE_DIR)  # получаем директорию, в которой находится приложение
BASE_DIR = os.path.dirname(BASE_DIR)  # поднимаемся выше и получаем директорию проекта

TEMPLATE_DIRS = (
	BASE_DIR + '/templates',
)
STATIC_ROOT = BASE_DIR + '/static'
```

### Паттерн local_settings.py
```py
# в конце project/settings.py

try:
	from ask_pupkin.local_settings import *
except ImportError:
	pass
```
## Маршрутизация URL
Router в Django представляет собой набор файлов `urls.py`.
### Порядок поиска контроллера
- Django начинает поиск с файла `ROOT-URLCONF` из настроек
- Загрузив файл, Django использует переменную `urlpatterns` (внутри файла может быть много разных переменных, т.к. это питоновский модуль)
- Django проходит по всем паттернам до первого совпадения
- Если совпадения не найдено, будет возвращён код `404 Not Found`
- Если совпадение найдено, Django перетает управление контроллеру, связанному с данным паттерном

### Маршрутизация в проекте
```py
# project/project/urls.py

urlpatterns = [
    url(r'^$', 'blog.views.home', name='home'),
    url(r'^', include('blog.urls')),
    url(r'^admin/', include('admin.site.urls')),
]
```
Первым аргументом функции `url` передаётся регулярное выражение, по которым идёт поиск. Вторым аргументом может быть либо название функции (в случае `'blog.views.home'` -- функция `home` из файла `views.py` приложения `blog`), либо сама функция, либо может включаться другой файл `urls.py` (например, `include('blog.urls')`), образуя таким образом дерево.

### Маршрутизация в приложении
```py
# project/blog/urls.py
from blog.views import post_list

urlpatterns = patterns('blog.views',
    url(r'^$', post_list, name='post-list'),
    url(r'^category/(\d+)/$', 'category_view', name='post-list-by-category'),
    url(r'^(?P<pk>\d+)/$', 'post_detail', name='post-detail'),
) 
```

Функции `patterns` передаётся последовательность урлов, а первым её аргументом является префикс, который добавляется ко всем именам функций. В списке урлов три маршрута, сформированные немного по-разному.

Первый маршрут сформирован непосредственной передачей функции `post_list` в `url`. Это наиболее рекомендуемое поведение, так как при указании функции по имени, как в последних двух примерах, она, а точнее, файл `views.py` будет загружена только при необходимости, и если в этом файле была ошибка, то она будет выявлена уже при работе сервера: сгенерится ответ с кодом 500, который будет показан конечному клиенту. Если же функции загружать не по имени, а явно, импортируя из модуля `views`, то если там содержалась ошибка, то она обнаружится уже при запуске сервера.

У всех маршрутов в этом файле есть имена (`name`). Это полезная практика для обратного построения маршрутов.

#### Используемые функции
- `url` -- для передачи именованных параметров
- `patterns` -- для добавления префикса к именам
- `include` -- включение одного `urls.py` внутрь другого

### Особенности маршрутизации в Django
- Слэш `/` в начале регулярок роутов не ставится
- можно указывать как имя, так и саму view-функцию
- роуты описываются с помощью регулярных выражений
- можно и нужно разносить роуты по приложениям (поиск по дереву быстрее простого перебора)
- можно и нужно создавать именованные роуты
- одно действие - один роут - один контроллер (!!!)

### Reverse routing
Для каждого маршрута указывается имя. Если мы хотим получить url, соответствующий этому маршруту, мы можем поступить следующим образом:
```py
from django.core.urlresolvers import reverse
reverse('home')
reverse('category-view', args=(10,))
reverse('post-detail', kwargs={'pk': 7}) # маршрут конкретной статьи
```
В шаблоне:
```http
{% url 'question-view' question.id %}
```
Таким образом, в приложении мы сможем отвязаться от конкретных урлов. У нас появится возможность менять урлы и передавать приложение кому-то другому.

## Django приложения
**Приложения** -- способ распространения кода в Django инфраструктуре. В случае, если вы не планируете публиковать ваш код, приложения -- это просто способ логической организации кода.

`./manage.py startapp crm` -- создание нового приложения с именем `crm`. Нужно вызывать из директории проекта.


### Структура приложения
```
- templates  # шаблоны (имеет смысл в open source)
- static  # статические файлы (имеет смысл в open source)
- templatetags  # собственные теги шаблонизатора
- management
	- commands  # менеджмент-команды терминала
- migrations  # миграции (скрипты изменения БД)
- models.py  # модели приложения, вся бизнес-логика
- tests.py  # тесты
- urls.py  # роутер для конкретного приложения
- views.py  # контроллеры
``` 

## Django Views

Контроллеры в Django -- это обычные функции, которые принимают объект `django.http.HttpRequest` первым параметром и возвращают объект `django.http.HttpResponse`. Такие функции по соглашению должны размещаться в файле `views.py`. Когда их становится много, этот файл можно разделить на части, но тогда надо будет самостоятельно озаботиться об импортировании: например, если они передаются в роутере по имени, они обязательно должны быть в `views.py`.

```py
# /blog/post_text/?id=123
def post_text(request: HttpRequest):
	try:
		id = request.GET.get('id')  # свойство GET содержит все GET-параметры
		# id = '123'
		obj = post.objects.get(pk=id)  # запрос к БД
	except Post.DoesNotExist:  # объект в БД не найден
		raise Http404
	return HttpResponse(obj.text, content_type='text/plain')
```

### Захват параметров из URL
Как можно передавать параметры внутрь функции view? Первый способ -- через GET-параметры (`/?id=123`), второй способ -- передача через путь: часто у веб-приложения делают человекочитаемые урлы, поэтому часто урл конкретного поста содержит не его id (типа `/blog/post/?id=123`),  а его слаг: урл вида `/blog/post/vsem_privet/` . В данном случае первая часть урла определяет приложение (но это зависит от роутера), вторая -- вьюшку, а третья всё время меняется, и это и есть тот параметр, который нужно передать во вьюшку.

Это называется захват параметров и реализовывается в двух местах: с одной стороны, в роутере, в файле `urls.py` в регулярке надо явно указать, что мы ожидаем какой-то параметр c помощью захвата групп. 

Далее при вызове вьюшки Django будет передавать захваченные переменные в качестве дополнительных параметров. При этом при неименованном захвате `()` они будут переданы как позиционные параметры `*args`, а при именованном `(?p<group_name>)` они будут переданы как именованные параметры `**kwargs`.

### HttpRequest и HttpResponse
#### Атрибуты HttpRequest

- `method` -- метод запроса
- `GET` -- словарь с GET параметрами
- `POST` -- словарь с POST параметрами
- `COOKIES` -- словарь с куками
- `FILES` -- загруженные файлы
- `META` -- CGI-like переменные
- `session` -- словарь-сессия (*) -- если подключен соответствующий middleware для поддержки сессий
- `user` -- текущий пользователь (*)

#### HttpResponse
```py
from django.http import HttpResponse

# создание ответа
response = HttpResponse("<html>Hello world</html>")

# установка заголовков
response['Age'] = 120

# установка всех параметров
response = HttpResponse(
	content = '<html><h1>Ничего</h1></html>',
	content_type = 'text/html',
	status = 404,
)
```

#### Специальные типы ответов
```py
from django.http import HttpResponseRedirect, \
	HttpResponseNotFound, ...  # наследники HttpResponse

redirect = HttpResponseRedirect('/')  # 302
redirect = httpResponsePermanentRedirect('/')  # 301
response = HttpResponseNotFound()   # 404
response = HttpResponseForbidden()  # 403
```

### Получение GET и POST параметров
```py
order = request.GET['sort'] # опасно!
# при указании неправильного ключа будет выброшено исключение => 500 ошибка
if order == 'rating':
	queryset = queryset.order_by('rating')
page = request.GET.get('page') or 1
try:
	page = int(page)  # в качестве параметра page могло быть передано все что угодно
except ValueError:
	return HttpResponseBadRequest()  # 400
```

На самом деле, атрибуты класса `HttpResponse` `GET` и `POST` -- это не словари, а объекты класса `QueryDict`, которые ведут себя как словари, но обладают дополнительным функционалом, связанным с тем, что в качестве одного параметра может передаваться несколько значений (например, при использовании чекбоксов):

`/path/?id=3&id=4&id=5`

Получение множественных значений:
```py
id = request.GET.get('id')  # id == 5
id = request.GET.getlist('id')  # id == [3, 4, 5]
```

Сериализация:
```py
qs = request.GET.urlencode()  # qs == 'id=3&id=4&id=5'
```

### Получение и установка HTTP заголовков
```py
user_agent = request.META.get('HTTP_USER_AGENT')
user_ip = request.META.get('HTTP_X_REAL_IP')
if user_ip is None:
	user_ip = request.META.get('REMOTE_ADDR')

response = HttpResponse(my_data, content_type='application/vnd.ms-excel')
response['Content-Disposition'] = 'attachment; filename="foo.xls"'
```

### Получение и установка Cookie
```py
response = HttpResponse(html)
response.set_cookie('visited', '1')

is_visited = request.COOKIES.get('visited')
```

### Декораторы
Декораторы применяются к вьюшкам.
```py
from django.views.decorators.http import require_POST

@require_POST
def like(request):
	pass
```

- `@require_GET` -- только GET запросы
- `@require_POST` -- только POST запросы
- `@login_required(login_url='/login/')` -- для вызова данной функции пользователь должен быть авторизован, иначе он будет перенаправлен на урл
- `@csrf_exempt` -- отключить проверку CSRF


## Шаблонизация
### Неправильный подход
```py
def header():
	return '<html><head>...</head><body>'

def footer():
	return '</body></html>'

def page1(data):
	return header() + \
		'<h1>' + data['title'] + '</h1>' + \
		'<p>' + data['text'] + '</p>' + \
		footer()
```
### Правильный подход
Необходимо отделить данные (**контекст**) от представления (**шаблона**). Для этого используются **шаблонизаторы**.

- разделение работы фронтендера и бэкендера
- повторное использование HTML кода
- более чистый python код

### Синтаксис шаблонов
```html
<!-- templates/blog/post_details.html -->
<html>
	<head>...</head>
	<body>
		<h1>{{ post.title|truncatechars:80 }}</h1>
		<p>{{ post.text }}</p>
		{% for comment in comments %}
			{% include "blog/comment.html" %}
		{% endfor %}
	</body>
</html>
```

`{{  }}` -- вывод переменной
### Вызов шаблонизатора
```py
# project/blog/views.py
from django.shortcuts import render, render_to_response

return render_to_response('blog/post_details.html', {
	'post': post,
	'comments': comments,
})  # первый аргумент -- шаблон, второй -- контекст. Возвращает HttpResponse

return render(request, 'blog/post_details.html', {
	'post': post,
	'comments': comments,
})  # если при отрисовке шаблона нужны переменные из request
```
### Возможности шаблонизатора
- `{% for item in list %}{% endfor %}` -- итерация по списку
- `{% if var %}{% endif %}` -- условное отображение
- `{% include "tpl.html" %}` -- включение подшаблона
- `{{ var }}` -- вывод переменной
- `{{ var|truncatechars:9 }}` -- применение фильтров
- `{# comment #}`, `{% comment %} {% endcomment %}` -- комментарии


### Доступ к свойствам и методам
Через точку можно получить свойство, метод, ключ либо индекс объекта:
```
{{ object.content }}
{{ name.strip }}
{{ info.avatar }}
{{ post_list.0 }}
```

Передавать параметры методам запрещено:
```html
{{ post_list.order_by('id') }} <!-- ошибка -->
{{ post_list.delete }}
```

### Особенности шаблонизатора
- шаблоны автоматически экранируют HTML сущности: если этого не было, у пользователя была бы возможность ввести тэг `<script></script>` и получится, что пользователь на странице нашего сайта разместил свой javascript. Это серьёзная проблема с безопасностью сайта (XSS). Поэтому если пользователь ввёл такую ерунду, эти данные будут экранированы и отображены просто как текст
- шаблонизатор можно расширять своими фильтрами и тэгами

### Наследование шаблонов
Похоже на наследование классов в языка программирования.

Рассмотрим базовый шаблон страницы сайта типа stackoverflow. Такой базовый шаблон ещё называют layout, потому что он задаёт расположение блоков на странице
#### base.html
```html
<!DOCTYPE HTML>
<html>
<head>
	<title>{% block title %}Q&A{% endblock %}</title>
	{% block extrahead %}{% endblock %}
</head>
<body>
	<h1>Вопросы и ответы</h1>
	{% block content %}{% endblock %}
</body>
</html>
```

Мы видим, что в этом шаблоне описана структура страницы. Также есть специальные тэги `block` и `endblock`, и в некоторых случаях у этих тэгов есть некоторое содержимое (например, `Q&A`). Если проводить аналогию с языком программирования, то layout -- это базовый класс, а блоки -- виртуальные методы: у некоторых методов есть реализация по умолчанию (например, значение), а у некоторых нет.

#### Шаблон конкретной страницы
```html
{% extends "base.html" %} <!-- наследование от базового шаблона -->
{% block title %}
	{{ block.super }} - главная
{% endblock %}
{% block content %}
	{% for obj in post_list %}
	<div class="question">
		<a href="{{ obj.build_url }}">{{ obj }}</a>
		{{ obj.created_date|date:"d.m.Y" }}
	</div>
	{% endfor %}
{% endblock %}
```
Как видно, содержимое унаследованного шаблона находится в блоках. Эти блоки перекрывают блоки базового шаблона. При этом внутри реализации блоков в наследниках есть возможность сначала отрисовать блок родителя с помощью `{{ block.super }}`.

Такой паттерн проектирования называется **template method**.

### Context processor
На практике оказывается, что какой-то набор переменных требуется на подавляющем большинстве страниц. Эти переменные можно было бы явно добавлять в контекст каждой вьюшки, но это неудобно.

**Context processors** -- это функции, которые вызываются перед отрисовкой шаблона и могут добавить данных в контекст.

Настройка `TEMPLATE_CONTEXT_PROCESSORS`:
- `django.core.context_processors.request` добавляет переменную `request`
- `django.core.context_processors.csrf` добавляет переменную `csrf_token`
- `django.core.context_processors.static` добавляет переменную `STATIC_URL` (префикс всех путей к статическим файлам)
- `django.contrib.auth.context_processors.auth` добавляет переменную `user`, `perms`

Контекст-процессоры вызываются при каждом вызове шаблона, поэтому очень важно не размещать там сложной логики и использовать только те переменные, которые действительно нужны на каждой странице сайта

Заметим, что функция `render(request, template_name, context)` вызывает контекст-процессор, а `render_to_response(template_name, context)` не вызывает.

## Работа с СУБД
### Работа с СУБД в Python
Полное описание интерфейса для работы с СУБД в PEP-0249

```py
import MySQLdb
db = MySQLdb.connect(host='localhost', user='joe',
					 passwd='moonpie', db='thangs')
cursor = db.cursor()
# запросы с использованием cursor
db.commit()
db.close()
```

#### Выполнение запросов
```py
cursor.execute("""
	update users set age = age + 1 where name = %s
""", (name,))  # вместо %s будет подставлена переменная name

cursor.execute("select * from users")
users = cursor.fetchall()

cursor.execute("""
	select * from users where name = %s
""", (name,))
user = cursor.fetchone()

# вставка многих записей (prepared statements)
cursor.executemany(
	"INSERT INTO users (name, age) VALUES (%s, %s)",
	[
		('Igor', 18),
		('Petr', 16),
		('Dasha', 17)
	]
)
```
#### Placeholders
```py
email = "' OR '1'='1"
cursor.execute(
	"select * from users where email = '" + email + "'"  # опасно, sql-инъекции
)
cursor.execute(
	"select * from users where email = '%s'",
	email  # в данном случае опасный символ (кавычка) будет экранирован
)
```
### Базы данных в Django
#### Прямой доступ к базе
```py
from django.db import connection, connections

cur = connection.cursor()  # соединение с дефолтной базой данных
cur.execute('select * from tbl limit 10')

default_cur = connections['default'].cursor()  # случай нескольких баз 
default_cur.execute('select * from tbl2 limit 10')
another_cur = connections['another'].cursor()
another_cur.execute('select * from tbl2 limit 10')
```
#### Полезные утилиты
- `./manage.py check` -- проверить структуру моделей
- `./manage.py makemigrations` -- создать миграции
- `./manage.py migrate` -- применить созданные миграции
- `./manage.py shell` -- запустить python shell
- `./manage.py dbshell` -- запустить клиент базы данных

### Django Models
Это библиотека ORM в Django
|  Django | SQL  |
|--|--|
|  класс модели  |  таблица  |
| объект модели | строка таблицы |
| QuerySet | запрос |

### ORM vs SQL
```py
# SQL
cursor.execute('select * from users where age > 18')
for user in cursor.fetchall():
	pk, name, age = user
	print(name)

# ORM
for user in User.objects.filter(age__gt=18):
	print(user.name)
```

### Модели Django
```py
from django.db import models

class Post(models.Model):
	title = models.CharField(max_length=255)
	content = models.TextField()
	creation_date = models.DateTimeField(blank=True)
	
	def __str__(self):
		return self.title

	def get_absolute_url(self):
		return f'/post/{self.pk}/'

	class Meta:  # задание опций модели
		db_table = 'blogposts'  # сохранять модель в указанную таблицу
		ordering = ['-creation_date']  # сортировка по умолчанию
```

### Типы полей
|Django |MySQL |
|--|--|
| CharField | VARCHAR(N) | 
| EmailField | VARCHAR(N)|
| TextField | LONGTEXT |
| BooleanField | TINYINT(1) |
| IntegerField | INT(11) |
| DateField | DATE |
| DateTimeField | DATETIME |

### Свойства полей
- `blank` -- поле может быть пустым с точки зрения Python (может содержаться `None`).
- `null` -- при этом хранится в базе как NULL
- `max_length` -- максимальная длина поля
- `primary_key` -- это поле -- первичный ключ
- `unique` -- поле уникально
- `db_index` -- для этого поля нужен индекс в базе
- `default` -- значение по умолчанию
- `choices` -- варианты значений

### Связи между моделями
```py
class Post(models.Model):
	title = models.CharField(max_length=255)
	# more fields...

	category = models.ForeignKey(Category, null=True, on_delete=models.SET_NULL)
	status = models.OneToOneField(PostStatus)
	tags = models.ManyToManyField(Tag)
```

### Ограничения внешних ключей
Применимо к полям типа `ForeignKey`, `OneToOneField`
- `RESTRICT` -> `models.PROTECT`
- `CASCADE` -> `models.CASCADE`
- `SET NULL` -> `models.SET_NULL`
- `NO ACTION` -> `models.DO_NOTHING`


### Использование отношений в коде
```py
post = Post.objects.get(pk=1)
category: Category = post.category
category_id: int = post.category_id
status: Status = post.status
status_id: int = post.status_id
tags_manager: RelatedManager = post.tags
post.tags.all()  # [Tags]

# использование обратного отношения
category.post_set.all()  # [Post]
tag.post_set.all()  # [Post]
```

## Django Models API
### Создание и изменение объектов
```py
from blog.models import Category, Post

# создание
c = Category(title='Perl')
c.save()  # сохранение в базу данных. В этот момент у модели появится свойство c.pk

# или за один вызов
c = Category.objects.create(title='Python')

# изменение
c.title = "About Python"
c.save()
```

### Создание объектов со связями
```py
from blog.models import Category, Post, Tag

t = Tag(title='easy'); t.save()
c = Category(title='Python'); c.save()

p = Post(title='Intro', text='...', category=c); p.save()
p.tags = Tag.objects.all()[0:3]; p.save()  # связь многие-ко-многим
p.tags.add(t); p.save()
```

### Загрузка объекта из базы
```py
# по ключу
try:
	post = Post.objects.get(pk=3)
except Post.DoesNotExist;
	post = None

# по другому полю
try:
	post = Post.objects.get(name='Python')
except MultipleObjectsReturned:
	post = None
```

### Выборка нескольких объектов
```py
all_posts = Post.objects.all()
first_three = Post.objects.all()[:3]

c = Category.objects.get(id=3)
python_posts = Post.objects.filter(category=c)

css_posts = Post.objects.filter(title__contains="css").order_by('-rating')[10:20]
```

### QuerySet
Это объекты, представляющие собой запрос к базе данных. Именно **запрос**, а не его результаты. QuerySet являются ленивыми (lazy) объектами. Это значит, что запрос осуществляется не в момент создания QuerySet, а в момент **итерации по нему**, либо вызова метода, возвращающего результат.

QuerySet  представляет множество объектов, которое можно уточнять и делать с ним какие-либо операции.


#### Chaining
```py
posts: ModelManager = Post.objects
posts: QuerySet = posts.filter(title__match="CSS")
posts: QuerySet = posts.exclude(category_id=7)
posts: QuerySet = posts.order_by('rating')
posts: QuerySet = posts.reverse()
posts: list[Post] = posts[0:10]
```
При вызове Chaining методов у QuerySet мы опять получаем объект QuerySet, при этом запроса в базу не происходит. Плюс такого подхода в том, что мы можем сохранять подготовленные запросы в переменных: например, мы можем подготовить QuerySet для постов, которые видны пользователю и применять к нему пользовательские операции типа сортировки по дате или по популярности.

- `filter`, `exclude` -- фильрация, в SQL это `WHERE`
- `order_by` -- сортировка
- `annotate` -- выборка агрегатов, в SQL это `JOIN` и `GROUP BY`
- `values` -- выборка отдельных колонок, а не объектов
- `distinct` -- выборка уникальных значений
- `select_related`, `prefetch_felated` -- выборка из нескольких таблиц

#### Методы, возвращающие результат
- `create` -- создание нового объекта
- `update` -- обновление всех подходящих объектов
- `delete` -- удаление всех подходящих объектов
- `get_or_create` -- выборка объекта или его создание
- `count` -- выборка количества `COUNT(*)`

#### Синтаксис условия в QuerySet
В методах `filter` и `exclude`:
- `field=value` -- точное совпадение
- `field__contains=value` -- суффикс оператора `LIKE`
- `field__isnull`, `field__gt`, `field__lte`
- `relation__field` -- условие по связанной таблице
- `category__title__contains="perl"`

Названия таблиц и полей не могут содержать `__`!

### ModelManager
В модели содержатся методы для работы с одним объектом (одной строкой). В **ModelManager** содержатся объекты для работы со множеством объектов. Он пол умолчанию содержит все те же методы, что и QuerySet и используется для создания QuerySet-объектов, связанных с данной моделью.

#### ModelManager по умолчанию
```py
class Post(models.Model):
	title = models.CharField()
	# ...

posts: Manager = Post.objects
posts: QuerySet = Post.objects.all()
posts: QuerySet = Post.objects.filter(id__gt=10)
```

#### Свой ModelManager
```py
class PostManager(models.Manager):
	def best_posts(self):
		return self.filter(rating__gt=50)
	
	def published(self):
		return self.filter(published=True)

	def create_draft(self, **kwargs):
		kwargs['draft'] = True
		return self.create(**kwargs)


class Post(models.Model):
	title = models.CharField()
	objects = PostManager()
```

Хорошей практикой является создание своего Model Manager'а. Как правило, для каждой модели создаётся свой отдельнный Model Manager. Смысл в том, что в своих ММ можно описать дополнительные методы для работы с набором объектов. Это позволяет помещать весь код внутрь модели и избегать его дублирования.

### RelatedManager
Когда в модели создаётся связь многие-ко-многим, создаётся новый объект RelatedManager. Этот менеджер также расширяет функционал QuerySet, но запросы строятся не просто к данной таблице, но они ещё и будут в себя включать условие на данный объект.

Допустим, у нас есть такая модель со связью многие-ко-многим:
```py
class Post(models.Model):
	# ...
	tags = models.ManyToManyField(Tag)


p1 = Post.objects.get(pk=3)
tags: RelatedManager = p1.tags
```

**RelatedManager** связан с конкретным объектом Post и во все выборки будет добавлять условие `post=p1`

#### Методы RelatedManager
- `create(**kwargs)` -- создание нового тэга, связанного с постом
- `add(t2)` -- привязка существующего тэга `t2` к текущему посту
- `remove(t2)` -- отвязка существующего тэга `t2` от текущего поста
- `clear()` -- очистка списка тэгов у текущего поста

## Миграции
Это процесс изменения структуры базы либо структуры модели. Дело в том, что приложения, как правило, существуют долго и развиваются, то есть вы тратите некоторое время на разработку, деплоите приложение, оно работает, а потом появляются дополнительные требования со стороны заказчика или хотите добавить новый функционал, но вы не можете просто так изменить ваши модели: тогда разойдётся структура моделей и таблиц в базе данных и всё перестанет работать, то есть при каждом изменении моделей нужно производить соответствующие изменения в базе данных. Для этого используется механизм миграции.

**Миграция** -- это процедура изменения схемы базы данных для приведения её в соответствие с моделями. Существуют разные подходы к решению этой проблемы: в Django с версии 1.7 есть встроенная система миграций, до этого можно было использовать отдельные специальные библиотеки, например, South.

В Django миграции представляют из себя отдельные файла, внутри каждого из которых находится класс миграции. Миграции описывают не структуры таблиц, а структуры моделей, причём они версионируются. Такми образом Django может автоматически отслеживать разницу между текущими моделями, описанными в коде, и теми моделями, которые реконструированы по всем миграциям. 

Если в приложении есть директория `migrations`, считается, что оно поддерживает миграции.

Плюсы миграций: поддержка разных баз данных; миграции бывают прямые и обратные (можно накатить и откатить).

Минус: на практике они часто неудобные или недостаточно выразительные, поэтому иногда удобно писать свои миграции, но для этого нужно гарантировать, что приложение не содержит директорию `migrations`

Свои миграции представляют собой обычные скрипты. Например, в своём проекте можно создать отдельную директорию `migration` и туда складывать скрипты.

```py
from django.core.management import setup_environ
from project import settings
setup_environ(settings)
from django,db import connections
cursor = connection.cursor()
cursor.execute('alter table blog_post add column is_best tinyint(1)')
```

Такие миграции гибкие и позволяют делать всё, что мы хотим. Однако они завязаны на определённую базу данных, поскольку мы пишем сырой sql код и у них нет обратных миграций, хотя на практике обратные миграции нужны крайне редко.

Хорошей практикой является начинать именование файла миграции с даты, например, `2020-08-06-more-post-fields.py`. Таким образом, мы гарантируем, что у файлов не будет пересечения и у нас появится возможность отслеживать, какие миграции уже были применены, а какие нет.

## Best practices
Есть один антипаттерн **Fat Controller** -- размещение логики в котроллерах. Это лишает возможности использовать её повторно. Всю бизнес-логику приложения следует размещать в **моделях**.

Ответственность контроллера заключается в обработке проткола HTTP, а в остальном он занимается только вызовом методов модели. То есть контроллер -- это то место, где идёт связка существующей логики.

Типичная проблема -- когда в контроллере пишется логика. Это решение очень популярно среди новичков, просто потому что так удобнее программировать: проблему решаем в том месте, где это оказывается наиболее простым. Но потом это логику невозможно переиспользовать, запустив её через утилиту командной строки или API.

Если действие связано с одним объектом, его лучше оформить в виде метода конкретной модели.

Если действие связано с набором объектов, его стоит оформить в виде метода ModelManager'a.

Если действие представляет собой процесс, который вовлекает множество разных моделей, принято создавать классы-хелперы или модули, в которых полностью описывается этот процесс. Важно, чтобы эти классы, модули или функции никак не были связаны с протоколом HTTP: там не должны использоваться request/reponse, переменные окружения, свзяннаые с HTTP и т.д., там идёт операция чисто с данными. Этот код можно будет повторно использовать из другой вьюшки.

Эта практике не стопроцентная, в некоторых случаях очевидно, что код временный и не относится к модели данных поэтому всегда нужно понимать, расширяется ли бизнес-логика или это временное решение, которое в бизнес-логику желательно не помещать.

# Типичные сценарии веб-приложений
1. Отображение объекта. В дальнейших рассуждения мы предполагаем, что объект хранится в реляционной базе данных
2. Отображение списка объектов. Здесь ситуация сложнее, всё зависит от поставленной задачи: это может быть как простейший поход в базе данных или очень сложная выборка, полнотекстовый поиск или что-то ещё. Мы будем рассматривать два варианта загрузки данных из базы: попроще и чуть посложнее.
3. Обработка форм и изменение объектов. Здесь всегда возникает проблема авторизации: в подавляющем большинстве случаев мы не можем позволить изменять данные кому угодно и нам надо знать, какой пользователь выполняет запрос.
4. Авторизация и сессии пользователей
5. Запуск фоновых процессов - предполагает, что наше веб-приложения состоит не только из HTTP-обработчика, но и из каких-то фоновых процессов, например, чистка данных, которые всё время работают.
6. Интеграция с внешними системами

## Отображение объекта
### Маршрут в urls.py
```py
# blog/urls.py
urlpatterns = [
	url(r'^post/(?P<slug>\w+)/$', post_details, name='post-details'),
	url(r'^tag/^(?P<slug>\w+)/$', tag_details, name='tag-details'),
]
```

Часто на объекты ссылаются не по **id**, а по **slug**. Это позволяет строить более запоминающийся для человека URL.

Мы предполагаем, что объект отображается по урлу `/blog/post/некоторый_текст/`. Заметим, что здесь мы использовали именно слаг. В маршрутизаторе мы видим, что урлы такого вида ссылаются на вьюшку `post_details`, которой будет передан параметр `slug`, выхваченный из урла.

### Базовый view
```py
from django.http import Http404
from django.shortcuts import render

def post_details(request, slug):
	try:
		post = Post.objects.get(slug=slug)
	except Post.DoesNotExist:
		raise Http404
	return render(request, 'blog/post_details.html', {'post': post})
```
Здесь есть несколько допущений и недоработок. Во-первых, конструкция 	`try-except` длинная и её приходится писать каждый раз. Для этого существуют шорткаты -- функции для выполнения типичных бытовых операций:
```py
from django.shortcuts import render, get_object_or_404
from django.views.decorators.http import require_GET

@require_GET  # запрещает другие запросы
def post_details(request, slug):
	post = get_object_or_404(Post, slug=slug)
	return render(request, 'blog/post_details.html', {'post': post})
```

### Отображение связанных сущностей
Надо понимать, что в большинстве случаев страница поста состоит не только из самого поста: там ещё категория, тэги, автор, лайки и так далее.

```py
def post_details(request, slug):
	post = get_object_or_404(Post, slug=slug)
	try:
		vote = post.votes.filter(user=request.user)[0] # выводим отношение текущего пользователя к текущему посту
	except vote.DoesNotExist: # пользователь не голосовал за этот пост
		vote = None
	return render(request, 'blog/post_details.html', {
		'post': post,
		'category': post.category,
		'tags': post.tags.all()[:]
		'vote': vote
	})
```
Мы видим, что в таком случае наш код раздувается и появляется дополнительная логика. Во многих подобных случаях можно обойтись только шаблонизатором, передавая в него только пост и голос:
```html
<h1>{{ post.category.title }} - {{ post.tile }}</h1>
{% for tag in post.tags.all %}
	<a href="{{ tag.get_url }}">{{ tag }}</a>
{% endfor %}
```

Чтобы данный код работал, в модели необходимо определить следующие методы:
```py
from django.core.urlresolvers import reverse

class Tag(models.Model):
	slug = models.SlugField(unique=True)
	title = models.CharField(max_length=64)

	def get_url(self):
		return reverse('blog:tag-details', kwargs={'slug': self.slug})  # reverse-routing

	def __str__(self):
		return self.title
```

## Отображение списка объектов
Помимо одного поста на странице, нам бы хотелось ещё видеть список этих постов. Причём очевидно, что списки будут разные: например, самые популярные, свежие и так далее. И очевидно, что, как правило, эти списки не умещаются на одном экране.

Начнём с простейшего варианта. Представим, что у нас есть запрос на список всех опубликованных постов, а их порядок нам пока не важен. Мы создаём в `urls.py` специальный маршрут, который ведёт к нашей вьюшке `post_list_all`:

```py
from django.core.paginator import Paginator

def post_list_all(request):
	posts = Post.objects.filter(is_published=True) # создание QuerySet
	limit = request.GET.get('limit', 10)
	page = request.GET.get('page', 1)  # какую страницу листинга мы смотрим
	paginator = Paginator(posts, limit)  # рассчитывает параметры для постраничного отображения
	paginator.baseurl = '/blog/all_posts/?page='
	page: Page = paginator.page(page) # получаем объект страницы по её номеру
	return render(request, 'blog/post_by_tag.html', {
		'posts': page.object_list,  # список постов, относящихся к данной странице
		'paginator': paginator,
		'page': page
	})
```

Нам необходимо реализовать механизм пагинации: добавления ссылок на другие страницы для навигации.

### Шаблон Paginator
```html
<nav><ul class="pagination">
{% for p in paginator.page_range %} <!-- список всех страниц, которые будут отображаться рядом с текущей -->
	{% if p.number == page.number %}
	<li class="active">
	{% else %}
	<li>
	{% endif &}
		<a href="{{ paginator.baseurl }}{{ p.number }}">{{ p.number }}</a>
	</li>
{% endfor %}
</ul></nav>
```

### django.core.paginator.Paginator
#### Свойства 
- `count` -- полное число объектов
- `num_pages` -- полное число страниц
- `page_range` -- список страниц, например, `[1, 2, 3, 4]`

#### Методы 
- `page(n)` -- получить n-ный объект `Page`. При вызове этого метода непосредственно загружаются объекты из базы данных.

Чтобы построить постраничный листинг, нужно:
1. получить некоторый QuerySet
2. получить параметры `page` и `limit`
3. создать объект `Paginator`, куда передать QuerySet и лимит
4. вызвать метод `page()` и получить объект `Page`

### django.core.paginator.Page
#### Свойства
- `object_list` -- список объектов на странице, которые нужно отображать.
- `number` -- порядковый номер страницы

#### Методы
- `has_next()`, `has_prevoius()` -- наличие соседней страницы
- `next_page_number()`, `previous_page_number()`
- `start_index()`, `end_index()` -- номера первого и последнего объектов на странице

### Best practices

- проверять валидность параметров `page` и `limit`
- отображать 404 ошибку при некорректных параметрах
- ограничивать максимальное значение `limit` <= 1000
- обрабатывать "пустую" последнюю страницу: если контент активно меняется, то с момента, когда пользователь увидел пагинатор, до момента, когда он щёлкнул на последнюю страницу, количество объектов может уменьшиться и номер последней страницы теперь изменился. В этом случае надо понимать, что пользователь не просто хотел увидеть страницу с конкретным номером, а именно последнюю страницу, так что ему надо показать именно новую последнюю страницу, пусть даже с другим номером.


Реализацию этих правил можно посмотреть в таком сниппете:
```py
def paginate(request, qs):
	try:
		limit = int(request.GET('limit', 10))
	except ValueError:
		limit = 10
	if limit > 100:
		limit = 10
	try:
		page = int(request.GET.get('page', 1))
	except ValueError:
		raise Http404
	paginator = Paginator(qs, limit)
	try:
		page = paginator.page(page)
	except EmptyPage:
		page = paginator.page(paginator.num_pages)
	return page
```
## Progressive Loading
С ростом популярности социальных сетей и мобильных приложений стала популярна последовательная загрузка. В этих случаях это естественный способ читать ленту новостей.

Помимо дизайна, у progressive loading есть ряд преимуществ. **Постраничная загрузка** хорошо работает в тех случаях, когда легко определить число объектов, подходящих под поисковый запрос. Другими словами -- когда можно составить эффективный SQL запрос. Иногда это сделать сложно, например: "отображать все посты в порядке добавления, но не больше одного поста из одной категории подряд". В нашем случае удобно загружать данные последовательно небольшими кусочками.

```py
# model manager
class PostManager(model.Manager):
	def main(self, since, limit=10):
		qs = self.order_by('-id')
		res = []
		if since is not None:
			qs = qs.filter('id__lt'=since)
		for p in qs[:1000]:
			if not len(res);
				res.append(p)
			elif res[-1].category != p.category:
				res.append(p)
			if len(res) >= limit:
				break
		return res
```

```py
# view
def post_list_main(request):
	since = request.GET.get('since')
	posts = Post.objects.main(since)
	return render(request, 'blog/post_main.html', {
		'posts': posts,
		'since': posts[-1].id,
	})
```
Шаблон:
```html
<a href="/blog/main/?since={{ since }}">Далее</a>

```

## Обработка форм
### GET/POST формы
**GET** -- метод для **получения** данных. GET запросы могут быть закешированы промежуточными серверами. **GET** должен применяться только в **поисковых** формах.

**POST** -- метод для **изменения** данных. POST запросы никогда не кешируются промежуточными серверами. **POST** должен применяться в формах, **изменяющих данные** на сервере.

Мы будем рассматривать POST-формы.

### Общий сценарий обработки
![](https://i.ibb.co/9cxSMvC/image.png)
У нас есть некоторая HTML-страничка, на которой находится форма. Пользователь заполняет форму и в какой-то момент происходит POST-запрос.

Нижняя часть схемы -- так логика, которая происходит на стороне сервера. Первое, что делает сервер, получив форму, -- проверяет валидность формы, то есть верны ли все её данные, возможно ли вообще эту форму сохранить. Если форма не валидна, веб-сервер возвращает HTML страничку с кодом 200 и показывает её заново со списком ошибок, которые не позволили серверу сохранить форму. 

Если сервер считает, что форма валидна, происходит сохранение данных. После того, как данные сохранены, пользователю нужно об этом сообщить. Происходит редирект (код 302) на новую страницу. Это может быть та же самая страница с формой редактирования объекта, или это может быть новая страница самого объекта и часто в урле передаётся сообщение об успехе, особенно если мы возвращаем пользователя опять на страницу редактирования: пользователь должен знать, что его действие успешно сохранено. Важно, что здесь отдаётся именно редирект: первоначальный запрос пользователя (отправка формы) был с методом POST. Если после успешного сохранения мы вернём пользователю код ответа 200, визуально будет выглядеть всё хорошо, но если он нечаянно нажмёт F5, запрос отправится повторно, после чего форма повторно сохранится. В некоторых случаях это крайне нежелательно: например, если пользователь совершает покупку в магазине, то повторная отправка формы приведёт к повторному списанию денег, поэтому после успешного сохранения нужно отдавать редирект.

### Best practice
- **Всегда** проверять пользовательские данные
- Для форм, изменяющих данные, использовать метод **POST**
- не заставлять вводить данные повторно: если он совершил ошибку, например, ввёл неправильный емейл, не нужно заставлять вводить его 50 других полей.
- сообщать об ошибках детально -- по полям
- сообщать об успешном сохранении формы
- при успешном сохранении делать перенаправление

### Http Redirect
Допустим, у нас был POST-запрос на сервер. Сервер выполняет некоторую логику и вместо HTML-странички отдаёт код ответа 302, тело ответа при этом пустое, плюс к этому стоит заголовок `Location`. Такая комбинация (302 + `Location`) говорит браузеру, что нужно сделать запрос повторно, но по новому урлу, переданному в заголовке `Location`.

Браузер повторяет запрос, но уже по новому урлу, и это будет уже GET запрос. Веб-сервер получает этот запрос, выполняет некоторую логику и на этот раз возвращает уже нормальную HTML-страничку.

В принципе, ситуация может не ограничиваться одним редиректом и сервер может отдать 302 и во второй раз. Это нормальная практика.

Веб-клиент также следит за зацикливанием, когда веб-сервер выдаёт перенаправление на изначальный урл.

- `302 Found` -- временное перенаправление
- `301 Moved Permanently` -- постоянное перенаправление (кешируется в браузере)
- `Location: url` -- URL для повторного запроса. Может быть как абсолютным, так и относительным.

### Перенаправления в Django
```py
from django.http import HttpResponseRedirect

def some_view(request):
	# logic ...
	return HttpResponseRediect('/new_url/')

# уязвимость open redirect
def dangerous_view(request):
	url = request.GET.get('continue')
	return HttpResponseRedirect(url)
```
Нужно отметить, что зачастую заранее неизвестно, на какую страницу нужно сделать редирект. Например, для формы авторизации пользователя нужно перенаправить на ту страницу, откуда он пришёл, поэтому страница, куда нужно отправить пользователя, часто передаётся GET-параметром. Здесь есть уязвимость Open Redirect: злоумышленник может направлять пользователя на свою страницу через наш сайт: чаще всего для пользователя это выглядит в виде письма со ссылкой `site.com/redirect/?continue=bad_url`. Таким образом, мы даём злоумышленника пользоваться репутацией нашего сайта. Поэтому когда делается подобного рода редирект, как минимум, нужно проверять домен сайта.

### Django Forms

В Django каждую форму рекомендовано представлять в виде отдельного класса. 

```py
from django import forms

class FeedbackForm(forms.Form):
	email = forms.EmailField(max_length=100)
	message = forms.CharField(widget=forms.TextArea)

	def clean(self):
		if is_spam(self.clean_data):
			raise forms.ValidateError(u'Сообщение похоже на спам', code='spam')
```

Такие классы часто хранятся в `forms.py`. По аналогии с моделями, мы перечисляем поля. В форме также можно определить метод `clean`, который отвечает за общую логику валидации формы. Например, мы видим, что внутри вызывается какая-то кастомная функция `is_spam`, которая магическим образом проверяет, похоже ли сообщение на спам. Если оказывается, что это спам, мы выбрасываем исключение `ValidationError`, означающая, что эту форму сохранять нельзя.

Рассмотрим другую форму:
```py
class AddPostForm(forms.Form):
	title = forms.CharField(max_length=100)
	message = forms.CharField(widget=forms.Textarea)

	def clean_message(self):
		massage = self.cleaned_data['message']
		if not is_ethic(message):
			raise forms.ValidateError(u'Сообщение не корректно', code=12)
		return message + '\nThank you for your attention'

	def save(self):
		post = Post(**self.cleaned_data)
		post.save()
		return post
```
Здесь метод `clean_message` соответствует валидации одного конкретного поля. Внутри этого метода мы обращаемся к свойству `cleaned_data` -- это свойство объекта формы, в котором лежат данные формы, уже прошедшие валидацию и очистку в соответствии с определенными полями (например, `EmailField` будет проверять, что там действительно емейл). Далее мы вызываем нашу магическую функцию `is_ethic`, которая осуществляет поиск нецензурных выражений в тексте. Если проверка не прошла, мы выбрасываем `ValidationError`, куда указываем сообщение для пользователя и код, если ошибка будет проверяться компьютером. 

Метод `clean_message` занимается дополнительной валидацией поля `message` и может как-то модифицировать `message`, чтобы перевести его во внутренний формат.

В методе `save` содержится непосредственно логика сохранения формы. Он вызывается уже после всех проверок.

### Типы полей
- `BooleanField` -- флажок
- `CharField` -- текстовое поле ввода
- `EmailField` -- текстовое поле, e-mail
- `PasswordField` -- текстовое поле, пароль
- `ChoiceField` -- выбор из нескольких вариантов
- `DateField` -- выбор даты
- `DateTimeField` -- выбор даты и времени
- `FileField` -- загрузка файлов

### Валидация данных
Срабатывает при вызове метода `is_valid()` формы.

- по типу поля, например, `EmailField`
- `clean_xxx` -- доп. проверка поля xxx, может изменить значение
- `clean` -- доп. проверка всех полей формы

Методы `clean` и `clean_xxx` должны использовать `self.cleaned_data` для получения данных формы и поднять `ValidationError` в случае некорректных данных.

Если все проверки проходят нормально и никто `ValidationError` не выбрасывает, метод `is_valid()` вернёт `True`.

### Использование во view
Типичная ситуация, когда вьюшка занимается и отображением формы, и обработкой её сабмита.
```py
def post_add(request):
	if request.method == 'POST':  # форма отправляется
		form = AddPostForm(request.POST)  # форма привязана к данным в методе
		if form.is_valid():  # очистка и валидация формы
			post = form.save()  # сохранение в базу
			url = post.get_url()  # получаем урл по модели
			return HttpResponseRedirect(url)
	else:  # форма отображается
		form = AddPostForm()  # unbound форма, не привязана к данным
	return render(request, 'blog/post_add.html', {'form': form})
```

### Использование в шаблонах
Вариант для ленивых -- отображение форм по умолчанию как маркированный список, через параграфы или через таблицу
```html
{{ form.as_ul }}
{{ form.as_p }}
{{ form.as_table }}
```

Есть более сложный вариант совмещения формы с Bootstrap:
```html
{% for e in form.non_field_errors %}
	<div class="alert alert-danger">{{ e }}</div>
{% endfor %}
<form class="form-horizontal" method="post" action="/blog/add/">
	<fieldset>
		{% for field in form %}
			<div class="control-group
				{% if field.errors %}has-error{% endif %}">
				<label class="control-label">{{field.label}}</label>
				<div class="controls">{{field}}</div>
			</div>
		{% endfor %}
	</fieldset>
	<div class="form-actions">
		<button type="submit" class="btn btn-primary">Сохранить</button>
	</div>
</form>
```

### Model forms
Код форм довольно однотипен, а список полей формы фактически повторяет список полей модели. Поэтому в Django был разработан специальный механизм, который позволяет строить форму для редактирования конкретной модели.

```py
from django.forms import ModelForm

class ArticleForm(ModelForm):
	class Meta:
		model = Post
		fields = ['title', 'content', 'category', 'tags']
```
Метод `save` уже определён и сохраняет модель `Meta.model`

### Безопасность
Как сделать проверку пользователя внутри формы? На практике важно, кто сохраняет форму.

```py
class AddPostForm(forms.Form):
	# ... поля ...
	def __init__(self, user, **kwargs):
		self._user = user
		super(AddPostForm, self).__init__(**kwargs)

	def clean(self):
		if self._user.is_banned:
			return ValidationError(u'доступ ограничен')

	def save(self):
		self.cleaned_data['author'] = self._user
		return Post.object.create(**self.cleaned_data)

```

Мы создаём класс формы и переопределяем инициализатор объекта, добавляя обязательный первый аргумент `user`, который сохраняется в отдельном атрибуте нашего класса. Теперь при вызове всех методов мы можем проверять текущего пользователя.

Посмотрим, как это используется во view:
```py
from django.contrib.auth.decorators import login_required

@login_required  # гарантирует, что пользователь придёт во вьюшку только авторизованным
def post_add(request):
	# ...
	form = AddPostForm(request.user, request.POST)
	if form.is_valid():
		post = form.save()
	# ...
```

### CSRF: Cross Site Resource Forgery
При запросе на какой-то конкретный домен браузер всегда добавляет куки, относящиеся к данному домену. Допустим, у нас есть сайт с обработчиком добавлением поста. Предполагалось, что на нашей странице есть формы, которые пользователь отправляет с методом `POST`, вместе с этим запросом передаются куки и на сайте создаётся пост от имени данного пользователя.

Нюанс в том, что куки будут передаваться даже если запрос пришел не с нашего сайта. Представим, что есть какой-то другой уязвимый сайт, где злоумышленник умудрился разместить картинку, у которой в `src` прописан адрес нашей функции, то есть вместо картинки там написано `<img src="site.com/blog/add?title=...&text=..."`. Когда злоумышленник приведёт кого-то на этот сайт, браузер попытается загрузить эту картинку и произойдёт GET-запрос. Браузер передаст все необходимые куки для нашего сайта, то есть авторизацию на нашем сайте, в результате чего будет вызван обработчик добавления поста с авторизацией пользователя, но с заголовком и текстом, указанными в `src` картинки злоумышленником.

Как можно бороться с CSRF?
- проверка метода `@require_POST`. Но если у злоумышленника большие возможности, он может внедрить и POST-запрос на уязвимый сайт.
- проверка заголовка `Referer`, но иногда нормальный пользователь может прийти без этого заголовка
- проверка CRSF-токенов: надёжный вариант.

CSRF-токен -- это длинная строка из случайных символов, которая для каждого пользователя отличается. Эта строка ставится в куку, как и авторизация и вводится в виде скрытого инпута в форму:
```html
<form method="POST" action="/blog/add">
	{% csrf_token %}
</form>
```

Таким образом, когда мы получаем нормальный запрос от формы, csrf-токен приходит и в POST-параметрах, и в куки, а когда мы получаем запрос от злоумышленника, csrf-токен придёт только в куки, потому что злоумышленник не может угадать его. 

## Авторизация
Исторически протокол HTTP является **stateless**- протоколом, то есть он не предполагает поддержания соединения между клиентом и сервером. Это значит, что сервер не может связать информацию о пользователе с конкретным соединением и вынужден загружать её при каждом запросе.

### Basic HTTP Authorization
Этот вариант авторизации реализован практически во всех серверах.

Начинается с того, что на сервере некоторая группа урлов, то есть локейшены, помечены, как требующие авторизации. Допустим, у нас это локейшн `/admin/`. Пользователь вводит урл и браузер делает запрос по пути `/admin/`. Веб-сервер пытается авторизовать пользователя, но, поскольку пользователь не передал никакой информации, а веб-сервер сконфигурирован так, что для данного локейшена требуется авторизация, то отправляется код ответа 401 Unauthorized и передаёт специальный заголовок `WWW-Authenticate`, который показывает, какой именно метод авторизации надо использовать: например, `Basic`. Кроме того, передаётся так называемый `realm` -- просто название части сайта: на сайте может быть много разных разделов с разной авторизацией.

Браузер получает этот ответ и показывает пользователю диалог ввода логина и пароля. Это стандартное для браузера окно. После этого браузер повторяет запрос, добавляя заголовок `Authorization`, где также указывается, что это Basic авторизация и какие-то данные -- закодированные логин и пароль пользователя.

Веб-сервер получает этот запрос, извлекает логин и пароль пользователя, проверяет авторизацию и решает, что они правильные, и возвращает 200.

После того, как пользователь авторизовался, его авторизация запоминается, то есть последующие запросы браузер будет делать, передавая заголовок Authorization.

#### Заголовки и коды ответа
- `401 Unauthorized` -- для доступа к ресурсу нужна авторизация
- `WWW-Authenticate: Basic realm="admin"` -- запрос логина/пароля для раздела admin
- `Authorization: Basuc sjhskjhvs126534==` -- передача логина/пароля в виде `base64(login + ':' + password)`
- `403 Forbidden` -- логин/пароль не подходят
- `REMOTE_USER` -- CGI переменная с именем авторизованного пользователя 

#### Достоинства
- простота и надежность
- готовые модули для веб серверов
- не требует написания кода

#### Недостатки
- логин/пароль передаются в открытом виде -- нужен HTTPS
- невозможно изменить дизайн формы входа
- невозможно сбросить авторизацию

### Cookies
**Cookies** -- небольшие фрагменты данных, которые браузер хранит на стороне клиента и передаёт на сервер при каждом запросе. Они привязаны к доменам, поэтому при каждом запросе сервер получает только свои куки. Невозможно получить доступ к кукам с другого домена. Куки используются для поддержания состояния (state management) в протоколе HTTP и, в частности, для авторизации.

#### Атрибуты куки
- `name=value` -- имя и значение
- `Expires` -- время жизни куки, по умолчанию -- до закрытия окна.
- `Domain` -- домен куки, по умолчанию -- домен текущего урла
- `Path` -- путь куки, по умолчанию -- путь текущего урла
- `Secure` -- кука должна передаваться только по https
- `HttpOnly` -- кука не доступна из javascript

#### Установка и удаление кук
```http
Set-Cookie: sessid=qieftq15fgva;
	Domain=.site.com; Path=/admin/;
	Expires=Sat, 15 Auh 2015 07:58:23 GMT;
	Secure; HttpOnly
Set-Cookie: lang=ru

Set-Cookie: sessid=xxx;
	Expires=Sun, 06 Nov 1994 08:49:37 GMT
```
Куки устанавливаются в заголовках HTTP. Для удаления куки сервер устанавливает `Expires` в прошлом.

#### Получение кук
```http
Cookie: sessid=kjahakjhkjh; lang=ru;
	csrftoken=kvjhvkjhvkhjkjh;
```

Браузер отправляет куки в заголовке `Cookie`. При каждом запросе он выбирает подходящие куки и отправляет только их значения.

В данном примере браузер передал три куки с именами `sessid`, `lang` и `csrftoken`.

#### Правила выбора кук браузером
Пусть URL = `http://my.app.site.com/blog/post/12`. Браузер выберет все куки, у которых
- не истек срок `Expires`
- `Domain` совпадает с `my.app.site.com` или является его .суффиксом, например, `.site.com` 
- `Path` является префиксом `/blog/path/12`, например, `Path=/blog/`
- Не стоит флага `Secure` (ведь мы передаёт по протоколу http,  а не https)
#### Работа с куками в Django

```py
# установка
resp.set_cookie('sessid', 'skvjhakjhkjh')
resp.set_cookie('sessid', 'khkajh', domain='.site.com', path='/blog/',
	expires = datetimme.now() + timedelta(days=30))

# удаление
resp.delete_cookie('another')

# получение
request.COOKIES  # все куки
request.COOKIES.get('sessid')  # одна кука
```

### Cookie-based авторизация
Она основана на двух основных сценариях: во-первых, это авторизация и, во-вторых, проверка сессии.

Мы начинаем с того, что при обращении к какому-то ресурсу Application сервер решает, что пользователь не авторизован и ему нужно запросить авторизацию. В этот момент апликейшн сервер перенаправляет пользователя на страницу входа, где он должен ввести логин и пароль.

Пользователь заполняет логин и пароль и отправляет форму логина: эта форма изменяет состояние, поэтому она отправляется методом POST.
 
Апликейшн сервер получает логин и пароль и запускает процесс авторизации. В процессе авторизации веб-сервер может ходить в базу данных, проверяя логин и пароль, может ходить в какие-то внешние сервисы авторизации. В результате если сервер понимает, что логин-пароль подходят, он создаёт так называемую сессию, у которой есть ключ -- относительно длинная строка, которую невозможно угадать. 

В ответе аппликейшн сервера ставится сессионная кука, то есть устанавливается соответствующий заголовок `Set-Cookie`. Этот ответ может быть, например, с кодом 302, чтобы перенаправить пользователя туда, откуда он пришёл на страницу авторизации.

Пользователь попадает на целевую страницу. Браузер делает GET-запрос и передаёт сессионную куку. Апликейшн сервер видит, что к нему пришла сессионная кука и делает проверку сессии: смотрит, действительно ли такой ключ сессии был у него запомнен. Если это так, то, поскольку, с каждым таким ключом связан конкретный пользователь, сервер сможет понять, какой пользователь к нему пришёл.

#### Необходимые модели
Как нам хранить пользователя и сессии? Это можно делать в базе данных, и для этого мы создадим соответствующие модели:
```py
class User(models.Model):
	login = models.CharField(unique=True)
	password = models.CharField()
	name = models.CharField()

class Session(models.Model):
	key = models.CharField(unique=True)
	user = models.ForeignKey(User)
	expires = models.DateTimeField()
```

#### Вход на сайт
URL = `/login/`
- Клиент отправляет логин-пароль на сервер
- сервер проверят логин-пароль и создаёт **сессию**
- сервер устанавливает куку, содержащую **ключ сессии**
- сервер делает перенаправление на целевую страницу

Вьюшка:
```py
def login(request):
	error = ''
	if request.method == 'POST':
		login = request.POST.get('login')
		password = request.POST.get('password')
		url = request.POST/get('continue', '/')
		sessid = do_login(login, password)
		if sessid:
			response = HttpResponseRedirect(url)
			response.set_cookie('sessid', sessid,
				domain='.site.com', httponly=True,
				expires=datetime.now()+timedelta(days=5)
			)
			return response
		else:
			error = u'invalid login/password'
	return render(request, 'login.html', {'error': error})
```

Модель:
```py
def do_login(login, password):
	try:
		user = User.objects.get(login=login)
	except User.DoesNotExist:
		return None
	hashed_pass = salt_and_hash(password)  # пароли не должны храниться в базе напрямую
	if user.password != hashed_pass:
		return None
	session = Session()
	session.key = generate_long_random_key()
	session.user = user
	session.expires = datetime.now() + timedelta(days=5)
	session.save()
	return session.key
```

#### Проверка сессии
При запросе по любому урлу
- клиент передаёт в заголовке `Cookie` свой `sessid`
- сервер загружает сессию из базы данных по `sessid`
- сервер загружает объект пользователя по id сессии

Как правило, для проверки сессии используются middleware, потому что эту логику нужно выполнять перед вьюшками и для всех вьюшек.

**Middleware** -- это Python класс, в котором есть один из указанных ниже методов. Список всех активных middleware указан в настройке `MIDDLEWARE_CLASSES`.

- `process_request(request)` вызывается до начала диспетчеризации урлов, вызывается до любой вьюшки
- `process_views(request, view, args, kwargs)` вызывается после диспетчеризации
- `process_response(request, response)` вызывается после отработки кода вьюшки, когда появился HttpResponse
- `process_exception(request, exception)`  вызывается после отработки кода вьюшки, если в процессе было выброшено неожиданное исключение.

В нашем случае авторизации мы хотим проверять авторизацию для каждой вьюшки, поэтому мы выберем метод `process_request`.

```py
# project/project/middleware.py
class CheckSessionMiddleware:
	def process_request(request):
		try:
			sessid = request.COOKIE.get('sessid')
			session = Session.objects.get(
				key=sessid,
				expires__gt=datetime.now(),
			)
			request.session = session
			request.user = session.user
		except Session.DoesNotExist:
			request.session = None
			request.user = None
```

#### Выход из приложения
Для выхода из приложения достаточно удалить объект сессии:
```py
def logout(request):
	sessid = request.COOKIE.get('sessid')
	if sessid is not None:
		Session.objects.delete(key=sessid)
	url = request.GET.get('continue', '/')
	return HttpResponseRedirect(url)
```

## Встроенная авторизация Django
### django.contrib.sessions
Предоставляет поддержку сессий, в том числе и **анонимных**. Позволяет хранить в сессии произвольные данные, а не только ID пользователя. Позволяет хранить сессии в различных хранилищах, например, **Redis** или **Memcached**.

```py
def some_view(request):
	val = request.session['some_name']
	request.session.flush()  # очистить содержимое сессии, аналогично удалению
	reques.session['some_name'] = 'val2'
```

Чтобы использовать django.contrib.sessions, во-первых, его нужно включить в `INSTALLED_APPS` в настройках. После этого появляется свойство `request.session`, которое ведёт себя как словарь.

### django.contrib.auth
Помимо системы сессий, в Django существует и система пользователей. Это приложение предоставляет готовую модель `User`, готовую системы разделения прав, view для регистрации/входа/выхода. Используется другими приложениями, например, django.contrib.admin

```py
def some_view(request):
	user = request.user  # Определено всегда!
	if user.is_authenticated():
		pass  # обычный пользователь
	else:
		pass  # анонимный пользователь
```

## Безопасность
### Безопасность паролей
Главная задача -- максимально затруднить доступ злоумышленника к исходному паролю пользователя. Меры безопасности:
- отправка формы входа по https
- пароли хранятся в виде хэшей с добавлением соли
- защита от перебора в форме логина, например, капча

### Безопасность сессий
Основное направление атаки -- кража куки, хранящей ключ сессии, то есть кража авторизации. Меры безопасности:
- ключ сессии невозможно подобрать перебором
- `HttpOnly` флаг для сессионной куки
- привязка сессии к IP адресу
- ограничение сессий по времени
- запрос пароля при критических действиях: смене пароля и т.д.


# AJAX
**AJAX** (Asynchronous JavaScript and XML) -- технология загрузки данных и отправки форм без обновления веб-страницы. XML совершенно не обязателен, возможна отправка и приём данных любого типа. Чаще всего вместо XML используется HTML либо JSON для загрузки сырых данных. 

AJAX реализован с помощью специального API объекта `XMLHttpRequest`, которое браузер предоставляет в Javascript.

```js
var xhr = new XMLHttpRequest();
xhr.open('POST', '/xhr/test.html', true); // указывает, с каким методом и по какому урлу нужно указывать данный запрос. 
// третий флаг True означает, что запрос асинхронный
xhr.onreadystatechange = function() {  // функция-обработчик при отработке запроса
	if (xhr.readyState == 4) { // был получен ответ или ошибка
		if (xhr.status == 200) {
			alert(xhr.responseText);
		}
	}
};
xhr.send('a=5&b=4') // отправка запроса, в метод передаётся тело
// в данный момент браузер отправляет HTTP-запрос, но он асинхронный и не приводит к перезагрузке страницы
```

В разных браузерах разное API, поэтому часто фронтенд-разработчики используют обёртки фреймворков. Например, для jQuery:
```js
$.ajax({
	url: '/blog/comments/add';
	type: 'POST';
	data: {post_id: 12, text: 'занятная идея'},
}).success(function(data) {
	if (data.status == 'ok') {
		console.log(data.comment_id);
	}
}).error(function() {
	console.log('http error')
});
```
ajax возвращает `promise` -- объекты с методами `success` (будет вызвано при успешном выполнении) и `error` при неуспешном.

### Особенности и ограничения AJAX
- **Same Origin Policy** -- AJAX запросы можно отправлять только на свой домен. В современных браузерах есть CORS как послабление к этому ограничению.
- Так как данные передаются явно в метод `send`, то нельзя загружать файлы. Однако в HTML5 есть FormData.
- AJAX на стороне сервера не отличим от обычного запроса. jQuery добавляет заголовок `X-Requested-With: XMLHttpRequest`
- Результаты запроса передаются в JavaScript-функцию, поэтому стандартные методы обработки ошибок не работают.

### Загрузка HTML данных
```py
def comments_list(request):
	post_id = request.GET.get('post_id')
	post = get_object_or_404(Post, post_id)
	comments = paginate(request, post.comments)
	return render(request, 'blog/comments.html', {
		'comments': comments
	})
```

Чаще всего загрузка HTML-данных через AJAX возникает при динамической загрузке страницы, например, если мы хотим подгрузить ещё комментариев.

В `blog/comments.html` отображается только HTML-код комментариев без окружающей страницы.

### JSON
Для общения между фронтендом и бэкендом при ajax используется json.
```json
{
	"status": "ok",
	"comment_id": 123
}
{
	"status": "error",
	"code": "no_auth",
	"message": "you are not unauthorized"
}
```

### Ajax в Django
```py
import json

class HttpResponseAjax(HttpResponse):
	def __init__(self, status='ok', **kwargs):
		kwargs['status'] = status
		super(HttpResponseAjax, self).__init__(
			content = json.dumps(kwargs),
			content_type = 'application/json',
		)

class HttpResponseAjaxError(HttpResponseAjax):
	def __init__(self, code, message):
		super(HttpResponseAjaxError, self).__init__(
			status='error', code=code, message=message
		)
```

Использование данных классов во вьюшке:

```py
@login_required_ajax
def comment_add(request):
	form = AddCommentForm(request.POST)
	if form.is_valid():
		comment = form.save()
		return HttpResponseAjax(comment_id=comment.id)
	else:
		return HttpResponseAjaxError(
			code='bad_params',
			message = form.errors.as_text(),
		)
```
Декоратор `@login_required_ajax`, в отличие от просто `@login_required`, не возвращает редирект, а возвращается некий json-объект для обработки его в js.

```py
def login_required(view):
	def inner(request, *args, **kwargs):
		if request.user.if_authenticated():
			return view(request, *args, **kwargs)
		elif request.is_ajax():
			return HttpResponseAjaxError(
				code='no_auth',
				message='you are not authorized'
			)
		else:
			redirect('/login/?continue='+request.get_full_path())
	return inner
```
## CORS
Cross Origin Resource Sharing: браузер выполняет AJAX запросы даже к чужому домену, но в этом случае не вызывает функцию-колбэк к js, т.е. не дает использовать данные, загруженные с чужого домена.

**CORS** позволяет серверу явно разрешить использование данных при кросс-доменных запросах.

### Заголовки CORS
- `Origin` -- указывает URL запрашивающего приложения
- `Access-Control-Allow-Origin: origin` разрешает использовать данные в кросс-доменном запросе. При этом `origin` либо совпадает с заголовком `Origin` в данном запросе, либо равняется `*`
- `Access-Control-Allow-Credentials` позволяет использовать данные, если были переданы куки


Не следует разрешать CORS для всех запросов (`*`). Хорошей практикой является проверка суффикса домена и проверка домена по списку доверенных.

### Декоратор для CORS
```py
def allow_cors(view):
	def inner(request, *args, **kwargs):
		response = view(request, *args, **kwargs)
		origin = request.META.get('HTTP_ORIGIN')
		if not origin:
			return response
		for domain in settings.CORS_WHITE_LIST:
			if origin.endswith('.'+domain):
				reponse['Access-Control-Allow-Origin'] = origin
		return response
	return inner
```
Этот декоратор применяется к любой вьюшке, поддерживающей кросс-доменные запросы.

# Realtime сообщения
Помимо Application сервера, появляется Comet/WebSocket сервер доставки сообщений.

Дело в том, что протокол HTTP подразумевает работу по принципу запрос-ответ, и пока клиент не осуществит запрос к серверу, он не узнает про какой-то результат: это ключевая проблема, которую надо решить.

В случае доставки сообщений выделяют следующие роли: существует какой-то инициатор, то есть либо клиент, либо какая-то фоновая активность инициирует и создаёт первоначальное событие: например, отправляет сообщение. Как правило, это сводится к некому вызову на Application сервере. Он проверяет всю необходимую логику: доступ, делает записи в базы данных, после чего необходимо доставить сообщение конкретным пользователям. Для того, чтобы оно было доставлено как можно быстрее, пользователи должны его ожидать: должно быть некоторое постоянное соединение от сервера ко всем постоянным получателям этого сообщения, и оно через это установленное соединение будет передано клиенту.

### Решения
- **Polling** -- периодический опрос сервера: клиент, который хочет получить сообщение, периодически спрашивает сервер, не пришло ли новое сообщение
- **Comet (Long polling)** -- polling с долгоживущими запросами. В этом случае клиент будет получать сообщения в тот момент, когда они действительно к нему пришли, а не когда он за ними обратился
- **Server Push** -- бесконечный запрос
- **WebSocket** -- специализированный протокол

## Polling
Клиент периодически делает обычные HTTP (скорее всего, ajax)  GET запросы на сервер. Тот смотрит, появились ли новые сообщения, и если ещё нет -- он может вернуть код ответа 204 No Content, а если пришли, -- 200 ОК.

### Polling на клиенте
```js
var since = 0;
setInterval(function() {
	$.ajax({
		type: 'GET',
		url: '/get_messages/',
		data: {channel_id: 5, since: since},
	}).success(function(resp) {
		if (!resp.messages || !resp.messages.length) {
			return;
		}
		handleMessages(resp.messages); // обработка сообщений, бизнес-логика
		since = resp.messages[0].id;
	});
}, 5000);
```
`channel_id` -- некоторая FIFO-очередь с сообщениями, номер канала (из какой комнаты или чата слушаем сообщения). Как вариант, вместо указания канала, сервер может ориентироваться на авторизационные куки: таким образом можно передавать личные сообщения.

### Polling на сервере
```py
def get_messages(request):
	chan_id = request.GET.get('channel_id')
	since = request.GET.get('since', 0)
	messages = Messages.filter(channel_id=chan_id, id__gt=since).order_by('-id')
	messages = [m.as_data() for m in messages]
	return HttpResponseAjax(messages=messages)
```

**Плюсы Polling**
- простота и надежность реализации
- не требуется дополнительного ПО

** Минусы Polling**
- сообщения приходят с задержкой до N секунд
- избыточное число HTTP запросов 
- ограничение по числу пользователей

## Comet
Сервер не отвечает до тех пор, пока не появятся данные.
### Comet на клиенте
```js
function getComet() {
	$.ajax({
		type: 'GET',
		url: '/get_messages/',
		data: {channel_id: 5},
	}).success(function(resp) {
		handleMessages(resp.messages);
		getComet();
	}).error(function() {
		setTimeout(getComet, 10000);
	});
}
getComet();
```

### Comet на сервере
В технологии **Comet** сревре должен поддерживать одновременно открытыми большое количество соединений, причём каждое из них находится в ожидании сообщений от него. По этой причине мы не можем использовать классический application-сервер в роли комет-сервера. Для него необходима отдельная технология, например, **nginx + mod_push**, то есть сервер, работающий по event модели.

```nginx
location /publish/ {
	set $push_channel_id $arg_cid;  # id канала
	push_store_messages off;  # не храним сообщения
	push_publisher;  # включаем отправку
	allow 127.0.0.1;
	deny all;
}
location /listen/ {
	push_subscriber_concurrency broadcast;  # всем
	set $push_channel_id $arg_cid;  # id канала
	default_type application/json;
	push_subscriber;  # включаем доставку
```

Теперь можно написать вьюшку:
```py
import urllib2
import json

def send_message(request):
	cid = request.POST.get('to')
	text = request.POST.get('text')
	url = 'http://127.0.0.1/publish/?cid=' + cid
	body = json.dumps({'messages': [text]})
	request = urllib2.Request(url, body, {})
	response = urllib2.urlopen(request)  # отправка в комет сервер, может быть долгой
	if response.getcode() == 200:
		return HttpResponseAjax()
	else:
		return HttpResponseAjaxError(code=response.getcode())
```
### Плюсы
- поддержка всеми браузерами
- поддержка большого числа пользователей
- относительная простота реализации

### Минусы
- избыточные HTTP запросы
- Half-duplex: с помощью комет можно только получать сообщения, а отправляются они по прежнему из ajax

## Server push
Использует возможность браузеров загружать бесконечные тэги -- так называемые `iframe`.

Клиент загружает основную страничку и внутри неё загружается дополнительный ифрейм -- подстраница. Этот ифрейм осуществляет GET запрос к push-серверу, который никогда на этот запрос не ответит до конца: веб сервер может отправить заголовки запроса, а тело запроса отдавать по частям сколь угодно долго. Поэтому push-сервер отвечает заголовками, а соединение оставляет открытым. Когда для данного пользователя приходит сообщение, пуш-сервер отдаёт кусочек данных, после этого соединение по-прежнему остаётся открытым и так далее.

### Server push на клиенте
```html
<script>
	function handle(message) {
		// любая логика обработки сообщений
	}
</script>
<iframe src='/messages/?cid=123'></iframe>
```

Ответ сервера:
```html
<script>parent.handle({message: 'hello'})</script>
```
Идея построена на том, что браузер выполняет html код сразу же после его получения. Поэтому и push-сервер постоянно отсылает кусочки html со скриптом внутри, который вызывает обработчик сообщения: получив его, браузер выполнит этот скрипт.

Проблема в том, что не все браузеры так поступают.

## WebSocket
Это расширение протокола HTTP. Оно начинается как обычное HTTP-соединение, то есть клиент открывает TCP-соединение и отправляет HTTP-запрос. Этот запрос особого вида, в том числе в нём есть заголовок `Upgrade: websocket`, который указывает, что нужно сменить протокол передачи данных в данном сетевом соединении. В этот момент сервер может принять решение, хочет ли он общаться с клиентом по протоколу websocket. Если всё ок, он отдаёт специальный код ответа 101 Switching Protocol -- это означает, что сервер согласен сменить протокол, и отдаётся набор заголовков, в том числе и `Upgrade: websocket`. Эта фаза называется рукопожатие, и мы можем сказать. что она фактически работает по протоколу HTTP.

Однако после того, как handshake завершен, следующие данные передаются по протоколу websocket. Это бинарный протокол, который позволяет передавать данные в виде фреймов -- фрагментов заранее указанной длины.
### Пример Handshake
#### Запрос
```http
GET /chat/ HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: alkjvlskjv
Sec-WebSocket-Origin: http://example.com
Sec-Websocket-Protocol: chat, superchat
Sec-Websocket-Version: 13
```

#### Ответ
```http
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: slkjlkj
Sec-WebSocket-Protocol: chat
```
### WebSocket на стороне клиента
```js
var socket = new WebSocket('ws://host/echo');

socket.onopen = function(event) {
	console.log('ws opened');
	var data = JSON.stringify({message: 'Hello WebSocket'});
	socket.end(data);
};
socket.onmessage = function(event) {
	var resp = JSON.parse(event.data);
	concolse.log('ws message', resp.message);
};
socket.oncolse = function(event) {
	console.log('ws closed');
};
```

### WebSocket на стороне сервера
Например, tornado -- event-сервер:
```py
class EchoWebSocket(tornado.websocket.WebSocketHandler):
	def open(self):
		print('websocket opened')
	
	def on_message(self, message):
		self.write_message(message)

	def on_close(self):
		print('websocket closed')
```

#### Плюсы
- минимальный объём трафика
- минимальная нагрузка на сервер
- поддержка большого числа пользователей
- полнодуплексное соединение: данные можно как принимать, так и отправлять

#### Минусы
- нет поддержки IE<10, OperaMini, Android<4.4
- требуется специальный websocket-сервер
- плохо работает с прокси-серверами: те должны уметь проксировать протокол websocket. Но есть обходной путь -- websocket secure (wss) протокол. Поскольку это шифрованное соединение, то прокси-сервер вынужден будет работать как прокси ТСР потока, не имея возможности проанализировать содержимое и wss будет работать для всех соединений. 
> Written with [StackEdit](https://stackedit.io/).
